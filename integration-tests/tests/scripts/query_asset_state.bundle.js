var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from4[key], enumerable: !(desc = __getOwnPropDesc(from4, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// ../../node_modules/@polkadot/api-derive/packageInfo.js
var import_meta, packageInfo;
var init_packageInfo = __esm({
  "../../node_modules/@polkadot/api-derive/packageInfo.js"() {
    import_meta = {};
    packageInfo = { name: "@polkadot/api-derive", path: import_meta && import_meta.url ? new URL(import_meta.url).pathname.substring(0, new URL(import_meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/rpc-core/packageInfo.js
var import_meta2, packageInfo2;
var init_packageInfo2 = __esm({
  "../../node_modules/@polkadot/rpc-core/packageInfo.js"() {
    import_meta2 = {};
    packageInfo2 = { name: "@polkadot/rpc-core", path: import_meta2 && import_meta2.url ? new URL(import_meta2.url).pathname.substring(0, new URL(import_meta2.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/rpc-provider/packageInfo.js
var import_meta3, packageInfo3;
var init_packageInfo3 = __esm({
  "../../node_modules/@polkadot/rpc-provider/packageInfo.js"() {
    import_meta3 = {};
    packageInfo3 = { name: "@polkadot/rpc-provider", path: import_meta3 && import_meta3.url ? new URL(import_meta3.url).pathname.substring(0, new URL(import_meta3.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/types/packageInfo.js
var import_meta4, packageInfo4;
var init_packageInfo4 = __esm({
  "../../node_modules/@polkadot/types/packageInfo.js"() {
    import_meta4 = {};
    packageInfo4 = { name: "@polkadot/types", path: import_meta4 && import_meta4.url ? new URL(import_meta4.url).pathname.substring(0, new URL(import_meta4.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/types-known/packageInfo.js
var import_meta5, packageInfo5;
var init_packageInfo5 = __esm({
  "../../node_modules/@polkadot/types-known/packageInfo.js"() {
    import_meta5 = {};
    packageInfo5 = { name: "@polkadot/types-known", path: import_meta5 && import_meta5.url ? new URL(import_meta5.url).pathname.substring(0, new URL(import_meta5.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/x-global/index.js
function evaluateThis(fn) {
  return fn("return this");
}
function extractGlobal(name, fallback) {
  return typeof xglobal[name] === "undefined" ? fallback : xglobal[name];
}
function exposeGlobal(name, fallback) {
  if (typeof xglobal[name] === "undefined") {
    xglobal[name] = fallback;
  }
}
var xglobal;
var init_x_global = __esm({
  "../../node_modules/@polkadot/x-global/index.js"() {
    xglobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function);
  }
});

// ../../node_modules/@polkadot/x-textdecoder/packageInfo.js
var import_meta6, packageInfo6;
var init_packageInfo6 = __esm({
  "../../node_modules/@polkadot/x-textdecoder/packageInfo.js"() {
    import_meta6 = {};
    packageInfo6 = { name: "@polkadot/x-textdecoder", path: import_meta6 && import_meta6.url ? new URL(import_meta6.url).pathname.substring(0, new URL(import_meta6.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/x-textdecoder/node.js
var import_node_util, TextDecoder2;
var init_node = __esm({
  "../../node_modules/@polkadot/x-textdecoder/node.js"() {
    import_node_util = __toESM(require("node:util"), 1);
    init_x_global();
    init_packageInfo6();
    TextDecoder2 = /* @__PURE__ */ extractGlobal("TextDecoder", import_node_util.default.TextDecoder);
  }
});

// ../../node_modules/@polkadot/x-textencoder/packageInfo.js
var import_meta7, packageInfo7;
var init_packageInfo7 = __esm({
  "../../node_modules/@polkadot/x-textencoder/packageInfo.js"() {
    import_meta7 = {};
    packageInfo7 = { name: "@polkadot/x-textencoder", path: import_meta7 && import_meta7.url ? new URL(import_meta7.url).pathname.substring(0, new URL(import_meta7.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/x-textencoder/node.js
var import_node_util2, Fallback, TextEncoder2;
var init_node2 = __esm({
  "../../node_modules/@polkadot/x-textencoder/node.js"() {
    import_node_util2 = __toESM(require("node:util"), 1);
    init_x_global();
    init_packageInfo7();
    Fallback = class {
      __internal__encoder;
      constructor() {
        this.__internal__encoder = new import_node_util2.default.TextEncoder();
      }
      // For a Jest 26.0.1 environment, Buffer !== Uint8Array
      encode(value) {
        return Uint8Array.from(this.__internal__encoder.encode(value));
      }
    };
    TextEncoder2 = /* @__PURE__ */ extractGlobal("TextEncoder", Fallback);
  }
});

// ../../node_modules/@polkadot/util/is/function.js
function isFunction(value) {
  return typeof value === "function";
}
var init_function = __esm({
  "../../node_modules/@polkadot/util/is/function.js"() {
  }
});

// ../../node_modules/@polkadot/util/detectPackage.js
function getEntry(name) {
  const _global = xglobal;
  if (!_global.__polkadotjs) {
    _global.__polkadotjs = {};
  }
  if (!_global.__polkadotjs[name]) {
    _global.__polkadotjs[name] = [];
  }
  return _global.__polkadotjs[name];
}
function formatDisplay(all3, fmt) {
  let max2 = 0;
  for (let i2 = 0, count = all3.length; i2 < count; i2++) {
    max2 = Math.max(max2, all3[i2].version.length);
  }
  return all3.map((d) => `	${fmt(d.version.padEnd(max2), d).join("	")}`).join("\n");
}
function formatInfo(version, { name }) {
  return [
    version,
    name
  ];
}
function formatVersion(version, { path, type }) {
  let extracted;
  if (path && path.length >= 5) {
    const nmIndex = path.indexOf("node_modules");
    extracted = nmIndex === -1 ? path : path.substring(nmIndex);
  } else {
    extracted = "<unknown>";
  }
  return [
    `${`${type || ""}`.padStart(3)} ${version}`,
    extracted
  ];
}
function getPath(infoPath, pathOrFn) {
  if (infoPath) {
    return infoPath;
  } else if (isFunction(pathOrFn)) {
    try {
      return pathOrFn() || "";
    } catch {
      return "";
    }
  }
  return pathOrFn || "";
}
function warn(pre, all3, fmt) {
  console.warn(`${pre}
${DEDUPE}
${formatDisplay(all3, fmt)}`);
}
function detectPackage({ name, path, type, version }, pathOrFn, deps = []) {
  if (!name.startsWith("@polkadot")) {
    throw new Error(`Invalid package descriptor ${name}`);
  }
  const entry = getEntry(name);
  entry.push({ path: getPath(path, pathOrFn), type, version });
  const entriesSameVersion = entry.every((e2) => e2.version === version);
  const esmCjsWarningDisabled = xglobal.process?.env?.[POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG] === "1";
  const multipleEntries = entry.length !== 1;
  const disableWarnings = esmCjsWarningDisabled && entriesSameVersion;
  if (multipleEntries && !disableWarnings) {
    warn(`${name} has multiple versions, ensure that there is only one installed.`, entry, formatVersion);
  } else {
    const mismatches = deps.filter((d) => d && d.version !== version);
    if (mismatches.length) {
      warn(`${name} requires direct dependencies exactly matching version ${version}.`, mismatches, formatInfo);
    }
  }
}
var DEDUPE, POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG;
var init_detectPackage = __esm({
  "../../node_modules/@polkadot/util/detectPackage.js"() {
    init_x_global();
    init_function();
    DEDUPE = "Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:";
    POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG = "POLKADOTJS_DISABLE_ESM_CJS_WARNING";
  }
});

// ../../node_modules/@polkadot/util/packageInfo.js
var import_meta8, packageInfo8;
var init_packageInfo8 = __esm({
  "../../node_modules/@polkadot/util/packageInfo.js"() {
    import_meta8 = {};
    packageInfo8 = { name: "@polkadot/util", path: import_meta8 && import_meta8.url ? new URL(import_meta8.url).pathname.substring(0, new URL(import_meta8.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/util/packageDetect.js
var init_packageDetect = __esm({
  "../../node_modules/@polkadot/util/packageDetect.js"() {
    init_node();
    init_node2();
    init_detectPackage();
    init_packageInfo8();
    detectPackage(packageInfo8, null, [packageInfo6, packageInfo7]);
  }
});

// ../../node_modules/@polkadot/util/array/chunk.js
function arrayChunk(array, chunkSize) {
  const outputSize = Math.ceil(array.length / chunkSize);
  if (outputSize === 1) {
    return [array];
  }
  const output = Array(outputSize);
  for (let i2 = 0; i2 < outputSize; i2++) {
    const offset = i2 * chunkSize;
    output[i2] = array.slice(offset, offset + chunkSize);
  }
  return output;
}
var init_chunk = __esm({
  "../../node_modules/@polkadot/util/array/chunk.js"() {
  }
});

// ../../node_modules/@polkadot/util/array/flatten.js
function arrayFlatten(arrays) {
  const num = arrays.length;
  if (num === 0) {
    return [];
  } else if (num === 1) {
    return arrays[0];
  }
  let size = 0;
  for (let i3 = 0; i3 < num; i3++) {
    size += arrays[i3].length;
  }
  const output = new Array(size);
  let i2 = -1;
  for (let j = 0; j < num; j++) {
    const a = arrays[j];
    for (let e2 = 0, count = a.length; e2 < count; e2++) {
      output[++i2] = a[e2];
    }
  }
  return output;
}
var init_flatten = __esm({
  "../../node_modules/@polkadot/util/array/flatten.js"() {
  }
});

// ../../node_modules/@polkadot/util/array/index.js
var init_array = __esm({
  "../../node_modules/@polkadot/util/array/index.js"() {
    init_chunk();
    init_flatten();
  }
});

// ../../node_modules/@polkadot/util/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(isFunction(message) ? message() : message);
  }
}
function assertReturn(value, message) {
  assert(value !== void 0 && value !== null, message);
  return value;
}
function assertUnreachable(x2) {
  throw new Error(`This codepath should be unreachable. Unhandled input: ${x2}`);
}
var init_assert = __esm({
  "../../node_modules/@polkadot/util/assert.js"() {
    init_function();
  }
});

// ../../node_modules/@polkadot/util/bi/helpers.js
function createCmp(cmp) {
  return (...items) => {
    const count = items.length;
    if (count === 0) {
      throw new Error("Must provide one or more arguments");
    }
    let result = items[0];
    for (let i2 = 1; i2 < count; i2++) {
      if (cmp(items[i2], result)) {
        result = items[i2];
      }
    }
    return result;
  };
}
var init_helpers = __esm({
  "../../node_modules/@polkadot/util/bi/helpers.js"() {
  }
});

// ../../node_modules/@polkadot/x-bigint/index.js
function invalidFallback() {
  return Number.NaN;
}
var BigInt2;
var init_x_bigint = __esm({
  "../../node_modules/@polkadot/x-bigint/index.js"() {
    init_x_global();
    BigInt2 = /* @__PURE__ */ extractGlobal("BigInt", invalidFallback);
  }
});

// ../../node_modules/@polkadot/util/bi/consts.js
var _0n, _1n, _1Bn, _1Qn, _2pow53n;
var init_consts = __esm({
  "../../node_modules/@polkadot/util/bi/consts.js"() {
    init_x_bigint();
    _0n = /* @__PURE__ */ BigInt2(0);
    _1n = /* @__PURE__ */ BigInt2(1);
    _1Bn = /* @__PURE__ */ BigInt2(1e9);
    _1Qn = _1Bn * _1Bn;
    _2pow53n = /* @__PURE__ */ BigInt2(Number.MAX_SAFE_INTEGER);
  }
});

// ../../node_modules/@polkadot/util/u8a/toBigInt.js
function u8aToBigInt(value, { isLe = true, isNegative = false } = {}) {
  if (!isLe) {
    value = value.slice().reverse();
  }
  const count = value.length;
  if (isNegative && count && value[count - 1] & 128) {
    switch (count) {
      case 0:
        return BigInt2(0);
      case 1:
        return BigInt2((value[0] ^ 255) * -1 - 1);
      case 2:
        return BigInt2((value[0] + (value[1] << 8) ^ 65535) * -1 - 1);
      case 4:
        return BigInt2((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) * -1 - 1);
    }
    const dvI2 = new DataView(value.buffer, value.byteOffset);
    if (count === 8) {
      return dvI2.getBigInt64(0, true);
    }
    let result = BigInt2(0);
    const mod2 = count % 2;
    for (let i2 = count - 2; i2 >= mod2; i2 -= 2) {
      result = result * U16_MAX + BigInt2(dvI2.getUint16(i2, true) ^ 65535);
    }
    if (mod2) {
      result = result * U8_MAX + BigInt2(value[0] ^ 255);
    }
    return result * -_1n - _1n;
  }
  switch (count) {
    case 0:
      return BigInt2(0);
    case 1:
      return BigInt2(value[0]);
    case 2:
      return BigInt2(value[0] + (value[1] << 8));
    case 4:
      return BigInt2(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216);
  }
  const dvI = new DataView(value.buffer, value.byteOffset);
  switch (count) {
    case 8:
      return dvI.getBigUint64(0, true);
    case 16:
      return dvI.getBigUint64(8, true) * U64_MAX + dvI.getBigUint64(0, true);
    default: {
      let result = BigInt2(0);
      const mod2 = count % 2;
      for (let i2 = count - 2; i2 >= mod2; i2 -= 2) {
        result = result * U16_MAX + BigInt2(dvI.getUint16(i2, true));
      }
      if (mod2) {
        result = result * U8_MAX + BigInt2(value[0]);
      }
      return result;
    }
  }
}
var U8_MAX, U16_MAX, U64_MAX;
var init_toBigInt = __esm({
  "../../node_modules/@polkadot/util/u8a/toBigInt.js"() {
    init_x_bigint();
    init_consts();
    U8_MAX = BigInt2(256);
    U16_MAX = BigInt2(256 * 256);
    U64_MAX = BigInt2("0x10000000000000000");
  }
});

// ../../node_modules/@polkadot/util/hex/toU8a.js
function hexToU8a(value, bitLength = -1) {
  if (!value) {
    return new Uint8Array();
  }
  let s2 = value.startsWith("0x") ? 2 : 0;
  const decLength = Math.ceil((value.length - s2) / 2);
  const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > decLength ? endLength - decLength : 0;
  for (let i2 = offset; i2 < endLength; i2++, s2 += 2) {
    result[i2] = U16[value.charCodeAt(s2) << 8 | value.charCodeAt(s2 + 1)];
  }
  return result;
}
var CHR, U8, U16;
var init_toU8a = __esm({
  "../../node_modules/@polkadot/util/hex/toU8a.js"() {
    CHR = "0123456789abcdef";
    U8 = new Uint8Array(256);
    U16 = new Uint8Array(256 * 256);
    for (let i2 = 0, count = CHR.length; i2 < count; i2++) {
      U8[CHR[i2].charCodeAt(0) | 0] = i2 | 0;
      if (i2 > 9) {
        U8[CHR[i2].toUpperCase().charCodeAt(0) | 0] = i2 | 0;
      }
    }
    for (let i2 = 0; i2 < 256; i2++) {
      const s2 = i2 << 8;
      for (let j = 0; j < 256; j++) {
        U16[s2 | j] = U8[i2] << 4 | U8[j];
      }
    }
  }
});

// ../../node_modules/@polkadot/util/hex/toBigInt.js
function hexToBigInt(value, { isLe = false, isNegative = false } = {}) {
  return !value || value === "0x" ? BigInt2(0) : u8aToBigInt(hexToU8a(value), { isLe, isNegative });
}
var init_toBigInt2 = __esm({
  "../../node_modules/@polkadot/util/hex/toBigInt.js"() {
    init_x_bigint();
    init_toBigInt();
    init_toU8a();
  }
});

// ../../node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert2(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require("buffer").Buffer;
        }
      } catch (e2) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init2(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
            w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul, "Invalid character");
          r2 += b;
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0; i2 < mod2; i2++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone2() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e2) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding2) {
        base = base || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer4) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer4, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray5(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t2 = w;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r2 += b;
          if (b !== 26) break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y) {
        this.x = x2;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t2 = new Array(N2);
        var l15 = BN2.prototype._countBits(N2) - 1;
        for (var i2 = 0; i2 < N2; i2++) {
          t2[i2] = this.revBin(i2, l15, N2);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x2, l15, N2) {
        if (x2 === 0 || x2 === N2 - 1) return x2;
        var rb = 0;
        for (var i2 = 0; i2 < l15; i2++) {
          rb |= (x2 & 1) << l15 - i2 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i2 = 0; i2 < N2; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l15 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l15);
          var itwdf = Math.sin(2 * Math.PI / l15);
          for (var p = 0; p < N2; p += l15) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s2; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s2];
              var io = itws[p + j + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s2] = re - ro;
              itws[p + j + s2] = ie - io;
              if (j !== l15) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N2 = Math.max(m2, n) | 1;
        var odd = N2 & 1;
        var i2 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1) return;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N2 - i2 - 1];
          rws[N2 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N2 - i2 - 1];
          iws[N2 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
          ws[i2] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N2; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i2 = 0; i2 < N2; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y, out) {
        var N2 = 2 * this.guessLen13b(x2.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x2.words, x2.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i2 = 0; i2 < N2; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x2.negative ^ y.negative;
        out.length = x2.length + y.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0) break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits2) {
        assert2(typeof bits2 === "number" && bits2 >= 0);
        var r2 = bits2 % 26;
        var s2 = (bits2 - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits2) {
        assert2(this.negative === 0);
        return this.iushln(bits2);
      };
      BN2.prototype.iushrn = function iushrn(bits2, hint, extended) {
        assert2(typeof bits2 === "number" && bits2 >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r2 = bits2 % 26;
        var s2 = Math.min((bits2 - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits2, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits2, hint, extended);
      };
      BN2.prototype.shln = function shln(bits2) {
        return this.clone().ishln(bits2);
      };
      BN2.prototype.ushln = function ushln(bits2) {
        return this.clone().iushln(bits2);
      };
      BN2.prototype.shrn = function shrn(bits2) {
        return this.clone().ishrn(bits2);
      };
      BN2.prototype.ushrn = function ushrn(bits2) {
        return this.clone().iushrn(bits2);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) return false;
        var w = this.words[s2];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits2) {
        assert2(typeof bits2 === "number" && bits2 >= 0);
        var r2 = bits2 % 26;
        var s2 = (bits2 - r2) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits2) {
        return this.clone().imaskn(bits2);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m2 = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m2 + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m2] = 1;
          }
        }
        for (var j = m2 - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x2 = this;
        var y = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x2.isEven() && y.isEven()) {
          x2.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            x2.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B.isOdd()) {
                A2.iadd(yp);
                B.isub(xp);
              }
              A2.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x2.cmp(y) >= 0) {
            x2.isub(y);
            A2.isub(C);
            B.isub(D);
          } else {
            y.isub(x2);
            C.isub(A2);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd2(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t2 = a;
            a = b;
            b = t2;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split3(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split3(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime6(name) {
        if (primes[name]) return primes[name];
        var prime7;
        if (name === "k256") {
          prime7 = new K256();
        } else if (name === "p224") {
          prime7 = new P224();
        } else if (name === "p192") {
          prime7 = new P192();
        } else if (name === "p25519") {
          prime7 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime7;
        return prime7;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime6 = BN2._prime(m2);
          this.m = prime6.p;
          this.prime = prime6;
        } else {
          assert2(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add3(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t2 = this.pow(a, q);
        var m2 = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m2);
          var b = this.pow(c, new BN2(1).iushln(m2 - i2 - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m2 = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t2 = a.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
        var t2 = a.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// ../../node_modules/@polkadot/util/bn/bn.js
var import_bn;
var init_bn = __esm({
  "../../node_modules/@polkadot/util/bn/bn.js"() {
    import_bn = __toESM(require_bn(), 1);
  }
});

// ../../node_modules/@polkadot/util/is/bn.js
function isBn(value) {
  return import_bn.default.isBN(value);
}
var init_bn2 = __esm({
  "../../node_modules/@polkadot/util/is/bn.js"() {
    init_bn();
  }
});

// ../../node_modules/@polkadot/util/is/hex.js
function isHex(value, bitLength = -1, ignoreLength) {
  return typeof value === "string" && (value === "0x" || REGEX_HEX_PREFIXED.test(value)) && (bitLength === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength / 4));
}
var REGEX_HEX_PREFIXED, REGEX_HEX_NOPREFIX;
var init_hex = __esm({
  "../../node_modules/@polkadot/util/is/hex.js"() {
    REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
    REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;
  }
});

// ../../node_modules/@polkadot/util/is/object.js
function isObject(value) {
  return !!value && typeof value === "object";
}
var init_object = __esm({
  "../../node_modules/@polkadot/util/is/object.js"() {
  }
});

// ../../node_modules/@polkadot/util/is/helpers.js
function isOn(...fns) {
  return (value) => (isObject(value) || isFunction(value)) && fns.every((f3) => isFunction(value[f3]));
}
function isOnFunction(...fns) {
  return (value) => isFunction(value) && fns.every((f3) => isFunction(value[f3]));
}
function isOnObject(...fns) {
  return (value) => isObject(value) && fns.every((f3) => isFunction(value[f3]));
}
var init_helpers2 = __esm({
  "../../node_modules/@polkadot/util/is/helpers.js"() {
    init_function();
    init_object();
  }
});

// ../../node_modules/@polkadot/util/is/toBigInt.js
var isToBigInt;
var init_toBigInt3 = __esm({
  "../../node_modules/@polkadot/util/is/toBigInt.js"() {
    init_helpers2();
    isToBigInt = /* @__PURE__ */ isOn("toBigInt");
  }
});

// ../../node_modules/@polkadot/util/is/toBn.js
var isToBn;
var init_toBn = __esm({
  "../../node_modules/@polkadot/util/is/toBn.js"() {
    init_helpers2();
    isToBn = /* @__PURE__ */ isOn("toBn");
  }
});

// ../../node_modules/@polkadot/util/bi/toBigInt.js
function nToBigInt(value) {
  return typeof value === "bigint" ? value : !value ? BigInt2(0) : isHex(value) ? hexToBigInt(value.toString()) : isBn(value) ? BigInt2(value.toString()) : isToBigInt(value) ? value.toBigInt() : isToBn(value) ? BigInt2(value.toBn().toString()) : BigInt2(value);
}
var init_toBigInt4 = __esm({
  "../../node_modules/@polkadot/util/bi/toBigInt.js"() {
    init_x_bigint();
    init_toBigInt2();
    init_bn2();
    init_hex();
    init_toBigInt3();
    init_toBn();
  }
});

// ../../node_modules/@polkadot/util/has.js
var hasBigInt, hasBuffer, hasProcess;
var init_has = __esm({
  "../../node_modules/@polkadot/util/has.js"() {
    init_x_bigint();
    init_x_global();
    hasBigInt = typeof BigInt2 === "function" && typeof BigInt2.asIntN === "function";
    hasBuffer = typeof xglobal.Buffer === "function" && typeof xglobal.Buffer.isBuffer === "function";
    hasProcess = typeof xglobal.process === "object";
  }
});

// ../../node_modules/@polkadot/util/is/buffer.js
function isBuffer(value) {
  return hasBuffer && !!value && isFunction(value.readDoubleLE) && xglobal.Buffer.isBuffer(value);
}
var init_buffer = __esm({
  "../../node_modules/@polkadot/util/is/buffer.js"() {
    init_x_global();
    init_has();
    init_function();
  }
});

// ../../node_modules/@polkadot/util/is/u8a.js
function isU8a(value) {
  return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}
var init_u8a = __esm({
  "../../node_modules/@polkadot/util/is/u8a.js"() {
  }
});

// ../../node_modules/@polkadot/util/string/toU8a.js
function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}
var encoder;
var init_toU8a2 = __esm({
  "../../node_modules/@polkadot/util/string/toU8a.js"() {
    init_node2();
    encoder = new TextEncoder2();
  }
});

// ../../node_modules/@polkadot/util/u8a/toU8a.js
function u8aToU8a(value) {
  return isU8a(value) ? isBuffer(value) ? new Uint8Array(value) : value : isHex(value) ? hexToU8a(value) : Array.isArray(value) ? new Uint8Array(value) : stringToU8a(value);
}
var init_toU8a3 = __esm({
  "../../node_modules/@polkadot/util/u8a/toU8a.js"() {
    init_toU8a();
    init_buffer();
    init_hex();
    init_u8a();
    init_toU8a2();
  }
});

// ../../node_modules/@polkadot/util/u8a/concat.js
function u8aConcat(...list) {
  const count = list.length;
  const u8as = new Array(count);
  let length = 0;
  for (let i2 = 0; i2 < count; i2++) {
    u8as[i2] = u8aToU8a(list[i2]);
    length += u8as[i2].length;
  }
  return u8aConcatStrict(u8as, length);
}
function u8aConcatStrict(u8as, length = 0) {
  const count = u8as.length;
  let offset = 0;
  if (!length) {
    for (let i2 = 0; i2 < count; i2++) {
      length += u8as[i2].length;
    }
  }
  const result = new Uint8Array(length);
  for (let i2 = 0; i2 < count; i2++) {
    result.set(u8as[i2], offset);
    offset += u8as[i2].length;
  }
  return result;
}
var init_concat = __esm({
  "../../node_modules/@polkadot/util/u8a/concat.js"() {
    init_toU8a3();
  }
});

// ../../node_modules/@polkadot/util/u8a/empty.js
function u8aEmpty(value) {
  const len = value.length | 0;
  for (let i2 = 0; i2 < len; i2++) {
    if (value[i2] | 0) {
      return false;
    }
  }
  return true;
}
var init_empty = __esm({
  "../../node_modules/@polkadot/util/u8a/empty.js"() {
  }
});

// ../../node_modules/@polkadot/util/u8a/eq.js
function u8aEq(a, b) {
  const u8aa = u8aToU8a(a);
  const u8ab = u8aToU8a(b);
  if (u8aa.length === u8ab.length) {
    const dvA = new DataView(u8aa.buffer, u8aa.byteOffset);
    const dvB = new DataView(u8ab.buffer, u8ab.byteOffset);
    const mod2 = u8aa.length % 4 | 0;
    const length = u8aa.length - mod2 | 0;
    for (let i2 = 0; i2 < length; i2 += 4) {
      if (dvA.getUint32(i2) !== dvB.getUint32(i2)) {
        return false;
      }
    }
    for (let i2 = length, count = u8aa.length; i2 < count; i2++) {
      if (u8aa[i2] !== u8ab[i2]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var init_eq = __esm({
  "../../node_modules/@polkadot/util/u8a/eq.js"() {
    init_toU8a3();
  }
});

// ../../node_modules/@polkadot/util/u8a/fixLength.js
function u8aFixLength(value, bitLength = -1, atStart = false) {
  const byteLength = Math.ceil(bitLength / 8);
  if (bitLength === -1 || value.length === byteLength) {
    return value;
  } else if (value.length > byteLength) {
    return value.subarray(0, byteLength);
  }
  const result = new Uint8Array(byteLength);
  result.set(value, atStart ? 0 : byteLength - value.length);
  return result;
}
var init_fixLength = __esm({
  "../../node_modules/@polkadot/util/u8a/fixLength.js"() {
  }
});

// ../../node_modules/@polkadot/util/u8a/toBn.js
function u8aToBn(value, { isLe = true, isNegative = false } = {}) {
  if (!isLe) {
    value = value.slice().reverse();
  }
  const count = value.length;
  if (isNegative && count && value[count - 1] & 128) {
    switch (count) {
      case 0:
        return new import_bn.default(0);
      case 1:
        return new import_bn.default((value[0] ^ 255) * -1 - 1);
      case 2:
        return new import_bn.default((value[0] + (value[1] << 8) ^ 65535) * -1 - 1);
      case 3:
        return new import_bn.default((value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215) * -1 - 1);
      case 4:
        return new import_bn.default((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) * -1 - 1);
      case 5:
        return new import_bn.default(((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 255) * 4294967296) * -1 - 1);
      case 6:
        return new import_bn.default(((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296) * -1 - 1);
      default:
        return new import_bn.default(value, "le").fromTwos(count * 8);
    }
  }
  switch (count) {
    case 0:
      return new import_bn.default(0);
    case 1:
      return new import_bn.default(value[0]);
    case 2:
      return new import_bn.default(value[0] + (value[1] << 8));
    case 3:
      return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16));
    case 4:
      return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216);
    case 5:
      return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216);
    case 6:
      return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);
    default:
      return new import_bn.default(value, "le");
  }
}
var init_toBn2 = __esm({
  "../../node_modules/@polkadot/util/u8a/toBn.js"() {
    init_bn();
  }
});

// ../../node_modules/@polkadot/util/u8a/toFloat.js
function u8aToFloat(value, { bitLength = 32, isLe = true } = {}) {
  if (bitLength !== 32 && bitLength !== 64) {
    throw new Error("Invalid bitLength provided, expected 32 or 64");
  } else if (value.length < bitLength / 8) {
    throw new Error(`Invalid input buffer provided, expected at least ${bitLength / 8} bytes, found ${value.length}`);
  }
  const dv = new DataView(value.buffer, value.byteOffset);
  return bitLength === 32 ? dv.getFloat32(0, isLe) : dv.getFloat64(0, isLe);
}
var init_toFloat = __esm({
  "../../node_modules/@polkadot/util/u8a/toFloat.js"() {
  }
});

// ../../node_modules/@polkadot/util/u8a/toHex.js
function hex(value, result) {
  const mod2 = value.length % 2 | 0;
  const length = value.length - mod2 | 0;
  for (let i2 = 0; i2 < length; i2 += 2) {
    result += U162[value[i2] << 8 | value[i2 + 1]];
  }
  if (mod2) {
    result += U82[value[length] | 0];
  }
  return result;
}
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  const empty2 = isPrefixed ? "0x" : "";
  if (!value?.length) {
    return empty2;
  } else if (bitLength > 0) {
    const length = Math.ceil(bitLength / 8);
    if (value.length > length) {
      return `${hex(value.subarray(0, length / 2), empty2)}\u2026${hex(value.subarray(value.length - length / 2), "")}`;
    }
  }
  return hex(value, empty2);
}
var U82, U162;
var init_toHex = __esm({
  "../../node_modules/@polkadot/util/u8a/toHex.js"() {
    U82 = new Array(256);
    U162 = new Array(256 * 256);
    for (let n = 0; n < 256; n++) {
      U82[n] = n.toString(16).padStart(2, "0");
    }
    for (let i2 = 0; i2 < 256; i2++) {
      const s2 = i2 << 8;
      for (let j = 0; j < 256; j++) {
        U162[s2 | j] = U82[i2] + U82[j];
      }
    }
  }
});

// ../../node_modules/@polkadot/util/u8a/toNumber.js
function u8aToNumber(value, { isLe = true, isNegative = false } = {}) {
  if (!isLe) {
    value = value.slice().reverse();
  }
  const count = value.length;
  if (isNegative && count && value[count - 1] & 128) {
    switch (count) {
      case 0:
        return 0;
      case 1:
        return (value[0] ^ 255) * -1 - 1;
      case 2:
        return (value[0] + (value[1] << 8) ^ 65535) * -1 - 1;
      case 3:
        return (value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215) * -1 - 1;
      case 4:
        return (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) * -1 - 1;
      case 5:
        return ((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 255) * 4294967296) * -1 - 1;
      case 6:
        return ((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296) * -1 - 1;
      default:
        throw new Error("Value more than 48-bits cannot be reliably converted");
    }
  }
  switch (count) {
    case 0:
      return 0;
    case 1:
      return value[0];
    case 2:
      return value[0] + (value[1] << 8);
    case 3:
      return value[0] + (value[1] << 8) + (value[2] << 16);
    case 4:
      return value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216;
    case 5:
      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216;
    case 6:
      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216;
    default:
      throw new Error("Value more than 48-bits cannot be reliably converted");
  }
}
var init_toNumber = __esm({
  "../../node_modules/@polkadot/util/u8a/toNumber.js"() {
  }
});

// ../../node_modules/@polkadot/util/u8a/toString.js
function u8aToString(value) {
  return value ? decoder.decode(value) : "";
}
var decoder;
var init_toString = __esm({
  "../../node_modules/@polkadot/util/u8a/toString.js"() {
    init_node();
    decoder = new TextDecoder2("utf-8");
  }
});

// ../../node_modules/@polkadot/util/u8a/wrap.js
function u8aIsWrapped(u8a, withEthereum) {
  return u8a.length >= WRAP_LEN && u8aEq(u8a.subarray(0, U8A_WRAP_PREFIX.length), U8A_WRAP_PREFIX) && u8aEq(u8a.slice(-U8A_WRAP_POSTFIX.length), U8A_WRAP_POSTFIX) || withEthereum && u8a.length >= U8A_WRAP_ETHEREUM.length && u8aEq(u8a.subarray(0, U8A_WRAP_ETHEREUM.length), U8A_WRAP_ETHEREUM);
}
function u8aUnwrapBytes(bytes2) {
  const u8a = u8aToU8a(bytes2);
  return u8aIsWrapped(u8a, false) ? u8a.subarray(U8A_WRAP_PREFIX.length, u8a.length - U8A_WRAP_POSTFIX.length) : u8a;
}
function u8aWrapBytes(bytes2) {
  const u8a = u8aToU8a(bytes2);
  return u8aIsWrapped(u8a, true) ? u8a : u8aConcatStrict([U8A_WRAP_PREFIX, u8a, U8A_WRAP_POSTFIX]);
}
var U8A_WRAP_ETHEREUM, U8A_WRAP_PREFIX, U8A_WRAP_POSTFIX, WRAP_LEN;
var init_wrap = __esm({
  "../../node_modules/@polkadot/util/u8a/wrap.js"() {
    init_concat();
    init_eq();
    init_toU8a3();
    U8A_WRAP_ETHEREUM = /* @__PURE__ */ u8aToU8a("Ethereum Signed Message:\n");
    U8A_WRAP_PREFIX = /* @__PURE__ */ u8aToU8a("<Bytes>");
    U8A_WRAP_POSTFIX = /* @__PURE__ */ u8aToU8a("</Bytes>");
    WRAP_LEN = U8A_WRAP_PREFIX.length + U8A_WRAP_POSTFIX.length;
  }
});

// ../../node_modules/@polkadot/util/u8a/index.js
var init_u8a2 = __esm({
  "../../node_modules/@polkadot/util/u8a/index.js"() {
    init_concat();
    init_empty();
    init_eq();
    init_fixLength();
    init_toBigInt();
    init_toBn2();
    init_toFloat();
    init_toHex();
    init_toNumber();
    init_toString();
    init_toU8a3();
    init_wrap();
  }
});

// ../../node_modules/@polkadot/util/bi/toU8a.js
function toU8a(value, isLe, isNegative) {
  const arr = [];
  const withSigned = isNegative && value < _0n;
  if (withSigned) {
    value = (value + _1n) * -_1n;
  }
  while (value !== _0n) {
    const mod2 = value % DIV;
    const val = Number(withSigned ? mod2 ^ NEG_MASK : mod2);
    if (isLe) {
      arr.push(val);
    } else {
      arr.unshift(val);
    }
    value = (value - mod2) / DIV;
  }
  return Uint8Array.from(arr);
}
function nToU8a(value, { bitLength = -1, isLe = true, isNegative = false } = {}) {
  const valueBi = nToBigInt(value);
  if (valueBi === _0n) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(Math.ceil((bitLength || 0) / 8));
  }
  const u8a = toU8a(valueBi, isLe, isNegative);
  if (bitLength === -1) {
    return u8a;
  }
  const byteLength = Math.ceil((bitLength || 0) / 8);
  const output = new Uint8Array(byteLength);
  if (isNegative) {
    output.fill(255);
  }
  output.set(u8a, isLe ? 0 : byteLength - u8a.length);
  return output;
}
var DIV, NEG_MASK;
var init_toU8a4 = __esm({
  "../../node_modules/@polkadot/util/bi/toU8a.js"() {
    init_x_bigint();
    init_consts();
    init_toBigInt4();
    DIV = BigInt2(256);
    NEG_MASK = BigInt2(255);
  }
});

// ../../node_modules/@polkadot/util/bi/index.js
var init_bi = __esm({
  "../../node_modules/@polkadot/util/bi/index.js"() {
    init_toU8a4();
    init_consts();
  }
});

// ../../node_modules/@polkadot/util/hex/stripPrefix.js
function hexStripPrefix(value) {
  if (!value || value === "0x") {
    return "";
  } else if (REGEX_HEX_PREFIXED.test(value)) {
    return value.substring(2);
  } else if (REGEX_HEX_NOPREFIX.test(value)) {
    return value;
  }
  throw new Error(`Expected hex value to convert, found '${value}'`);
}
var init_stripPrefix = __esm({
  "../../node_modules/@polkadot/util/hex/stripPrefix.js"() {
    init_hex();
  }
});

// ../../node_modules/@polkadot/util/hex/toBn.js
function hexToBn(value, { isLe = false, isNegative = false } = {}) {
  if (!value || value === "0x") {
    return new import_bn.default(0);
  }
  const stripped = hexStripPrefix(value);
  const bn = new import_bn.default(stripped, 16, isLe ? "le" : "be");
  return isNegative ? bn.fromTwos(stripped.length * 4) : bn;
}
var init_toBn3 = __esm({
  "../../node_modules/@polkadot/util/hex/toBn.js"() {
    init_bn();
    init_stripPrefix();
  }
});

// ../../node_modules/@polkadot/util/bn/min.js
var bnMax, bnMin;
var init_min = __esm({
  "../../node_modules/@polkadot/util/bn/min.js"() {
    init_helpers();
    bnMax = /* @__PURE__ */ createCmp((a, b) => a.gt(b));
    bnMin = /* @__PURE__ */ createCmp((a, b) => a.lt(b));
  }
});

// ../../node_modules/@polkadot/util/bn/consts.js
var BN_ZERO, BN_ONE, BN_TWO, BN_HUNDRED, BN_MILLION, BN_BILLION, BN_QUINTILL, BN_MAX_INTEGER, BN_SQRT_MAX_INTEGER;
var init_consts2 = __esm({
  "../../node_modules/@polkadot/util/bn/consts.js"() {
    init_bn();
    BN_ZERO = /* @__PURE__ */ new import_bn.default(0);
    BN_ONE = /* @__PURE__ */ new import_bn.default(1);
    BN_TWO = /* @__PURE__ */ new import_bn.default(2);
    BN_HUNDRED = /* @__PURE__ */ new import_bn.default(100);
    BN_MILLION = /* @__PURE__ */ new import_bn.default(1e6);
    BN_BILLION = /* @__PURE__ */ new import_bn.default(1e9);
    BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
    BN_MAX_INTEGER = /* @__PURE__ */ new import_bn.default(Number.MAX_SAFE_INTEGER);
    BN_SQRT_MAX_INTEGER = /* @__PURE__ */ new import_bn.default(94906265);
  }
});

// ../../node_modules/@polkadot/util/is/bigInt.js
function isBigInt(value) {
  return typeof value === "bigint";
}
var init_bigInt = __esm({
  "../../node_modules/@polkadot/util/is/bigInt.js"() {
  }
});

// ../../node_modules/@polkadot/util/bn/toBn.js
function bnToBn(value) {
  return value ? import_bn.default.isBN(value) ? value : isHex(value) ? hexToBn(value.toString()) : isBigInt(value) ? new import_bn.default(value.toString()) : isToBn(value) ? value.toBn() : isToBigInt(value) ? new import_bn.default(value.toBigInt().toString()) : new import_bn.default(value) : new import_bn.default(0);
}
var init_toBn4 = __esm({
  "../../node_modules/@polkadot/util/bn/toBn.js"() {
    init_toBn3();
    init_bigInt();
    init_hex();
    init_toBigInt3();
    init_toBn();
    init_bn();
  }
});

// ../../node_modules/@polkadot/util/bn/sqrt.js
function bnSqrt(value) {
  const n = bnToBn(value);
  if (n.isNeg()) {
    throw new Error("square root of negative numbers is not supported");
  }
  if (n.lte(BN_MAX_INTEGER)) {
    return new import_bn.default(~~Math.sqrt(n.toNumber()));
  }
  let x0 = BN_SQRT_MAX_INTEGER.clone();
  while (true) {
    const x1 = n.div(x0).iadd(x0).ishrn(1);
    if (x0.eq(x1) || x0.eq(x1.sub(BN_ONE))) {
      return x0;
    }
    x0 = x1;
  }
}
var init_sqrt = __esm({
  "../../node_modules/@polkadot/util/bn/sqrt.js"() {
    init_bn();
    init_consts2();
    init_toBn4();
  }
});

// ../../node_modules/@polkadot/util/bn/toU8a.js
function bnToU8a(value, { bitLength = -1, isLe = true, isNegative = false } = DEFAULT_OPTS) {
  const valueBn = bnToBn(value);
  const byteLength = bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((bitLength || 0) / 8);
  if (!value) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(byteLength);
  }
  const output = new Uint8Array(byteLength);
  const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
  output.set(bn.toArray(isLe ? "le" : "be", byteLength), 0);
  return output;
}
var DEFAULT_OPTS;
var init_toU8a5 = __esm({
  "../../node_modules/@polkadot/util/bn/toU8a.js"() {
    init_toBn4();
    DEFAULT_OPTS = { bitLength: -1, isLe: true, isNegative: false };
  }
});

// ../../node_modules/@polkadot/util/bn/toHex.js
function bnToHex(value, { bitLength = -1, isLe = false, isNegative = false } = {}) {
  return u8aToHex(bnToU8a(value, { bitLength, isLe, isNegative }));
}
var init_toHex2 = __esm({
  "../../node_modules/@polkadot/util/bn/toHex.js"() {
    init_u8a2();
    init_toU8a5();
  }
});

// ../../node_modules/@polkadot/util/bn/index.js
var init_bn3 = __esm({
  "../../node_modules/@polkadot/util/bn/index.js"() {
    init_bn();
    init_min();
    init_sqrt();
    init_toBn4();
    init_toHex2();
    init_toU8a5();
    init_consts2();
  }
});

// ../../node_modules/@polkadot/util/buffer/index.js
var init_buffer2 = __esm({
  "../../node_modules/@polkadot/util/buffer/index.js"() {
  }
});

// ../../node_modules/@polkadot/util/compact/toU8a.js
function compactToU8a(value) {
  const bn = bnToBn(value);
  if (bn.lte(MAX_U8)) {
    return new Uint8Array([bn.toNumber() << 2]);
  } else if (bn.lte(MAX_U16)) {
    return bnToU8a(bn.shln(2).iadd(BN_ONE), BL_16);
  } else if (bn.lte(MAX_U32)) {
    return bnToU8a(bn.shln(2).iadd(BN_TWO), BL_32);
  }
  const u8a = bnToU8a(bn);
  let length = u8a.length;
  while (u8a[length - 1] === 0) {
    length--;
  }
  if (length < 4) {
    throw new Error("Invalid length, previous checks match anything less than 2^30");
  }
  return u8aConcatStrict([
    // subtract 4 as minimum (also catered for in decoding)
    new Uint8Array([(length - 4 << 2) + 3]),
    u8a.subarray(0, length)
  ]);
}
var MAX_U8, MAX_U16, MAX_U32, BL_16, BL_32;
var init_toU8a6 = __esm({
  "../../node_modules/@polkadot/util/compact/toU8a.js"() {
    init_bn3();
    init_u8a2();
    MAX_U8 = BN_TWO.pow(new import_bn.default(8 - 2)).isub(BN_ONE);
    MAX_U16 = BN_TWO.pow(new import_bn.default(16 - 2)).isub(BN_ONE);
    MAX_U32 = BN_TWO.pow(new import_bn.default(32 - 2)).isub(BN_ONE);
    BL_16 = { bitLength: 16 };
    BL_32 = { bitLength: 32 };
  }
});

// ../../node_modules/@polkadot/util/compact/addLength.js
function compactAddLength(input) {
  return u8aConcatStrict([
    compactToU8a(input.length),
    input
  ]);
}
var init_addLength = __esm({
  "../../node_modules/@polkadot/util/compact/addLength.js"() {
    init_u8a2();
    init_toU8a6();
  }
});

// ../../node_modules/@polkadot/util/compact/fromU8a.js
function compactFromU8a(input) {
  const u8a = u8aToU8a(input);
  switch (u8a[0] & 3) {
    case 0:
      return [1, new import_bn.default(u8a[0] >>> 2)];
    case 1:
      return [2, new import_bn.default(u8a[0] + (u8a[1] << 8) >>> 2)];
    case 2:
      return [4, new import_bn.default(u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 16777216 >>> 2)];
    // 0b11
    default: {
      const offset = (u8a[0] >>> 2) + 5;
      switch (offset) {
        // there still could be 4 bytes data, similar to 0b10 above (with offsets)
        case 5:
          return [5, new import_bn.default(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 16777216)];
        case 6:
          return [6, new import_bn.default(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 16777216)];
        // 6 bytes data is the maximum, 48 bits (56 would overflow)
        case 7:
          return [7, new import_bn.default(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216)];
        // for anything else, use the non-unrolled version
        default:
          return [offset, u8aToBn(u8a.subarray(1, offset))];
      }
    }
  }
}
function compactFromU8aLim(u8a) {
  switch (u8a[0] & 3) {
    case 0:
      return [1, u8a[0] >>> 2];
    case 1:
      return [2, u8a[0] + (u8a[1] << 8) >>> 2];
    case 2:
      return [4, u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 16777216 >>> 2];
    // 0b11
    default: {
      switch ((u8a[0] >>> 2) + 5) {
        // there still could be 4 bytes data, similar to 0b10 above (with offsets)
        case 5:
          return [5, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 16777216];
        case 6:
          return [6, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 16777216];
        // 6 bytes data is the maximum, 48 bits (56 would overflow)
        case 7:
          return [7, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216];
        // for anything else, we are above the actual MAX_SAFE_INTEGER - bail out
        default:
          throw new Error("Compact input is > Number.MAX_SAFE_INTEGER");
      }
    }
  }
}
var init_fromU8a = __esm({
  "../../node_modules/@polkadot/util/compact/fromU8a.js"() {
    init_bn3();
    init_u8a2();
  }
});

// ../../node_modules/@polkadot/util/compact/stripLength.js
function compactStripLength(input) {
  const [offset, length] = compactFromU8a(input);
  const total = offset + length.toNumber();
  return [
    total,
    input.subarray(offset, total)
  ];
}
var init_stripLength = __esm({
  "../../node_modules/@polkadot/util/compact/stripLength.js"() {
    init_fromU8a();
  }
});

// ../../node_modules/@polkadot/util/compact/index.js
var init_compact = __esm({
  "../../node_modules/@polkadot/util/compact/index.js"() {
    init_addLength();
    init_fromU8a();
    init_stripLength();
    init_toU8a6();
  }
});

// ../../node_modules/@polkadot/util/extractTime.js
var MIN_MS, HR_MS, DAY_MS;
var init_extractTime = __esm({
  "../../node_modules/@polkadot/util/extractTime.js"() {
    MIN_MS = 60 * 1e3;
    HR_MS = MIN_MS * 60;
    DAY_MS = HR_MS * 24;
  }
});

// ../../node_modules/@polkadot/util/float/toU8a.js
function floatToU8a(value = 0, { bitLength = 32, isLe = true } = {}) {
  if (bitLength !== 32 && bitLength !== 64) {
    throw new Error("Invalid bitLength provided, expected 32 or 64");
  }
  const result = new Uint8Array(bitLength / 8);
  const dv = new DataView(result.buffer, result.byteOffset);
  if (bitLength === 32) {
    dv.setFloat32(0, Number(value), isLe);
  } else {
    dv.setFloat64(0, Number(value), isLe);
  }
  return result;
}
var init_toU8a7 = __esm({
  "../../node_modules/@polkadot/util/float/toU8a.js"() {
  }
});

// ../../node_modules/@polkadot/util/float/index.js
var init_float = __esm({
  "../../node_modules/@polkadot/util/float/index.js"() {
    init_toU8a7();
  }
});

// ../../node_modules/@polkadot/util/is/boolean.js
function isBoolean(value) {
  return typeof value === "boolean";
}
var init_boolean = __esm({
  "../../node_modules/@polkadot/util/is/boolean.js"() {
  }
});

// ../../node_modules/@polkadot/util/format/formatDecimal.js
function formatDecimal(value, separator = ",") {
  const isNegative = value[0].startsWith("-");
  const matched = isNegative ? value.substring(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
  return matched ? `${isNegative ? "-" : ""}${matched.join(separator)}` : value;
}
var NUMBER_REGEX;
var init_formatDecimal = __esm({
  "../../node_modules/@polkadot/util/format/formatDecimal.js"() {
    NUMBER_REGEX = new RegExp("(\\d+?)(?=(\\d{3})+(?!\\d)|$)", "g");
  }
});

// ../../node_modules/@polkadot/util/format/getSeparator.js
function getSeparator(locale) {
  return {
    decimal: 0.1.toLocaleString(locale).substring(1, 2),
    thousand: 1e3.toLocaleString(locale).substring(1, 2)
  };
}
var init_getSeparator = __esm({
  "../../node_modules/@polkadot/util/format/getSeparator.js"() {
  }
});

// ../../node_modules/@polkadot/util/format/si.js
function findSi(type) {
  for (let i2 = 0, count = SI.length; i2 < count; i2++) {
    if (SI[i2].value === type) {
      return SI[i2];
    }
  }
  return SI[SI_MID];
}
function calcSi(text, decimals, forceUnit) {
  if (forceUnit) {
    return findSi(forceUnit);
  }
  const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);
  return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
}
var SI_MID, SI;
var init_si = __esm({
  "../../node_modules/@polkadot/util/format/si.js"() {
    SI_MID = 8;
    SI = [
      { power: -24, text: "yocto", value: "y" },
      { power: -21, text: "zepto", value: "z" },
      { power: -18, text: "atto", value: "a" },
      { power: -15, text: "femto", value: "f" },
      { power: -12, text: "pico", value: "p" },
      { power: -9, text: "nano", value: "n" },
      { power: -6, text: "micro", value: "\xB5" },
      { power: -3, text: "milli", value: "m" },
      { power: 0, text: "Unit", value: "-" },
      // position 8
      { power: 3, text: "Kilo", value: "k" },
      { power: 6, text: "Mill", value: "M" },
      // Mega, M
      { power: 9, text: "Bill", value: "B" },
      // Giga, G
      { power: 12, text: "Tril", value: "T" },
      // Tera, T
      { power: 15, text: "Peta", value: "P" },
      { power: 18, text: "Exa", value: "E" },
      { power: 21, text: "Zeta", value: "Z" },
      { power: 24, text: "Yotta", value: "Y" }
    ];
  }
});

// ../../node_modules/@polkadot/util/format/formatBalance.js
function _formatBalance(input, { decimals = defaultDecimals, forceUnit, locale = "en", withAll = false, withSi = true, withSiFull = false, withUnit = true, withZero = true } = {}) {
  let text = bnToBn(input).toString();
  if (text.length === 0 || text === "0") {
    return "0";
  }
  let sign2 = "";
  if (text[0].startsWith("-")) {
    sign2 = "-";
    text = text.substring(1);
  }
  const si = calcSi(text, decimals, forceUnit);
  const mid = text.length - (decimals + si.power);
  const pre = mid <= 0 ? "0" : text.substring(0, mid);
  let post = text.padStart(mid < 0 ? decimals : 1, "0").substring(mid < 0 ? 0 : mid).padEnd(withAll ? Math.max(decimals, 4) : 4, "0").substring(0, withAll ? Math.max(4, decimals + si.power) : 4);
  if (!withZero) {
    let end = post.length - 1;
    do {
      if (post[end] === "0") {
        end--;
      }
    } while (post[end] === "0");
    post = post.substring(0, end + 1);
  }
  const unit = isBoolean(withUnit) ? SI[SI_MID].text : withUnit;
  const units = withSi || withSiFull ? si.value === "-" ? withUnit ? ` ${unit}` : "" : ` ${withSiFull ? `${si.text}${withUnit ? " " : ""}` : si.value}${withUnit ? unit : ""}` : "";
  const { decimal, thousand } = getSeparator(locale);
  return `${sign2}${formatDecimal(pre, thousand)}${post && `${decimal}${post}`}${units}`;
}
var DEFAULT_DECIMALS, DEFAULT_UNIT, defaultDecimals, defaultUnit, formatBalance;
var init_formatBalance = __esm({
  "../../node_modules/@polkadot/util/format/formatBalance.js"() {
    init_toBn4();
    init_boolean();
    init_formatDecimal();
    init_getSeparator();
    init_si();
    DEFAULT_DECIMALS = 0;
    DEFAULT_UNIT = SI[SI_MID].text;
    defaultDecimals = DEFAULT_DECIMALS;
    defaultUnit = DEFAULT_UNIT;
    formatBalance = _formatBalance;
    formatBalance.calcSi = (text, decimals = defaultDecimals) => calcSi(text, decimals);
    formatBalance.findSi = findSi;
    formatBalance.getDefaults = () => {
      return {
        decimals: defaultDecimals,
        unit: defaultUnit
      };
    };
    formatBalance.getOptions = (decimals = defaultDecimals) => {
      return SI.filter(({ power }) => power < 0 ? decimals + power >= 0 : true);
    };
    formatBalance.setDefaults = ({ decimals, unit }) => {
      defaultDecimals = (Array.isArray(decimals) ? decimals[0] : decimals) ?? defaultDecimals;
      defaultUnit = (Array.isArray(unit) ? unit[0] : unit) ?? defaultUnit;
      SI[SI_MID].text = defaultUnit;
    };
  }
});

// ../../node_modules/@polkadot/util/format/formatDate.js
function zeroPad(value) {
  return value.toString().padStart(2, "0");
}
function formatDate(date) {
  const year = date.getFullYear().toString();
  const month = zeroPad(date.getMonth() + 1);
  const day = zeroPad(date.getDate());
  const hour = zeroPad(date.getHours());
  const minute = zeroPad(date.getMinutes());
  const second = zeroPad(date.getSeconds());
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}
var init_formatDate = __esm({
  "../../node_modules/@polkadot/util/format/formatDate.js"() {
  }
});

// ../../node_modules/@polkadot/util/format/formatNumber.js
function formatNumber(value, { locale = "en" } = {}) {
  const { thousand } = getSeparator(locale);
  return formatDecimal(bnToBn(value).toString(), thousand);
}
var init_formatNumber = __esm({
  "../../node_modules/@polkadot/util/format/formatNumber.js"() {
    init_toBn4();
    init_formatDecimal();
    init_getSeparator();
  }
});

// ../../node_modules/@polkadot/util/format/index.js
var init_format = __esm({
  "../../node_modules/@polkadot/util/format/index.js"() {
    init_formatBalance();
    init_formatNumber();
  }
});

// ../../node_modules/@polkadot/util/hex/index.js
var init_hex2 = __esm({
  "../../node_modules/@polkadot/util/hex/index.js"() {
    init_toBn3();
    init_toU8a();
  }
});

// ../../node_modules/@polkadot/util/is/string.js
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
var init_string = __esm({
  "../../node_modules/@polkadot/util/is/string.js"() {
  }
});

// ../../node_modules/@polkadot/util/is/ascii.js
function isAsciiStr(str) {
  for (let i2 = 0, count = str.length; i2 < count; i2++) {
    const b = str.charCodeAt(i2);
    if (b < 32 || b > 126) {
      return false;
    }
  }
  return true;
}
function isAsciiBytes(u8a) {
  for (let i2 = 0, count = u8a.length; i2 < count; i2++) {
    const b = u8a[i2] | 0;
    if (b < 32 || b > 126) {
      return false;
    }
  }
  return true;
}
function isAscii(value) {
  return isString(value) ? isHex(value) ? isAsciiBytes(u8aToU8a(value)) : isAsciiStr(value) : value ? isAsciiBytes(value) : false;
}
var init_ascii = __esm({
  "../../node_modules/@polkadot/util/is/ascii.js"() {
    init_toU8a3();
    init_hex();
    init_string();
  }
});

// ../../node_modules/@polkadot/util/is/class.js
var isClass;
var init_class = __esm({
  "../../node_modules/@polkadot/util/is/class.js"() {
    init_helpers2();
    isClass = /* @__PURE__ */ isOnFunction("isPrototypeOf", "hasOwnProperty");
  }
});

// ../../node_modules/@polkadot/util/is/childClass.js
function isChildClass(Parent, Child) {
  return isClass(Child) && isClass(Parent) ? Parent === Child || Parent.isPrototypeOf(Child) : false;
}
var init_childClass = __esm({
  "../../node_modules/@polkadot/util/is/childClass.js"() {
    init_class();
  }
});

// ../../node_modules/@polkadot/util/is/codec.js
function isCodec(value) {
  return checkCodec(value) && checkRegistry(value.registry);
}
var checkCodec, checkRegistry;
var init_codec = __esm({
  "../../node_modules/@polkadot/util/is/codec.js"() {
    init_helpers2();
    checkCodec = /* @__PURE__ */ isOnObject("toHex", "toHuman", "toU8a");
    checkRegistry = /* @__PURE__ */ isOnObject("get");
  }
});

// ../../node_modules/@polkadot/util/is/compact.js
var isCompact;
var init_compact2 = __esm({
  "../../node_modules/@polkadot/util/is/compact.js"() {
    init_helpers2();
    isCompact = /* @__PURE__ */ isOnObject("toBigInt", "toBn", "toNumber", "unwrap");
  }
});

// ../../node_modules/@polkadot/util/is/error.js
function isError(value) {
  return (value && value.constructor) === Error || value instanceof Error;
}
var init_error = __esm({
  "../../node_modules/@polkadot/util/is/error.js"() {
  }
});

// ../../node_modules/@polkadot/util/stringify.js
function replacer(_, v) {
  return isBigInt(v) ? v.toString() : v;
}
function stringify(value, space) {
  return JSON.stringify(value, replacer, space);
}
var init_stringify = __esm({
  "../../node_modules/@polkadot/util/stringify.js"() {
    init_bigInt();
  }
});

// ../../node_modules/@polkadot/util/is/null.js
function isNull(value) {
  return value === null;
}
var init_null = __esm({
  "../../node_modules/@polkadot/util/is/null.js"() {
  }
});

// ../../node_modules/@polkadot/util/is/number.js
function isNumber(value) {
  return typeof value === "number";
}
var init_number = __esm({
  "../../node_modules/@polkadot/util/is/number.js"() {
  }
});

// ../../node_modules/@polkadot/util/is/undefined.js
function isUndefined(value) {
  return value === void 0;
}
var init_undefined = __esm({
  "../../node_modules/@polkadot/util/is/undefined.js"() {
  }
});

// ../../node_modules/@polkadot/util/is/utf8.js
function isUtf8(value) {
  if (!value) {
    return isString(value);
  }
  const u8a = u8aToU8a(value);
  const len = u8a.length;
  let i2 = 0;
  while (i2 < len) {
    if (u8a[i2] <= 127) {
      i2 += 1;
    } else if (u8a[i2] >= 194 && u8a[i2] <= 223) {
      if (i2 + 1 < len) {
        if (u8a[i2 + 1] < 128 || u8a[i2 + 1] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 2;
    } else if (u8a[i2] === 224) {
      if (i2 + 2 < len) {
        if (u8a[i2 + 1] < 160 || u8a[i2 + 1] > 191) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 3;
    } else if (u8a[i2] >= 225 && u8a[i2] <= 236) {
      if (i2 + 2 < len) {
        if (u8a[i2 + 1] < 128 || u8a[i2 + 1] > 191) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 3;
    } else if (u8a[i2] === 237) {
      if (i2 + 2 < len) {
        if (u8a[i2 + 1] < 128 || u8a[i2 + 1] > 159) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 3;
    } else if (u8a[i2] >= 238 && u8a[i2] <= 239) {
      if (i2 + 2 < len) {
        if (u8a[i2 + 1] < 128 || u8a[i2 + 1] > 191) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 3;
    } else if (u8a[i2] === 240) {
      if (i2 + 3 < len) {
        if (u8a[i2 + 1] < 144 || u8a[i2 + 1] > 191) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
        if (u8a[i2 + 3] < 128 || u8a[i2 + 3] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 4;
    } else if (u8a[i2] >= 241 && u8a[i2] <= 243) {
      if (i2 + 3 < len) {
        if (u8a[i2 + 1] < 128 || u8a[i2 + 1] > 191) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
        if (u8a[i2 + 3] < 128 || u8a[i2 + 3] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 4;
    } else if (u8a[i2] === 244) {
      if (i2 + 3 < len) {
        if (u8a[i2 + 1] < 128 || u8a[i2 + 1] > 143) {
          return false;
        }
        if (u8a[i2 + 2] < 128 || u8a[i2 + 2] > 191) {
          return false;
        }
        if (u8a[i2 + 3] < 128 || u8a[i2 + 3] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i2 += 4;
    } else {
      return false;
    }
  }
  return true;
}
var init_utf8 = __esm({
  "../../node_modules/@polkadot/util/is/utf8.js"() {
    init_toU8a3();
    init_string();
  }
});

// ../../node_modules/@polkadot/util/is/index.js
var init_is = __esm({
  "../../node_modules/@polkadot/util/is/index.js"() {
    init_ascii();
    init_bigInt();
    init_bn2();
    init_boolean();
    init_childClass();
    init_codec();
    init_compact2();
    init_error();
    init_function();
    init_hex();
    init_null();
    init_number();
    init_object();
    init_string();
    init_u8a();
    init_undefined();
    init_utf8();
  }
});

// ../../node_modules/@polkadot/util/lazy.js
function lazyMethod(result, item, creator, getName, index = 0) {
  const name = getName ? getName(item, index) : item.toString();
  let value;
  Object.defineProperty(result, name, {
    // This allows for re-configuration with the embedded defineProperty below
    // and ensures that on tested browsers and Node, it _will_ be redefined
    // and thus short-circuited for future access
    configurable: true,
    enumerable: true,
    // Use a function here, we don't want to capture the outer this, i.e.
    // don't use arrow functions in this context since we have a this inside
    get: function() {
      if (value === void 0) {
        value = creator(item, index, this);
        try {
          Object.defineProperty(this, name, { value });
        } catch {
        }
      }
      return value;
    }
  });
}
function lazyMethods(result, items, creator, getName) {
  for (let i2 = 0, count = items.length; i2 < count; i2++) {
    lazyMethod(result, items[i2], creator, getName, i2);
  }
  return result;
}
var init_lazy = __esm({
  "../../node_modules/@polkadot/util/lazy.js"() {
  }
});

// ../../node_modules/@polkadot/util/noop.js
function identity(value) {
  return value;
}
function noop() {
}
var init_noop = __esm({
  "../../node_modules/@polkadot/util/noop.js"() {
  }
});

// ../../node_modules/@polkadot/util/logger.js
function formatOther(value) {
  if (value && isObject(value) && value.constructor === Object) {
    const result = {};
    for (const [k, v] of Object.entries(value)) {
      result[k] = loggerFormat(v);
    }
    return result;
  }
  return value;
}
function loggerFormat(value) {
  if (Array.isArray(value)) {
    return value.map(loggerFormat);
  } else if (isBn(value)) {
    return value.toString();
  } else if (isU8a(value) || isBuffer(value)) {
    return u8aToHex(u8aToU8a(value));
  }
  return formatOther(value);
}
function formatWithLength(maxLength) {
  return (v) => {
    if (maxLength <= 0) {
      return v;
    }
    const r2 = `${v}`;
    return r2.length < maxLength ? v : `${r2.substring(0, maxLength)} ...`;
  };
}
function apply(log, type, values, maxSize = -1) {
  if (values.length === 1 && isFunction(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
  }
  console[logTo[log]](formatDate(/* @__PURE__ */ new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));
}
function isDebugOn(e2, type) {
  return !!e2 && (e2 === "*" || type === e2 || e2.endsWith("*") && type.startsWith(e2.slice(0, -1)));
}
function isDebugOff(e2, type) {
  return !!e2 && (e2.startsWith("-") && (type === e2.slice(1) || e2.endsWith("*") && type.startsWith(e2.slice(1, -1))));
}
function getDebugFlag(env, type) {
  let flag = false;
  for (const e2 of env) {
    if (isDebugOn(e2, type)) {
      flag = true;
    } else if (isDebugOff(e2, type)) {
      flag = false;
    }
  }
  return flag;
}
function parseEnv(type) {
  const maxSize = parseInt(xglobal.process?.env?.["DEBUG_MAX"] || "-1", 10);
  return [
    getDebugFlag((xglobal.process?.env?.["DEBUG"] || "").toLowerCase().split(","), type),
    isNaN(maxSize) ? -1 : maxSize
  ];
}
function logger(origin) {
  const type = `${origin.toUpperCase()}:`.padStart(16);
  const [isDebug, maxSize] = parseEnv(origin.toLowerCase());
  return {
    debug: isDebug ? (...values) => apply("debug", type, values, maxSize) : noop,
    error: (...values) => apply("error", type, values),
    log: (...values) => apply("log", type, values),
    noop,
    warn: (...values) => apply("warn", type, values)
  };
}
var logTo;
var init_logger = __esm({
  "../../node_modules/@polkadot/util/logger.js"() {
    init_x_global();
    init_formatDate();
    init_bn2();
    init_buffer();
    init_function();
    init_object();
    init_u8a();
    init_toHex();
    init_toU8a3();
    init_noop();
    logTo = {
      debug: "log",
      error: "error",
      log: "log",
      warn: "warn"
    };
  }
});

// ../../node_modules/@polkadot/util/memoize.js
function defaultGetId() {
  return "none";
}
function memoize(fn, { getInstanceId = defaultGetId } = {}) {
  const cache = {};
  const memoized2 = (...args) => {
    const stringParams = stringify(args);
    const instanceId = getInstanceId();
    if (!cache[instanceId]) {
      cache[instanceId] = {};
    }
    if (cache[instanceId][stringParams] === void 0) {
      cache[instanceId][stringParams] = fn(...args);
    }
    return cache[instanceId][stringParams];
  };
  memoized2.unmemoize = (...args) => {
    const stringParams = stringify(args);
    const instanceId = getInstanceId();
    if (cache[instanceId]?.[stringParams] !== void 0) {
      delete cache[instanceId][stringParams];
    }
  };
  return memoized2;
}
var init_memoize = __esm({
  "../../node_modules/@polkadot/util/memoize.js"() {
    init_stringify();
  }
});

// ../../node_modules/@polkadot/util/nextTick.js
function nextTick(onExec, onError) {
  setTimeout(() => {
    Promise.resolve().then(() => {
      onExec();
    }).catch((error) => {
      if (onError) {
        onError(error);
      } else {
        console.error(error);
      }
    });
  }, 0);
}
var init_nextTick = __esm({
  "../../node_modules/@polkadot/util/nextTick.js"() {
  }
});

// ../../node_modules/@polkadot/util/number/index.js
var init_number2 = __esm({
  "../../node_modules/@polkadot/util/number/index.js"() {
  }
});

// ../../node_modules/@polkadot/util/object/clear.js
function objectClear(value) {
  const keys2 = Object.keys(value);
  for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
    delete value[keys2[i2]];
  }
  return value;
}
var init_clear = __esm({
  "../../node_modules/@polkadot/util/object/clear.js"() {
  }
});

// ../../node_modules/@polkadot/util/object/spread.js
function objectSpread(dest, ...sources) {
  for (let i2 = 0, count = sources.length; i2 < count; i2++) {
    const src = sources[i2];
    if (src) {
      if (typeof src.entries === "function") {
        for (const [key, value] of src.entries()) {
          dest[key] = value;
        }
      } else {
        Object.assign(dest, src);
      }
    }
  }
  return dest;
}
var init_spread = __esm({
  "../../node_modules/@polkadot/util/object/spread.js"() {
  }
});

// ../../node_modules/@polkadot/util/object/property.js
function objectProperty(that, key, getter, getName, index = 0) {
  const name = getName ? getName(key, index) : key;
  if (!(name in that)) {
    Object.defineProperty(that, name, {
      enumerable: true,
      // Unlike in lazy, we always call into the upper function, i.e. this method
      // does not cache old values (it is expected to be used for dynamic values)
      get: function() {
        return getter(key, index, this);
      }
    });
  }
}
function objectProperties(that, keys2, getter, getName) {
  for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
    objectProperty(that, keys2[i2], getter, getName, i2);
  }
}
var init_property = __esm({
  "../../node_modules/@polkadot/util/object/property.js"() {
  }
});

// ../../node_modules/@polkadot/util/object/index.js
var init_object2 = __esm({
  "../../node_modules/@polkadot/util/object/index.js"() {
    init_clear();
    init_property();
    init_spread();
  }
});

// ../../node_modules/@polkadot/util/promisify.js
var init_promisify = __esm({
  "../../node_modules/@polkadot/util/promisify.js"() {
  }
});

// ../../node_modules/@polkadot/util/string/camelCase.js
function formatAllCaps(w) {
  return w.slice(0, w.length - 1).toLowerCase() + CC_TO_UP[w.charCodeAt(w.length - 1)];
}
function converter(format) {
  return (value) => {
    const parts = value.replace(/[-_., ]+/g, " ").trim().split(" ");
    let result = "";
    for (let i2 = 0, count = parts.length; i2 < count; i2++) {
      const w = parts[i2];
      result += format(/^[\dA-Z]+$/.test(w) ? w.toLowerCase() : w.replace(/^[\dA-Z]{2,}[^a-z]/, formatAllCaps), i2);
    }
    return result;
  };
}
var CC_TO_UP, CC_TO_LO, stringCamelCase, stringPascalCase;
var init_camelCase = __esm({
  "../../node_modules/@polkadot/util/string/camelCase.js"() {
    CC_TO_UP = new Array(256);
    CC_TO_LO = new Array(256);
    for (let i2 = 0, count = CC_TO_UP.length; i2 < count; i2++) {
      CC_TO_LO[i2] = String.fromCharCode(i2).toLowerCase();
      CC_TO_UP[i2] = String.fromCharCode(i2).toUpperCase();
    }
    stringCamelCase = /* @__PURE__ */ converter((w, i2) => (i2 ? CC_TO_UP[w.charCodeAt(0)] : CC_TO_LO[w.charCodeAt(0)]) + w.slice(1));
    stringPascalCase = /* @__PURE__ */ converter((w) => CC_TO_UP[w.charCodeAt(0)] + w.slice(1));
  }
});

// ../../node_modules/@polkadot/util/string/lowerFirst.js
function converter2(map79) {
  return (value) => value ? map79[value.charCodeAt(0)] + value.slice(1) : "";
}
var stringUpperFirst;
var init_lowerFirst = __esm({
  "../../node_modules/@polkadot/util/string/lowerFirst.js"() {
    init_camelCase();
    stringUpperFirst = /* @__PURE__ */ converter2(CC_TO_UP);
  }
});

// ../../node_modules/@polkadot/util/string/toHex.js
function stringToHex(value) {
  return u8aToHex(stringToU8a(value));
}
var init_toHex3 = __esm({
  "../../node_modules/@polkadot/util/string/toHex.js"() {
    init_toHex();
    init_toU8a2();
  }
});

// ../../node_modules/@polkadot/util/string/index.js
var init_string2 = __esm({
  "../../node_modules/@polkadot/util/string/index.js"() {
    init_camelCase();
    init_lowerFirst();
    init_toHex3();
    init_toU8a2();
  }
});

// ../../node_modules/@polkadot/util/bundle.js
var init_bundle = __esm({
  "../../node_modules/@polkadot/util/bundle.js"() {
    init_array();
    init_assert();
    init_bi();
    init_bn3();
    init_buffer2();
    init_compact();
    init_detectPackage();
    init_extractTime();
    init_float();
    init_format();
    init_has();
    init_hex2();
    init_is();
    init_lazy();
    init_logger();
    init_memoize();
    init_nextTick();
    init_noop();
    init_number2();
    init_object2();
    init_promisify();
    init_string2();
    init_stringify();
    init_u8a2();
  }
});

// ../../node_modules/@polkadot/util/index.js
var init_util = __esm({
  "../../node_modules/@polkadot/util/index.js"() {
    init_packageDetect();
    init_bundle();
  }
});

// ../../node_modules/@polkadot/api/packageInfo.js
var import_meta9, packageInfo9;
var init_packageInfo9 = __esm({
  "../../node_modules/@polkadot/api/packageInfo.js"() {
    import_meta9 = {};
    packageInfo9 = { name: "@polkadot/api", path: import_meta9 && import_meta9.url ? new URL(import_meta9.url).pathname.substring(0, new URL(import_meta9.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/api/packageDetect.js
var init_packageDetect2 = __esm({
  "../../node_modules/@polkadot/api/packageDetect.js"() {
    init_packageInfo();
    init_packageInfo2();
    init_packageInfo3();
    init_packageInfo4();
    init_packageInfo5();
    init_util();
    init_packageInfo9();
    detectPackage(packageInfo9, null, [packageInfo2, packageInfo, packageInfo5, packageInfo3, packageInfo4]);
  }
});

// ../../node_modules/@polkadot/util-crypto/packageInfo.js
var import_meta10, packageInfo10;
var init_packageInfo10 = __esm({
  "../../node_modules/@polkadot/util-crypto/packageInfo.js"() {
    import_meta10 = {};
    packageInfo10 = { name: "@polkadot/util-crypto", path: import_meta10 && import_meta10.url ? new URL(import_meta10.url).pathname.substring(0, new URL(import_meta10.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/keyring/packageInfo.js
var import_meta11, packageInfo11;
var init_packageInfo11 = __esm({
  "../../node_modules/@polkadot/keyring/packageInfo.js"() {
    import_meta11 = {};
    packageInfo11 = { name: "@polkadot/keyring", path: import_meta11 && import_meta11.url ? new URL(import_meta11.url).pathname.substring(0, new URL(import_meta11.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/keyring/packageDetect.js
var init_packageDetect3 = __esm({
  "../../node_modules/@polkadot/keyring/packageDetect.js"() {
    init_util();
    init_packageInfo8();
    init_packageInfo10();
    init_packageInfo11();
    detectPackage(packageInfo11, null, [packageInfo10, packageInfo8]);
  }
});

// ../../node_modules/@polkadot/networks/packageInfo.js
var import_meta12, packageInfo12;
var init_packageInfo12 = __esm({
  "../../node_modules/@polkadot/networks/packageInfo.js"() {
    import_meta12 = {};
    packageInfo12 = { name: "@polkadot/networks", path: import_meta12 && import_meta12.url ? new URL(import_meta12.url).pathname.substring(0, new URL(import_meta12.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/x-randomvalues/packageInfo.js
var import_meta13, packageInfo13;
var init_packageInfo13 = __esm({
  "../../node_modules/@polkadot/x-randomvalues/packageInfo.js"() {
    import_meta13 = {};
    packageInfo13 = { name: "@polkadot/x-randomvalues", path: import_meta13 && import_meta13.url ? new URL(import_meta13.url).pathname.substring(0, new URL(import_meta13.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.2.3" };
  }
});

// ../../node_modules/@polkadot/x-randomvalues/node.js
function getRandomValues(output) {
  return crypto.getRandomValues(output);
}
var import_node_crypto, crypto;
var init_node3 = __esm({
  "../../node_modules/@polkadot/x-randomvalues/node.js"() {
    import_node_crypto = __toESM(require("node:crypto"), 1);
    init_x_global();
    init_packageInfo13();
    crypto = /* @__PURE__ */ extractGlobal("crypto", import_node_crypto.default.webcrypto);
  }
});

// ../../node_modules/@polkadot/util-crypto/packageDetect.js
var init_packageDetect4 = __esm({
  "../../node_modules/@polkadot/util-crypto/packageDetect.js"() {
    init_packageInfo12();
    init_util();
    init_packageInfo8();
    init_node3();
    init_packageInfo10();
    detectPackage(packageInfo10, null, [packageInfo12, packageInfo13, packageInfo8]);
  }
});

// ../../node_modules/@polkadot/x-bigint/shim.js
var init_shim = __esm({
  "../../node_modules/@polkadot/x-bigint/shim.js"() {
    init_x_bigint();
    init_x_global();
    exposeGlobal("BigInt", BigInt2);
  }
});

// ../../node_modules/@polkadot/wasm-bridge/packageInfo.js
var import_meta14, packageInfo14;
var init_packageInfo14 = __esm({
  "../../node_modules/@polkadot/wasm-bridge/packageInfo.js"() {
    import_meta14 = {};
    packageInfo14 = { name: "@polkadot/wasm-bridge", path: import_meta14 && import_meta14.url ? new URL(import_meta14.url).pathname.substring(0, new URL(import_meta14.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "7.4.1" };
  }
});

// ../../node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js
var import_meta15, packageInfo15;
var init_packageInfo15 = __esm({
  "../../node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js"() {
    import_meta15 = {};
    packageInfo15 = { name: "@polkadot/wasm-crypto-asmjs", path: import_meta15 && import_meta15.url ? new URL(import_meta15.url).pathname.substring(0, new URL(import_meta15.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "7.4.1" };
  }
});

// ../../node_modules/@polkadot/wasm-crypto-init/packageInfo.js
var import_meta16, packageInfo16;
var init_packageInfo16 = __esm({
  "../../node_modules/@polkadot/wasm-crypto-init/packageInfo.js"() {
    import_meta16 = {};
    packageInfo16 = { name: "@polkadot/wasm-crypto-init", path: import_meta16 && import_meta16.url ? new URL(import_meta16.url).pathname.substring(0, new URL(import_meta16.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "7.4.1" };
  }
});

// ../../node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js
var import_meta17, packageInfo17;
var init_packageInfo17 = __esm({
  "../../node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js"() {
    import_meta17 = {};
    packageInfo17 = { name: "@polkadot/wasm-crypto-wasm", path: import_meta17 && import_meta17.url ? new URL(import_meta17.url).pathname.substring(0, new URL(import_meta17.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "7.4.1" };
  }
});

// ../../node_modules/@polkadot/wasm-util/packageInfo.js
var import_meta18, packageInfo18;
var init_packageInfo18 = __esm({
  "../../node_modules/@polkadot/wasm-util/packageInfo.js"() {
    import_meta18 = {};
    packageInfo18 = { name: "@polkadot/wasm-util", path: import_meta18 && import_meta18.url ? new URL(import_meta18.url).pathname.substring(0, new URL(import_meta18.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "7.4.1" };
  }
});

// ../../node_modules/@polkadot/wasm-crypto/packageInfo.js
var import_meta19, packageInfo19;
var init_packageInfo19 = __esm({
  "../../node_modules/@polkadot/wasm-crypto/packageInfo.js"() {
    import_meta19 = {};
    packageInfo19 = { name: "@polkadot/wasm-crypto", path: import_meta19 && import_meta19.url ? new URL(import_meta19.url).pathname.substring(0, new URL(import_meta19.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "7.4.1" };
  }
});

// ../../node_modules/@polkadot/wasm-crypto/packageDetect.js
var init_packageDetect5 = __esm({
  "../../node_modules/@polkadot/wasm-crypto/packageDetect.js"() {
    init_util();
    init_packageInfo14();
    init_packageInfo15();
    init_packageInfo16();
    init_packageInfo17();
    init_packageInfo18();
    init_packageInfo19();
    detectPackage(packageInfo19, null, [packageInfo15, packageInfo14, packageInfo16, packageInfo18, packageInfo17]);
  }
});

// ../../node_modules/@polkadot/wasm-bridge/packageDetect.js
var init_packageDetect6 = __esm({
  "../../node_modules/@polkadot/wasm-bridge/packageDetect.js"() {
    init_util();
    init_packageInfo14();
    detectPackage(packageInfo14, null, []);
  }
});

// ../../node_modules/@polkadot/wasm-bridge/wbg.js
var DEFAULT_CRYPTO, DEFAULT_SELF, Wbg;
var init_wbg = __esm({
  "../../node_modules/@polkadot/wasm-bridge/wbg.js"() {
    init_node3();
    DEFAULT_CRYPTO = { getRandomValues };
    DEFAULT_SELF = { crypto: DEFAULT_CRYPTO };
    Wbg = class {
      __internal__bridge;
      constructor(bridge2) {
        this.__internal__bridge = bridge2;
      }
      /** @internal */
      abort = () => {
        throw new Error("abort");
      };
      /** @internal */
      __wbindgen_is_undefined = (idx) => {
        return this.__internal__bridge.getObject(idx) === void 0;
      };
      /** @internal */
      __wbindgen_throw = (ptr, len) => {
        throw new Error(this.__internal__bridge.getString(ptr, len));
      };
      /** @internal */
      __wbg_self_1b7a39e3a92c949c = () => {
        return this.__internal__bridge.addObject(DEFAULT_SELF);
      };
      /** @internal */
      __wbg_require_604837428532a733 = (ptr, len) => {
        throw new Error(`Unable to require ${this.__internal__bridge.getString(ptr, len)}`);
      };
      /** @internal */
      __wbg_crypto_968f1772287e2df0 = (_idx) => {
        return this.__internal__bridge.addObject(DEFAULT_CRYPTO);
      };
      /** @internal */
      __wbg_getRandomValues_a3d34b4fee3c2869 = (_idx) => {
        return this.__internal__bridge.addObject(DEFAULT_CRYPTO.getRandomValues);
      };
      /** @internal */
      __wbg_getRandomValues_f5e14ab7ac8e995d = (_arg0, ptr, len) => {
        DEFAULT_CRYPTO.getRandomValues(this.__internal__bridge.getU8a(ptr, len));
      };
      /** @internal */
      __wbg_randomFillSync_d5bd2d655fdf256a = (_idx, _ptr, _len) => {
        throw new Error("randomFillsync is not available");
      };
      /** @internal */
      __wbindgen_object_drop_ref = (idx) => {
        this.__internal__bridge.takeObject(idx);
      };
    };
  }
});

// ../../node_modules/@polkadot/wasm-bridge/bridge.js
var Bridge;
var init_bridge = __esm({
  "../../node_modules/@polkadot/wasm-bridge/bridge.js"() {
    init_util();
    init_wbg();
    Bridge = class {
      __internal__createWasm;
      __internal__heap;
      __internal__wbg;
      __internal__cachegetInt32;
      __internal__cachegetUint8;
      __internal__heapNext;
      __internal__wasm;
      __internal__wasmError;
      __internal__wasmPromise;
      __internal__type;
      constructor(createWasm2) {
        this.__internal__createWasm = createWasm2;
        this.__internal__cachegetInt32 = null;
        this.__internal__cachegetUint8 = null;
        this.__internal__heap = new Array(32).fill(void 0).concat(void 0, null, true, false);
        this.__internal__heapNext = this.__internal__heap.length;
        this.__internal__type = "none";
        this.__internal__wasm = null;
        this.__internal__wasmError = null;
        this.__internal__wasmPromise = null;
        this.__internal__wbg = { ...new Wbg(this) };
      }
      /** @description Returns the init error */
      get error() {
        return this.__internal__wasmError;
      }
      /** @description Returns the init type */
      get type() {
        return this.__internal__type;
      }
      /** @description Returns the created wasm interface */
      get wasm() {
        return this.__internal__wasm;
      }
      /** @description Performs the wasm initialization */
      async init(createWasm2) {
        if (!this.__internal__wasmPromise || createWasm2) {
          this.__internal__wasmPromise = (createWasm2 || this.__internal__createWasm)(this.__internal__wbg);
        }
        const { error, type, wasm } = await this.__internal__wasmPromise;
        this.__internal__type = type;
        this.__internal__wasm = wasm;
        this.__internal__wasmError = error;
        return this.__internal__wasm;
      }
      /**
       * @internal
       * @description Gets an object from the heap
       */
      getObject(idx) {
        return this.__internal__heap[idx];
      }
      /**
       * @internal
       * @description Removes an object from the heap
       */
      dropObject(idx) {
        if (idx < 36) {
          return;
        }
        this.__internal__heap[idx] = this.__internal__heapNext;
        this.__internal__heapNext = idx;
      }
      /**
       * @internal
       * @description Retrieves and removes an object to the heap
       */
      takeObject(idx) {
        const ret = this.getObject(idx);
        this.dropObject(idx);
        return ret;
      }
      /**
       * @internal
       * @description Adds an object to the heap
       */
      addObject(obj) {
        if (this.__internal__heapNext === this.__internal__heap.length) {
          this.__internal__heap.push(this.__internal__heap.length + 1);
        }
        const idx = this.__internal__heapNext;
        this.__internal__heapNext = this.__internal__heap[idx];
        this.__internal__heap[idx] = obj;
        return idx;
      }
      /**
       * @internal
       * @description Retrieve an Int32 in the WASM interface
       */
      getInt32() {
        if (this.__internal__cachegetInt32 === null || this.__internal__cachegetInt32.buffer !== this.__internal__wasm.memory.buffer) {
          this.__internal__cachegetInt32 = new Int32Array(this.__internal__wasm.memory.buffer);
        }
        return this.__internal__cachegetInt32;
      }
      /**
       * @internal
       * @description Retrieve an Uint8Array in the WASM interface
       */
      getUint8() {
        if (this.__internal__cachegetUint8 === null || this.__internal__cachegetUint8.buffer !== this.__internal__wasm.memory.buffer) {
          this.__internal__cachegetUint8 = new Uint8Array(this.__internal__wasm.memory.buffer);
        }
        return this.__internal__cachegetUint8;
      }
      /**
       * @internal
       * @description Retrieves an Uint8Array in the WASM interface
       */
      getU8a(ptr, len) {
        return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
      }
      /**
       * @internal
       * @description Retrieves a string in the WASM interface
       */
      getString(ptr, len) {
        return u8aToString(this.getU8a(ptr, len));
      }
      /**
       * @internal
       * @description Allocates an Uint8Array in the WASM interface
       */
      allocU8a(arg) {
        const ptr = this.__internal__wasm.__wbindgen_malloc(arg.length * 1);
        this.getUint8().set(arg, ptr / 1);
        return [ptr, arg.length];
      }
      /**
       * @internal
       * @description Allocates a string in the WASM interface
       */
      allocString(arg) {
        return this.allocU8a(stringToU8a(arg));
      }
      /**
       * @internal
       * @description Retrieves an Uint8Array from the WASM interface
       */
      resultU8a() {
        const r0 = this.getInt32()[8 / 4 + 0];
        const r1 = this.getInt32()[8 / 4 + 1];
        const ret = this.getU8a(r0, r1).slice();
        this.__internal__wasm.__wbindgen_free(r0, r1 * 1);
        return ret;
      }
      /**
       * @internal
       * @description Retrieve a string from the WASM interface
       */
      resultString() {
        return u8aToString(this.resultU8a());
      }
    };
  }
});

// ../../node_modules/@polkadot/wasm-bridge/init.js
function createWasmFn(root, wasmBytes2, asmFn) {
  return async (wbg) => {
    const result = {
      error: null,
      type: "none",
      wasm: null
    };
    try {
      if (!wasmBytes2?.length) {
        throw new Error("No WebAssembly provided for initialization");
      } else if (typeof WebAssembly !== "object" || typeof WebAssembly.instantiate !== "function") {
        throw new Error("WebAssembly is not available in your environment");
      }
      const source = await WebAssembly.instantiate(wasmBytes2, { wbg });
      result.wasm = source.instance.exports;
      result.type = "wasm";
    } catch (error) {
      if (typeof asmFn === "function") {
        result.wasm = asmFn(wbg);
        result.type = "asm";
      } else {
        result.error = `FATAL: Unable to initialize @polkadot/wasm-${root}:: ${error.message}`;
        console.error(result.error);
      }
    }
    return result;
  };
}
var init_init = __esm({
  "../../node_modules/@polkadot/wasm-bridge/init.js"() {
  }
});

// ../../node_modules/@polkadot/wasm-bridge/bundle.js
var init_bundle2 = __esm({
  "../../node_modules/@polkadot/wasm-bridge/bundle.js"() {
    init_bridge();
    init_init();
  }
});

// ../../node_modules/@polkadot/wasm-bridge/index.js
var init_wasm_bridge = __esm({
  "../../node_modules/@polkadot/wasm-bridge/index.js"() {
    init_packageDetect6();
    init_bundle2();
  }
});

// ../../node_modules/@polkadot/wasm-crypto-wasm/packageDetect.js
var init_packageDetect7 = __esm({
  "../../node_modules/@polkadot/wasm-crypto-wasm/packageDetect.js"() {
    init_util();
    init_packageInfo17();
    detectPackage(packageInfo17, null, []);
  }
});

// ../../node_modules/@polkadot/wasm-util/packageDetect.js
var init_packageDetect8 = __esm({
  "../../node_modules/@polkadot/wasm-util/packageDetect.js"() {
    init_util();
    init_packageInfo18();
    detectPackage(packageInfo18, null, []);
  }
});

// ../../node_modules/@polkadot/wasm-util/base64.js
function base64Decode(data, out) {
  let byte = 0;
  let bits2 = 0;
  let pos = -1;
  for (let i2 = 0, last = out.length - 1; pos !== last; i2++) {
    byte = byte << 6 | map[data.charCodeAt(i2)];
    if ((bits2 += 6) >= 8) {
      out[++pos] = byte >>> (bits2 -= 8) & 255;
    }
  }
  return out;
}
var CHR2, map;
var init_base64 = __esm({
  "../../node_modules/@polkadot/wasm-util/base64.js"() {
    CHR2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    map = new Array(256);
    for (let i2 = 0, count = CHR2.length; i2 < count; i2++) {
      map[CHR2.charCodeAt(i2)] = i2;
    }
  }
});

// ../../node_modules/@polkadot/wasm-util/fflate.js
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var u8, u16, u32, clim, fleb, fdeb, freb, fl, revfl, fd, rev, hMap, flt, fdt, flrm, fdrm, bits, bits16, shft, slc, max, inflt, zlv;
var init_fflate = __esm({
  "../../node_modules/@polkadot/wasm-util/fflate.js"() {
    u8 = Uint8Array;
    u16 = Uint16Array;
    u32 = Uint32Array;
    clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    freb = (eb, start) => {
      const b = new u16(31);
      for (let i2 = 0; i2 < 31; ++i2) {
        b[i2] = start += 1 << eb[i2 - 1];
      }
      const r2 = new u32(b[30]);
      for (let i2 = 1; i2 < 30; ++i2) {
        for (let j = b[i2]; j < b[i2 + 1]; ++j) {
          r2[j] = j - b[i2] << 5 | i2;
        }
      }
      return [b, r2];
    };
    [fl, revfl] = freb(fleb, 2);
    fl[28] = 258, revfl[258] = 28;
    [fd] = freb(fdeb, 0);
    rev = new u16(32768);
    for (let i2 = 0; i2 < 32768; ++i2) {
      let x2 = (i2 & 43690) >>> 1 | (i2 & 21845) << 1;
      x2 = (x2 & 52428) >>> 2 | (x2 & 13107) << 2;
      x2 = (x2 & 61680) >>> 4 | (x2 & 3855) << 4;
      rev[i2] = ((x2 & 65280) >>> 8 | (x2 & 255) << 8) >>> 1;
    }
    hMap = (cd, mb, r2) => {
      const s2 = cd.length;
      let i2 = 0;
      const l15 = new u16(mb);
      for (; i2 < s2; ++i2) {
        if (cd[i2])
          ++l15[cd[i2] - 1];
      }
      const le = new u16(mb);
      for (i2 = 1; i2 < mb; ++i2) {
        le[i2] = le[i2 - 1] + l15[i2 - 1] << 1;
      }
      let co;
      if (r2) {
        co = new u16(1 << mb);
        const rvb = 15 - mb;
        for (i2 = 0; i2 < s2; ++i2) {
          if (cd[i2]) {
            const sv = i2 << 4 | cd[i2];
            const r3 = mb - cd[i2];
            let v = le[cd[i2] - 1]++ << r3;
            for (const m2 = v | (1 << r3) - 1; v <= m2; ++v) {
              co[rev[v] >> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s2);
        for (i2 = 0; i2 < s2; ++i2) {
          if (cd[i2]) {
            co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
          }
        }
      }
      return co;
    };
    flt = new u8(288);
    for (let i2 = 0; i2 < 144; ++i2)
      flt[i2] = 8;
    for (let i2 = 144; i2 < 256; ++i2)
      flt[i2] = 9;
    for (let i2 = 256; i2 < 280; ++i2)
      flt[i2] = 7;
    for (let i2 = 280; i2 < 288; ++i2)
      flt[i2] = 8;
    fdt = new u8(32);
    for (let i2 = 0; i2 < 32; ++i2)
      fdt[i2] = 5;
    flrm = hMap(flt, 9, 1);
    fdrm = hMap(fdt, 5, 1);
    bits = (d, p, m2) => {
      const o = p >>> 3;
      return (d[o] | d[o + 1] << 8) >>> (p & 7) & m2;
    };
    bits16 = (d, p) => {
      const o = p >>> 3;
      return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);
    };
    shft = (p) => (p >>> 3) + (p & 7 && 1);
    slc = (v, s2, e2) => {
      if (s2 == null || s2 < 0)
        s2 = 0;
      if (e2 == null || e2 > v.length)
        e2 = v.length;
      const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e2 - s2);
      n.set(v.subarray(s2, e2));
      return n;
    };
    max = (a) => {
      let m2 = a[0];
      for (let i2 = 1, count = a.length; i2 < count; ++i2) {
        if (a[i2] > m2)
          m2 = a[i2];
      }
      return m2;
    };
    inflt = (dat, buf, st) => {
      const noSt = !st || st.i;
      if (!st)
        st = {};
      const sl = dat.length;
      const noBuf = !buf || !noSt;
      if (!buf)
        buf = new u8(sl * 3);
      const cbuf = (l15) => {
        let bl = buf.length;
        if (l15 > bl) {
          const nbuf = new u8(Math.max(bl << 1, l15));
          nbuf.set(buf);
          buf = nbuf;
        }
      };
      let final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      if (final && !lm)
        return buf;
      const tbts = sl << 3;
      do {
        if (!lm) {
          st.f = final = bits(dat, pos, 1);
          const type = bits(dat, pos + 1, 3);
          pos += 3;
          if (!type) {
            const s2 = shft(pos) + 4, l15 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l15;
            if (t2 > sl) {
              if (noSt)
                throw "unexpected EOF";
              break;
            }
            if (noBuf)
              cbuf(bt + l15);
            buf.set(dat.subarray(s2, t2), bt);
            st.b = bt += l15, st.p = pos = t2 << 3;
            continue;
          } else if (type == 1)
            lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
          else if (type == 2) {
            const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
            const tl = hLit + bits(dat, pos + 5, 31) + 1;
            pos += 14;
            const ldt = new u8(tl);
            const clt = new u8(19);
            for (let i2 = 0; i2 < hcLen; ++i2) {
              clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
            }
            pos += hcLen * 3;
            const clb = max(clt), clbmsk = (1 << clb) - 1;
            if (!noSt && pos + tl * (clb + 7) > tbts)
              break;
            const clm = hMap(clt, clb, 1);
            for (let i2 = 0; i2 < tl; ) {
              const r2 = clm[bits(dat, pos, clbmsk)];
              pos += r2 & 15;
              const s2 = r2 >>> 4;
              if (s2 < 16) {
                ldt[i2++] = s2;
              } else {
                let c = 0, n = 0;
                if (s2 == 16)
                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
                else if (s2 == 17)
                  n = 3 + bits(dat, pos, 7), pos += 3;
                else if (s2 == 18)
                  n = 11 + bits(dat, pos, 127), pos += 7;
                while (n--)
                  ldt[i2++] = c;
              }
            }
            const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
            lbt = max(lt);
            dbt = max(dt);
            lm = hMap(lt, lbt, 1);
            dm = hMap(dt, dbt, 1);
          } else
            throw "invalid block type";
          if (pos > tbts)
            throw "unexpected EOF";
        }
        if (noBuf)
          cbuf(bt + 131072);
        const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        const mxa = lbt + dbt + 18;
        while (noSt || pos + mxa < tbts) {
          const c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
          pos += c & 15;
          if (pos > tbts)
            throw "unexpected EOF";
          if (!c)
            throw "invalid length/literal";
          if (sym < 256)
            buf[bt++] = sym;
          else if (sym == 256) {
            lm = void 0;
            break;
          } else {
            let add3 = sym - 254;
            if (sym > 264) {
              const i2 = sym - 257, b = fleb[i2];
              add3 = bits(dat, pos, (1 << b) - 1) + fl[i2];
              pos += b;
            }
            const d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
            if (!d)
              throw "invalid distance";
            pos += d & 15;
            let dt = fd[dsym];
            if (dsym > 3) {
              const b = fdeb[dsym];
              dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
            }
            if (pos > tbts)
              throw "unexpected EOF";
            if (noBuf)
              cbuf(bt + 131072);
            const end = bt + add3;
            for (; bt < end; bt += 4) {
              buf[bt] = buf[bt - dt];
              buf[bt + 1] = buf[bt + 1 - dt];
              buf[bt + 2] = buf[bt + 2 - dt];
              buf[bt + 3] = buf[bt + 3 - dt];
            }
            bt = end;
          }
        }
        st.l = lm, st.p = pos, st.b = bt;
        if (lm)
          final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt == buf.length ? buf : slc(buf, 0, bt);
    };
    zlv = (d) => {
      if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        throw "invalid zlib data";
      if (d[1] & 32)
        throw "invalid zlib data: preset dictionaries not supported";
    };
  }
});

// ../../node_modules/@polkadot/wasm-util/bundle.js
var init_bundle3 = __esm({
  "../../node_modules/@polkadot/wasm-util/bundle.js"() {
    init_base64();
    init_fflate();
  }
});

// ../../node_modules/@polkadot/wasm-util/index.js
var init_wasm_util = __esm({
  "../../node_modules/@polkadot/wasm-util/index.js"() {
    init_packageDetect8();
    init_bundle3();
  }
});

// ../../node_modules/@polkadot/wasm-crypto-wasm/cjs/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/@polkadot/wasm-crypto-wasm/cjs/bytes.js"(exports2) {
    exports2.lenIn = 171008;
    exports2.lenOut = 339468;
    exports2.bytes = "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";
  }
});

// ../../node_modules/@polkadot/wasm-crypto-wasm/bundle.js
var import_bytes, wasmBytes;
var init_bundle4 = __esm({
  "../../node_modules/@polkadot/wasm-crypto-wasm/bundle.js"() {
    init_wasm_util();
    import_bytes = __toESM(require_bytes(), 1);
    wasmBytes = /* @__PURE__ */ unzlibSync(base64Decode(import_bytes.bytes, new Uint8Array(import_bytes.lenIn)), new Uint8Array(import_bytes.lenOut));
  }
});

// ../../node_modules/@polkadot/wasm-crypto-wasm/index.js
var init_wasm_crypto_wasm = __esm({
  "../../node_modules/@polkadot/wasm-crypto-wasm/index.js"() {
    init_packageDetect7();
    init_bundle4();
  }
});

// ../../node_modules/@polkadot/wasm-crypto-init/wasm.js
var createWasm;
var init_wasm = __esm({
  "../../node_modules/@polkadot/wasm-crypto-init/wasm.js"() {
    init_wasm_bridge();
    init_wasm_crypto_wasm();
    createWasm = /* @__PURE__ */ createWasmFn("crypto", wasmBytes, null);
  }
});

// ../../node_modules/@polkadot/wasm-crypto/init.js
async function initBridge(createWasm2) {
  return bridge.init(createWasm2);
}
var bridge;
var init_init2 = __esm({
  "../../node_modules/@polkadot/wasm-crypto/init.js"() {
    init_wasm_bridge();
    init_wasm();
    bridge = new Bridge(createWasm);
  }
});

// ../../node_modules/@polkadot/wasm-crypto/bundle.js
function withWasm(fn) {
  return (...params) => {
    if (!bridge.wasm) {
      throw new Error("The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.");
    }
    return fn(bridge.wasm, ...params);
  };
}
function isReady() {
  return !!bridge.wasm;
}
async function waitReady() {
  try {
    const wasm = await initBridge();
    return !!wasm;
  } catch {
    return false;
  }
}
var bip39ToEntropy, bip39ToMiniSecret, bip39ToSeed, bip39Validate, ed25519KeypairFromSeed, ed25519Sign, ed25519Verify, secp256k1FromSeed, secp256k1Compress, secp256k1Expand, secp256k1Recover, secp256k1Sign, sr25519DeriveKeypairHard, sr25519DeriveKeypairSoft, sr25519KeypairFromSeed, sr25519Sign, sr25519Verify, vrfSign, vrfVerify, blake2b, hmacSha256, hmacSha512, keccak256, keccak512, pbkdf2, scrypt, sha256, sha512, twox;
var init_bundle5 = __esm({
  "../../node_modules/@polkadot/wasm-crypto/bundle.js"() {
    init_init2();
    bip39ToEntropy = /* @__PURE__ */ withWasm((wasm, phrase) => {
      wasm.ext_bip39_to_entropy(8, ...bridge.allocString(phrase));
      return bridge.resultU8a();
    });
    bip39ToMiniSecret = /* @__PURE__ */ withWasm((wasm, phrase, password) => {
      wasm.ext_bip39_to_mini_secret(8, ...bridge.allocString(phrase), ...bridge.allocString(password));
      return bridge.resultU8a();
    });
    bip39ToSeed = /* @__PURE__ */ withWasm((wasm, phrase, password) => {
      wasm.ext_bip39_to_seed(8, ...bridge.allocString(phrase), ...bridge.allocString(password));
      return bridge.resultU8a();
    });
    bip39Validate = /* @__PURE__ */ withWasm((wasm, phrase) => {
      const ret = wasm.ext_bip39_validate(...bridge.allocString(phrase));
      return ret !== 0;
    });
    ed25519KeypairFromSeed = /* @__PURE__ */ withWasm((wasm, seed) => {
      wasm.ext_ed_from_seed(8, ...bridge.allocU8a(seed));
      return bridge.resultU8a();
    });
    ed25519Sign = /* @__PURE__ */ withWasm((wasm, pubkey, seckey, message) => {
      wasm.ext_ed_sign(8, ...bridge.allocU8a(pubkey), ...bridge.allocU8a(seckey), ...bridge.allocU8a(message));
      return bridge.resultU8a();
    });
    ed25519Verify = /* @__PURE__ */ withWasm((wasm, signature, message, pubkey) => {
      const ret = wasm.ext_ed_verify(...bridge.allocU8a(signature), ...bridge.allocU8a(message), ...bridge.allocU8a(pubkey));
      return ret !== 0;
    });
    secp256k1FromSeed = /* @__PURE__ */ withWasm((wasm, seckey) => {
      wasm.ext_secp_from_seed(8, ...bridge.allocU8a(seckey));
      return bridge.resultU8a();
    });
    secp256k1Compress = /* @__PURE__ */ withWasm((wasm, pubkey) => {
      wasm.ext_secp_pub_compress(8, ...bridge.allocU8a(pubkey));
      return bridge.resultU8a();
    });
    secp256k1Expand = /* @__PURE__ */ withWasm((wasm, pubkey) => {
      wasm.ext_secp_pub_expand(8, ...bridge.allocU8a(pubkey));
      return bridge.resultU8a();
    });
    secp256k1Recover = /* @__PURE__ */ withWasm((wasm, msgHash, sig2, recovery) => {
      wasm.ext_secp_recover(8, ...bridge.allocU8a(msgHash), ...bridge.allocU8a(sig2), recovery);
      return bridge.resultU8a();
    });
    secp256k1Sign = /* @__PURE__ */ withWasm((wasm, msgHash, seckey) => {
      wasm.ext_secp_sign(8, ...bridge.allocU8a(msgHash), ...bridge.allocU8a(seckey));
      return bridge.resultU8a();
    });
    sr25519DeriveKeypairHard = /* @__PURE__ */ withWasm((wasm, pair, cc) => {
      wasm.ext_sr_derive_keypair_hard(8, ...bridge.allocU8a(pair), ...bridge.allocU8a(cc));
      return bridge.resultU8a();
    });
    sr25519DeriveKeypairSoft = /* @__PURE__ */ withWasm((wasm, pair, cc) => {
      wasm.ext_sr_derive_keypair_soft(8, ...bridge.allocU8a(pair), ...bridge.allocU8a(cc));
      return bridge.resultU8a();
    });
    sr25519KeypairFromSeed = /* @__PURE__ */ withWasm((wasm, seed) => {
      wasm.ext_sr_from_seed(8, ...bridge.allocU8a(seed));
      return bridge.resultU8a();
    });
    sr25519Sign = /* @__PURE__ */ withWasm((wasm, pubkey, secret, message) => {
      wasm.ext_sr_sign(8, ...bridge.allocU8a(pubkey), ...bridge.allocU8a(secret), ...bridge.allocU8a(message));
      return bridge.resultU8a();
    });
    sr25519Verify = /* @__PURE__ */ withWasm((wasm, signature, message, pubkey) => {
      const ret = wasm.ext_sr_verify(...bridge.allocU8a(signature), ...bridge.allocU8a(message), ...bridge.allocU8a(pubkey));
      return ret !== 0;
    });
    vrfSign = /* @__PURE__ */ withWasm((wasm, secret, context, message, extra) => {
      wasm.ext_vrf_sign(8, ...bridge.allocU8a(secret), ...bridge.allocU8a(context), ...bridge.allocU8a(message), ...bridge.allocU8a(extra));
      return bridge.resultU8a();
    });
    vrfVerify = /* @__PURE__ */ withWasm((wasm, pubkey, context, message, extra, outAndProof) => {
      const ret = wasm.ext_vrf_verify(...bridge.allocU8a(pubkey), ...bridge.allocU8a(context), ...bridge.allocU8a(message), ...bridge.allocU8a(extra), ...bridge.allocU8a(outAndProof));
      return ret !== 0;
    });
    blake2b = /* @__PURE__ */ withWasm((wasm, data, key, size) => {
      wasm.ext_blake2b(8, ...bridge.allocU8a(data), ...bridge.allocU8a(key), size);
      return bridge.resultU8a();
    });
    hmacSha256 = /* @__PURE__ */ withWasm((wasm, key, data) => {
      wasm.ext_hmac_sha256(8, ...bridge.allocU8a(key), ...bridge.allocU8a(data));
      return bridge.resultU8a();
    });
    hmacSha512 = /* @__PURE__ */ withWasm((wasm, key, data) => {
      wasm.ext_hmac_sha512(8, ...bridge.allocU8a(key), ...bridge.allocU8a(data));
      return bridge.resultU8a();
    });
    keccak256 = /* @__PURE__ */ withWasm((wasm, data) => {
      wasm.ext_keccak256(8, ...bridge.allocU8a(data));
      return bridge.resultU8a();
    });
    keccak512 = /* @__PURE__ */ withWasm((wasm, data) => {
      wasm.ext_keccak512(8, ...bridge.allocU8a(data));
      return bridge.resultU8a();
    });
    pbkdf2 = /* @__PURE__ */ withWasm((wasm, data, salt, rounds) => {
      wasm.ext_pbkdf2(8, ...bridge.allocU8a(data), ...bridge.allocU8a(salt), rounds);
      return bridge.resultU8a();
    });
    scrypt = /* @__PURE__ */ withWasm((wasm, password, salt, log2n, r2, p) => {
      wasm.ext_scrypt(8, ...bridge.allocU8a(password), ...bridge.allocU8a(salt), log2n, r2, p);
      return bridge.resultU8a();
    });
    sha256 = /* @__PURE__ */ withWasm((wasm, data) => {
      wasm.ext_sha256(8, ...bridge.allocU8a(data));
      return bridge.resultU8a();
    });
    sha512 = /* @__PURE__ */ withWasm((wasm, data) => {
      wasm.ext_sha512(8, ...bridge.allocU8a(data));
      return bridge.resultU8a();
    });
    twox = /* @__PURE__ */ withWasm((wasm, data, rounds) => {
      wasm.ext_twox(8, ...bridge.allocU8a(data), rounds);
      return bridge.resultU8a();
    });
  }
});

// ../../node_modules/@polkadot/wasm-crypto/index.js
var init_wasm_crypto = __esm({
  "../../node_modules/@polkadot/wasm-crypto/index.js"() {
    init_packageDetect5();
    init_bundle5();
  }
});

// ../../node_modules/@polkadot/util-crypto/crypto.js
function cryptoWaitReady() {
  return waitReady().then(() => {
    if (!isReady()) {
      throw new Error("Unable to initialize @polkadot/util-crypto");
    }
    return true;
  }).catch(() => false);
}
var init_crypto = __esm({
  "../../node_modules/@polkadot/util-crypto/crypto.js"() {
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/bundleInit.js
var init_bundleInit = __esm({
  "../../node_modules/@polkadot/util-crypto/bundleInit.js"() {
    init_shim();
    init_crypto();
    cryptoWaitReady().catch(() => {
    });
  }
});

// ../../node_modules/@scure/base/lib/esm/index.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString2, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString2) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x2) => x2.encode).reduceRight(wrap, id);
  const decode2 = args.map((x2) => x2.decode).reduce(wrap, id);
  return { encode, decode: decode2 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes3 = new Map(lettersA.map((l15, i2) => [l15, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes3.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from4) => {
      astrArr("join.decode", from4);
      return from4.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding(bits2, chr = "=") {
  anumber(bits2);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits2 % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits2 % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits2;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function convertRadix(data, from4, to) {
  if (from4 < 2)
    throw new Error(`convertRadix: invalid from=${from4}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber(d);
    if (d < 0 || d >= from4)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from4 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from4 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
function convertRadix2(data, from4, to, padding2) {
  aArr(data);
  if (from4 <= 0 || from4 > 32)
    throw new Error(`convertRadix2: wrong from=${from4}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (/* @__PURE__ */ radix2carry(from4, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from4} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from4, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max2 = powers[from4];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber(n);
    if (n >= max2)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from4}`);
    carry = carry << from4 | n;
    if (pos + from4 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from4}`);
    pos += from4;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from4)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
// @__NO_SIDE_EFFECTS__
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function radix2(bits2, revPadding = false) {
  anumber(bits2);
  if (bits2 <= 0 || bits2 > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry(8, bits2) > 32 || /* @__PURE__ */ radix2carry(bits2, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits2, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits2, 8, revPadding));
    }
  };
}
var gcd, radix2carry, powers, base64, genBase58, base58;
var init_esm = __esm({
  "../../node_modules/@scure/base/lib/esm/index.js"() {
    gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from4, to) => from4 + (to - gcd(from4, to));
    powers = /* @__PURE__ */ (() => {
      let res = [];
      for (let i2 = 0; i2 < 40; i2++)
        res.push(2 ** i2);
      return res;
    })();
    base64 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
    genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
    base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  }
});

// ../../node_modules/@polkadot/util-crypto/base32/helpers.js
function createDecode({ coder, ipfs }, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}
function createEncode({ coder, ipfs }) {
  return (value, ipfsCompat) => {
    const out = coder.encode(u8aToU8a(value));
    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
  };
}
function createValidate({ chars, ipfs, type, withPadding }) {
  return (value, ipfsCompat) => {
    if (typeof value !== "string") {
      throw new Error(`Expected ${type} string input`);
    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i2 = ipfsCompat ? 1 : 0, count = value.length; i2 < count; i2++) {
      if (chars.includes(value[i2])) {
      } else if (withPadding && value[i2] === "=") {
        if (i2 === count - 1) {
        } else if (value[i2 + 1] === "=") {
        } else {
          throw new Error(`Invalid ${type} padding sequence "${value[i2]}${value[i2 + 1]}" at index ${i2}`);
        }
      } else {
        throw new Error(`Invalid ${type} character "${value[i2]}" (0x${value.charCodeAt(i2).toString(16)}) at index ${i2}`);
      }
    }
    return true;
  };
}
var init_helpers3 = __esm({
  "../../node_modules/@polkadot/util-crypto/base32/helpers.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/util-crypto/base58/bs58.js
var config, base58Validate, base58Decode, base58Encode;
var init_bs58 = __esm({
  "../../node_modules/@polkadot/util-crypto/base58/bs58.js"() {
    init_esm();
    init_helpers3();
    config = {
      chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      coder: base58,
      ipfs: "z",
      type: "base58"
    };
    base58Validate = /* @__PURE__ */ createValidate(config);
    base58Decode = /* @__PURE__ */ createDecode(config, base58Validate);
    base58Encode = /* @__PURE__ */ createEncode(config);
  }
});

// ../../node_modules/@polkadot/util-crypto/base58/index.js
var init_base58 = __esm({
  "../../node_modules/@polkadot/util-crypto/base58/index.js"() {
    init_bs58();
  }
});

// ../../node_modules/@noble/hashes/esm/_assert.js
function anumber2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber2(h2.outputLen);
  anumber2(h2.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
var init_assert2 = __esm({
  "../../node_modules/@noble/hashes/esm/_assert.js"() {
  }
});

// ../../node_modules/@noble/hashes/esm/utils.js
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var u322, createView, rotr, rotl, isLE, byteSwap, byteSwapIfBE, Hash;
var init_utils = __esm({
  "../../node_modules/@noble/hashes/esm/utils.js"() {
    init_assert2();
    u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    rotr = (word, shift) => word << 32 - shift | word >>> shift;
    rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);
    Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
  }
});

// ../../node_modules/@noble/hashes/esm/_blake.js
var SIGMA, BLAKE;
var init_blake = __esm({
  "../../node_modules/@noble/hashes/esm/_blake.js"() {
    init_assert2();
    init_utils();
    SIGMA = /* @__PURE__ */ new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ]);
    BLAKE = class extends Hash {
      constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.length = 0;
        this.pos = 0;
        this.finished = false;
        this.destroyed = false;
        anumber2(blockLen);
        anumber2(outputLen);
        anumber2(keyLen);
        if (outputLen < 0 || outputLen > keyLen)
          throw new Error("outputLen bigger than keyLen");
        if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
          throw new Error("key length must be undefined or 1.." + keyLen);
        if (opts.salt !== void 0 && opts.salt.length !== saltLen)
          throw new Error("salt must be undefined or " + saltLen);
        if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
          throw new Error("personalization must be undefined or " + persLen);
        this.buffer = new Uint8Array(blockLen);
        this.buffer32 = u322(this.buffer);
      }
      update(data) {
        aexists(this);
        const { blockLen, buffer, buffer32 } = this;
        data = toBytes(data);
        const len = data.length;
        const offset = data.byteOffset;
        const buf = data.buffer;
        for (let pos = 0; pos < len; ) {
          if (this.pos === blockLen) {
            if (!isLE)
              byteSwap32(buffer32);
            this.compress(buffer32, 0, false);
            if (!isLE)
              byteSwap32(buffer32);
            this.pos = 0;
          }
          const take = Math.min(blockLen - this.pos, len - pos);
          const dataOffset = offset + pos;
          if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
            const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
            if (!isLE)
              byteSwap32(data32);
            for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
              this.length += blockLen;
              this.compress(data32, pos32, false);
            }
            if (!isLE)
              byteSwap32(data32);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          this.length += take;
          pos += take;
        }
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        const { pos, buffer32 } = this;
        this.finished = true;
        this.buffer.subarray(pos).fill(0);
        if (!isLE)
          byteSwap32(buffer32);
        this.compress(buffer32, 0, true);
        if (!isLE)
          byteSwap32(buffer32);
        const out32 = u322(out);
        this.get().forEach((v, i2) => out32[i2] = byteSwapIfBE(v));
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        const { buffer, length, finished, destroyed, outputLen, pos } = this;
        to || (to = new this.constructor({ dkLen: outputLen }));
        to.set(...this.get());
        to.length = length;
        to.finished = finished;
        to.destroyed = destroyed;
        to.outputLen = outputLen;
        to.buffer.set(buffer);
        to.pos = pos;
        return to;
      }
    };
  }
});

// ../../node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l15 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h2, l15];
  }
  return [Ah, Al];
}
function add(Ah, Al, Bh, Bl) {
  const l15 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l15 / 2 ** 32 | 0) | 0, l: l15 | 0 };
}
var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
var init_u64 = __esm({
  "../../node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n = /* @__PURE__ */ BigInt(32);
    toBig = (h2, l15) => BigInt(h2 >>> 0) << _32n | BigInt(l15 >>> 0);
    shrSH = (h2, _l, s2) => h2 >>> s2;
    shrSL = (h2, l15, s2) => h2 << 32 - s2 | l15 >>> s2;
    rotrSH = (h2, l15, s2) => h2 >>> s2 | l15 << 32 - s2;
    rotrSL = (h2, l15, s2) => h2 << 32 - s2 | l15 >>> s2;
    rotrBH = (h2, l15, s2) => h2 << 64 - s2 | l15 >>> s2 - 32;
    rotrBL = (h2, l15, s2) => h2 >>> s2 - 32 | l15 << 64 - s2;
    rotr32H = (_h, l15) => l15;
    rotr32L = (h2, _l) => h2;
    rotlSH = (h2, l15, s2) => h2 << s2 | l15 >>> 32 - s2;
    rotlSL = (h2, l15, s2) => l15 << s2 | h2 >>> 32 - s2;
    rotlBH = (h2, l15, s2) => l15 << s2 - 32 | h2 >>> 64 - s2;
    rotlBL = (h2, l15, s2) => h2 << s2 - 32 | l15 >>> 64 - s2;
    add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    u64_default = u64;
  }
});

// ../../node_modules/@noble/hashes/esm/blake2b.js
function G1b(a, b, c, d, msg, x2) {
  const Xl = msg[x2], Xh = msg[x2 + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotr32H(Dh, Dl), Dl: u64_default.rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b, c, d, msg, x2) {
  const Xl = msg[x2], Xh = msg[x2 + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotrSH(Dh, Dl, 16), Dl: u64_default.rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
var B2B_IV, BBUF, BLAKE2b, blake2b2;
var init_blake2b = __esm({
  "../../node_modules/@noble/hashes/esm/blake2b.js"() {
    init_blake();
    init_u64();
    init_utils();
    B2B_IV = /* @__PURE__ */ new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    BBUF = /* @__PURE__ */ new Uint32Array(32);
    BLAKE2b = class extends BLAKE {
      constructor(opts = {}) {
        super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
        this.v0l = B2B_IV[0] | 0;
        this.v0h = B2B_IV[1] | 0;
        this.v1l = B2B_IV[2] | 0;
        this.v1h = B2B_IV[3] | 0;
        this.v2l = B2B_IV[4] | 0;
        this.v2h = B2B_IV[5] | 0;
        this.v3l = B2B_IV[6] | 0;
        this.v3h = B2B_IV[7] | 0;
        this.v4l = B2B_IV[8] | 0;
        this.v4h = B2B_IV[9] | 0;
        this.v5l = B2B_IV[10] | 0;
        this.v5h = B2B_IV[11] | 0;
        this.v6l = B2B_IV[12] | 0;
        this.v6h = B2B_IV[13] | 0;
        this.v7l = B2B_IV[14] | 0;
        this.v7h = B2B_IV[15] | 0;
        const keyLength = opts.key ? opts.key.length : 0;
        this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
        if (opts.salt) {
          const salt = u322(toBytes(opts.salt));
          this.v4l ^= byteSwapIfBE(salt[0]);
          this.v4h ^= byteSwapIfBE(salt[1]);
          this.v5l ^= byteSwapIfBE(salt[2]);
          this.v5h ^= byteSwapIfBE(salt[3]);
        }
        if (opts.personalization) {
          const pers = u322(toBytes(opts.personalization));
          this.v6l ^= byteSwapIfBE(pers[0]);
          this.v6h ^= byteSwapIfBE(pers[1]);
          this.v7l ^= byteSwapIfBE(pers[2]);
          this.v7h ^= byteSwapIfBE(pers[3]);
        }
        if (opts.key) {
          const tmp = new Uint8Array(this.blockLen);
          tmp.set(toBytes(opts.key));
          this.update(tmp);
        }
      }
      // prettier-ignore
      get() {
        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
      }
      // prettier-ignore
      set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
      }
      compress(msg, offset, isLast) {
        this.get().forEach((v, i2) => BBUF[i2] = v);
        BBUF.set(B2B_IV, 16);
        let { h: h2, l: l15 } = u64_default.fromBig(BigInt(this.length));
        BBUF[24] = B2B_IV[8] ^ l15;
        BBUF[25] = B2B_IV[9] ^ h2;
        if (isLast) {
          BBUF[28] = ~BBUF[28];
          BBUF[29] = ~BBUF[29];
        }
        let j = 0;
        const s2 = SIGMA;
        for (let i2 = 0; i2 < 12; i2++) {
          G1b(0, 4, 8, 12, msg, offset + 2 * s2[j++]);
          G2b(0, 4, 8, 12, msg, offset + 2 * s2[j++]);
          G1b(1, 5, 9, 13, msg, offset + 2 * s2[j++]);
          G2b(1, 5, 9, 13, msg, offset + 2 * s2[j++]);
          G1b(2, 6, 10, 14, msg, offset + 2 * s2[j++]);
          G2b(2, 6, 10, 14, msg, offset + 2 * s2[j++]);
          G1b(3, 7, 11, 15, msg, offset + 2 * s2[j++]);
          G2b(3, 7, 11, 15, msg, offset + 2 * s2[j++]);
          G1b(0, 5, 10, 15, msg, offset + 2 * s2[j++]);
          G2b(0, 5, 10, 15, msg, offset + 2 * s2[j++]);
          G1b(1, 6, 11, 12, msg, offset + 2 * s2[j++]);
          G2b(1, 6, 11, 12, msg, offset + 2 * s2[j++]);
          G1b(2, 7, 8, 13, msg, offset + 2 * s2[j++]);
          G2b(2, 7, 8, 13, msg, offset + 2 * s2[j++]);
          G1b(3, 4, 9, 14, msg, offset + 2 * s2[j++]);
          G2b(3, 4, 9, 14, msg, offset + 2 * s2[j++]);
        }
        this.v0l ^= BBUF[0] ^ BBUF[16];
        this.v0h ^= BBUF[1] ^ BBUF[17];
        this.v1l ^= BBUF[2] ^ BBUF[18];
        this.v1h ^= BBUF[3] ^ BBUF[19];
        this.v2l ^= BBUF[4] ^ BBUF[20];
        this.v2h ^= BBUF[5] ^ BBUF[21];
        this.v3l ^= BBUF[6] ^ BBUF[22];
        this.v3h ^= BBUF[7] ^ BBUF[23];
        this.v4l ^= BBUF[8] ^ BBUF[24];
        this.v4h ^= BBUF[9] ^ BBUF[25];
        this.v5l ^= BBUF[10] ^ BBUF[26];
        this.v5h ^= BBUF[11] ^ BBUF[27];
        this.v6l ^= BBUF[12] ^ BBUF[28];
        this.v6h ^= BBUF[13] ^ BBUF[29];
        this.v7l ^= BBUF[14] ^ BBUF[30];
        this.v7h ^= BBUF[15] ^ BBUF[31];
        BBUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer32.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    blake2b2 = /* @__PURE__ */ wrapConstructorWithOpts((opts) => new BLAKE2b(opts));
  }
});

// ../../node_modules/@polkadot/util-crypto/helpers.js
function createAsHex(fn) {
  return (...args) => u8aToHex(fn(...args));
}
function createBitHasher(bitLength, fn) {
  return (data, onlyJs) => fn(data, bitLength, onlyJs);
}
function createDualHasher(wa, js) {
  return (value, bitLength = 256, onlyJs) => {
    const u8a = u8aToU8a(value);
    return !hasBigInt || !onlyJs && isReady() ? wa[bitLength](u8a) : js[bitLength](u8a);
  };
}
var init_helpers4 = __esm({
  "../../node_modules/@polkadot/util-crypto/helpers.js"() {
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/blake2/asU8a.js
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b(u8a, u8aToU8a(key), byteLength) : key ? blake2b2(u8a, { dkLen: byteLength, key }) : blake2b2(u8a, { dkLen: byteLength });
}
var blake2AsHex;
var init_asU8a = __esm({
  "../../node_modules/@polkadot/util-crypto/blake2/asU8a.js"() {
    init_blake2b();
    init_util();
    init_wasm_crypto();
    init_helpers4();
    blake2AsHex = /* @__PURE__ */ createAsHex(blake2AsU8a);
  }
});

// ../../node_modules/@polkadot/util-crypto/address/sshash.js
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}
var SS58_PREFIX;
var init_sshash = __esm({
  "../../node_modules/@polkadot/util-crypto/address/sshash.js"() {
    init_util();
    init_asU8a();
    SS58_PREFIX = stringToU8a("SS58PRE");
  }
});

// ../../node_modules/@polkadot/util-crypto/address/checksum.js
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 64 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);
  const hash = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}
var init_checksum = __esm({
  "../../node_modules/@polkadot/util-crypto/address/checksum.js"() {
    init_sshash();
  }
});

// ../../node_modules/@substrate/ss58-registry/esm/index.js
var esm_default;
var init_esm2 = __esm({
  "../../node_modules/@substrate/ss58-registry/esm/index.js"() {
    esm_default = [
      {
        "prefix": 0,
        "network": "polkadot",
        "displayName": "Polkadot Relay Chain",
        "symbols": [
          "DOT"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://polkadot.network"
      },
      {
        "prefix": 1,
        "network": "BareSr25519",
        "displayName": "Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.",
        "symbols": [],
        "decimals": [],
        "standardAccount": "Sr25519",
        "website": null
      },
      {
        "prefix": 2,
        "network": "kusama",
        "displayName": "Kusama Relay Chain",
        "symbols": [
          "KSM"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://kusama.network"
      },
      {
        "prefix": 3,
        "network": "BareEd25519",
        "displayName": "Bare 32-bit Ed25519 public key.",
        "symbols": [],
        "decimals": [],
        "standardAccount": "Ed25519",
        "website": null
      },
      {
        "prefix": 4,
        "network": "katalchain",
        "displayName": "Katal Chain",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
      },
      {
        "prefix": 5,
        "network": "astar",
        "displayName": "Astar Network",
        "symbols": [
          "ASTR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://astar.network"
      },
      {
        "prefix": 6,
        "network": "bifrost",
        "displayName": "Bifrost",
        "symbols": [
          "BNC"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://bifrost.finance/"
      },
      {
        "prefix": 7,
        "network": "edgeware",
        "displayName": "Edgeware",
        "symbols": [
          "EDG"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://edgewa.re"
      },
      {
        "prefix": 8,
        "network": "karura",
        "displayName": "Karura",
        "symbols": [
          "KAR"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://karura.network/"
      },
      {
        "prefix": 9,
        "network": "reynolds",
        "displayName": "Laminar Reynolds Canary",
        "symbols": [
          "REY"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "http://laminar.network/"
      },
      {
        "prefix": 10,
        "network": "acala",
        "displayName": "Acala",
        "symbols": [
          "ACA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://acala.network/"
      },
      {
        "prefix": 11,
        "network": "laminar",
        "displayName": "Laminar",
        "symbols": [
          "LAMI"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "http://laminar.network/"
      },
      {
        "prefix": 12,
        "network": "polymesh",
        "displayName": "Polymesh",
        "symbols": [
          "POLYX"
        ],
        "decimals": [
          6
        ],
        "standardAccount": "*25519",
        "website": "https://polymath.network/"
      },
      {
        "prefix": 13,
        "network": "integritee",
        "displayName": "Integritee",
        "symbols": [
          "TEER"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://integritee.network"
      },
      {
        "prefix": 14,
        "network": "totem",
        "displayName": "Totem",
        "symbols": [
          "TOTEM"
        ],
        "decimals": [
          0
        ],
        "standardAccount": "*25519",
        "website": "https://totemaccounting.com"
      },
      {
        "prefix": 15,
        "network": "synesthesia",
        "displayName": "Synesthesia",
        "symbols": [
          "SYN"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://synesthesia.network/"
      },
      {
        "prefix": 16,
        "network": "kulupu",
        "displayName": "Kulupu",
        "symbols": [
          "KLP"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://kulupu.network/"
      },
      {
        "prefix": 17,
        "network": "dark",
        "displayName": "Dark Mainnet",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
      },
      {
        "prefix": 18,
        "network": "darwinia",
        "displayName": "Darwinia Network",
        "symbols": [
          "RING"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "secp256k1",
        "website": "https://darwinia.network"
      },
      {
        "prefix": 19,
        "network": "watr",
        "displayName": "Watr Protocol",
        "symbols": [
          "WATR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://www.watr.org"
      },
      {
        "prefix": 20,
        "network": "stafi",
        "displayName": "Stafi",
        "symbols": [
          "FIS"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://stafi.io"
      },
      {
        "prefix": 21,
        "network": "karmachain",
        "displayName": "Karmacoin",
        "symbols": [
          "KCOIN"
        ],
        "decimals": [
          6
        ],
        "standardAccount": "*25519",
        "website": "https://karmaco.in"
      },
      {
        "prefix": 22,
        "network": "dock-pos-mainnet",
        "displayName": "Dock Mainnet",
        "symbols": [
          "DCK"
        ],
        "decimals": [
          6
        ],
        "standardAccount": "*25519",
        "website": "https://dock.io"
      },
      {
        "prefix": 23,
        "network": "shift",
        "displayName": "ShiftNrg",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
      },
      {
        "prefix": 24,
        "network": "zero",
        "displayName": "ZERO",
        "symbols": [
          "ZERO"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://zero.io"
      },
      {
        "prefix": 25,
        "network": "zero-alphaville",
        "displayName": "ZERO Alphaville",
        "symbols": [
          "ZERO"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://zero.io"
      },
      {
        "prefix": 26,
        "network": "jupiter",
        "displayName": "Jupiter",
        "symbols": [
          "jDOT"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://jupiter.patract.io"
      },
      {
        "prefix": 27,
        "network": "kabocha",
        "displayName": "Kabocha",
        "symbols": [
          "KAB"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://kabocha.network"
      },
      {
        "prefix": 28,
        "network": "subsocial",
        "displayName": "Subsocial",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
      },
      {
        "prefix": 29,
        "network": "cord",
        "displayName": "CORD Network",
        "symbols": [
          "DHI",
          "WAY"
        ],
        "decimals": [
          12,
          12
        ],
        "standardAccount": "*25519",
        "website": "https://cord.network/"
      },
      {
        "prefix": 30,
        "network": "phala",
        "displayName": "Phala Network",
        "symbols": [
          "PHA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://phala.network"
      },
      {
        "prefix": 31,
        "network": "litentry",
        "displayName": "Litentry Network",
        "symbols": [
          "LIT"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://litentry.com/"
      },
      {
        "prefix": 32,
        "network": "robonomics",
        "displayName": "Robonomics",
        "symbols": [
          "XRT"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://robonomics.network"
      },
      {
        "prefix": 33,
        "network": "datahighway",
        "displayName": "DataHighway",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
      },
      {
        "prefix": 34,
        "network": "ares",
        "displayName": "Ares Protocol",
        "symbols": [
          "ARES"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://www.aresprotocol.com/"
      },
      {
        "prefix": 35,
        "network": "vln",
        "displayName": "Valiu Liquidity Network",
        "symbols": [
          "USDv"
        ],
        "decimals": [
          15
        ],
        "standardAccount": "*25519",
        "website": "https://valiu.com/"
      },
      {
        "prefix": 36,
        "network": "centrifuge",
        "displayName": "Centrifuge Chain",
        "symbols": [
          "CFG"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://centrifuge.io/"
      },
      {
        "prefix": 37,
        "network": "nodle",
        "displayName": "Nodle Chain",
        "symbols": [
          "NODL"
        ],
        "decimals": [
          11
        ],
        "standardAccount": "*25519",
        "website": "https://nodle.io/"
      },
      {
        "prefix": 38,
        "network": "kilt",
        "displayName": "KILT Spiritnet",
        "symbols": [
          "KILT"
        ],
        "decimals": [
          15
        ],
        "standardAccount": "*25519",
        "website": "https://kilt.io/"
      },
      {
        "prefix": 39,
        "network": "mathchain",
        "displayName": "MathChain mainnet",
        "symbols": [
          "MATH"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://mathwallet.org"
      },
      {
        "prefix": 40,
        "network": "mathchain-testnet",
        "displayName": "MathChain testnet",
        "symbols": [
          "MATH"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://mathwallet.org"
      },
      {
        "prefix": 41,
        "network": "polimec",
        "displayName": "Polimec Protocol",
        "symbols": [
          "PLMC"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://www.polimec.org/"
      },
      {
        "prefix": 42,
        "network": "substrate",
        "displayName": "Substrate",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": "https://substrate.io/"
      },
      {
        "prefix": 43,
        "network": "BareSecp256k1",
        "displayName": "Bare 32-bit ECDSA SECP-256k1 public key.",
        "symbols": [],
        "decimals": [],
        "standardAccount": "secp256k1",
        "website": null
      },
      {
        "prefix": 44,
        "network": "chainx",
        "displayName": "ChainX",
        "symbols": [
          "PCX"
        ],
        "decimals": [
          8
        ],
        "standardAccount": "*25519",
        "website": "https://chainx.org/"
      },
      {
        "prefix": 45,
        "network": "uniarts",
        "displayName": "UniArts Network",
        "symbols": [
          "UART",
          "UINK"
        ],
        "decimals": [
          12,
          12
        ],
        "standardAccount": "*25519",
        "website": "https://uniarts.me"
      },
      {
        "prefix": 46,
        "network": "reserved46",
        "displayName": "This prefix is reserved.",
        "symbols": [],
        "decimals": [],
        "standardAccount": null,
        "website": null
      },
      {
        "prefix": 47,
        "network": "reserved47",
        "displayName": "This prefix is reserved.",
        "symbols": [],
        "decimals": [],
        "standardAccount": null,
        "website": null
      },
      {
        "prefix": 48,
        "network": "neatcoin",
        "displayName": "Neatcoin Mainnet",
        "symbols": [
          "NEAT"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://neatcoin.org"
      },
      {
        "prefix": 49,
        "network": "picasso",
        "displayName": "Picasso",
        "symbols": [
          "PICA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://picasso.composable.finance"
      },
      {
        "prefix": 50,
        "network": "composable",
        "displayName": "Composable Finance",
        "symbols": [
          "LAYR"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://composable.finance"
      },
      {
        "prefix": 51,
        "network": "oak",
        "displayName": "OAK Network",
        "symbols": [
          "OAK",
          "TUR"
        ],
        "decimals": [
          10,
          10
        ],
        "standardAccount": "*25519",
        "website": "https://oak.tech"
      },
      {
        "prefix": 52,
        "network": "KICO",
        "displayName": "KICO",
        "symbols": [
          "KICO"
        ],
        "decimals": [
          14
        ],
        "standardAccount": "*25519",
        "website": "https://dico.io"
      },
      {
        "prefix": 53,
        "network": "DICO",
        "displayName": "DICO",
        "symbols": [
          "DICO"
        ],
        "decimals": [
          14
        ],
        "standardAccount": "*25519",
        "website": "https://dico.io"
      },
      {
        "prefix": 54,
        "network": "cere",
        "displayName": "Cere Network",
        "symbols": [
          "CERE"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://cere.network"
      },
      {
        "prefix": 55,
        "network": "xxnetwork",
        "displayName": "xx network",
        "symbols": [
          "XX"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://xx.network"
      },
      {
        "prefix": 56,
        "network": "pendulum",
        "displayName": "Pendulum chain",
        "symbols": [
          "PEN"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://pendulumchain.org/"
      },
      {
        "prefix": 57,
        "network": "amplitude",
        "displayName": "Amplitude chain",
        "symbols": [
          "AMPE"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://pendulumchain.org/"
      },
      {
        "prefix": 58,
        "network": "eternal-civilization",
        "displayName": "Eternal Civilization",
        "symbols": [
          "ECC"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "http://www.ysknfr.cn/"
      },
      {
        "prefix": 63,
        "network": "hydradx",
        "displayName": "Hydration",
        "symbols": [
          "HDX"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://hydration.net"
      },
      {
        "prefix": 65,
        "network": "aventus",
        "displayName": "Aventus Mainnet",
        "symbols": [
          "AVT"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://aventus.io"
      },
      {
        "prefix": 66,
        "network": "crust",
        "displayName": "Crust Network",
        "symbols": [
          "CRU"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://crust.network"
      },
      {
        "prefix": 67,
        "network": "genshiro",
        "displayName": "Genshiro Network",
        "symbols": [
          "GENS",
          "EQD",
          "LPT0"
        ],
        "decimals": [
          9,
          9,
          9
        ],
        "standardAccount": "*25519",
        "website": "https://genshiro.equilibrium.io"
      },
      {
        "prefix": 68,
        "network": "equilibrium",
        "displayName": "Equilibrium Network",
        "symbols": [
          "EQ"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://equilibrium.io"
      },
      {
        "prefix": 69,
        "network": "sora",
        "displayName": "SORA Network",
        "symbols": [
          "XOR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://sora.org"
      },
      {
        "prefix": 71,
        "network": "p3d",
        "displayName": "3DP network",
        "symbols": [
          "P3D"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://3dpass.org"
      },
      {
        "prefix": 72,
        "network": "p3dt",
        "displayName": "3DP test network",
        "symbols": [
          "P3Dt"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://3dpass.org"
      },
      {
        "prefix": 73,
        "network": "zeitgeist",
        "displayName": "Zeitgeist",
        "symbols": [
          "ZTG"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://zeitgeist.pm"
      },
      {
        "prefix": 77,
        "network": "manta",
        "displayName": "Manta network",
        "symbols": [
          "MANTA"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://manta.network"
      },
      {
        "prefix": 78,
        "network": "calamari",
        "displayName": "Calamari: Manta Canary Network",
        "symbols": [
          "KMA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://manta.network"
      },
      {
        "prefix": 81,
        "network": "sora_dot_para",
        "displayName": "SORA Polkadot Parachain",
        "symbols": [
          "XOR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://sora.org"
      },
      {
        "prefix": 88,
        "network": "polkadex",
        "displayName": "Polkadex Mainnet",
        "symbols": [
          "PDEX"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://polkadex.trade"
      },
      {
        "prefix": 89,
        "network": "polkadexparachain",
        "displayName": "Polkadex Parachain",
        "symbols": [
          "PDEX"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://polkadex.trade"
      },
      {
        "prefix": 90,
        "network": "frequency",
        "displayName": "Frequency",
        "symbols": [
          "FRQCY"
        ],
        "decimals": [
          8
        ],
        "standardAccount": "*25519",
        "website": "https://www.frequency.xyz"
      },
      {
        "prefix": 92,
        "network": "anmol",
        "displayName": "Anmol Network",
        "symbols": [
          "ANML"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://anmol.network/"
      },
      {
        "prefix": 93,
        "network": "fragnova",
        "displayName": "Fragnova Network",
        "symbols": [
          "NOVA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://fragnova.com"
      },
      {
        "prefix": 98,
        "network": "polkasmith",
        "displayName": "PolkaSmith Canary Network",
        "symbols": [
          "PKS"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://polkafoundry.com"
      },
      {
        "prefix": 99,
        "network": "polkafoundry",
        "displayName": "PolkaFoundry Network",
        "symbols": [
          "PKF"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://polkafoundry.com"
      },
      {
        "prefix": 100,
        "network": "ibtida",
        "displayName": "Anmol Network Ibtida Canary network",
        "symbols": [
          "IANML"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://anmol.network/"
      },
      {
        "prefix": 101,
        "network": "origintrail-parachain",
        "displayName": "OriginTrail Parachain",
        "symbols": [
          "OTP"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://parachain.origintrail.io/"
      },
      {
        "prefix": 105,
        "network": "pontem-network",
        "displayName": "Pontem Network",
        "symbols": [
          "PONT"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://pontem.network"
      },
      {
        "prefix": 110,
        "network": "heiko",
        "displayName": "Heiko",
        "symbols": [
          "HKO"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://parallel.fi/"
      },
      {
        "prefix": 113,
        "network": "integritee-incognito",
        "displayName": "Integritee Incognito",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": "https://integritee.network"
      },
      {
        "prefix": 117,
        "network": "tinker",
        "displayName": "Tinker",
        "symbols": [
          "TNKR"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://invarch.network"
      },
      {
        "prefix": 126,
        "network": "joystream",
        "displayName": "Joystream",
        "symbols": [
          "JOY"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://www.joystream.org"
      },
      {
        "prefix": 128,
        "network": "clover",
        "displayName": "Clover Finance",
        "symbols": [
          "CLV"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://clover.finance"
      },
      {
        "prefix": 129,
        "network": "dorafactory-polkadot",
        "displayName": "Dorafactory Polkadot Network",
        "symbols": [
          "DORA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://dorafactory.org"
      },
      {
        "prefix": 131,
        "network": "litmus",
        "displayName": "Litmus Network",
        "symbols": [
          "LIT"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://litentry.com/"
      },
      {
        "prefix": 136,
        "network": "altair",
        "displayName": "Altair",
        "symbols": [
          "AIR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://centrifuge.io/"
      },
      {
        "prefix": 137,
        "network": "vara",
        "displayName": "Vara Network",
        "symbols": [
          "VARA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://vara.network/"
      },
      {
        "prefix": 172,
        "network": "parallel",
        "displayName": "Parallel",
        "symbols": [
          "PARA"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://parallel.fi/"
      },
      {
        "prefix": 252,
        "network": "social-network",
        "displayName": "Social Network",
        "symbols": [
          "NET"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://social.network"
      },
      {
        "prefix": 255,
        "network": "quartz_mainnet",
        "displayName": "QUARTZ by UNIQUE",
        "symbols": [
          "QTZ"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://unique.network"
      },
      {
        "prefix": 268,
        "network": "pioneer_network",
        "displayName": "Pioneer Network by Bit.Country",
        "symbols": [
          "NEER"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://bit.country"
      },
      {
        "prefix": 420,
        "network": "sora_kusama_para",
        "displayName": "SORA Kusama Parachain",
        "symbols": [
          "XOR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://sora.org"
      },
      {
        "prefix": 440,
        "network": "allfeat_network",
        "displayName": "Allfeat Network",
        "symbols": [
          "AFT"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://allfeat.network"
      },
      {
        "prefix": 666,
        "network": "metaquity_network",
        "displayName": "Metaquity Network",
        "symbols": [
          "MQTY"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://metaquity.xyz/"
      },
      {
        "prefix": 777,
        "network": "curio",
        "displayName": "Curio",
        "symbols": [
          "CGT"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://parachain.capitaldex.exchange/"
      },
      {
        "prefix": 789,
        "network": "geek",
        "displayName": "GEEK Network",
        "symbols": [
          "GEEK"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://geek.gl"
      },
      {
        "prefix": 995,
        "network": "ternoa",
        "displayName": "Ternoa",
        "symbols": [
          "CAPS"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://www.ternoa.network"
      },
      {
        "prefix": 1110,
        "network": "efinity",
        "displayName": "Efinity",
        "symbols": [
          "EFI"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://efinity.io/"
      },
      {
        "prefix": 1221,
        "network": "peaq",
        "displayName": "Peaq Network",
        "symbols": [
          "PEAQ"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "Sr25519",
        "website": "https://www.peaq.network/"
      },
      {
        "prefix": 1222,
        "network": "krest",
        "displayName": "Krest Network",
        "symbols": [
          "KREST"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "Sr25519",
        "website": "https://www.peaq.network/"
      },
      {
        "prefix": 1284,
        "network": "moonbeam",
        "displayName": "Moonbeam",
        "symbols": [
          "GLMR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "secp256k1",
        "website": "https://moonbeam.network"
      },
      {
        "prefix": 1285,
        "network": "moonriver",
        "displayName": "Moonriver",
        "symbols": [
          "MOVR"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "secp256k1",
        "website": "https://moonbeam.network"
      },
      {
        "prefix": 1328,
        "network": "ajuna",
        "displayName": "Ajuna Network",
        "symbols": [
          "AJUN"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://ajuna.io"
      },
      {
        "prefix": 1337,
        "network": "bajun",
        "displayName": "Bajun Network",
        "symbols": [
          "BAJU"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://ajuna.io"
      },
      {
        "prefix": 1516,
        "network": "societal",
        "displayName": "Societal",
        "symbols": [
          "SCTL"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://www.sctl.xyz"
      },
      {
        "prefix": 1985,
        "network": "seals",
        "displayName": "Seals Network",
        "symbols": [
          "SEAL"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://seals.app"
      },
      {
        "prefix": 2007,
        "network": "kapex",
        "displayName": "Kapex",
        "symbols": [
          "KAPEX"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://totemaccounting.com"
      },
      {
        "prefix": 2009,
        "network": "cloudwalk_mainnet",
        "displayName": "CloudWalk Network Mainnet",
        "symbols": [
          "CWN"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://explorer.mainnet.cloudwalk.io"
      },
      {
        "prefix": 2021,
        "network": "logion",
        "displayName": "logion network",
        "symbols": [
          "LGNT"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://logion.network"
      },
      {
        "prefix": 2024,
        "network": "vow-chain",
        "displayName": "Enigmatic Smile",
        "symbols": [
          "VOW"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://www.vow.foundation/"
      },
      {
        "prefix": 2032,
        "network": "interlay",
        "displayName": "Interlay",
        "symbols": [
          "INTR"
        ],
        "decimals": [
          10
        ],
        "standardAccount": "*25519",
        "website": "https://interlay.io/"
      },
      {
        "prefix": 2092,
        "network": "kintsugi",
        "displayName": "Kintsugi",
        "symbols": [
          "KINT"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://interlay.io/"
      },
      {
        "prefix": 2106,
        "network": "bitgreen",
        "displayName": "Bitgreen",
        "symbols": [
          "BBB"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://bitgreen.org/"
      },
      {
        "prefix": 2112,
        "network": "chainflip",
        "displayName": "Chainflip",
        "symbols": [
          "FLIP"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://chainflip.io/"
      },
      {
        "prefix": 2199,
        "network": "moonsama",
        "displayName": "Moonsama",
        "symbols": [
          "SAMA"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "secp256k1",
        "website": "https://moonsama.com"
      },
      {
        "prefix": 2206,
        "network": "ICE",
        "displayName": "ICE Network",
        "symbols": [
          "ICY"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://icenetwork.io"
      },
      {
        "prefix": 2207,
        "network": "SNOW",
        "displayName": "SNOW: ICE Canary Network",
        "symbols": [
          "ICZ"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://icenetwork.io"
      },
      {
        "prefix": 2254,
        "network": "subspace_testnet",
        "displayName": "Subspace testnet",
        "symbols": [
          "tSSC"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://subspace.network"
      },
      {
        "prefix": 3333,
        "network": "peerplays",
        "displayName": "Peerplays",
        "symbols": [
          "PPY"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "secp256k1",
        "website": "https://www.peerplays.com/"
      },
      {
        "prefix": 4450,
        "network": "g1",
        "displayName": "\u011E1",
        "symbols": [
          "G1"
        ],
        "decimals": [
          2
        ],
        "standardAccount": "*25519",
        "website": "https://duniter.org"
      },
      {
        "prefix": 5234,
        "network": "humanode",
        "displayName": "Humanode Network",
        "symbols": [
          "HMND"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://humanode.io"
      },
      {
        "prefix": 5845,
        "network": "tangle",
        "displayName": "Tangle Network",
        "symbols": [
          "TNT"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://www.tangle.tools/"
      },
      {
        "prefix": 6094,
        "network": "autonomys",
        "displayName": "Autonomys",
        "symbols": [
          "AI3"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://autonomys.xyz"
      },
      {
        "prefix": 7007,
        "network": "tidefi",
        "displayName": "Tidefi",
        "symbols": [
          "TDFY"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://tidefi.com"
      },
      {
        "prefix": 7013,
        "network": "gm",
        "displayName": "GM",
        "symbols": [
          "FREN",
          "GM",
          "GN"
        ],
        "decimals": [
          12,
          0,
          0
        ],
        "standardAccount": "*25519",
        "website": "https://gmordie.com"
      },
      {
        "prefix": 7306,
        "network": "krigan",
        "displayName": "Krigan Network",
        "symbols": [
          "KRGN"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://krigan.network"
      },
      {
        "prefix": 7391,
        "network": "unique_mainnet",
        "displayName": "Unique Network",
        "symbols": [
          "UNQ"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://unique.network"
      },
      {
        "prefix": 8866,
        "network": "golden_gate",
        "displayName": "Golden Gate",
        "symbols": [
          "GGX"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://ggxchain.io/"
      },
      {
        "prefix": 8883,
        "network": "sapphire_mainnet",
        "displayName": "Sapphire by Unique",
        "symbols": [
          "QTZ"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://unique.network"
      },
      {
        "prefix": 8886,
        "network": "golden_gate_sydney",
        "displayName": "Golden Gate Sydney",
        "symbols": [
          "GGXT"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://ggxchain.io/"
      },
      {
        "prefix": 9072,
        "network": "hashed",
        "displayName": "Hashed Network",
        "symbols": [
          "HASH"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://hashed.network"
      },
      {
        "prefix": 9807,
        "network": "dentnet",
        "displayName": "DENTNet",
        "symbols": [
          "DENTX"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://www.dentnet.io"
      },
      {
        "prefix": 9935,
        "network": "t3rn",
        "displayName": "t3rn",
        "symbols": [
          "TRN"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://t3rn.io/"
      },
      {
        "prefix": 10041,
        "network": "basilisk",
        "displayName": "Basilisk",
        "symbols": [
          "BSX"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://bsx.fi"
      },
      {
        "prefix": 11330,
        "network": "cess-testnet",
        "displayName": "CESS Testnet",
        "symbols": [
          "TCESS"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://cess.cloud"
      },
      {
        "prefix": 11331,
        "network": "cess",
        "displayName": "CESS",
        "symbols": [
          "CESS"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://cess.cloud"
      },
      {
        "prefix": 11486,
        "network": "luhn",
        "displayName": "Luhn Network",
        "symbols": [
          "LUHN"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://luhn.network"
      },
      {
        "prefix": 11820,
        "network": "contextfree",
        "displayName": "Automata ContextFree",
        "symbols": [
          "CTX"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://ata.network"
      },
      {
        "prefix": 12155,
        "network": "impact",
        "displayName": "Impact Protocol Network",
        "symbols": [
          "BSTY"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://impactprotocol.network/"
      },
      {
        "prefix": 12191,
        "network": "nftmart",
        "displayName": "NFTMart",
        "symbols": [
          "NMT"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://nftmart.io"
      },
      {
        "prefix": 12850,
        "network": "analog-timechain",
        "displayName": "Analog Timechain",
        "symbols": [
          "ANLOG"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://analog.one"
      },
      {
        "prefix": 13116,
        "network": "bittensor",
        "displayName": "Bittensor",
        "symbols": [
          "TAO"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://bittensor.com"
      },
      {
        "prefix": 14697,
        "network": "goro",
        "displayName": "GORO Network",
        "symbols": [
          "GORO"
        ],
        "decimals": [
          9
        ],
        "standardAccount": "*25519",
        "website": "https://goro.network"
      },
      {
        "prefix": 14998,
        "network": "mosaic-chain",
        "displayName": "Mosaic Chain",
        "symbols": [
          "MOS"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "*25519",
        "website": "https://mosaicchain.io"
      },
      {
        "prefix": 29972,
        "network": "mythos",
        "displayName": "Mythos",
        "symbols": [
          "MYTH"
        ],
        "decimals": [
          18
        ],
        "standardAccount": "secp256k1",
        "website": "https://mythos.foundation"
      },
      {
        "prefix": 8888,
        "network": "xcavate",
        "displayName": "Xcavate Protocol",
        "symbols": [
          "XCAV"
        ],
        "decimals": [
          12
        ],
        "standardAccount": "*25519",
        "website": "https://xcavate.io/"
      }
    ];
  }
});

// ../../node_modules/@polkadot/networks/defaults/genesis.js
var knownGenesis;
var init_genesis = __esm({
  "../../node_modules/@polkadot/networks/defaults/genesis.js"() {
    knownGenesis = {
      acala: [
        "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
      ],
      ajuna: [
        "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
      ],
      "aleph-node": [
        "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
      ],
      astar: [
        "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
      ],
      basilisk: [
        "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
      ],
      bifrost: [
        "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
      ],
      "bifrost-kusama": [
        "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
      ],
      bittensor: [
        "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
      ],
      centrifuge: [
        "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
        "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
      ],
      cere: [
        "0x81443836a9a24caaa23f1241897d1235717535711d1d3fe24eae4fdc942c092c"
      ],
      composable: [
        "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
      ],
      darwinia: [
        "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
      ],
      "dock-mainnet": [
        "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
        "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
      ],
      edgeware: [
        "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
      ],
      encointer: [
        "0x7dd99936c1e9e6d1ce7d90eb6f33bea8393b4bf87677d675aa63c9cb3e8c5b5b"
      ],
      enjin: [
        "0xd8761d3c88f26dc12875c00d3165f7d67243d56fc85b4cf19937601a7916e5a9"
      ],
      equilibrium: [
        "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
      ],
      frequency: [
        "0x4a587bf17a404e3572747add7aab7bbe56e805a5479c6c436f07f36fcc8d3ae1"
      ],
      genshiro: [
        "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
      ],
      hydradx: [
        "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
        // Hydration | HydraDX Parachain
        "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
        // Snakenet Gen3-1
        "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
        // Snakenet Gen3
        "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
        // Snakenet Gen2
        "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
        // Snakenet Gen1
      ],
      integritee: [
        "0xcdedc8eadbfa209d3f207bba541e57c3c58a667b05a2e1d1e86353c9000758da",
        // on Kusama
        "0xe13e7af377c64e83f95e0d70d5e5c3c01d697a84538776c5b9bbe0e7d7b6034c"
        // on Polkadot
      ],
      "interlay-parachain": [
        "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
      ],
      karura: [
        "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
      ],
      khala: [
        "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
      ],
      kulupu: [
        "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
      ],
      kusama: [
        "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
        // Kusama CC3,
        "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
        // Kusama CC2
        "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
        // Kusama CC1
      ],
      matrixchain: [
        "0x3af4ff48ec76d2efc8476730f423ac07e25ad48f5f4c9dc39c778b164d808615"
      ],
      nodle: [
        "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
      ],
      origintrail: [
        "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
      ],
      p3d: [
        "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
      ],
      parallel: [
        "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
      ],
      peaq: [
        "0xd2a5d385932d1f650dae03ef8e2748983779ee342c614f80854d32b8cd8fa48c"
      ],
      pendulum: [
        "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
      ],
      phala: [
        "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
      ],
      picasso: [
        "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
        "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
      ],
      polimec: [
        "0x7eb9354488318e7549c722669dcbdcdc526f1fef1420e7944667212f3601fdbd"
      ],
      polkadex: [
        "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
      ],
      polkadot: [
        "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
      ],
      polymesh: [
        "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
      ],
      quartz: [
        "0xcd4d732201ebe5d6b014edda071c4203e16867305332301dc8d092044b28e554"
      ],
      rococo: [
        "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
        "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
        "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
        "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
        "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
        "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
        "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
        "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
        "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
        "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
        "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
        "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
      ],
      sora: [
        "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
      ],
      stafi: [
        "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
      ],
      statemine: [
        "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
      ],
      statemint: [
        "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
      ],
      subsocial: [
        "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
      ],
      ternoa: [
        "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
      ],
      unique: [
        "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
      ],
      vara: [
        "0xfe1b4c55fd4d668101126434206571a7838a8b6b93a6d1b95d607e78e6c53763"
      ],
      vtb: [
        "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
        "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
      ],
      westend: [
        "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
      ],
      xxnetwork: [
        "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
      ],
      zeitgeist: [
        "0x1bf2a2ecb4a868de66ea8610f2ce7c8c43706561b6476031315f6640fe38e060"
      ]
    };
  }
});

// ../../node_modules/@polkadot/networks/defaults/icons.js
var knownIcon;
var init_icons = __esm({
  "../../node_modules/@polkadot/networks/defaults/icons.js"() {
    knownIcon = {
      centrifuge: "polkadot",
      kusama: "polkadot",
      polkadot: "polkadot",
      sora: "polkadot",
      statemine: "polkadot",
      statemint: "polkadot",
      westmint: "polkadot"
    };
  }
});

// ../../node_modules/@polkadot/networks/defaults/ledger.js
var knownLedger;
var init_ledger = __esm({
  "../../node_modules/@polkadot/networks/defaults/ledger.js"() {
    knownLedger = {
      acala: 787,
      ajuna: 354,
      "aleph-node": 643,
      astar: 810,
      bifrost: 788,
      "bifrost-kusama": 788,
      bittensor: 354,
      centrifuge: 747,
      composable: 354,
      darwinia: 354,
      "dock-mainnet": 594,
      edgeware: 523,
      encointer: 434,
      enjin: 1155,
      equilibrium: 99999997,
      frequency: 2091,
      genshiro: 99999996,
      hydradx: 354,
      integritee: 2015,
      "interlay-parachain": 354,
      karura: 686,
      khala: 434,
      kusama: 434,
      matrixchain: 1155,
      nodle: 1003,
      origintrail: 354,
      parallel: 354,
      peaq: 3338,
      pendulum: 354,
      phala: 354,
      picasso: 434,
      polimec: 3344,
      polkadex: 799,
      polkadot: 354,
      polymesh: 595,
      quartz: 631,
      sora: 617,
      stafi: 907,
      statemine: 434,
      // common-good on Kusama, shares derivation
      statemint: 354,
      // common-good on Polkadot, shares derivation
      ternoa: 995,
      unique: 661,
      vara: 4976,
      vtb: 694,
      xxnetwork: 1955,
      zeitgeist: 354
    };
  }
});

// ../../node_modules/@polkadot/networks/defaults/testnets.js
var knownTestnet;
var init_testnets = __esm({
  "../../node_modules/@polkadot/networks/defaults/testnets.js"() {
    knownTestnet = {
      "": true,
      // this is the default non-network entry
      "cess-testnet": true,
      "dock-testnet": true,
      jupiter: true,
      "mathchain-testnet": true,
      p3dt: true,
      subspace_testnet: true,
      "zero-alphaville": true
    };
  }
});

// ../../node_modules/@polkadot/networks/defaults/index.js
var init_defaults = __esm({
  "../../node_modules/@polkadot/networks/defaults/index.js"() {
    init_genesis();
    init_icons();
    init_ledger();
    init_testnets();
  }
});

// ../../node_modules/@polkadot/networks/interfaces.js
function toExpanded(o) {
  const network = o.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n = o;
  n.slip44 = knownLedger[network];
  n.hasLedgerSupport = !!n.slip44;
  n.genesisHash = knownGenesis[network] || [];
  n.icon = knownIcon[network] || "substrate";
  n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n.isIgnored = n.isTestnet || !(o.standardAccount && o.decimals?.length && o.symbols?.length) && o.prefix !== 42;
  return n;
}
function filterSelectable({ genesisHash, prefix: prefix2 }) {
  return !!genesisHash.length || prefix2 === 42;
}
function filterAvailable(n) {
  return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
  const isUnSortedA = UNSORTED.includes(a.prefix);
  const isUnSortedB = UNSORTED.includes(b.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
}
var UNSORTED, TESTNETS, allNetworks, availableNetworks, selectableNetworks;
var init_interfaces = __esm({
  "../../node_modules/@polkadot/networks/interfaces.js"() {
    init_esm2();
    init_defaults();
    UNSORTED = [0, 2, 42];
    TESTNETS = ["testnet"];
    allNetworks = esm_default.map(toExpanded);
    availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
    selectableNetworks = availableNetworks.filter(filterSelectable);
  }
});

// ../../node_modules/@polkadot/networks/index.js
var init_networks = __esm({
  "../../node_modules/@polkadot/networks/index.js"() {
    init_interfaces();
  }
});

// ../../node_modules/@polkadot/util-crypto/networks.js
var init_networks2 = __esm({
  "../../node_modules/@polkadot/util-crypto/networks.js"() {
    init_networks();
  }
});

// ../../node_modules/@polkadot/util-crypto/address/defaults.js
var defaults;
var init_defaults2 = __esm({
  "../../node_modules/@polkadot/util-crypto/address/defaults.js"() {
    init_networks2();
    defaults = {
      allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
      // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
      allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
      allowedPrefix: availableNetworks.map(({ prefix: prefix2 }) => prefix2),
      prefix: 42
    };
  }
});

// ../../node_modules/@polkadot/util-crypto/address/decode.js
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error("Invalid empty address passed");
  }
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error("Invalid decoded address length");
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error("Invalid decoded address checksum");
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}
var init_decode = __esm({
  "../../node_modules/@polkadot/util-crypto/address/decode.js"() {
    init_util();
    init_base58();
    init_checksum();
    init_defaults2();
  }
});

// ../../node_modules/@polkadot/util-crypto/bn.js
var BN_BE_OPTS, BN_LE_OPTS, BN_BE_32_OPTS, BN_LE_32_OPTS, BN_BE_256_OPTS, BN_LE_256_OPTS;
var init_bn4 = __esm({
  "../../node_modules/@polkadot/util-crypto/bn.js"() {
    BN_BE_OPTS = { isLe: false };
    BN_LE_OPTS = { isLe: true };
    BN_BE_32_OPTS = { bitLength: 32, isLe: false };
    BN_LE_32_OPTS = { bitLength: 32, isLe: true };
    BN_BE_256_OPTS = { bitLength: 256, isLe: false };
    BN_LE_256_OPTS = { bitLength: 256, isLe: true };
  }
});

// ../../node_modules/@polkadot/util-crypto/key/DeriveJunction.js
var RE_NUMBER, JUNCTION_ID_LEN, DeriveJunction;
var init_DeriveJunction = __esm({
  "../../node_modules/@polkadot/util-crypto/key/DeriveJunction.js"() {
    init_util();
    init_asU8a();
    init_bn4();
    RE_NUMBER = /^\d+$/;
    JUNCTION_ID_LEN = 32;
    DeriveJunction = class _DeriveJunction {
      __internal__chainCode = new Uint8Array(32);
      __internal__isHard = false;
      static from(value) {
        const result = new _DeriveJunction();
        const [code, isHard] = value.startsWith("/") ? [value.substring(1), true] : [value, false];
        result.soft(RE_NUMBER.test(code) ? new import_bn.default(code, 10) : code);
        return isHard ? result.harden() : result;
      }
      get chainCode() {
        return this.__internal__chainCode;
      }
      get isHard() {
        return this.__internal__isHard;
      }
      get isSoft() {
        return !this.__internal__isHard;
      }
      hard(value) {
        return this.soft(value).harden();
      }
      harden() {
        this.__internal__isHard = true;
        return this;
      }
      soft(value) {
        if (isNumber(value) || isBn(value) || isBigInt(value)) {
          return this.soft(bnToU8a(value, BN_LE_256_OPTS));
        } else if (isHex(value)) {
          return this.soft(hexToU8a(value));
        } else if (isString(value)) {
          return this.soft(compactAddLength(stringToU8a(value)));
        } else if (value.length > JUNCTION_ID_LEN) {
          return this.soft(blake2AsU8a(value));
        }
        this.__internal__chainCode.fill(0);
        this.__internal__chainCode.set(value, 0);
        return this;
      }
      soften() {
        this.__internal__isHard = false;
        return this;
      }
    };
  }
});

// ../../node_modules/@polkadot/util-crypto/key/extractPath.js
function keyExtractPath(derivePath) {
  const parts = derivePath.match(RE_JUNCTION);
  const path = [];
  let constructed = "";
  if (parts) {
    constructed = parts.join("");
    for (const p of parts) {
      path.push(DeriveJunction.from(p.substring(1)));
    }
  }
  if (constructed !== derivePath) {
    throw new Error(`Re-constructed path "${constructed}" does not match input`);
  }
  return {
    parts,
    path
  };
}
var RE_JUNCTION;
var init_extractPath = __esm({
  "../../node_modules/@polkadot/util-crypto/key/extractPath.js"() {
    init_DeriveJunction();
    RE_JUNCTION = /\/(\/?)([^/]+)/g;
  }
});

// ../../node_modules/@polkadot/util-crypto/key/extractSuri.js
function keyExtractSuri(suri) {
  const matches = suri.match(RE_CAPTURE);
  if (matches === null) {
    throw new Error("Unable to match provided value to a secret URI");
  }
  const [, phrase, , derivePath, , , password] = matches;
  const { path } = keyExtractPath(derivePath);
  return {
    derivePath,
    password,
    path,
    phrase
  };
}
var RE_CAPTURE;
var init_extractSuri = __esm({
  "../../node_modules/@polkadot/util-crypto/key/extractSuri.js"() {
    init_extractPath();
    RE_CAPTURE = /^(\w+( \w+)*)((\/\/?[^/]+)*)(\/\/\/(.*))?$/;
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js
function secp256k1DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);
}
var HDKD;
var init_deriveHard = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js"() {
    init_util();
    init_asU8a();
    HDKD = compactAddLength(stringToU8a("Secp256k1HDKD"));
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
function anumber3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash2(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber3(h2.outputLen);
  anumber3(h2.blockLen);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
var init_assert3 = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js"() {
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js
var nc, crypto2;
var init_cryptoNode = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js"() {
    nc = __toESM(require("node:crypto"), 1);
    crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  abytes2(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return crypto2.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var createView2, rotr2, Hash2;
var init_utils2 = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js"() {
    init_cryptoNode();
    init_assert3();
    createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
    Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n4 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n4 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l15 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l15, wl, isLE2);
}
var Chi, Maj, HashMD;
var init_md = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js"() {
    init_assert3();
    init_utils2();
    Chi = (a, b, c) => a & b ^ ~a & c;
    Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    HashMD = class extends Hash2 {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView2(this.buffer);
      }
      update(data) {
        aexists2(this);
        const { view, buffer, blockLen } = this;
        data = toBytes2(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView2(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists2(this);
        aoutput2(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView2(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K, SHA256_IV, SHA256_W, SHA256, sha2562;
var init_sha256 = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js"() {
    init_md();
    init_utils2();
    SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    SHA256 = class extends HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A2, B, C, D, E, F: F2, G, H } = this;
        return [A2, B, C, D, E, F2, G, H];
      }
      // prettier-ignore
      set(A2, B, C, D, E, F2, G, H) {
        this.A = A2 | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F2 | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
          const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
        }
        let { A: A2, B, C, D, E, F: F2, G, H } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
          const T1 = H + sigma1 + Chi(E, F2, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = rotr2(A2, 2) ^ rotr2(A2, 13) ^ rotr2(A2, 22);
          const T2 = sigma0 + Maj(A2, B, C) | 0;
          H = G;
          G = F2;
          F2 = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A2;
          A2 = T1 + T2 | 0;
        }
        A2 = A2 + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F2 = F2 + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A2, B, C, D, E, F2, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    sha2562 = /* @__PURE__ */ wrapConstructor2(() => new SHA256());
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac;
var init_hmac = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js"() {
    init_assert3();
    init_utils2();
    HMAC = class extends Hash2 {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash2(hash);
        const key = toBytes2(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        aexists2(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        aexists2(this);
        abytes2(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// ../../node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes3,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  inRange: () => inRange,
  isBytes: () => isBytes4,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject
});
function isBytes4(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes3(item) {
  if (!isBytes4(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function bytesToHex(bytes2) {
  abytes3(bytes2);
  let hex2 = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex2 += hexes[bytes2[i2]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n2 : BigInt("0x" + hex2);
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes3(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e2) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e2);
    }
  } else if (isBytes4(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    abytes3(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a.length; i2++)
    diff |= a[i2] ^ b[i2];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function inRange(n, min, max2) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max2) && min <= n && n < max2;
}
function aInRange(title, n, min, max2) {
  if (!inRange(n, min, max2))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max2 + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h2 = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h2(u8fr([0]), seed);
    v = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v = h2();
  };
  const gen2 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h2();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators2, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators2))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(fn) {
  const map79 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map79.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map79.set(arg, computed);
    return computed;
  };
}
var _0n2, _1n2, _2n, hexes, asciis, isPosBig, bitMask, u8n, u8fr, validatorFns, notImplemented;
var init_utils3 = __esm({
  "../../node_modules/@noble/curves/esm/abstract/utils.js"() {
    _0n2 = /* @__PURE__ */ BigInt(0);
    _1n2 = /* @__PURE__ */ BigInt(1);
    _2n = /* @__PURE__ */ BigInt(2);
    hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
    asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    isPosBig = (n) => typeof n === "bigint" && _0n2 <= n;
    bitMask = (n) => (_2n << BigInt(n - 1)) - _1n2;
    u8n = (data) => new Uint8Array(data);
    u8fr = (arr) => Uint8Array.from(arr);
    validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes4(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    notImplemented = () => {
      throw new Error("not implemented");
    };
  }
});

// ../../node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n3)
    throw new Error("invalid modulus");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n3)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n3)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number, modulo);
  let b = modulo;
  let x2 = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r2 = b % a;
    const m2 = x2 - u * q;
    const n = y - v * q;
    b = a, a = r2, x2 = u, y = v, u = m2, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n2;
  let Q, S2, Z2;
  for (Q = P - _1n3, S2 = 0; Q % _2n2 === _0n3; Q /= _2n2, S2++)
    ;
  for (Z2 = _2n2; Z2 < P && pow(Z2, legendreC, P) !== P - _1n3; Z2++) {
    if (Z2 > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S2 === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q);
    let x2 = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n3 << BigInt(r2 - m2 - 1));
      g = Fp2.sqr(ge);
      x2 = Fp2.mul(x2, ge);
      b = Fp2.mul(b, g);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i2 = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map79, val) => {
    map79[val] = "function";
    return map79;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f3, num, power) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n3)
    return f3.ONE;
  if (power === _1n3)
    return num;
  let p = f3.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f3.mul(p, d);
    d = f3.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f3, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f3.is0(num))
      return acc;
    tmp[i2] = acc;
    return f3.mul(acc, num);
  }, f3.ONE);
  const inverted = f3.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f3.is0(num))
      return acc;
    tmp[i2] = f3.mul(acc, tmp[i2]);
    return f3.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f3 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f3, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f3, n);
    }),
    invertBatch: (lst) => FpInvertBatch(f3, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f3);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n3, _1n3, _2n2, _3n, _4n, _5n, _8n, _9n, _16n, isNegativeLE, FIELD_FIELDS;
var init_modular = __esm({
  "../../node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_utils3();
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
    _2n2 = /* @__PURE__ */ BigInt(2);
    _3n = /* @__PURE__ */ BigInt(3);
    _4n = /* @__PURE__ */ BigInt(4);
    _5n = /* @__PURE__ */ BigInt(5);
    _8n = /* @__PURE__ */ BigInt(8);
    _9n = /* @__PURE__ */ BigInt(9);
    _16n = /* @__PURE__ */ BigInt(16);
    isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n3) === _1n3;
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
  }
});

// ../../node_modules/@noble/curves/esm/abstract/curve.js
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits2) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits2)
    throw new Error("invalid window size, expected [1.." + bits2 + "], got W=" + W);
}
function calcWOpts(W, bits2) {
  validateW(W, bits2);
  const windows = Math.ceil(bits2 / W) + 1;
  const windowSize = 2 ** (W - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i2) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s2, i2) => {
    if (!field.isValid(s2))
      throw new Error("invalid scalar at index " + i2);
  });
}
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits2) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits2);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = calcWOpts(W, bits2);
      let p = c.ZERO;
      let f3 = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f3 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W, bits2);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        if (n === _0n4)
          break;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W, bits2);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n4, _1n4, pointPrecomputes, pointWindowSizes;
var init_curve = __esm({
  "../../node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_modular();
    init_utils3();
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    pointWindowSizes = /* @__PURE__ */ new WeakMap();
  }
});

// ../../node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y };
  });
  function weierstrassEquation(x2) {
    const { a, b } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n5, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes4(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod(num, N2);
    aInRange("private key", num, _1n5, N2);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x2, py: y, pz: z } = p;
    if (Fp2.eql(z, Fp2.ONE))
      return { x: x2, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(z);
    const ax = Fp2.mul(x2, iz);
    const ay = Fp2.mul(y, iz);
    const zz = Fp2.mul(z, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp2.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y } = p.toAffine();
    if (!Fp2.isValid(x2) || !Fp2.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left = Fp2.sqr(y);
    const right = weierstrassEquation(x2);
    if (!Fp2.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x: x2, y } = p || {};
      if (!p || !Fp2.isValid(x2) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
      if (is0(x2) && is0(y))
        return Point2.ZERO;
      return new Point2(x2, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point2.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", sc, _0n5, N2);
      const I = Point2.ZERO;
      if (sc === _0n5)
        return I;
      if (this.is0() || sc === _1n5)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point2.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", scalar, _1n5, N2);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f3 } = this.wNAF(scalar);
        point = p;
        fake = f3;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x2 = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!inRange(x2, _1n5, Fp2.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x: x2, y };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n5;
    return number > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b, from4, to) => bytesToNumberBE(b.slice(from4, to));
  class Signature {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l15 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l15 * 2);
      return new Signature(slcNum(hex2, 0, l15), slcNum(hex2, l15, 2 * l15));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r2, s2);
    }
    assertValidity() {
      aInRange("r", this.r, _1n5, CURVE_ORDER);
      aInRange("s", this.s, _1n5, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix2 = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix2 + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes4(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n5, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r2 = modN(q.x);
      if (r2 === _0n5)
        return;
      const s2 = modN(ik * modN(m2 + r2 * d));
      if (s2 === _0n5)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n5);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg === "string" || isBytes4(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h2 * is);
    const u2 = modN(r2 * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}
var b2n, h2b, DER, _0n5, _1n5, _2n3, _3n2, _4n2;
var init_weierstrass = __esm({
  "../../node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_curve();
    init_modular();
    init_utils3();
    init_utils3();
    ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports);
    DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m2 = "") {
          super(m2);
        }
      },
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = numberToHexUnpadded(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
          const t2 = numberToHexUnpadded(tag);
          return t2 + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first2 = data[pos++];
          const isLong = !!(first2 & 128);
          let length = 0;
          if (!isLong)
            length = first2;
          else {
            const lenLen = first2 & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = DER;
          if (num < _0n5)
            throw new E("integer: negative integers are not allowed");
          let hex2 = numberToHexUnpadded(num);
          if (Number.parseInt(hex2[0], 16) & 8)
            hex2 = "00" + hex2;
          if (hex2.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex2;
        },
        decode(data) {
          const { Err: E } = DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return b2n(data);
        }
      },
      toSig(hex2) {
        const { Err: E, _int: int, _tlv: tlv } = DER;
        const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
        abytes3(data);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig2) {
        const { _tlv: tlv, _int: int } = DER;
        const rs = tlv.encode(2, int.encode(sig2.r));
        const ss = tlv.encode(2, int.encode(sig2.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    _0n5 = BigInt(0);
    _1n5 = BigInt(1);
    _2n3 = BigInt(2);
    _3n2 = BigInt(3);
    _4n2 = BigInt(4);
  }
});

// ../../node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash) {
  return {
    hash,
    hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
  return Object.freeze({ ...create(defHash), create });
}
var init_shortw_utils = __esm({
  "../../node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_hmac();
    init_utils2();
    init_weierstrass();
  }
});

// ../../node_modules/@noble/curves/esm/secp256k1.js
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n4 = BigInt(3), _6n = BigInt(6), _11n2 = BigInt(11), _22n = BigInt(22);
  const _23n2 = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n4, P) * b3 % P;
  const b9 = pow2(b6, _3n4, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n2, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n4, P) * b3 % P;
  const t1 = pow2(b223, _23n2, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var secp256k1P, secp256k1N, _1n6, _2n4, divNearest, Fpk1, secp256k1, _0n6, Point;
var init_secp256k1 = __esm({
  "../../node_modules/@noble/curves/esm/secp256k1.js"() {
    init_sha256();
    init_shortw_utils();
    init_modular();
    secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    _1n6 = BigInt(1);
    _2n4 = BigInt(2);
    divNearest = (a, b) => (a + b / _2n4) / b;
    Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    secp256k1 = createCurve({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp: Fpk1,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = mod(k - c1 * a1 - c2 * a2, n);
          let k2 = mod(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha2562);
    _0n6 = BigInt(0);
    Point = secp256k1.ProjectivePoint;
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js
function secp256k1PairFromSeed(seed, onlyJs) {
  if (seed.length !== 32) {
    throw new Error("Expected valid 32-byte private key as a seed");
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = secp256k1FromSeed(seed);
    const publicKey = full.slice(32);
    if (u8aEmpty(publicKey)) {
      throw new Error("Invalid publicKey generated from WASM interface");
    }
    return {
      publicKey,
      secretKey: full.slice(0, 32)
    };
  }
  return {
    publicKey: secp256k1.getPublicKey(seed, true),
    secretKey: seed
  };
}
var init_fromSeed = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js"() {
    init_secp256k1();
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/key/hdkdDerive.js
function createSeedDeriveFn(fromSeed, derive2) {
  return (keypair, { chainCode, isHard }) => {
    if (!isHard) {
      throw new Error("A soft key was found in the path and is not supported");
    }
    return fromSeed(derive2(keypair.secretKey.subarray(0, 32), chainCode));
  };
}
var init_hdkdDerive = __esm({
  "../../node_modules/@polkadot/util-crypto/key/hdkdDerive.js"() {
  }
});

// ../../node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js
var keyHdkdEcdsa;
var init_hdkdEcdsa = __esm({
  "../../node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js"() {
    init_deriveHard();
    init_fromSeed();
    init_hdkdDerive();
    keyHdkdEcdsa = /* @__PURE__ */ createSeedDeriveFn(secp256k1PairFromSeed, secp256k1DeriveHard);
  }
});

// ../../node_modules/@polkadot/util-crypto/ed25519/deriveHard.js
function ed25519DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD2, seed, chainCode));
}
var HDKD2;
var init_deriveHard2 = __esm({
  "../../node_modules/@polkadot/util-crypto/ed25519/deriveHard.js"() {
    init_util();
    init_asU8a();
    HDKD2 = compactAddLength(stringToU8a("Ed25519HDKD"));
  }
});

// ../../node_modules/@polkadot/util-crypto/random/asU8a.js
function randomAsU8a(length = 32) {
  return getRandomValues(new Uint8Array(length));
}
var init_asU8a2 = __esm({
  "../../node_modules/@polkadot/util-crypto/random/asU8a.js"() {
    init_node3();
  }
});

// ../../node_modules/@polkadot/util-crypto/random/index.js
var init_random = __esm({
  "../../node_modules/@polkadot/util-crypto/random/index.js"() {
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js
function fromBig2(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
  return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
}
function split2(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l15 } = fromBig2(lst[i2], le);
    [Ah[i2], Al[i2]] = [h2, l15];
  }
  return [Ah, Al];
}
function add2(Ah, Al, Bh, Bl) {
  const l15 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l15 / 2 ** 32 | 0) | 0, l: l15 | 0 };
}
var U32_MASK642, _32n2, toBig2, shrSH2, shrSL2, rotrSH2, rotrSL2, rotrBH2, rotrBL2, rotr32H2, rotr32L2, rotlSH2, rotlSL2, rotlBH2, rotlBL2, add3L2, add3H2, add4L2, add4H2, add5L2, add5H2, u642, u64_default2;
var init_u642 = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n2 = /* @__PURE__ */ BigInt(32);
    toBig2 = (h2, l15) => BigInt(h2 >>> 0) << _32n2 | BigInt(l15 >>> 0);
    shrSH2 = (h2, _l, s2) => h2 >>> s2;
    shrSL2 = (h2, l15, s2) => h2 << 32 - s2 | l15 >>> s2;
    rotrSH2 = (h2, l15, s2) => h2 >>> s2 | l15 << 32 - s2;
    rotrSL2 = (h2, l15, s2) => h2 << 32 - s2 | l15 >>> s2;
    rotrBH2 = (h2, l15, s2) => h2 << 64 - s2 | l15 >>> s2 - 32;
    rotrBL2 = (h2, l15, s2) => h2 >>> s2 - 32 | l15 << 64 - s2;
    rotr32H2 = (_h, l15) => l15;
    rotr32L2 = (h2, _l) => h2;
    rotlSH2 = (h2, l15, s2) => h2 << s2 | l15 >>> 32 - s2;
    rotlSL2 = (h2, l15, s2) => l15 << s2 | h2 >>> 32 - s2;
    rotlBH2 = (h2, l15, s2) => l15 << s2 - 32 | h2 >>> 64 - s2;
    rotlBL2 = (h2, l15, s2) => h2 << s2 - 32 | l15 >>> 64 - s2;
    add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    u642 = {
      fromBig: fromBig2,
      split: split2,
      toBig: toBig2,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H: rotr32H2,
      rotr32L: rotr32L2,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add: add2,
      add3L: add3L2,
      add3H: add3H2,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    u64_default2 = u642;
  }
});

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js
var SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, sha5122;
var init_sha512 = __esm({
  "../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js"() {
    init_md();
    init_u642();
    init_utils2();
    [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default2.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    SHA512 = class extends HashMD {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4) {
          SHA512_W_H[i2] = view.getUint32(offset);
          SHA512_W_L[i2] = view.getUint32(offset += 4);
        }
        for (let i2 = 16; i2 < 80; i2++) {
          const W15h = SHA512_W_H[i2 - 15] | 0;
          const W15l = SHA512_W_L[i2 - 15] | 0;
          const s0h = u64_default2.rotrSH(W15h, W15l, 1) ^ u64_default2.rotrSH(W15h, W15l, 8) ^ u64_default2.shrSH(W15h, W15l, 7);
          const s0l = u64_default2.rotrSL(W15h, W15l, 1) ^ u64_default2.rotrSL(W15h, W15l, 8) ^ u64_default2.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i2 - 2] | 0;
          const W2l = SHA512_W_L[i2 - 2] | 0;
          const s1h = u64_default2.rotrSH(W2h, W2l, 19) ^ u64_default2.rotrBH(W2h, W2l, 61) ^ u64_default2.shrSH(W2h, W2l, 6);
          const s1l = u64_default2.rotrSL(W2h, W2l, 19) ^ u64_default2.rotrBL(W2h, W2l, 61) ^ u64_default2.shrSL(W2h, W2l, 6);
          const SUMl = u64_default2.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
          const SUMh = u64_default2.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
          SHA512_W_H[i2] = SUMh | 0;
          SHA512_W_L[i2] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          const sigma1h = u64_default2.rotrSH(Eh, El, 14) ^ u64_default2.rotrSH(Eh, El, 18) ^ u64_default2.rotrBH(Eh, El, 41);
          const sigma1l = u64_default2.rotrSL(Eh, El, 14) ^ u64_default2.rotrSL(Eh, El, 18) ^ u64_default2.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64_default2.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
          const T1h = u64_default2.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
          const T1l = T1ll | 0;
          const sigma0h = u64_default2.rotrSH(Ah, Al, 28) ^ u64_default2.rotrBH(Ah, Al, 34) ^ u64_default2.rotrBH(Ah, Al, 39);
          const sigma0l = u64_default2.rotrSL(Ah, Al, 28) ^ u64_default2.rotrBL(Ah, Al, 34) ^ u64_default2.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64_default2.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64_default2.add3L(T1l, sigma0l, MAJl);
          Ah = u64_default2.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64_default2.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64_default2.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64_default2.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64_default2.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64_default2.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64_default2.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64_default2.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64_default2.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    sha5122 = /* @__PURE__ */ wrapConstructor2(() => new SHA512());
  }
});

// ../../node_modules/@noble/curves/esm/abstract/edwards.js
function validateOpts2(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n5 << BigInt(nByteLength * 8) - _1n7;
  const modP = Fp2.create;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const uvRatio2 = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
    } catch (e2) {
      return { isValid: false, value: _0n7 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n) {
    aInRange("coordinate " + title, n, _0n7, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x2, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp2.inv(z);
    const ax = modP(x2 * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n7, y: _1n7 };
    if (zz !== _1n7)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z2, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z22 = modP(Z2 * Z2);
    const Z4 = modP(Z22 * Z22);
    const aX2 = modP(X2 * a);
    const left = modP(Z22 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z2 * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x: x2, y } = p || {};
      aCoordinate("x", x2);
      aCoordinate("y", y);
      return new Point2(x2, y, _1n7, modP(x2 * y));
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.ez));
      return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A2 = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n5 * modP(Z1 * Z1));
      const D = modP(a * A2);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A2 - B);
      const G2 = D + B;
      const F2 = G2 - C;
      const H = D - B;
      const X3 = modP(E * F2);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F2 * G2);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a === BigInt(-1)) {
        const A3 = modP((Y1 - X1) * (Y2 + X2));
        const B2 = modP((Y1 + X1) * (Y2 - X2));
        const F3 = modP(B2 - A3);
        if (F3 === _0n7)
          return this.double();
        const C2 = modP(Z1 * _2n5 * T2);
        const D2 = modP(T1 * _2n5 * Z2);
        const E2 = D2 + C2;
        const G3 = B2 + A3;
        const H2 = D2 - C2;
        const X32 = modP(E2 * F3);
        const Y32 = modP(G3 * H2);
        const T32 = modP(E2 * H2);
        const Z32 = modP(F3 * G3);
        return new Point2(X32, Y32, Z32, T32);
      }
      const A2 = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A2 - B);
      const F2 = D - C;
      const G2 = D + C;
      const H = modP(B - a * A2);
      const X3 = modP(E * F2);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F2 * G2);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point2.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n7, CURVE_ORDER);
      const { p, f: f3 } = this.wNAF(n);
      return Point2.normalizeZ([p, f3])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n7, CURVE_ORDER);
      if (n === _0n7)
        return I;
      if (this.is0() || n === _1n7)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n, Point2.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n7)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex2 = ensureBytes("pointHex", hex2, len);
      abool("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max2 = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y, _0n7, max2);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n7);
      const v = modP(d * y2 - a);
      let { isValid, value: x2 } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n7) === _1n7;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n7 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point2.fromAffine({ x: x2, y });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x2, y } = this.toAffine();
      const bytes2 = numberToBytesLE(y, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n7 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n7, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n7, _1n7, _1n7, _0n7);
  const { BASE: G, ZERO: I } = Point2;
  const wnaf = wNAF(Point2, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getExtendedPublicKey(key) {
    const len = Fp2.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix2 = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix: prefix2, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix: prefix2, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r2 = hashDomainToScalar(options.context, prefix2, msg);
    const R = G.multiply(r2).toRawBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s2 = modN(r2 + k * scalar);
    aInRange("signature.s", s2, _0n7, CURVE_ORDER);
    const res = concatBytes2(R, numberToBytesLE(s2, Fp2.BYTES));
    return ensureBytes("result", res, Fp2.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig2, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig2 = ensureBytes("signature", sig2, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE(sig2.slice(len, 2 * len));
    let A2, R, SB;
    try {
      A2 = Point2.fromHex(publicKey, zip215);
      R = Point2.fromHex(sig2.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A2.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A2.toRawBytes(), msg);
    const RkA = R.add(A2.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
  }
  G._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign2,
    verify,
    ExtendedPoint: Point2,
    utils
  };
}
var _0n7, _1n7, _2n5, _8n2, VERIFY_DEFAULT;
var init_edwards = __esm({
  "../../node_modules/@noble/curves/esm/abstract/edwards.js"() {
    init_curve();
    init_modular();
    init_utils3();
    init_utils3();
    _0n7 = BigInt(0);
    _1n7 = BigInt(1);
    _2n5 = BigInt(2);
    _8n2 = BigInt(8);
    VERIFY_DEFAULT = { zip215: true };
  }
});

// ../../node_modules/@noble/curves/esm/ed25519.js
function ed25519_pow_2_252_3(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x22 = x2 * x2 % P;
  const b2 = x22 * x2 % P;
  const b4 = pow2(b2, _2n6, P) * b2 % P;
  const b5 = pow2(b4, _1n8, P) * x2 % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n6, P) * x2 % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u, v) {
  const P = ED25519_P;
  const v32 = mod(v * v * v, P);
  const v7 = mod(v32 * v32 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x2 = mod(u * v32 * pow3, P);
  const vx2 = mod(v * x2 * x2, P);
  const root1 = x2;
  const root2 = mod(x2 * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE(x2, P))
    x2 = mod(-x2, P);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
var ED25519_P, ED25519_SQRT_M1, _0n8, _1n8, _2n6, _3n3, _5n2, _8n3, Fp, ed25519Defaults, ed25519;
var init_ed25519 = __esm({
  "../../node_modules/@noble/curves/esm/ed25519.js"() {
    init_sha512();
    init_utils2();
    init_edwards();
    init_modular();
    ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
    ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    _0n8 = BigInt(0);
    _1n8 = BigInt(1);
    _2n6 = BigInt(2);
    _3n3 = BigInt(3);
    _5n2 = BigInt(5);
    _8n3 = BigInt(8);
    Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
    ed25519Defaults = /* @__PURE__ */ (() => ({
      // Param: a
      a: BigInt(-1),
      // Fp.create(-1) is proper; our way still works and is faster
      // d is equal to -121665/121666 over finite field.
      // Negative number is P - number, and division is invert(number, P)
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
      Fp,
      // Subgroup order: how many points curve has
      // 2n**252n + 27742317777372353535851937790883648493n;
      n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
      // Cofactor
      h: _8n3,
      // Base point (x, y) aka generator point
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
      hash: sha5122,
      randomBytes,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/√v
      uvRatio
    }))();
    ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  }
});

// ../../node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js
function ed25519PairFromSeed(seed, onlyJs) {
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = ed25519KeypairFromSeed(seed);
    return {
      publicKey: full.slice(32),
      secretKey: full.slice(0, 64)
    };
  }
  const publicKey = ed25519.getPublicKey(seed);
  return {
    publicKey,
    secretKey: u8aConcatStrict([seed, publicKey])
  };
}
var init_fromSeed2 = __esm({
  "../../node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js"() {
    init_ed25519();
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/ed25519/sign.js
function ed25519Sign2(message, { publicKey, secretKey }, onlyJs) {
  if (!secretKey) {
    throw new Error("Expected a valid secretKey");
  } else if (!publicKey) {
    throw new Error("Expected a valid publicKey");
  }
  const messageU8a = u8aToU8a(message);
  const privateU8a = secretKey.subarray(0, 32);
  return !hasBigInt || !onlyJs && isReady() ? ed25519Sign(publicKey, privateU8a, messageU8a) : ed25519.sign(messageU8a, privateU8a);
}
var init_sign = __esm({
  "../../node_modules/@polkadot/util-crypto/ed25519/sign.js"() {
    init_ed25519();
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/ed25519/verify.js
function ed25519Verify2(message, signature, publicKey, onlyJs) {
  const messageU8a = u8aToU8a(message);
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  try {
    return !hasBigInt || !onlyJs && isReady() ? ed25519Verify(signatureU8a, messageU8a, publicKeyU8a) : ed25519.verify(signatureU8a, messageU8a, publicKeyU8a);
  } catch {
    return false;
  }
}
var init_verify = __esm({
  "../../node_modules/@polkadot/util-crypto/ed25519/verify.js"() {
    init_ed25519();
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/ed25519/index.js
var init_ed255192 = __esm({
  "../../node_modules/@polkadot/util-crypto/ed25519/index.js"() {
    init_deriveHard2();
    init_fromSeed2();
    init_sign();
  }
});

// ../../node_modules/@polkadot/util-crypto/key/hdkdEd25519.js
var keyHdkdEd25519;
var init_hdkdEd25519 = __esm({
  "../../node_modules/@polkadot/util-crypto/key/hdkdEd25519.js"() {
    init_ed255192();
    init_hdkdDerive();
    keyHdkdEd25519 = /* @__PURE__ */ createSeedDeriveFn(ed25519PairFromSeed, ed25519DeriveHard);
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/pair/fromU8a.js
function sr25519PairFromU8a(full) {
  const fullU8a = u8aToU8a(full);
  if (fullU8a.length !== TOT_LEN) {
    throw new Error(`Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);
  }
  return {
    publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),
    secretKey: fullU8a.slice(0, SEC_LEN)
  };
}
var SEC_LEN, PUB_LEN, TOT_LEN;
var init_fromU8a2 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/pair/fromU8a.js"() {
    init_util();
    SEC_LEN = 64;
    PUB_LEN = 32;
    TOT_LEN = SEC_LEN + PUB_LEN;
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/pair/toU8a.js
function sr25519KeypairToU8a({ publicKey, secretKey }) {
  return u8aConcat(secretKey, publicKey).slice();
}
var init_toU8a8 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/pair/toU8a.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/derive.js
function createDeriveFn(derive2) {
  return (keypair, chainCode) => {
    if (!isU8a(chainCode) || chainCode.length !== 32) {
      throw new Error("Invalid chainCode passed to derive");
    }
    return sr25519PairFromU8a(derive2(sr25519KeypairToU8a(keypair), chainCode));
  };
}
var init_derive = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/derive.js"() {
    init_util();
    init_fromU8a2();
    init_toU8a8();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/deriveHard.js
var sr25519DeriveHard;
var init_deriveHard3 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/deriveHard.js"() {
    init_wasm_crypto();
    init_derive();
    sr25519DeriveHard = /* @__PURE__ */ createDeriveFn(sr25519DeriveKeypairHard);
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/deriveSoft.js
var sr25519DeriveSoft;
var init_deriveSoft = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/deriveSoft.js"() {
    init_wasm_crypto();
    init_derive();
    sr25519DeriveSoft = /* @__PURE__ */ createDeriveFn(sr25519DeriveKeypairSoft);
  }
});

// ../../node_modules/@polkadot/util-crypto/key/hdkdSr25519.js
function keyHdkdSr25519(keypair, { chainCode, isSoft }) {
  return isSoft ? sr25519DeriveSoft(keypair, chainCode) : sr25519DeriveHard(keypair, chainCode);
}
var init_hdkdSr25519 = __esm({
  "../../node_modules/@polkadot/util-crypto/key/hdkdSr25519.js"() {
    init_deriveHard3();
    init_deriveSoft();
  }
});

// ../../node_modules/@polkadot/util-crypto/key/fromPath.js
function keyFromPath(pair, path, type) {
  const keyHdkd = generators[type];
  let result = pair;
  for (const junction of path) {
    result = keyHdkd(result, junction);
  }
  return result;
}
var generators;
var init_fromPath = __esm({
  "../../node_modules/@polkadot/util-crypto/key/fromPath.js"() {
    init_hdkdEcdsa();
    init_hdkdEd25519();
    init_hdkdSr25519();
    generators = {
      ecdsa: keyHdkdEcdsa,
      ed25519: keyHdkdEd25519,
      // FIXME This is Substrate-compatible, not Ethereum-compatible
      ethereum: keyHdkdEcdsa,
      sr25519: keyHdkdSr25519
    };
  }
});

// ../../node_modules/@polkadot/util-crypto/key/index.js
var init_key = __esm({
  "../../node_modules/@polkadot/util-crypto/key/index.js"() {
    init_extractPath();
    init_extractSuri();
    init_fromPath();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/pair/fromSeed.js
function sr25519PairFromSeed(seed) {
  const seedU8a = u8aToU8a(seed);
  if (seedU8a.length !== 32) {
    throw new Error(`Expected a seed matching 32 bytes, found ${seedU8a.length}`);
  }
  return sr25519PairFromU8a(sr25519KeypairFromSeed(seedU8a));
}
var init_fromSeed3 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/pair/fromSeed.js"() {
    init_util();
    init_wasm_crypto();
    init_fromU8a2();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/sign.js
function sr25519Sign2(message, { publicKey, secretKey }) {
  if (publicKey?.length !== 32) {
    throw new Error("Expected a valid publicKey, 32-bytes");
  } else if (secretKey?.length !== 64) {
    throw new Error("Expected a valid secretKey, 64-bytes");
  }
  return sr25519Sign(publicKey, secretKey, u8aToU8a(message));
}
var init_sign2 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/sign.js"() {
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/verify.js
function sr25519Verify2(message, signature, publicKey) {
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return sr25519Verify(signatureU8a, u8aToU8a(message), publicKeyU8a);
}
var init_verify2 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/verify.js"() {
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/vrfSign.js
function sr25519VrfSign(message, { secretKey }, context = EMPTY_U8A, extra = EMPTY_U8A) {
  if (secretKey?.length !== 64) {
    throw new Error("Invalid secretKey, expected 64-bytes");
  }
  return vrfSign(secretKey, u8aToU8a(context), u8aToU8a(message), u8aToU8a(extra));
}
var EMPTY_U8A;
var init_vrfSign = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/vrfSign.js"() {
    init_util();
    init_wasm_crypto();
    EMPTY_U8A = new Uint8Array();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/vrfVerify.js
function sr25519VrfVerify(message, signOutput, publicKey, context = EMPTY_U8A2, extra = EMPTY_U8A2) {
  const publicKeyU8a = u8aToU8a(publicKey);
  const proofU8a = u8aToU8a(signOutput);
  if (publicKeyU8a.length !== 32) {
    throw new Error("Invalid publicKey, expected 32-bytes");
  } else if (proofU8a.length !== 96) {
    throw new Error("Invalid vrfSign output, expected 96 bytes");
  }
  return vrfVerify(publicKeyU8a, u8aToU8a(context), u8aToU8a(message), u8aToU8a(extra), proofU8a);
}
var EMPTY_U8A2;
var init_vrfVerify = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/vrfVerify.js"() {
    init_util();
    init_wasm_crypto();
    EMPTY_U8A2 = new Uint8Array();
  }
});

// ../../node_modules/@polkadot/util-crypto/sr25519/index.js
var init_sr25519 = __esm({
  "../../node_modules/@polkadot/util-crypto/sr25519/index.js"() {
    init_fromSeed3();
    init_sign2();
    init_vrfSign();
    init_vrfVerify();
  }
});

// ../../node_modules/@polkadot/util-crypto/address/encode.js
function encodeAddress(key, ss58Format = defaults.prefix) {
  const u8a = decodeAddress(key);
  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {
    throw new Error("Out of range ss58Format specified");
  } else if (!defaults.allowedDecodedLengths.includes(u8a.length)) {
    throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(", ")}`);
  }
  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  ], u8a);
  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}
var init_encode = __esm({
  "../../node_modules/@polkadot/util-crypto/address/encode.js"() {
    init_util();
    init_base58();
    init_decode();
    init_defaults2();
    init_sshash();
  }
});

// ../../node_modules/@polkadot/util-crypto/blake2/index.js
var init_blake2 = __esm({
  "../../node_modules/@polkadot/util-crypto/blake2/index.js"() {
    init_asU8a();
  }
});

// ../../node_modules/@noble/hashes/esm/sha3.js
function keccakP(s2, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s2[x2 + y] ^= Th;
        s2[x2 + y + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B[x2] = s2[y + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y + x2] ^= ~B[(x2 + 2) % 10] & B[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round];
    s2[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n9, _1n9, _2n7, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "../../node_modules/@noble/hashes/esm/sha3.js"() {
    init_assert2();
    init_u64();
    init_utils();
    SHA3_PI = [];
    SHA3_ROTL = [];
    _SHA3_IOTA = [];
    _0n9 = /* @__PURE__ */ BigInt(0);
    _1n9 = /* @__PURE__ */ BigInt(1);
    _2n7 = /* @__PURE__ */ BigInt(2);
    _7n = /* @__PURE__ */ BigInt(7);
    _256n = /* @__PURE__ */ BigInt(256);
    _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R = _1n9, x2 = 1, y = 0; round < 24; round++) {
      [x2, y] = [y, (2 * x2 + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x2));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t2 = _0n9;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n9 ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n7)
          t2 ^= _1n9 << (_1n9 << /* @__PURE__ */ BigInt(j)) - _1n9;
      }
      _SHA3_IOTA.push(t2);
    }
    [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
    rotlH = (h2, l15, s2) => s2 > 32 ? rotlBH(h2, l15, s2) : rotlSH(h2, l15, s2);
    rotlL = (h2, l15, s2) => s2 > 32 ? rotlBL(h2, l15, s2) : rotlSL(h2, l15, s2);
    Keccak = class _Keccak extends Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        anumber2(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u322(this.state);
      }
      keccak() {
        if (!isLE)
          byteSwap32(this.state32);
        keccakP(this.state32, this.rounds);
        if (!isLE)
          byteSwap32(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        aexists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i2 = 0; i2 < take; i2++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        aexists(this, false);
        abytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes2) {
        anumber2(bytes2);
        return this.xofInto(new Uint8Array(bytes2));
      }
      digestInto(out) {
        aoutput(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
    sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
    sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
    sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
    keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
    keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
    keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
    keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
    genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
    shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
  }
});

// ../../node_modules/@polkadot/util-crypto/keccak/asU8a.js
var keccakAsU8a;
var init_asU8a3 = __esm({
  "../../node_modules/@polkadot/util-crypto/keccak/asU8a.js"() {
    init_sha3();
    init_wasm_crypto();
    init_helpers4();
    keccakAsU8a = /* @__PURE__ */ createDualHasher({ 256: keccak256, 512: keccak512 }, { 256: keccak_256, 512: keccak_512 });
  }
});

// ../../node_modules/@polkadot/util-crypto/keccak/index.js
var init_keccak = __esm({
  "../../node_modules/@polkadot/util-crypto/keccak/index.js"() {
    init_asU8a3();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/hasher.js
function hasher(hashType, data, onlyJs) {
  return hashType === "keccak" ? keccakAsU8a(data, void 0, onlyJs) : blake2AsU8a(data, void 0, void 0, onlyJs);
}
var init_hasher = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/hasher.js"() {
    init_blake2();
    init_keccak();
  }
});

// ../../node_modules/@polkadot/util-crypto/address/index.js
var init_address = __esm({
  "../../node_modules/@polkadot/util-crypto/address/index.js"() {
    init_decode();
    init_encode();
  }
});

// ../../node_modules/@polkadot/util-crypto/base32/index.js
var init_base32 = __esm({
  "../../node_modules/@polkadot/util-crypto/base32/index.js"() {
  }
});

// ../../node_modules/@polkadot/util-crypto/base64/bs64.js
var config2, base64Validate, base64Decode2, base64Encode;
var init_bs64 = __esm({
  "../../node_modules/@polkadot/util-crypto/base64/bs64.js"() {
    init_esm();
    init_helpers3();
    config2 = {
      chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      coder: base64,
      type: "base64",
      withPadding: true
    };
    base64Validate = /* @__PURE__ */ createValidate(config2);
    base64Decode2 = /* @__PURE__ */ createDecode(config2, base64Validate);
    base64Encode = /* @__PURE__ */ createEncode(config2);
  }
});

// ../../node_modules/@polkadot/util-crypto/base64/index.js
var init_base642 = __esm({
  "../../node_modules/@polkadot/util-crypto/base64/index.js"() {
    init_bs64();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/compress.js
function secp256k1Compress2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 33) {
    return publicKey;
  }
  return !hasBigInt || !onlyJs && isReady() ? secp256k1Compress(publicKey) : secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(true);
}
var init_compress = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/compress.js"() {
    init_secp256k1();
    init_util();
    init_wasm_crypto();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/expand.js
function secp256k1Expand2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 65) {
    return publicKey.subarray(1);
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Expand(publicKey).subarray(1);
  }
  const { px, py } = secp256k1.ProjectivePoint.fromHex(publicKey);
  return u8aConcat(bnToU8a(px, BN_BE_256_OPTS), bnToU8a(py, BN_BE_256_OPTS));
}
var init_expand = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/expand.js"() {
    init_secp256k1();
    init_util();
    init_wasm_crypto();
    init_bn4();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/recover.js
function secp256k1Recover2(msgHash, signature, recovery, hashType = "blake2", onlyJs) {
  const sig2 = u8aToU8a(signature).subarray(0, 64);
  const msg = u8aToU8a(msgHash);
  const publicKey = !hasBigInt || !onlyJs && isReady() ? secp256k1Recover(msg, sig2, recovery) : secp256k1.Signature.fromCompact(sig2).addRecoveryBit(recovery).recoverPublicKey(msg).toRawBytes();
  if (!publicKey) {
    throw new Error("Unable to recover publicKey from signature");
  }
  return hashType === "keccak" ? secp256k1Expand2(publicKey, onlyJs) : secp256k1Compress2(publicKey, onlyJs);
}
var init_recover = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/recover.js"() {
    init_secp256k1();
    init_util();
    init_wasm_crypto();
    init_compress();
    init_expand();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/sign.js
function secp256k1Sign2(message, { secretKey }, hashType = "blake2", onlyJs) {
  if (secretKey?.length !== 32) {
    throw new Error("Expected valid secp256k1 secretKey, 32-bytes");
  }
  const data = hasher(hashType, message, onlyJs);
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Sign(data, secretKey);
  }
  const signature = secp256k1.sign(data, secretKey, { lowS: true });
  return u8aConcat(bnToU8a(signature.r, BN_BE_256_OPTS), bnToU8a(signature.s, BN_BE_256_OPTS), new Uint8Array([signature.recovery || 0]));
}
var init_sign3 = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/sign.js"() {
    init_secp256k1();
    init_util();
    init_wasm_crypto();
    init_bn4();
    init_hasher();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/tweakAdd.js
function addBi(seckey, tweak) {
  let res = u8aToBigInt(tweak, BN_BE_OPTS);
  if (res >= N_BI) {
    throw new Error("Tweak parameter is out of range");
  }
  res += u8aToBigInt(seckey, BN_BE_OPTS);
  if (res >= N_BI) {
    res -= N_BI;
  }
  if (res === _0n) {
    throw new Error("Invalid resulting private key");
  }
  return nToU8a(res, BN_BE_256_OPTS);
}
function addBn(seckey, tweak) {
  const res = new import_bn.default(tweak);
  if (res.cmp(N_BN) >= 0) {
    throw new Error("Tweak parameter is out of range");
  }
  res.iadd(new import_bn.default(seckey));
  if (res.cmp(N_BN) >= 0) {
    res.isub(N_BN);
  }
  if (res.isZero()) {
    throw new Error("Invalid resulting private key");
  }
  return bnToU8a(res, BN_BE_256_OPTS);
}
function secp256k1PrivateKeyTweakAdd(seckey, tweak, onlyBn) {
  if (!isU8a(seckey) || seckey.length !== 32) {
    throw new Error("Expected seckey to be an Uint8Array with length 32");
  } else if (!isU8a(tweak) || tweak.length !== 32) {
    throw new Error("Expected tweak to be an Uint8Array with length 32");
  }
  return !hasBigInt || onlyBn ? addBn(seckey, tweak) : addBi(seckey, tweak);
}
var N, N_BI, N_BN;
var init_tweakAdd = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/tweakAdd.js"() {
    init_util();
    init_x_bigint();
    init_bn4();
    N = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, "");
    N_BI = BigInt2(`0x${N}`);
    N_BN = new import_bn.default(N, "hex");
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/verify.js
function secp256k1Verify(msgHash, signature, address, hashType = "blake2", onlyJs) {
  const sig2 = u8aToU8a(signature);
  if (sig2.length !== 65) {
    throw new Error(`Expected signature with 65 bytes, ${sig2.length} found instead`);
  }
  const publicKey = secp256k1Recover2(hasher(hashType, msgHash), sig2, sig2[64], hashType, onlyJs);
  const signerAddr = hasher(hashType, publicKey, onlyJs);
  const inputAddr = u8aToU8a(address);
  return u8aEq(publicKey, inputAddr) || (hashType === "keccak" ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20)) : u8aEq(signerAddr, inputAddr));
}
var init_verify3 = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/verify.js"() {
    init_util();
    init_hasher();
    init_recover();
  }
});

// ../../node_modules/@polkadot/util-crypto/secp256k1/index.js
var init_secp256k12 = __esm({
  "../../node_modules/@polkadot/util-crypto/secp256k1/index.js"() {
    init_compress();
    init_expand();
    init_fromSeed();
    init_sign3();
    init_tweakAdd();
  }
});

// ../../node_modules/@polkadot/util-crypto/ethereum/encode.js
function getH160(u8a) {
  if ([33, 65].includes(u8a.length)) {
    u8a = keccakAsU8a(secp256k1Expand2(u8a));
  }
  return u8a.slice(-20);
}
function ethereumEncode(addressOrPublic) {
  if (!addressOrPublic) {
    return "0x";
  }
  const u8aAddress = u8aToU8a(addressOrPublic);
  if (![20, 32, 33, 65].includes(u8aAddress.length)) {
    throw new Error(`Invalid address or publicKey provided, received ${u8aAddress.length} bytes input`);
  }
  const address = u8aToHex(getH160(u8aAddress), -1, false);
  const hash = u8aToHex(keccakAsU8a(address), -1, false);
  let result = "";
  for (let i2 = 0; i2 < 40; i2++) {
    result = `${result}${parseInt(hash[i2], 16) > 7 ? address[i2].toUpperCase() : address[i2]}`;
  }
  return `0x${result}`;
}
var init_encode2 = __esm({
  "../../node_modules/@polkadot/util-crypto/ethereum/encode.js"() {
    init_util();
    init_keccak();
    init_secp256k12();
  }
});

// ../../node_modules/@polkadot/util-crypto/ethereum/isChecksum.js
function isInvalidChar(char, byte) {
  return char !== (byte > 7 ? char.toUpperCase() : char.toLowerCase());
}
function isEthereumChecksum(_address) {
  const address = _address.replace("0x", "");
  const hash = u8aToHex(keccakAsU8a(address.toLowerCase()), -1, false);
  for (let i2 = 0; i2 < 40; i2++) {
    if (isInvalidChar(address[i2], parseInt(hash[i2], 16))) {
      return false;
    }
  }
  return true;
}
var init_isChecksum = __esm({
  "../../node_modules/@polkadot/util-crypto/ethereum/isChecksum.js"() {
    init_util();
    init_keccak();
  }
});

// ../../node_modules/@polkadot/util-crypto/ethereum/isAddress.js
function isEthereumAddress(address) {
  if (!address || address.length !== 42 || !isHex(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  }
  return isEthereumChecksum(address);
}
var init_isAddress = __esm({
  "../../node_modules/@polkadot/util-crypto/ethereum/isAddress.js"() {
    init_util();
    init_isChecksum();
  }
});

// ../../node_modules/@polkadot/util-crypto/ethereum/index.js
var init_ethereum = __esm({
  "../../node_modules/@polkadot/util-crypto/ethereum/index.js"() {
    init_encode2();
    init_isAddress();
  }
});

// ../../node_modules/@noble/hashes/esm/hmac.js
var HMAC2, hmac2;
var init_hmac2 = __esm({
  "../../node_modules/@noble/hashes/esm/hmac.js"() {
    init_assert2();
    init_utils();
    HMAC2 = class extends Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash);
        const key = toBytes(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        aexists(this);
        abytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac2 = (hash, key, message) => new HMAC2(hash, key).update(message).digest();
    hmac2.create = (hash, key) => new HMAC2(hash, key);
  }
});

// ../../node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n4 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n4 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l15 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l15, wl, isLE2);
}
var Chi2, Maj2, HashMD2;
var init_md2 = __esm({
  "../../node_modules/@noble/hashes/esm/_md.js"() {
    init_assert2();
    init_utils();
    Chi2 = (a, b, c) => a & b ^ ~a & c;
    Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
    HashMD2 = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        aexists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
  }
});

// ../../node_modules/@noble/hashes/esm/sha256.js
var SHA256_K2, SHA256_IV2, SHA256_W2, SHA2562, sha2563;
var init_sha2562 = __esm({
  "../../node_modules/@noble/hashes/esm/sha256.js"() {
    init_md2();
    init_utils();
    SHA256_K2 = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_IV2 = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
    SHA2562 = class extends HashMD2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV2[0] | 0;
        this.B = SHA256_IV2[1] | 0;
        this.C = SHA256_IV2[2] | 0;
        this.D = SHA256_IV2[3] | 0;
        this.E = SHA256_IV2[4] | 0;
        this.F = SHA256_IV2[5] | 0;
        this.G = SHA256_IV2[6] | 0;
        this.H = SHA256_IV2[7] | 0;
      }
      get() {
        const { A: A2, B, C, D, E, F: F2, G, H } = this;
        return [A2, B, C, D, E, F2, G, H];
      }
      // prettier-ignore
      set(A2, B, C, D, E, F2, G, H) {
        this.A = A2 | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F2 | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W2[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W2[i2 - 15];
          const W2 = SHA256_W2[i2 - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
        }
        let { A: A2, B, C, D, E, F: F2, G, H } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi2(E, F2, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
          const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
          const T2 = sigma0 + Maj2(A2, B, C) | 0;
          H = G;
          G = F2;
          F2 = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A2;
          A2 = T1 + T2 | 0;
        }
        A2 = A2 + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F2 = F2 + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A2, B, C, D, E, F2, G, H);
      }
      roundClean() {
        SHA256_W2.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    sha2563 = /* @__PURE__ */ wrapConstructor(() => new SHA2562());
  }
});

// ../../node_modules/@noble/hashes/esm/sha512.js
var SHA512_Kh2, SHA512_Kl2, SHA512_W_H2, SHA512_W_L2, SHA5122, sha5123;
var init_sha5122 = __esm({
  "../../node_modules/@noble/hashes/esm/sha512.js"() {
    init_md2();
    init_u64();
    init_utils();
    [SHA512_Kh2, SHA512_Kl2] = /* @__PURE__ */ (() => u64_default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
    SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);
    SHA5122 = class extends HashMD2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4) {
          SHA512_W_H2[i2] = view.getUint32(offset);
          SHA512_W_L2[i2] = view.getUint32(offset += 4);
        }
        for (let i2 = 16; i2 < 80; i2++) {
          const W15h = SHA512_W_H2[i2 - 15] | 0;
          const W15l = SHA512_W_L2[i2 - 15] | 0;
          const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
          const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i2 - 2] | 0;
          const W2l = SHA512_W_L2[i2 - 2] | 0;
          const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
          const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
          const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L2[i2 - 7], SHA512_W_L2[i2 - 16]);
          const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i2 - 7], SHA512_W_H2[i2 - 16]);
          SHA512_W_H2[i2] = SUMh | 0;
          SHA512_W_L2[i2] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
          const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i2], SHA512_W_L2[i2]);
          const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i2], SHA512_W_H2[i2]);
          const T1l = T1ll | 0;
          const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
          const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64_default.add3L(T1l, sigma0l, MAJl);
          Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H2.fill(0);
        SHA512_W_L2.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    sha5123 = /* @__PURE__ */ wrapConstructor(() => new SHA5122());
  }
});

// ../../node_modules/@polkadot/util-crypto/hmac/shaAsU8a.js
function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {
  const u8aKey = u8aToU8a(key);
  return !hasBigInt || !onlyJs && isReady() ? WA_MHAC[bitLength](u8aKey, data) : hmac2(JS_HASH[bitLength], u8aKey, data);
}
var JS_HASH, WA_MHAC;
var init_shaAsU8a = __esm({
  "../../node_modules/@polkadot/util-crypto/hmac/shaAsU8a.js"() {
    init_hmac2();
    init_sha2562();
    init_sha5122();
    init_util();
    init_wasm_crypto();
    JS_HASH = {
      256: sha2563,
      512: sha5123
    };
    WA_MHAC = {
      256: hmacSha256,
      512: hmacSha512
    };
  }
});

// ../../node_modules/@polkadot/util-crypto/hmac/index.js
var init_hmac3 = __esm({
  "../../node_modules/@polkadot/util-crypto/hmac/index.js"() {
    init_shaAsU8a();
  }
});

// ../../node_modules/@polkadot/util-crypto/hd/validatePath.js
function hdValidatePath(path) {
  if (!path.startsWith("m/")) {
    return false;
  }
  const parts = path.split("/").slice(1);
  for (const p of parts) {
    const n = /^\d+'?$/.test(p) ? parseInt(p.replace(/'$/, ""), 10) : Number.NaN;
    if (isNaN(n) || n >= HARDENED || n < 0) {
      return false;
    }
  }
  return true;
}
var HARDENED;
var init_validatePath = __esm({
  "../../node_modules/@polkadot/util-crypto/hd/validatePath.js"() {
    HARDENED = 2147483648;
  }
});

// ../../node_modules/@polkadot/util-crypto/hd/ethereum/index.js
function createCoded(secretKey, chainCode) {
  return {
    chainCode,
    publicKey: secp256k1PairFromSeed(secretKey).publicKey,
    secretKey
  };
}
function deriveChild(hd, index) {
  const indexBuffer = bnToU8a(index, BN_BE_32_OPTS);
  const data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);
  try {
    const I = hmacShaAsU8a(hd.chainCode, data, 512);
    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));
  } catch {
    return deriveChild(hd, index + 1);
  }
}
function hdEthereum(seed, path = "") {
  const I = hmacShaAsU8a(MASTER_SECRET, seed, 512);
  let hd = createCoded(I.slice(0, 32), I.slice(32));
  if (!path || path === "m" || path === "M" || path === "m'" || path === "M'") {
    return hd;
  }
  if (!hdValidatePath(path)) {
    throw new Error("Invalid derivation path");
  }
  const parts = path.split("/").slice(1);
  for (const p of parts) {
    hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith("'") ? HARDENED : 0));
  }
  return hd;
}
var MASTER_SECRET;
var init_ethereum2 = __esm({
  "../../node_modules/@polkadot/util-crypto/hd/ethereum/index.js"() {
    init_util();
    init_bn4();
    init_hmac3();
    init_secp256k12();
    init_validatePath();
    MASTER_SECRET = stringToU8a("Bitcoin seed");
  }
});

// ../../node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber2(c);
  anumber2(dkLen);
  anumber2(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf22(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
var init_pbkdf2 = __esm({
  "../../node_modules/@noble/hashes/esm/pbkdf2.js"() {
    init_assert2();
    init_hmac2();
    init_utils();
  }
});

// ../../node_modules/@polkadot/util-crypto/pbkdf2/encode.js
function pbkdf2Encode(passphrase, salt = randomAsU8a(), rounds = 2048, onlyJs) {
  const u8aPass = u8aToU8a(passphrase);
  const u8aSalt = u8aToU8a(salt);
  return {
    password: !hasBigInt || !onlyJs && isReady() ? pbkdf2(u8aPass, u8aSalt, rounds) : pbkdf22(sha5123, u8aPass, u8aSalt, { c: rounds, dkLen: 64 }),
    rounds,
    salt
  };
}
var init_encode3 = __esm({
  "../../node_modules/@polkadot/util-crypto/pbkdf2/encode.js"() {
    init_pbkdf2();
    init_sha5122();
    init_util();
    init_wasm_crypto();
    init_asU8a2();
  }
});

// ../../node_modules/@polkadot/util-crypto/pbkdf2/index.js
var init_pbkdf22 = __esm({
  "../../node_modules/@polkadot/util-crypto/pbkdf2/index.js"() {
    init_encode3();
  }
});

// ../../node_modules/@polkadot/util-crypto/sha/asU8a.js
var shaAsU8a, sha256AsU8a;
var init_asU8a4 = __esm({
  "../../node_modules/@polkadot/util-crypto/sha/asU8a.js"() {
    init_sha2562();
    init_sha5122();
    init_wasm_crypto();
    init_helpers4();
    shaAsU8a = /* @__PURE__ */ createDualHasher({ 256: sha256, 512: sha512 }, { 256: sha2563, 512: sha5123 });
    sha256AsU8a = /* @__PURE__ */ createBitHasher(256, shaAsU8a);
  }
});

// ../../node_modules/@polkadot/util-crypto/sha/index.js
var init_sha = __esm({
  "../../node_modules/@polkadot/util-crypto/sha/index.js"() {
    init_asU8a4();
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/wordlists/en.js
var en_default;
var init_en = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/wordlists/en.js"() {
    en_default = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|");
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/bip39.js
function normalize(str) {
  return (str || "").normalize("NFKD");
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes2) {
  return bytes2.map((x2) => x2.toString(2).padStart(8, "0")).join("");
}
function deriveChecksumBits(entropyBuffer) {
  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);
}
function mnemonicToSeedSync(mnemonic, password) {
  return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;
}
function mnemonicToEntropy(mnemonic, wordlist = en_default) {
  const words = normalize(mnemonic).split(" ");
  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  }
  const bits2 = words.map((word) => {
    const index = wordlist.indexOf(word);
    if (index === -1) {
      throw new Error(INVALID_MNEMONIC);
    }
    return index.toString(2).padStart(11, "0");
  }).join("");
  const dividerIndex = Math.floor(bits2.length / 33) * 32;
  const entropyBits = bits2.slice(0, dividerIndex);
  const checksumBits = bits2.slice(dividerIndex);
  const matched = entropyBits.match(/(.{1,8})/g);
  const entropyBytes = matched?.map(binaryToByte);
  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }
  const entropy = u8aToU8a(entropyBytes);
  if (deriveChecksumBits(entropy) !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }
  return entropy;
}
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch {
    return false;
  }
  return true;
}
var INVALID_MNEMONIC, INVALID_ENTROPY, INVALID_CHECKSUM;
var init_bip39 = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/bip39.js"() {
    init_util();
    init_pbkdf22();
    init_sha();
    init_en();
    INVALID_MNEMONIC = "Invalid mnemonic";
    INVALID_ENTROPY = "Invalid entropy";
    INVALID_CHECKSUM = "Invalid mnemonic checksum";
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/toEntropy.js
function mnemonicToEntropy2(mnemonic, wordlist, onlyJs) {
  return !hasBigInt || !wordlist && !onlyJs && isReady() ? bip39ToEntropy(mnemonic) : mnemonicToEntropy(mnemonic, wordlist);
}
var init_toEntropy = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/toEntropy.js"() {
    init_util();
    init_wasm_crypto();
    init_bip39();
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/validate.js
function mnemonicValidate(mnemonic, wordlist, onlyJs) {
  return !hasBigInt || !wordlist && !onlyJs && isReady() ? bip39Validate(mnemonic) : validateMnemonic(mnemonic, wordlist);
}
var init_validate = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/validate.js"() {
    init_util();
    init_wasm_crypto();
    init_bip39();
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/toLegacySeed.js
function mnemonicToLegacySeed(mnemonic, password = "", onlyJs, byteLength = 32) {
  if (!mnemonicValidate(mnemonic)) {
    throw new Error("Invalid bip39 mnemonic specified");
  } else if (![32, 64].includes(byteLength)) {
    throw new Error(`Invalid seed length ${byteLength}, expected 32 or 64`);
  }
  return byteLength === 32 ? !hasBigInt || !onlyJs && isReady() ? bip39ToSeed(mnemonic, password) : mnemonicToSeedSync(mnemonic, password).subarray(0, 32) : mnemonicToSeedSync(mnemonic, password);
}
var init_toLegacySeed = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/toLegacySeed.js"() {
    init_util();
    init_wasm_crypto();
    init_bip39();
    init_validate();
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/toMiniSecret.js
function mnemonicToMiniSecret(mnemonic, password = "", wordlist, onlyJs) {
  if (!mnemonicValidate(mnemonic, wordlist, onlyJs)) {
    throw new Error("Invalid bip39 mnemonic specified");
  } else if (!wordlist && !onlyJs && isReady()) {
    return bip39ToMiniSecret(mnemonic, password);
  }
  const entropy = mnemonicToEntropy2(mnemonic, wordlist);
  const salt = stringToU8a(`mnemonic${password}`);
  return pbkdf2Encode(entropy, salt).password.slice(0, 32);
}
var init_toMiniSecret = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/toMiniSecret.js"() {
    init_util();
    init_wasm_crypto();
    init_pbkdf22();
    init_toEntropy();
    init_validate();
  }
});

// ../../node_modules/@polkadot/util-crypto/mnemonic/index.js
var init_mnemonic = __esm({
  "../../node_modules/@polkadot/util-crypto/mnemonic/index.js"() {
    init_toLegacySeed();
    init_toMiniSecret();
  }
});

// ../../node_modules/@polkadot/util-crypto/hd/index.js
var init_hd = __esm({
  "../../node_modules/@polkadot/util-crypto/hd/index.js"() {
    init_ethereum2();
  }
});

// ../../node_modules/@polkadot/util-crypto/nacl/tweetnacl.js
function L32(x2, c) {
  return x2 << c | x2 >>> 32 - c;
}
function ld32(x2, i2) {
  let u = x2[i2 + 3] & 255;
  u = u << 8 | x2[i2 + 2] & 255;
  u = u << 8 | x2[i2 + 1] & 255;
  return u << 8 | x2[i2 + 0] & 255;
}
function st32(x2, j, u) {
  for (let i2 = 0; i2 < 4; i2++) {
    x2[j + i2] = u & 255;
    u >>>= 8;
  }
}
function vn(x2, xi, y, yi, n) {
  let d = 0;
  for (let i2 = 0; i2 < n; i2++)
    d |= x2[xi + i2] ^ y[yi + i2];
  return (1 & d - 1 >>> 8) - 1;
}
function core(out, inp, k, c, h2) {
  const w = new Uint32Array(16), x2 = new Uint32Array(16), y = new Uint32Array(16), t2 = new Uint32Array(4);
  let i2, j, m2;
  for (i2 = 0; i2 < 4; i2++) {
    x2[5 * i2] = ld32(c, 4 * i2);
    x2[1 + i2] = ld32(k, 4 * i2);
    x2[6 + i2] = ld32(inp, 4 * i2);
    x2[11 + i2] = ld32(k, 16 + 4 * i2);
  }
  for (i2 = 0; i2 < 16; i2++)
    y[i2] = x2[i2];
  for (i2 = 0; i2 < 20; i2++) {
    for (j = 0; j < 4; j++) {
      for (m2 = 0; m2 < 4; m2++)
        t2[m2] = x2[(5 * j + 4 * m2) % 16];
      t2[1] ^= L32(t2[0] + t2[3] | 0, 7);
      t2[2] ^= L32(t2[1] + t2[0] | 0, 9);
      t2[3] ^= L32(t2[2] + t2[1] | 0, 13);
      t2[0] ^= L32(t2[3] + t2[2] | 0, 18);
      for (m2 = 0; m2 < 4; m2++)
        w[4 * j + (j + m2) % 4] = t2[m2];
    }
    for (m2 = 0; m2 < 16; m2++)
      x2[m2] = w[m2];
  }
  if (h2) {
    for (i2 = 0; i2 < 16; i2++)
      x2[i2] = x2[i2] + y[i2] | 0;
    for (i2 = 0; i2 < 4; i2++) {
      x2[5 * i2] = x2[5 * i2] - ld32(c, 4 * i2) | 0;
      x2[6 + i2] = x2[6 + i2] - ld32(inp, 4 * i2) | 0;
    }
    for (i2 = 0; i2 < 4; i2++) {
      st32(out, 4 * i2, x2[5 * i2]);
      st32(out, 16 + 4 * i2, x2[6 + i2]);
    }
  } else {
    for (i2 = 0; i2 < 16; i2++)
      st32(out, 4 * i2, x2[i2] + y[i2] | 0);
  }
}
function crypto_stream_salsa20_xor(c, cpos, m2, mpos, b, n, k) {
  const z = new Uint8Array(16), x2 = new Uint8Array(64);
  let u, i2;
  if (!b)
    return 0;
  for (i2 = 0; i2 < 16; i2++)
    z[i2] = 0;
  for (i2 = 0; i2 < 8; i2++)
    z[i2] = n[i2];
  while (b >= 64) {
    core(x2, z, k, sigma, false);
    for (i2 = 0; i2 < 64; i2++)
      c[cpos + i2] = (m2 ? m2[mpos + i2] : 0) ^ x2[i2];
    u = 1;
    for (i2 = 8; i2 < 16; i2++) {
      u = u + (z[i2] & 255) | 0;
      z[i2] = u & 255;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    if (m2)
      mpos += 64;
  }
  if (b > 0) {
    core(x2, z, k, sigma, false);
    for (i2 = 0; i2 < b; i2++)
      c[cpos + i2] = (m2 ? m2[mpos + i2] : 0) ^ x2[i2];
  }
  return 0;
}
function crypto_stream_xor(c, cpos, m2, mpos, d, n, k) {
  const s2 = new Uint8Array(32);
  core(s2, n, k, sigma, true);
  return crypto_stream_salsa20_xor(c, cpos, m2, mpos, d, n.subarray(16), s2);
}
function add1305(h2, c) {
  let u = 0;
  for (let j = 0; j < 17; j++) {
    u = u + (h2[j] + c[j] | 0) | 0;
    h2[j] = u & 255;
    u >>>= 8;
  }
}
function crypto_onetimeauth(out, outpos, m2, mpos, n, k) {
  let i2, j, u;
  const x2 = new Uint32Array(17), r2 = new Uint32Array(17), h2 = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);
  for (j = 0; j < 17; j++)
    r2[j] = h2[j] = 0;
  for (j = 0; j < 16; j++)
    r2[j] = k[j];
  r2[3] &= 15;
  r2[4] &= 252;
  r2[7] &= 15;
  r2[8] &= 252;
  r2[11] &= 15;
  r2[12] &= 252;
  r2[15] &= 15;
  while (n > 0) {
    for (j = 0; j < 17; j++)
      c[j] = 0;
    for (j = 0; j < 16 && j < n; ++j)
      c[j] = m2[mpos + j];
    c[j] = 1;
    mpos += j;
    n -= j;
    add1305(h2, c);
    for (i2 = 0; i2 < 17; i2++) {
      x2[i2] = 0;
      for (j = 0; j < 17; j++)
        x2[i2] = x2[i2] + h2[j] * (j <= i2 ? r2[i2 - j] : 320 * r2[i2 + 17 - j] | 0) | 0 | 0;
    }
    for (i2 = 0; i2 < 17; i2++)
      h2[i2] = x2[i2];
    u = 0;
    for (j = 0; j < 16; j++) {
      u = u + h2[j] | 0;
      h2[j] = u & 255;
      u >>>= 8;
    }
    u = u + h2[16] | 0;
    h2[16] = u & 3;
    u = 5 * (u >>> 2) | 0;
    for (j = 0; j < 16; j++) {
      u = u + h2[j] | 0;
      h2[j] = u & 255;
      u >>>= 8;
    }
    u = u + h2[16] | 0;
    h2[16] = u;
  }
  for (j = 0; j < 17; j++)
    g[j] = h2[j];
  add1305(h2, minusp);
  const s2 = -(h2[16] >>> 7) | 0;
  for (j = 0; j < 17; j++)
    h2[j] ^= s2 & (g[j] ^ h2[j]);
  for (j = 0; j < 16; j++)
    c[j] = k[j + 16];
  c[16] = 0;
  add1305(h2, c);
  for (j = 0; j < 16; j++)
    out[outpos + j] = h2[j];
  return 0;
}
function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n, k) {
  const x2 = new Uint8Array(16);
  crypto_onetimeauth(x2, 0, m2, mpos, n, k);
  return vn(h2, hpos, x2, 0, 16);
}
function crypto_secretbox(c, m2, d, n, k) {
  if (d < 32)
    return -1;
  crypto_stream_xor(c, 0, m2, 0, d, n, k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (let i2 = 0; i2 < 16; i2++)
    c[i2] = 0;
  return 0;
}
function crypto_secretbox_open(m2, c, d, n, k) {
  const x2 = new Uint8Array(32);
  if (d < 32)
    return -1;
  crypto_stream_xor(x2, 0, null, 0, 32, n, k);
  if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x2) !== 0)
    return -1;
  crypto_stream_xor(m2, 0, c, 0, d, n, k);
  for (let i2 = 0; i2 < 32; i2++)
    m2[i2] = 0;
  return 0;
}
function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES)
    throw new Error("bad key size");
  if (n.length !== crypto_secretbox_NONCEBYTES)
    throw new Error("bad nonce size");
}
function checkArrayTypes(...args) {
  for (let i2 = 0, count = args.length; i2 < count; i2++) {
    if (!(args[i2] instanceof Uint8Array))
      throw new TypeError("unexpected type, use Uint8Array");
  }
}
function naclSecretbox(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  const m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  const c = new Uint8Array(m2.length);
  for (let i2 = 0; i2 < msg.length; i2++)
    m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
  crypto_secretbox(c, m2, m2.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
}
function naclSecretboxOpen(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  const c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  const m2 = new Uint8Array(c.length);
  for (let i2 = 0; i2 < box.length; i2++)
    c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
  if (c.length < 32)
    return null;
  if (crypto_secretbox_open(m2, c, c.length, nonce, key) !== 0)
    return null;
  return m2.subarray(crypto_secretbox_ZEROBYTES);
}
var sigma, minusp, crypto_secretbox_KEYBYTES, crypto_secretbox_NONCEBYTES, crypto_secretbox_ZEROBYTES, crypto_secretbox_BOXZEROBYTES;
var init_tweetnacl = __esm({
  "../../node_modules/@polkadot/util-crypto/nacl/tweetnacl.js"() {
    sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);
    crypto_secretbox_KEYBYTES = 32;
    crypto_secretbox_NONCEBYTES = 24;
    crypto_secretbox_ZEROBYTES = 32;
    crypto_secretbox_BOXZEROBYTES = 16;
  }
});

// ../../node_modules/@polkadot/util-crypto/nacl/decrypt.js
function naclDecrypt(encrypted, nonce, secret) {
  return naclSecretboxOpen(encrypted, nonce, secret);
}
var init_decrypt = __esm({
  "../../node_modules/@polkadot/util-crypto/nacl/decrypt.js"() {
    init_tweetnacl();
  }
});

// ../../node_modules/@polkadot/util-crypto/nacl/encrypt.js
function naclEncrypt(message, secret, nonce = randomAsU8a(24)) {
  return {
    encrypted: naclSecretbox(message, nonce, secret),
    nonce
  };
}
var init_encrypt = __esm({
  "../../node_modules/@polkadot/util-crypto/nacl/encrypt.js"() {
    init_asU8a2();
    init_tweetnacl();
  }
});

// ../../node_modules/@polkadot/util-crypto/nacl/index.js
var init_nacl = __esm({
  "../../node_modules/@polkadot/util-crypto/nacl/index.js"() {
    init_decrypt();
    init_encrypt();
  }
});

// ../../node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i2 = 0; i2 < 8; i2 += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r2) {
  let head = oi + 0;
  let tail = oi + 16 * r2;
  for (let i2 = 0; i2 < 16; i2++)
    out[tail + i2] = input[ii + (2 * r2 - 1) * 16 + i2];
  for (let i2 = 0; i2 < r2; i2++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i2 > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r: r2, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber2(N2);
  anumber2(r2);
  anumber2(p);
  anumber2(dkLen);
  anumber2(asyncTick);
  anumber2(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " + maxmem);
  }
  const B = pbkdf22(sha2563, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u322(B);
  const V = u322(new Uint8Array(blockSize * N2));
  const tmp = u322(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf22(sha2563, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt2(password, salt, opts) {
  const { N: N2, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  if (!isLE)
    byteSwap32(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i2 = 0; i2 < blockSize32; i2++)
      V[i2] = B32[Pi + i2];
    for (let i2 = 0, pos = 0; i2 < N2 - 1; i2++) {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi, r2);
    blockMixCb();
    for (let i2 = 0; i2 < N2; i2++) {
      const j = B32[Pi + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r2);
      blockMixCb();
    }
  }
  if (!isLE)
    byteSwap32(B32);
  return scryptOutput(password, dkLen, B, V, tmp);
}
var init_scrypt = __esm({
  "../../node_modules/@noble/hashes/esm/scrypt.js"() {
    init_assert2();
    init_sha2562();
    init_pbkdf2();
    init_utils();
  }
});

// ../../node_modules/@polkadot/util-crypto/scrypt/defaults.js
var DEFAULT_PARAMS;
var init_defaults3 = __esm({
  "../../node_modules/@polkadot/util-crypto/scrypt/defaults.js"() {
    DEFAULT_PARAMS = {
      N: 1 << 15,
      p: 1,
      r: 8
    };
  }
});

// ../../node_modules/@polkadot/util-crypto/scrypt/encode.js
function scryptEncode(passphrase, salt = randomAsU8a(), params = DEFAULT_PARAMS, onlyJs) {
  const u8a = u8aToU8a(passphrase);
  return {
    params,
    password: !hasBigInt || !onlyJs && isReady() ? scrypt(u8a, salt, Math.log2(params.N), params.r, params.p) : scrypt2(u8a, salt, objectSpread({ dkLen: 64 }, params)),
    salt
  };
}
var init_encode4 = __esm({
  "../../node_modules/@polkadot/util-crypto/scrypt/encode.js"() {
    init_scrypt();
    init_util();
    init_wasm_crypto();
    init_asU8a2();
    init_defaults3();
  }
});

// ../../node_modules/@polkadot/util-crypto/scrypt/fromU8a.js
function scryptFromU8a(data) {
  const salt = data.subarray(0, 32);
  const N2 = u8aToBn(data.subarray(32 + 0, 32 + 4), BN_LE_OPTS).toNumber();
  const p = u8aToBn(data.subarray(32 + 4, 32 + 8), BN_LE_OPTS).toNumber();
  const r2 = u8aToBn(data.subarray(32 + 8, 32 + 12), BN_LE_OPTS).toNumber();
  if (N2 !== DEFAULT_PARAMS.N || p !== DEFAULT_PARAMS.p || r2 !== DEFAULT_PARAMS.r) {
    throw new Error("Invalid injected scrypt params found");
  }
  return { params: { N: N2, p, r: r2 }, salt };
}
var init_fromU8a3 = __esm({
  "../../node_modules/@polkadot/util-crypto/scrypt/fromU8a.js"() {
    init_util();
    init_bn4();
    init_defaults3();
  }
});

// ../../node_modules/@polkadot/util-crypto/scrypt/toU8a.js
function scryptToU8a(salt, { N: N2, p, r: r2 }) {
  return u8aConcat(salt, bnToU8a(N2, BN_LE_32_OPTS), bnToU8a(p, BN_LE_32_OPTS), bnToU8a(r2, BN_LE_32_OPTS));
}
var init_toU8a9 = __esm({
  "../../node_modules/@polkadot/util-crypto/scrypt/toU8a.js"() {
    init_util();
    init_bn4();
  }
});

// ../../node_modules/@polkadot/util-crypto/scrypt/index.js
var init_scrypt2 = __esm({
  "../../node_modules/@polkadot/util-crypto/scrypt/index.js"() {
    init_encode4();
    init_fromU8a3();
    init_toU8a9();
  }
});

// ../../node_modules/@polkadot/util-crypto/json/constants.js
var ENCODING, ENCODING_NONE, ENCODING_VERSION, NONCE_LENGTH, SCRYPT_LENGTH;
var init_constants = __esm({
  "../../node_modules/@polkadot/util-crypto/json/constants.js"() {
    ENCODING = ["scrypt", "xsalsa20-poly1305"];
    ENCODING_NONE = ["none"];
    ENCODING_VERSION = "3";
    NONCE_LENGTH = 24;
    SCRYPT_LENGTH = 32 + 3 * 4;
  }
});

// ../../node_modules/@polkadot/util-crypto/json/decryptData.js
function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {
  if (!encrypted) {
    throw new Error("No encrypted data available to decode");
  } else if (encType.includes("xsalsa20-poly1305") && !passphrase) {
    throw new Error("Password required to decode encrypted data");
  }
  let encoded = encrypted;
  if (passphrase) {
    let password;
    if (encType.includes("scrypt")) {
      const { params, salt } = scryptFromU8a(encrypted);
      password = scryptEncode(passphrase, salt, params).password;
      encrypted = encrypted.subarray(SCRYPT_LENGTH);
    } else {
      password = stringToU8a(passphrase);
    }
    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));
  }
  if (!encoded) {
    throw new Error("Unable to decode using the supplied passphrase");
  }
  return encoded;
}
var init_decryptData = __esm({
  "../../node_modules/@polkadot/util-crypto/json/decryptData.js"() {
    init_util();
    init_nacl();
    init_scrypt2();
    init_constants();
  }
});

// ../../node_modules/@polkadot/util-crypto/json/encryptFormat.js
function jsonEncryptFormat(encoded, contentType, isEncrypted) {
  return {
    encoded: base64Encode(encoded),
    encoding: {
      content: contentType,
      type: isEncrypted ? ENCODING : ENCODING_NONE,
      version: ENCODING_VERSION
    }
  };
}
var init_encryptFormat = __esm({
  "../../node_modules/@polkadot/util-crypto/json/encryptFormat.js"() {
    init_base642();
    init_constants();
  }
});

// ../../node_modules/@polkadot/util-crypto/json/index.js
var init_json = __esm({
  "../../node_modules/@polkadot/util-crypto/json/index.js"() {
    init_decryptData();
    init_encryptFormat();
  }
});

// ../../node_modules/@polkadot/util-crypto/signature/verify.js
function verifyDetect(result, { message, publicKey, signature }, verifiers = VERIFIERS) {
  result.isValid = verifiers.some(([crypto3, verify]) => {
    try {
      if (verify(message, signature, publicKey)) {
        result.crypto = crypto3;
        return true;
      }
    } catch {
    }
    return false;
  });
  return result;
}
function verifyMultisig(result, { message, publicKey, signature }) {
  if (![0, 1, 2].includes(signature[0])) {
    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);
  }
  const type = CRYPTO_TYPES[signature[0]] || "none";
  result.crypto = type;
  try {
    result.isValid = {
      ecdsa: () => verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS_ECDSA).isValid,
      ed25519: () => ed25519Verify2(message, signature.subarray(1), publicKey),
      none: () => {
        throw Error("no verify for `none` crypto type");
      },
      sr25519: () => sr25519Verify2(message, signature.subarray(1), publicKey)
    }[type]();
  } catch {
  }
  return result;
}
function getVerifyFn(signature) {
  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;
}
function signatureVerify(message, signature, addressOrPublicKey) {
  const signatureU8a = u8aToU8a(signature);
  if (![64, 65, 66].includes(signatureU8a.length)) {
    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);
  }
  const publicKey = decodeAddress(addressOrPublicKey);
  const input = { message: u8aToU8a(message), publicKey, signature: signatureU8a };
  const result = { crypto: "none", isValid: false, isWrapped: u8aIsWrapped(input.message, true), publicKey };
  const isWrappedBytes = u8aIsWrapped(input.message, false);
  const verifyFn = getVerifyFn(signatureU8a);
  verifyFn(result, input);
  if (result.crypto !== "none" || result.isWrapped && !isWrappedBytes) {
    return result;
  }
  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);
  return verifyFn(result, input);
}
var secp256k1VerifyHasher, VERIFIERS_ECDSA, VERIFIERS, CRYPTO_TYPES;
var init_verify4 = __esm({
  "../../node_modules/@polkadot/util-crypto/signature/verify.js"() {
    init_util();
    init_decode();
    init_verify();
    init_verify3();
    init_verify2();
    secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);
    VERIFIERS_ECDSA = [
      ["ecdsa", secp256k1VerifyHasher("blake2")],
      ["ethereum", secp256k1VerifyHasher("keccak")]
    ];
    VERIFIERS = [
      ["ed25519", ed25519Verify2],
      ["sr25519", sr25519Verify2],
      ...VERIFIERS_ECDSA
    ];
    CRYPTO_TYPES = ["ed25519", "sr25519", "ecdsa"];
  }
});

// ../../node_modules/@polkadot/util-crypto/signature/index.js
var init_signature = __esm({
  "../../node_modules/@polkadot/util-crypto/signature/index.js"() {
    init_verify4();
  }
});

// ../../node_modules/@polkadot/util-crypto/xxhash/xxhash64.js
function rotl2(a, b) {
  const c = a & U64;
  return (c << b | c >> _64n - b) & U64;
}
function fromU8a(u8a, p, count) {
  const bigints = new Array(count);
  let offset = 0;
  for (let i2 = 0; i2 < count; i2++, offset += 2) {
    bigints[i2] = BigInt2(u8a[p + offset] | u8a[p + 1 + offset] << 8);
  }
  let result = _0n;
  for (let i2 = count - 1; i2 >= 0; i2--) {
    result = (result << _16n2) + bigints[i2];
  }
  return result;
}
function init(seed, input) {
  const state = {
    seed,
    u8a: new Uint8Array(32),
    u8asize: 0,
    v1: seed + P64_1 + P64_2,
    v2: seed + P64_2,
    v3: seed,
    v4: seed - P64_1
  };
  if (input.length < 32) {
    state.u8a.set(input);
    state.u8asize = input.length;
    return state;
  }
  const limit = input.length - 32;
  let p = 0;
  if (limit >= 0) {
    const adjustV = (v) => P64_1 * rotl2(v + P64_2 * fromU8a(input, p, 4), _31n);
    do {
      state.v1 = adjustV(state.v1);
      p += 8;
      state.v2 = adjustV(state.v2);
      p += 8;
      state.v3 = adjustV(state.v3);
      p += 8;
      state.v4 = adjustV(state.v4);
      p += 8;
    } while (p <= limit);
  }
  if (p < input.length) {
    state.u8a.set(input.subarray(p, input.length));
    state.u8asize = input.length - p;
  }
  return state;
}
function xxhash64(input, initSeed) {
  const { seed, u8a, u8asize, v1: v17, v2: v22, v3: v32, v4: v42 } = init(BigInt2(initSeed), input);
  let p = 0;
  let h64 = U64 & BigInt2(input.length) + (input.length >= 32 ? ((((rotl2(v17, _1n) + rotl2(v22, _7n2) + rotl2(v32, _12n) + rotl2(v42, _18n) ^ P64_1 * rotl2(v17 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl2(v22 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl2(v32 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl2(v42 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
  while (p <= u8asize - 8) {
    h64 = U64 & P64_4 + P64_1 * rotl2(h64 ^ P64_1 * rotl2(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);
    p += 8;
  }
  if (p + 4 <= u8asize) {
    h64 = U64 & P64_3 + P64_2 * rotl2(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);
    p += 4;
  }
  while (p < u8asize) {
    h64 = U64 & P64_1 * rotl2(h64 ^ P64_5 * BigInt2(u8a[p++]), _11n);
  }
  h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
  h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
  h64 = U64 & (h64 ^ h64 >> _32n3);
  const result = new Uint8Array(8);
  for (let i2 = 7; i2 >= 0; i2--) {
    result[i2] = Number(h64 % _256n2);
    h64 = h64 / _256n2;
  }
  return result;
}
var P64_1, P64_2, P64_3, P64_4, P64_5, U64, _7n2, _11n, _12n, _16n2, _18n, _23n, _27n, _29n, _31n, _32n3, _33n, _64n, _256n2;
var init_xxhash64 = __esm({
  "../../node_modules/@polkadot/util-crypto/xxhash/xxhash64.js"() {
    init_util();
    init_x_bigint();
    P64_1 = BigInt2("11400714785074694791");
    P64_2 = BigInt2("14029467366897019727");
    P64_3 = BigInt2("1609587929392839161");
    P64_4 = BigInt2("9650029242287828579");
    P64_5 = BigInt2("2870177450012600261");
    U64 = BigInt2("0xffffffffffffffff");
    _7n2 = BigInt2(7);
    _11n = BigInt2(11);
    _12n = BigInt2(12);
    _16n2 = BigInt2(16);
    _18n = BigInt2(18);
    _23n = BigInt2(23);
    _27n = BigInt2(27);
    _29n = BigInt2(29);
    _31n = BigInt2(31);
    _32n3 = BigInt2(32);
    _33n = BigInt2(33);
    _64n = BigInt2(64);
    _256n2 = BigInt2(256);
  }
});

// ../../node_modules/@polkadot/util-crypto/xxhash/asU8a.js
function xxhashAsU8a(data, bitLength = 64, onlyJs) {
  const rounds = Math.ceil(bitLength / 64);
  const u8a = u8aToU8a(data);
  if (!hasBigInt || !onlyJs && isReady()) {
    return twox(u8a, rounds);
  }
  const result = new Uint8Array(rounds * 8);
  for (let seed = 0; seed < rounds; seed++) {
    result.set(xxhash64(u8a, seed).reverse(), seed * 8);
  }
  return result;
}
var init_asU8a5 = __esm({
  "../../node_modules/@polkadot/util-crypto/xxhash/asU8a.js"() {
    init_util();
    init_wasm_crypto();
    init_xxhash64();
  }
});

// ../../node_modules/@polkadot/util-crypto/xxhash/index.js
var init_xxhash = __esm({
  "../../node_modules/@polkadot/util-crypto/xxhash/index.js"() {
    init_asU8a5();
  }
});

// ../../node_modules/@polkadot/util-crypto/bundle.js
var init_bundle6 = __esm({
  "../../node_modules/@polkadot/util-crypto/bundle.js"() {
    init_bundleInit();
    init_address();
    init_base32();
    init_base58();
    init_base642();
    init_blake2();
    init_crypto();
    init_ed255192();
    init_ethereum();
    init_hd();
    init_hmac3();
    init_json();
    init_keccak();
    init_key();
    init_mnemonic();
    init_nacl();
    init_networks2();
    init_pbkdf22();
    init_random();
    init_scrypt2();
    init_secp256k12();
    init_sha();
    init_signature();
    init_sr25519();
    init_xxhash();
  }
});

// ../../node_modules/@polkadot/util-crypto/index.js
var init_util_crypto = __esm({
  "../../node_modules/@polkadot/util-crypto/index.js"() {
    init_packageDetect4();
    init_bundle6();
  }
});

// ../../node_modules/@polkadot/keyring/pair/defaults.js
var PAIR_DIV, PAIR_HDR, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH;
var init_defaults4 = __esm({
  "../../node_modules/@polkadot/keyring/pair/defaults.js"() {
    PAIR_DIV = new Uint8Array([161, 35, 3, 33, 0]);
    PAIR_HDR = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);
    PUB_LENGTH = 32;
    SEC_LENGTH = 64;
    SEED_LENGTH = 32;
  }
});

// ../../node_modules/@polkadot/keyring/pair/decode.js
function decodePair(passphrase, encrypted, _encType) {
  const encType = Array.isArray(_encType) || _encType === void 0 ? _encType : [_encType];
  const decrypted = jsonDecryptData(encrypted, passphrase, encType);
  const header = decrypted.subarray(0, PAIR_HDR.length);
  if (!u8aEq(header, PAIR_HDR)) {
    throw new Error("Invalid encoding header found in body");
  }
  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);
  let divOffset = SEED_OFFSET + SEC_LENGTH;
  let divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);
  if (!u8aEq(divider, PAIR_DIV)) {
    divOffset = SEED_OFFSET + SEED_LENGTH;
    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);
    divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);
    if (!u8aEq(divider, PAIR_DIV)) {
      throw new Error("Invalid encoding divider found in body");
    }
  }
  const pubOffset = divOffset + PAIR_DIV.length;
  const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);
  return {
    publicKey,
    secretKey
  };
}
var SEED_OFFSET;
var init_decode2 = __esm({
  "../../node_modules/@polkadot/keyring/pair/decode.js"() {
    init_util();
    init_util_crypto();
    init_defaults4();
    SEED_OFFSET = PAIR_HDR.length;
  }
});

// ../../node_modules/@polkadot/keyring/pair/encode.js
function encodePair({ publicKey, secretKey }, passphrase) {
  if (!secretKey) {
    throw new Error("Expected a valid secretKey to be passed to encode");
  }
  const encoded = u8aConcat(PAIR_HDR, secretKey, PAIR_DIV, publicKey);
  if (!passphrase) {
    return encoded;
  }
  const { params, password, salt } = scryptEncode(passphrase);
  const { encrypted, nonce } = naclEncrypt(encoded, password.subarray(0, 32));
  return u8aConcat(scryptToU8a(salt, params), nonce, encrypted);
}
var init_encode5 = __esm({
  "../../node_modules/@polkadot/keyring/pair/encode.js"() {
    init_util();
    init_util_crypto();
    init_defaults4();
  }
});

// ../../node_modules/@polkadot/keyring/pair/toJson.js
function pairToJson(type, { address, meta }, encoded, isEncrypted) {
  return objectSpread(jsonEncryptFormat(encoded, ["pkcs8", type], isEncrypted), {
    address,
    meta
  });
}
var init_toJson = __esm({
  "../../node_modules/@polkadot/keyring/pair/toJson.js"() {
    init_util();
    init_util_crypto();
  }
});

// ../../node_modules/@polkadot/keyring/pair/index.js
function isLocked(secretKey) {
  return !secretKey || u8aEmpty(secretKey);
}
function vrfHash(proof, context, extra) {
  return blake2AsU8a(u8aConcat(context || "", extra || "", proof));
}
function createPair({ toSS58, type }, { publicKey, secretKey }, meta = {}, encoded = null, encTypes) {
  const decodePkcs8 = (passphrase, userEncoded) => {
    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);
    if (decoded.secretKey.length === 64) {
      publicKey = decoded.publicKey;
      secretKey = decoded.secretKey;
    } else {
      const pair = TYPE_FROM_SEED[type](decoded.secretKey);
      publicKey = pair.publicKey;
      secretKey = pair.secretKey;
    }
  };
  const recode = (passphrase) => {
    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);
    encoded = encodePair({ publicKey, secretKey }, passphrase);
    encTypes = void 0;
    return encoded;
  };
  const encodeAddress2 = () => {
    const raw = TYPE_ADDRESS[type](publicKey);
    return type === "ethereum" ? ethereumEncode(raw) : toSS58(raw);
  };
  return {
    get address() {
      return encodeAddress2();
    },
    get addressRaw() {
      const raw = TYPE_ADDRESS[type](publicKey);
      return type === "ethereum" ? raw.slice(-20) : raw;
    },
    get isLocked() {
      return isLocked(secretKey);
    },
    get meta() {
      return meta;
    },
    get publicKey() {
      return publicKey;
    },
    get type() {
      return type;
    },
    // eslint-disable-next-line sort-keys
    decodePkcs8,
    derive: (suri, meta2) => {
      if (type === "ethereum") {
        throw new Error("Unable to derive on this keypair");
      } else if (isLocked(secretKey)) {
        throw new Error("Cannot derive on a locked keypair");
      }
      const { path } = keyExtractPath(suri);
      const derived = keyFromPath({ publicKey, secretKey }, path, type);
      return createPair({ toSS58, type }, derived, meta2, null);
    },
    encodePkcs8: (passphrase) => {
      return recode(passphrase);
    },
    lock: () => {
      secretKey = new Uint8Array();
    },
    setMeta: (additional) => {
      meta = objectSpread({}, meta, additional);
    },
    sign: (message, options = {}) => {
      if (isLocked(secretKey)) {
        throw new Error("Cannot sign with a locked key pair");
      }
      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey }));
    },
    toJson: (passphrase) => {
      const address = ["ecdsa", "ethereum"].includes(type) ? publicKey.length === 20 ? u8aToHex(publicKey) : u8aToHex(secp256k1Compress2(publicKey)) : encodeAddress2();
      return pairToJson(type, { address, meta }, recode(passphrase), !!passphrase);
    },
    unlock: (passphrase) => {
      return decodePkcs8(passphrase);
    },
    verify: (message, signature, signerPublic) => {
      return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;
    },
    vrfSign: (message, context, extra) => {
      if (isLocked(secretKey)) {
        throw new Error("Cannot sign with a locked key pair");
      }
      if (type === "sr25519") {
        return sr25519VrfSign(message, { secretKey }, context, extra);
      }
      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey });
      return u8aConcat(vrfHash(proof, context, extra), proof);
    },
    vrfVerify: (message, vrfResult, signerPublic, context, extra) => {
      if (type === "sr25519") {
        return sr25519VrfVerify(message, vrfResult, publicKey, context, extra);
      }
      const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));
      return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));
    }
  };
}
var SIG_TYPE_NONE, TYPE_FROM_SEED, TYPE_PREFIX, TYPE_SIGNATURE, TYPE_ADDRESS;
var init_pair = __esm({
  "../../node_modules/@polkadot/keyring/pair/index.js"() {
    init_util();
    init_util_crypto();
    init_decode2();
    init_encode5();
    init_toJson();
    SIG_TYPE_NONE = new Uint8Array();
    TYPE_FROM_SEED = {
      ecdsa: secp256k1PairFromSeed,
      ed25519: ed25519PairFromSeed,
      ethereum: secp256k1PairFromSeed,
      sr25519: sr25519PairFromSeed
    };
    TYPE_PREFIX = {
      ecdsa: new Uint8Array([2]),
      ed25519: new Uint8Array([0]),
      ethereum: new Uint8Array([2]),
      sr25519: new Uint8Array([1])
    };
    TYPE_SIGNATURE = {
      ecdsa: (m2, p) => secp256k1Sign2(m2, p, "blake2"),
      ed25519: ed25519Sign2,
      ethereum: (m2, p) => secp256k1Sign2(m2, p, "keccak"),
      sr25519: sr25519Sign2
    };
    TYPE_ADDRESS = {
      ecdsa: (p) => p.length > 32 ? blake2AsU8a(p) : p,
      ed25519: (p) => p,
      ethereum: (p) => p.length === 20 ? p : keccakAsU8a(secp256k1Expand2(p)),
      sr25519: (p) => p
    };
  }
});

// ../../node_modules/@polkadot/keyring/defaults.js
var DEV_PHRASE;
var init_defaults5 = __esm({
  "../../node_modules/@polkadot/keyring/defaults.js"() {
    DEV_PHRASE = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";
  }
});

// ../../node_modules/@polkadot/keyring/pairs.js
var Pairs;
var init_pairs = __esm({
  "../../node_modules/@polkadot/keyring/pairs.js"() {
    init_util();
    init_util_crypto();
    Pairs = class {
      __internal__map = {};
      add(pair) {
        this.__internal__map[decodeAddress(pair.address).toString()] = pair;
        return pair;
      }
      all() {
        return Object.values(this.__internal__map);
      }
      get(address) {
        const pair = this.__internal__map[decodeAddress(address).toString()];
        if (!pair) {
          throw new Error(`Unable to retrieve keypair '${isU8a(address) || isHex(address) ? u8aToHex(u8aToU8a(address)) : address}'`);
        }
        return pair;
      }
      remove(address) {
        delete this.__internal__map[decodeAddress(address).toString()];
      }
    };
  }
});

// ../../node_modules/@polkadot/keyring/keyring.js
function pairToPublic({ publicKey }) {
  return publicKey;
}
var PairFromSeed, Keyring;
var init_keyring = __esm({
  "../../node_modules/@polkadot/keyring/keyring.js"() {
    init_util();
    init_util_crypto();
    init_pair();
    init_defaults5();
    init_pairs();
    PairFromSeed = {
      ecdsa: (seed) => secp256k1PairFromSeed(seed),
      ed25519: (seed) => ed25519PairFromSeed(seed),
      ethereum: (seed) => secp256k1PairFromSeed(seed),
      sr25519: (seed) => sr25519PairFromSeed(seed)
    };
    Keyring = class {
      __internal__pairs;
      __internal__type;
      __internal__ss58;
      decodeAddress = decodeAddress;
      constructor(options = {}) {
        options.type = options.type || "ed25519";
        if (!["ecdsa", "ethereum", "ed25519", "sr25519"].includes(options.type || "undefined")) {
          throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || "unknown"}`);
        }
        this.__internal__pairs = new Pairs();
        this.__internal__ss58 = options.ss58Format;
        this.__internal__type = options.type;
      }
      /**
       * @description retrieve the pairs (alias for getPairs)
       */
      get pairs() {
        return this.getPairs();
      }
      /**
       * @description retrieve the publicKeys (alias for getPublicKeys)
       */
      get publicKeys() {
        return this.getPublicKeys();
      }
      /**
       * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa
       */
      get type() {
        return this.__internal__type;
      }
      /**
       * @name addPair
       * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary
       */
      addPair(pair) {
        return this.__internal__pairs.add(pair);
      }
      /**
       * @name addFromAddress
       * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary
       * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally
       * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file
       * of an account backup), and then generates a keyring pair from them that it passes to
       * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
       */
      addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {
        const publicKey = this.decodeAddress(address, ignoreChecksum);
        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, { publicKey, secretKey: new Uint8Array() }, meta, encoded, encType));
      }
      /**
       * @name addFromJson
       * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
       * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file
       * of an account backup), and then generates a keyring pair from it that it passes to
       * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
       */
      addFromJson(json, ignoreChecksum) {
        return this.addPair(this.createFromJson(json, ignoreChecksum));
      }
      /**
       * @name addFromMnemonic
       * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary
       * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)
       * argument and a metadata argument that contains account information (that may be obtained from the json file
       * of an account backup), and then generates a keyring pair from it that it passes to
       * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
       */
      addFromMnemonic(mnemonic, meta = {}, type = this.type) {
        return this.addFromUri(mnemonic, meta, type);
      }
      /**
       * @name addFromPair
       * @summary Stores an account created from an explicit publicKey/secreteKey combination
       */
      addFromPair(pair, meta = {}, type = this.type) {
        return this.addPair(this.createFromPair(pair, meta, type));
      }
      /**
       * @name addFromSeed
       * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
       * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.
       * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to
       * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
       */
      addFromSeed(seed, meta = {}, type = this.type) {
        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, PairFromSeed[type](seed), meta, null));
      }
      /**
       * @name addFromUri
       * @summary Creates an account via an suri
       * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)
       */
      addFromUri(suri, meta = {}, type = this.type) {
        return this.addPair(this.createFromUri(suri, meta, type));
      }
      /**
       * @name createFromJson
       * @description Creates a pair from a JSON keyfile
       */
      createFromJson({ address, encoded, encoding: { content, type, version }, meta }, ignoreChecksum) {
        if (version === "3" && content[0] !== "pkcs8") {
          throw new Error(`Unable to decode non-pkcs8 type, [${content.join(",")}] found}`);
        }
        const cryptoType = version === "0" || !Array.isArray(content) ? this.type : content[1];
        const encType = !Array.isArray(type) ? [type] : type;
        if (!["ed25519", "sr25519", "ecdsa", "ethereum"].includes(cryptoType)) {
          throw new Error(`Unknown crypto type ${cryptoType}`);
        }
        const publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);
        const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode2(encoded);
        return createPair({ toSS58: this.encodeAddress, type: cryptoType }, { publicKey, secretKey: new Uint8Array() }, meta, decoded, encType);
      }
      /**
       * @name createFromPair
       * @summary Creates a pair from an explicit publicKey/secreteKey combination
       */
      createFromPair(pair, meta = {}, type = this.type) {
        return createPair({ toSS58: this.encodeAddress, type }, pair, meta, null);
      }
      /**
       * @name createFromUri
       * @summary Creates a Keypair from an suri
       * @description This creates a pair from the suri, but does not add it to the keyring
       */
      createFromUri(_suri, meta = {}, type = this.type) {
        const suri = _suri.startsWith("//") ? `${DEV_PHRASE}${_suri}` : _suri;
        const { derivePath, password, path, phrase } = keyExtractSuri(suri);
        let seed;
        const isPhraseHex = isHex(phrase, 256);
        if (isPhraseHex) {
          seed = hexToU8a(phrase);
        } else {
          const parts = phrase.split(" ");
          if ([12, 15, 18, 21, 24].includes(parts.length)) {
            seed = type === "ethereum" ? mnemonicToLegacySeed(phrase, "", false, 64) : mnemonicToMiniSecret(phrase, password);
          } else {
            if (phrase.length > 32) {
              throw new Error("specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes");
            }
            seed = stringToU8a(phrase.padEnd(32));
          }
        }
        const derived = type === "ethereum" ? isPhraseHex ? PairFromSeed[type](seed) : hdEthereum(seed, derivePath.substring(1)) : keyFromPath(PairFromSeed[type](seed), path, type);
        return createPair({ toSS58: this.encodeAddress, type }, derived, meta, null);
      }
      /**
       * @name encodeAddress
       * @description Encodes the input into an ss58 representation
       */
      encodeAddress = (address, ss58Format) => {
        return this.type === "ethereum" ? ethereumEncode(address) : encodeAddress(address, ss58Format ?? this.__internal__ss58);
      };
      /**
       * @name getPair
       * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address
       * @description Returns a keyring pair value from the keyring pair dictionary by performing
       * a key lookup using the provided account address or public key (after decoding it).
       */
      getPair(address) {
        return this.__internal__pairs.get(address);
      }
      /**
       * @name getPairs
       * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary
       * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.
       */
      getPairs() {
        return this.__internal__pairs.all();
      }
      /**
       * @name getPublicKeys
       * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary
       * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.
       */
      getPublicKeys() {
        return this.__internal__pairs.all().map(pairToPublic);
      }
      /**
       * @name removePair
       * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.
       */
      removePair(address) {
        this.__internal__pairs.remove(address);
      }
      /**
       * @name setSS58Format;
       * @description Sets the ss58 format for the keyring
       */
      setSS58Format(ss58) {
        this.__internal__ss58 = ss58;
      }
      /**
       * @name toJson
       * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account
       * @description Returns a JSON object containing the metadata associated with an account
       * when valid address or public key and when the account passphrase is provided if the account secret
       * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user
       * may backup their account to a JSON file that contains this information.
       */
      toJson(address, passphrase) {
        return this.__internal__pairs.get(address).toJson(passphrase);
      }
    };
  }
});

// ../../node_modules/@polkadot/keyring/bundle.js
var init_bundle7 = __esm({
  "../../node_modules/@polkadot/keyring/bundle.js"() {
    init_keyring();
    init_defaults5();
  }
});

// ../../node_modules/@polkadot/keyring/index.js
var init_keyring2 = __esm({
  "../../node_modules/@polkadot/keyring/index.js"() {
    init_packageDetect3();
    init_bundle7();
  }
});

// ../../node_modules/@polkadot/rpc-provider/packageDetect.js
var init_packageDetect9 = __esm({
  "../../node_modules/@polkadot/rpc-provider/packageDetect.js"() {
    init_packageInfo4();
    init_util();
    init_packageInfo3();
    detectPackage(packageInfo3, null, [packageInfo4]);
  }
});

// ../../node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base642 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default;
var init_dist = __esm({
  "../../node_modules/data-uri-to-buffer/dist/index.js"() {
    dist_default = dataUriToBuffer;
  }
});

// ../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      function noop3() {
        return void 0;
      }
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop3;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true
          });
        } catch (_a2) {
        }
      }
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise((resolve) => resolve(value));
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let _queueMicrotask = (callback) => {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          const resolvedPromise = promiseResolvedWith(void 0);
          _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      const AbortSteps = Symbol("[[AbortSteps]]");
      const ErrorSteps = Symbol("[[ErrorSteps]]");
      const CancelSteps = Symbol("[[CancelSteps]]");
      const PullSteps = Symbol("[[PullSteps]]");
      const ReleaseSteps = Symbol("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x2, context) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject2(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context) {
        if (!isObject2(x2)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamDefaultReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e2) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        });
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a2) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      var _a, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = (buffer) => buffer.transfer();
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = (buffer) => structuredClone(buffer, { transfer: [buffer] });
        } else {
          TransferArrayBuffer = (buffer) => buffer;
        }
        return TransferArrayBuffer(O);
      };
      let IsDetachedBuffer = (O) => {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = (buffer) => buffer.detached;
        } else {
          IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        const syncIterable = {
          [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        const asyncIterator = async function* () {
          return yield* syncIterable;
        }();
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint = "sync", method) {
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              const syncMethod = GetMethod(obj, Symbol.iterator);
              const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, Symbol.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer)) {
            throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
          }
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer)) {
            throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
          }
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              minimumFill: 1,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
          if (this._pendingPullIntos.length > 0) {
            const firstPullInto = this._pendingPullIntos.peek();
            firstPullInto.readerType = "none";
            this._pendingPullIntos = new SimpleQueue();
            this._pendingPullIntos.push(firstPullInto);
          }
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        let clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
          buffer = TransferArrayBuffer(view.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a2;
        assertDictionary(options, context);
        const min = (_a2 = options === null || options === void 0 ? void 0 : options.min) !== null && _a2 !== void 0 ? _a2 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
        };
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer)) {
            return promiseRejectedWith(new TypeError("view's buffer has been detached"));
          }
          let options;
          try {
            options = convertByobReadOptions(rawOptions, "options");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const min = options.min;
          if (min === 0) {
            return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
          }
          if (!isDataView(view)) {
            if (min > view.length) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
            }
          } else if (min > view.byteLength) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamBYOBReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        });
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init2, context) {
        assertDictionary(init2, context);
        const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
        const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a2) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a2;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort(reason);
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
          const closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
          const writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        } else {
          writeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        } else {
          closeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        } else {
          abortAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
          return null;
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException2 = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = signal.reason !== void 0 ? signal.reason : new DOMException2("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              return null;
            }
          }
          function shutdown(isError2, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError2, error));
            } else {
              finalize(isError2, error);
            }
          }
          function finalize(isError2, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError2) {
              reject(error);
            } else {
              resolve(void 0);
            }
            return null;
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
        /** @internal */
        [ReleaseSteps]() {
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, "async");
        const startAlgorithm = noop3;
        function pullAlgorithm() {
          let nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            const done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          const iterator = iteratorRecord.iterator;
          let returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          let returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop3;
        function pullAlgorithm() {
          let readPromise;
          try {
            readPromise = reader.read();
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return transformPromiseWith(readPromise, (readResult) => {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
          return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
          return ReadableStreamFrom(asyncIterable);
        }
      }
      Object.defineProperties(ReadableStream2, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream2.from, "from");
      setFunctionName(ReadableStream2.prototype.cancel, "cancel");
      setFunctionName(ReadableStream2.prototype.getReader, "getReader");
      setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream2.prototype.tee, "tee");
      setFunctionName(ReadableStream2.prototype.values, "values");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          const readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop3);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          const readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init2, context) {
        assertDictionary(init2, context);
        const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        } else {
          transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        } else {
          flushAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = (reason) => transformer.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const writable = stream._writable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r2);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    });
  }
});

// ../../node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "../../node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error) {
          process2.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob4 } = require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// ../../node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob3, fetch_blob_default;
var init_fetch_blob = __esm({
  "../../node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null) options = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder2.encode(`${element}`);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        const decoder2 = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder2.decode(part, { stream: true });
        }
        str += decoder2.decode();
        return str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    fetch_blob_default = Blob3;
  }
});

// ../../node_modules/fetch-blob/file.js
var _File, File2, file_default;
var init_file = __esm({
  "../../node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = class File extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null) options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File2 = _File;
    file_default = File2;
  }
});

// ../../node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, FormData;
var init_esm_min = __esm({
  "../../node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l15 = b.length, c = 0; c < l15; c++) if (b[c][0] === a) return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this) a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this) yield a;
      }
      *values() {
        for (var [, a] of this) yield a;
      }
    };
  }
});

// ../../node_modules/node-fetch/src/errors/base.js
var FetchBaseError;
var init_base = __esm({
  "../../node_modules/node-fetch/src/errors/base.js"() {
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  }
});

// ../../node_modules/node-fetch/src/errors/fetch-error.js
var FetchError;
var init_fetch_error = __esm({
  "../../node_modules/node-fetch/src/errors/fetch-error.js"() {
    init_base();
    FetchError = class extends FetchBaseError {
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} [type] -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
  }
});

// ../../node_modules/node-fetch/src/utils/is.js
var NAME, isURLSearchParameters, isBlob, isAbortSignal, isDomainOrSubdomain, isSameProtocol;
var init_is2 = __esm({
  "../../node_modules/node-fetch/src/utils/is.js"() {
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    isDomainOrSubdomain = (destination, original) => {
      const orig = new URL(original).hostname;
      const dest = new URL(destination).hostname;
      return orig === dest || orig.endsWith(`.${dest}`);
    };
    isSameProtocol = (destination, original) => {
      const orig = new URL(original).protocol;
      const dest = new URL(destination).protocol;
      return orig === dest;
    };
  }
});

// ../../node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "../../node_modules/node-domexception/index.js"(exports2, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// ../../node_modules/fetch-blob/from.js
var import_node_fs, import_node_path, import_node_domexception, stat, blobFromSync, blobFrom, fileFrom, fileFromSync, fromBlob, fromFile, BlobDataItem;
var init_from = __esm({
  "../../node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs");
    import_node_path = require("node:path");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs.promises);
    blobFromSync = (path, type) => fromBlob((0, import_node_fs.statSync)(path), path, type);
    blobFrom = (path, type) => stat(path).then((stat2) => fromBlob(stat2, path, type));
    fileFrom = (path, type) => stat(path).then((stat2) => fromFile(stat2, path, type));
    fileFromSync = (path, type) => fromFile((0, import_node_fs.statSync)(path), path, type);
    fromBlob = (stat2, path, type = "") => new fetch_blob_default([new BlobDataItem({
      path,
      size: stat2.size,
      lastModified: stat2.mtimeMs,
      start: 0
    })], { type });
    fromFile = (stat2, path, type = "") => new file_default([new BlobDataItem({
      path,
      size: stat2.size,
      lastModified: stat2.mtimeMs,
      start: 0
    })], (0, import_node_path.basename)(path), { type, lastModified: stat2.mtimeMs });
    BlobDataItem = class _BlobDataItem {
      #path;
      #start;
      constructor(options) {
        this.#path = options.path;
        this.#start = options.start;
        this.size = options.size;
        this.lastModified = options.lastModified;
      }
      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new _BlobDataItem({
          path: this.#path,
          lastModified: this.lastModified,
          size: end - start,
          start: this.#start + start
        });
      }
      async *stream() {
        const { mtimeMs } = await stat(this.#path);
        if (mtimeMs > this.lastModified) {
          throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        }
        yield* (0, import_node_fs.createReadStream)(this.#path, {
          start: this.#start,
          end: this.#start + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
  }
});

// ../../node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder2.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder2 = new TextDecoder("utf-8");
  decoder2.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder2.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder2.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder2.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop2, MultipartParser;
var init_multipart_parser = __esm({
  "../../node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop2 = () => {
    };
    MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop2;
        this.onHeaderField = noop2;
        this.onHeadersEnd = noop2;
        this.onHeaderValue = noop2;
        this.onPartBegin = noop2;
        this.onPartData = noop2;
        this.onPartEnd = noop2;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags: flags2 } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags2 |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags2 & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags2 = 0;
                } else if (!(flags2 & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            // falls through
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            // falls through
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            // falls through
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags2 |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags2 |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags2 & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags2 &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags2 & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags2 = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags2;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// ../../node_modules/node-fetch/src/body.js
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return import_node_buffer.Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return import_node_buffer.Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return import_node_buffer.Buffer.from(accum.join(""));
      }
      return import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var import_node_stream, import_node_util3, import_node_buffer, pipeline, INTERNALS, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream;
var init_body = __esm({
  "../../node_modules/node-fetch/src/body.js"() {
    import_node_stream = __toESM(require("node:stream"), 1);
    import_node_util3 = require("node:util");
    import_node_buffer = require("node:buffer");
    init_fetch_blob();
    init_esm_min();
    init_fetch_error();
    init_base();
    init_is2();
    pipeline = (0, import_node_util3.promisify)(import_node_stream.default.pipeline);
    INTERNALS = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = import_node_buffer.Buffer.from(body.toString());
        } else if (isBlob(body)) {
        } else if (import_node_buffer.Buffer.isBuffer(body)) {
        } else if (import_node_util3.types.isAnyArrayBuffer(body)) {
          body = import_node_buffer.Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream.default) {
        } else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = import_node_buffer.Buffer.from(String(body));
        }
        let stream = body;
        if (import_node_buffer.Buffer.isBuffer(body)) {
          stream = import_node_stream.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream.default.Readable.from(body.stream());
        }
        this[INTERNALS] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream.default) {
          body.on("error", (error_) => {
            const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS].error = error;
          });
        }
      }
      get body() {
        return this[INTERNALS].stream;
      }
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
        const buf = await this.arrayBuffer();
        return new fetch_blob_default([buf], {
          type: ct
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      async json() {
        const text = await this.text();
        return JSON.parse(text);
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      async text() {
        const buffer = await consumeBody(this);
        return new TextDecoder().decode(buffer);
      }
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util3.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true },
      data: { get: (0, import_node_util3.deprecate)(
        () => {
        },
        "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
        "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
      ) }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream.PassThrough({ highWaterMark });
        p2 = new import_node_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util3.deprecate)(
      (body) => body.getBoundary(),
      "form-data doesn't follow the spec and requires special treatment. Use alternative package",
      "https://github.com/node-fetch/node-fetch/issues/1167"
    );
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (import_node_buffer.Buffer.isBuffer(body) || import_node_util3.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (import_node_buffer.Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = async (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        await pipeline(body, dest);
      }
    };
  }
});

// ../../node_modules/node-fetch/src/headers.js
function fromRawHeaders(headers = []) {
  return new Headers(
    headers.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch {
        return false;
      }
    })
  );
}
var import_node_util4, import_node_http, validateHeaderName, validateHeaderValue, Headers;
var init_headers = __esm({
  "../../node_modules/node-fetch/src/headers.js"() {
    import_node_util4 = require("node:util");
    import_node_http = __toESM(require("node:http"), 1);
    validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error;
      }
    };
    validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
        throw error;
      }
    };
    Headers = class _Headers extends URLSearchParams {
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init2) {
        let result = [];
        if (init2 instanceof _Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null) {
        } else if (typeof init2 === "object" && !import_node_util4.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_node_util4.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(
                    target,
                    String(name).toLowerCase(),
                    String(value)
                  );
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(
                    target,
                    String(name).toLowerCase()
                  );
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      /**
       * @type {() => IterableIterator<[string, string]>}
       */
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(
      Headers.prototype,
      ["get", "entries", "forEach", "values"].reduce((result, property) => {
        result[property] = { enumerable: true };
        return result;
      }, {})
    );
  }
});

// ../../node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus, isRedirect;
var init_is_redirect = __esm({
  "../../node_modules/node-fetch/src/utils/is-redirect.js"() {
    redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
  }
});

// ../../node_modules/node-fetch/src/response.js
var INTERNALS2, Response;
var init_response = __esm({
  "../../node_modules/node-fetch/src/response.js"() {
    init_headers();
    init_body();
    init_is_redirect();
    INTERNALS2 = Symbol("Response internals");
    Response = class _Response extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS2] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS2].type;
      }
      get url() {
        return this[INTERNALS2].url || "";
      }
      get status() {
        return this[INTERNALS2].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
      }
      get redirected() {
        return this[INTERNALS2].counter > 0;
      }
      get statusText() {
        return this[INTERNALS2].statusText;
      }
      get headers() {
        return this[INTERNALS2].headers;
      }
      get highWaterMark() {
        return this[INTERNALS2].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new _Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new _Response(null, { status: 0, statusText: "" });
        response[INTERNALS2].type = "error";
        return response;
      }
      static json(data = void 0, init2 = {}) {
        const body = JSON.stringify(data);
        if (body === void 0) {
          throw new TypeError("data is not JSON serializable");
        }
        const headers = new Headers(init2 && init2.headers);
        if (!headers.has("content-type")) {
          headers.set("content-type", "application/json");
        }
        return new _Response(body, {
          ...init2,
          headers
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
  }
});

// ../../node_modules/node-fetch/src/utils/get-search.js
var getSearch;
var init_get_search = __esm({
  "../../node_modules/node-fetch/src/utils/get-search.js"() {
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    };
  }
});

// ../../node_modules/node-fetch/src/utils/referrer.js
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
var import_node_net, ReferrerPolicy, DEFAULT_REFERRER_POLICY;
var init_referrer = __esm({
  "../../node_modules/node-fetch/src/utils/referrer.js"() {
    import_node_net = require("node:net");
    ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
  }
});

// ../../node_modules/node-fetch/src/request.js
var import_node_url, import_node_util5, INTERNALS3, isRequest, doBadDataWarn, Request, getNodeRequestOptions;
var init_request = __esm({
  "../../node_modules/node-fetch/src/request.js"() {
    import_node_url = require("node:url");
    import_node_util5 = require("node:util");
    init_headers();
    init_body();
    init_is2();
    init_get_search();
    init_referrer();
    INTERNALS3 = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS3] === "object";
    };
    doBadDataWarn = (0, import_node_util5.deprecate)(
      () => {
      },
      ".data is not a valid RequestInit property, use .body instead",
      "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
    );
    Request = class _Request extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
        }
        let method = init2.method || input.method || "GET";
        if (/^(delete|get|head|options|post|put)$/i.test(method)) {
          method = method.toUpperCase();
        }
        if (!isRequest(init2) && "data" in init2) {
          doBadDataWarn();
        }
        if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS3] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      /** @returns {string} */
      get method() {
        return this[INTERNALS3].method;
      }
      /** @returns {string} */
      get url() {
        return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
      }
      /** @returns {Headers} */
      get headers() {
        return this[INTERNALS3].headers;
      }
      get redirect() {
        return this[INTERNALS3].redirect;
      }
      /** @returns {AbortSignal} */
      get signal() {
        return this[INTERNALS3].signal;
      }
      // https://fetch.spec.whatwg.org/#dom-request-referrer
      get referrer() {
        if (this[INTERNALS3].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS3].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS3].referrer) {
          return this[INTERNALS3].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS3].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS3];
      const headers = new Headers(request[INTERNALS3].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS3].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS3].referrer = "no-referrer";
      }
      if (request[INTERNALS3].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip, deflate, br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      const search = getSearch(parsedURL);
      const options = {
        // Overwrite search to retain trailing ? (issue #776)
        path: parsedURL.pathname + search,
        // The following options are not expressed in the URL
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        /** @type {URL} */
        parsedURL,
        options
      };
    };
  }
});

// ../../node_modules/node-fetch/src/errors/abort-error.js
var AbortError;
var init_abort_error = __esm({
  "../../node_modules/node-fetch/src/errors/abort-error.js"() {
    init_base();
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
  }
});

// ../../node_modules/node-fetch/src/index.js
var src_exports = {};
__export(src_exports, {
  AbortError: () => AbortError,
  Blob: () => fetch_blob_default,
  FetchError: () => FetchError,
  File: () => file_default,
  FormData: () => FormData,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  blobFrom: () => blobFrom,
  blobFromSync: () => blobFromSync,
  default: () => fetch,
  fileFrom: () => fileFrom,
  fileFromSync: () => fileFromSync,
  isRedirect: () => isRedirect
});
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location2 === null ? null : new URL(location2, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response(body, responseOptions);
          resolve(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response(body, responseOptions);
            resolve(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer2.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}
var import_node_http2, import_node_https, import_node_zlib, import_node_stream2, import_node_buffer2, supportedSchemas;
var init_src = __esm({
  "../../node_modules/node-fetch/src/index.js"() {
    import_node_http2 = __toESM(require("node:http"), 1);
    import_node_https = __toESM(require("node:https"), 1);
    import_node_zlib = __toESM(require("node:zlib"), 1);
    import_node_stream2 = __toESM(require("node:stream"), 1);
    import_node_buffer2 = require("node:buffer");
    init_dist();
    init_body();
    init_response();
    init_headers();
    init_request();
    init_fetch_error();
    init_abort_error();
    init_is_redirect();
    init_esm_min();
    init_is2();
    init_referrer();
    init_from();
    supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
  }
});

// ../../node_modules/@polkadot/x-fetch/node.js
async function nodeFetch(...args) {
  if (!modFn) {
    const mod2 = await importFetch;
    if (!mod2?.default) {
      throw new Error("Unable to import node-fetch in this environment");
    }
    modFn = mod2.default;
  }
  return modFn(...args);
}
var importFetch, modFn, fetch2;
var init_node4 = __esm({
  "../../node_modules/@polkadot/x-fetch/node.js"() {
    init_x_global();
    importFetch = Promise.resolve().then(() => (init_src(), src_exports)).catch(() => null);
    modFn = null;
    fetch2 = /* @__PURE__ */ extractGlobal("fetch", nodeFetch);
  }
});

// ../../node_modules/@polkadot/rpc-provider/coder/error.js
function extend(that, name, value) {
  Object.defineProperty(that, name, {
    configurable: true,
    enumerable: false,
    value
  });
}
var UNKNOWN, RpcError;
var init_error2 = __esm({
  "../../node_modules/@polkadot/rpc-provider/coder/error.js"() {
    init_util();
    UNKNOWN = -99999;
    RpcError = class extends Error {
      code;
      data;
      message;
      name;
      stack;
      constructor(message = "", code = UNKNOWN, data) {
        super();
        extend(this, "message", String(message));
        extend(this, "name", this.constructor.name);
        extend(this, "data", data);
        extend(this, "code", code);
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          const { stack } = new Error(message);
          stack && extend(this, "stack", stack);
        }
      }
      static CODES = {
        ASSERT: -90009,
        INVALID_JSONRPC: -99998,
        METHOD_NOT_FOUND: -32601,
        // Rust client
        UNKNOWN
      };
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/coder/index.js
function formatErrorData(data) {
  if (isUndefined(data)) {
    return "";
  }
  const formatted = `: ${isString(data) ? data.replace(/Error\("/g, "").replace(/\("/g, "(").replace(/"\)/g, ")").replace(/\(/g, ", ").replace(/\)/g, "") : stringify(data)}`;
  return formatted.length <= 256 ? formatted : `${formatted.substring(0, 255)}\u2026`;
}
function checkError(error) {
  if (error) {
    const { code, data, message } = error;
    throw new RpcError(`${code}: ${message}${formatErrorData(data)}`, code, data);
  }
}
var RpcCoder;
var init_coder = __esm({
  "../../node_modules/@polkadot/rpc-provider/coder/index.js"() {
    init_util();
    init_error2();
    RpcCoder = class {
      __internal__id = 0;
      decodeResponse(response) {
        if (!response || response.jsonrpc !== "2.0") {
          throw new Error("Invalid jsonrpc field in decoded object");
        }
        const isSubscription = !isUndefined(response.params) && !isUndefined(response.method);
        if (!isNumber(response.id) && (!isSubscription || !isNumber(response.params.subscription) && !isString(response.params.subscription))) {
          throw new Error("Invalid id field in decoded object");
        }
        checkError(response.error);
        if (response.result === void 0 && !isSubscription) {
          throw new Error("No result found in jsonrpc response");
        }
        if (isSubscription) {
          checkError(response.params.error);
          return response.params.result;
        }
        return response.result;
      }
      encodeJson(method, params) {
        const [id, data] = this.encodeObject(method, params);
        return [id, stringify(data)];
      }
      encodeObject(method, params) {
        const id = ++this.__internal__id;
        return [id, {
          id,
          jsonrpc: "2.0",
          method,
          params
        }];
      }
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/defaults.js
var HTTP_URL, WS_URL, defaults_default;
var init_defaults6 = __esm({
  "../../node_modules/@polkadot/rpc-provider/defaults.js"() {
    HTTP_URL = "http://127.0.0.1:9933";
    WS_URL = "ws://127.0.0.1:9944";
    defaults_default = {
      HTTP_URL,
      WS_URL
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/lru.js
var DEFAULT_CAPACITY, LRUNode, LRUCache;
var init_lru = __esm({
  "../../node_modules/@polkadot/rpc-provider/lru.js"() {
    DEFAULT_CAPACITY = 1024;
    LRUNode = class {
      key;
      __internal__expires;
      __internal__ttl;
      createdAt;
      next;
      prev;
      constructor(key, ttl) {
        this.key = key;
        this.__internal__ttl = ttl;
        this.__internal__expires = Date.now() + ttl;
        this.createdAt = Date.now();
        this.next = this.prev = this;
      }
      refresh() {
        this.__internal__expires = Date.now() + this.__internal__ttl;
      }
      get expiry() {
        return this.__internal__expires;
      }
    };
    LRUCache = class {
      capacity;
      __internal__data = /* @__PURE__ */ new Map();
      __internal__refs = /* @__PURE__ */ new Map();
      __internal__length = 0;
      __internal__head;
      __internal__tail;
      __internal__ttl;
      constructor(capacity = DEFAULT_CAPACITY, ttl = 3e4) {
        this.capacity = capacity;
        this.__internal__ttl = ttl;
        this.__internal__head = this.__internal__tail = new LRUNode("<empty>", ttl);
      }
      get ttl() {
        return this.__internal__ttl;
      }
      get length() {
        return this.__internal__length;
      }
      get lengthData() {
        return this.__internal__data.size;
      }
      get lengthRefs() {
        return this.__internal__refs.size;
      }
      entries() {
        const keys2 = this.keys();
        const count = keys2.length;
        const entries = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          const key = keys2[i2];
          entries[i2] = [key, this.__internal__data.get(key)];
        }
        return entries;
      }
      keys() {
        const keys2 = [];
        if (this.__internal__length) {
          let curr = this.__internal__head;
          while (curr !== this.__internal__tail) {
            keys2.push(curr.key);
            curr = curr.next;
          }
          keys2.push(curr.key);
        }
        return keys2;
      }
      get(key) {
        const data = this.__internal__data.get(key);
        if (data) {
          this.__internal__toHead(key);
          this.__internal__evictTTL();
          return data;
        }
        this.__internal__evictTTL();
        return null;
      }
      set(key, value) {
        if (this.__internal__data.has(key)) {
          this.__internal__toHead(key);
        } else {
          const node = new LRUNode(key, this.__internal__ttl);
          this.__internal__refs.set(node.key, node);
          if (this.length === 0) {
            this.__internal__head = this.__internal__tail = node;
          } else {
            this.__internal__head.prev = node;
            node.next = this.__internal__head;
            this.__internal__head = node;
          }
          if (this.__internal__length === this.capacity) {
            this.__internal__data.delete(this.__internal__tail.key);
            this.__internal__refs.delete(this.__internal__tail.key);
            this.__internal__tail = this.__internal__tail.prev;
            this.__internal__tail.next = this.__internal__head;
          } else {
            this.__internal__length += 1;
          }
        }
        this.__internal__evictTTL();
        this.__internal__data.set(key, value);
      }
      __internal__evictTTL() {
        while (this.__internal__tail.expiry && this.__internal__tail.expiry < Date.now() && this.__internal__length > 0) {
          this.__internal__refs.delete(this.__internal__tail.key);
          this.__internal__data.delete(this.__internal__tail.key);
          this.__internal__length -= 1;
          this.__internal__tail = this.__internal__tail.prev;
          this.__internal__tail.next = this.__internal__head;
        }
        if (this.__internal__length === 0) {
          this.__internal__head = this.__internal__tail = new LRUNode("<empty>", this.__internal__ttl);
        }
      }
      __internal__toHead(key) {
        const ref = this.__internal__refs.get(key);
        if (ref && ref !== this.__internal__head) {
          ref.refresh();
          ref.prev.next = ref.next;
          ref.next.prev = ref.prev;
          ref.next = this.__internal__head;
          this.__internal__head.prev = ref;
          this.__internal__head = ref;
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/http/index.js
var ERROR_SUBSCRIBE, l, HttpProvider;
var init_http = __esm({
  "../../node_modules/@polkadot/rpc-provider/http/index.js"() {
    init_util();
    init_node4();
    init_coder();
    init_defaults6();
    init_lru();
    ERROR_SUBSCRIBE = "HTTP Provider does not have subscriptions, use WebSockets instead";
    l = logger("api-http");
    HttpProvider = class _HttpProvider {
      __internal__callCache;
      __internal__cacheCapacity;
      __internal__coder;
      __internal__endpoint;
      __internal__headers;
      __internal__stats;
      /**
       * @param {string} endpoint The endpoint url starting with http://
       */
      constructor(endpoint = defaults_default.HTTP_URL, headers = {}, cacheCapacity) {
        if (!/^(https|http):\/\//.test(endpoint)) {
          throw new Error(`Endpoint should start with 'http://' or 'https://', received '${endpoint}'`);
        }
        this.__internal__coder = new RpcCoder();
        this.__internal__endpoint = endpoint;
        this.__internal__headers = headers;
        this.__internal__callCache = new LRUCache(cacheCapacity === 0 ? 0 : cacheCapacity || DEFAULT_CAPACITY);
        this.__internal__cacheCapacity = cacheCapacity === 0 ? 0 : cacheCapacity || DEFAULT_CAPACITY;
        this.__internal__stats = {
          active: { requests: 0, subscriptions: 0 },
          total: { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 }
        };
      }
      /**
       * @summary `true` when this provider supports subscriptions
       */
      get hasSubscriptions() {
        return false;
      }
      /**
       * @description Returns a clone of the object
       */
      clone() {
        return new _HttpProvider(this.__internal__endpoint, this.__internal__headers);
      }
      /**
       * @description Manually connect from the connection
       */
      async connect() {
      }
      /**
       * @description Manually disconnect from the connection
       */
      async disconnect() {
      }
      /**
       * @description Returns the connection stats
       */
      get stats() {
        return this.__internal__stats;
      }
      /**
       * @summary `true` when this provider supports clone()
       */
      get isClonable() {
        return true;
      }
      /**
       * @summary Whether the node is connected or not.
       * @return {boolean} true if connected
       */
      get isConnected() {
        return true;
      }
      /**
       * @summary Events are not supported with the HttpProvider, see [[WsProvider]].
       * @description HTTP Provider does not have 'on' emitters. WebSockets should be used instead.
       */
      on(_type, _sub) {
        l.error("HTTP Provider does not have 'on' emitters, use WebSockets instead");
        return noop;
      }
      /**
       * @summary Send HTTP POST Request with Body to configured HTTP Endpoint.
       */
      async send(method, params, isCacheable) {
        this.__internal__stats.total.requests++;
        const [, body] = this.__internal__coder.encodeJson(method, params);
        if (this.__internal__cacheCapacity === 0) {
          return this.__internal__send(body);
        }
        const cacheKey = isCacheable ? `${method}::${stringify(params)}` : "";
        let resultPromise = isCacheable ? this.__internal__callCache.get(cacheKey) : null;
        if (!resultPromise) {
          resultPromise = this.__internal__send(body);
          if (isCacheable) {
            this.__internal__callCache.set(cacheKey, resultPromise);
          }
        } else {
          this.__internal__stats.total.cached++;
        }
        return resultPromise;
      }
      async __internal__send(body) {
        this.__internal__stats.active.requests++;
        this.__internal__stats.total.bytesSent += body.length;
        try {
          const response = await fetch2(this.__internal__endpoint, {
            body,
            headers: {
              Accept: "application/json",
              "Content-Length": `${body.length}`,
              "Content-Type": "application/json",
              ...this.__internal__headers
            },
            method: "POST"
          });
          if (!response.ok) {
            throw new Error(`[${response.status}]: ${response.statusText}`);
          }
          const result = await response.text();
          this.__internal__stats.total.bytesRecv += result.length;
          const decoded = this.__internal__coder.decodeResponse(JSON.parse(result));
          this.__internal__stats.active.requests--;
          return decoded;
        } catch (e2) {
          this.__internal__stats.active.requests--;
          this.__internal__stats.total.errors++;
          throw e2;
        }
      }
      /**
       * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].
       */
      // eslint-disable-next-line @typescript-eslint/require-await
      async subscribe(_types, _method, _params, _cb) {
        l.error(ERROR_SUBSCRIBE);
        throw new Error(ERROR_SUBSCRIBE);
      }
      /**
       * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].
       */
      // eslint-disable-next-line @typescript-eslint/require-await
      async unsubscribe(_type, _method, _id) {
        l.error(ERROR_SUBSCRIBE);
        throw new Error(ERROR_SUBSCRIBE);
      }
    };
  }
});

// ../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events2() {
    }
    if (Object.create) {
      Events2.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events2().__proto__) prefix2 = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events2();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l15 = handlers.length, ee = new Array(l15); i2 < l15; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events2 = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events2.push(listeners[i2]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// ../../node_modules/eventemitter3/index.mjs
var import_index3;
var init_eventemitter3 = __esm({
  "../../node_modules/eventemitter3/index.mjs"() {
    import_index3 = __toESM(require_eventemitter3(), 1);
  }
});

// ../../node_modules/@polkadot/rpc-provider/substrate-connect/Health.js
function healthChecker() {
  let checker = null;
  let sendJsonRpc = null;
  return {
    responsePassThrough: (jsonRpcResponse) => {
      if (checker === null) {
        return jsonRpcResponse;
      }
      return checker.responsePassThrough(jsonRpcResponse);
    },
    sendJsonRpc: (request) => {
      if (!sendJsonRpc) {
        throw new Error("setSendJsonRpc must be called before sending requests");
      }
      if (checker === null) {
        sendJsonRpc(request);
      } else {
        checker.sendJsonRpc(request);
      }
    },
    setSendJsonRpc: (cb) => {
      sendJsonRpc = cb;
    },
    start: (healthCallback) => {
      if (checker !== null) {
        throw new Error("Can't start the health checker multiple times in parallel");
      } else if (!sendJsonRpc) {
        throw new Error("setSendJsonRpc must be called before starting the health checks");
      }
      checker = new InnerChecker(healthCallback, sendJsonRpc);
      checker.update(true);
    },
    stop: () => {
      if (checker === null) {
        return;
      }
      checker.destroy();
      checker = null;
    }
  };
}
var InnerChecker;
var init_Health = __esm({
  "../../node_modules/@polkadot/rpc-provider/substrate-connect/Health.js"() {
    init_util();
    InnerChecker = class {
      __internal__healthCallback;
      __internal__currentHealthCheckId = null;
      __internal__currentHealthTimeout = null;
      __internal__currentSubunsubRequestId = null;
      __internal__currentSubscriptionId = null;
      __internal__requestToSmoldot;
      __internal__isSyncing = false;
      __internal__nextRequestId = 0;
      constructor(healthCallback, requestToSmoldot) {
        this.__internal__healthCallback = healthCallback;
        this.__internal__requestToSmoldot = (request) => requestToSmoldot(stringify(request));
      }
      sendJsonRpc = (request) => {
        let parsedRequest;
        try {
          parsedRequest = JSON.parse(request);
        } catch {
          return;
        }
        if (parsedRequest.id) {
          const newId = "extern:" + stringify(parsedRequest.id);
          parsedRequest.id = newId;
        }
        this.__internal__requestToSmoldot(parsedRequest);
      };
      responsePassThrough = (jsonRpcResponse) => {
        let parsedResponse;
        try {
          parsedResponse = JSON.parse(jsonRpcResponse);
        } catch {
          return jsonRpcResponse;
        }
        if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {
          this.__internal__currentHealthCheckId = null;
          if (!parsedResponse.result) {
            this.update(false);
            return null;
          }
          this.__internal__healthCallback(parsedResponse.result);
          this.__internal__isSyncing = parsedResponse.result.isSyncing;
          this.update(false);
          return null;
        }
        if (parsedResponse.id && this.__internal__currentSubunsubRequestId === parsedResponse.id) {
          this.__internal__currentSubunsubRequestId = null;
          if (!parsedResponse.result) {
            this.update(false);
            return null;
          }
          if (this.__internal__currentSubscriptionId) {
            this.__internal__currentSubscriptionId = null;
          } else {
            this.__internal__currentSubscriptionId = parsedResponse.result;
          }
          this.update(false);
          return null;
        }
        if (parsedResponse.params && this.__internal__currentSubscriptionId && parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {
          this.update(true);
          return null;
        }
        if (parsedResponse.id) {
          const id = parsedResponse.id;
          if (!id.startsWith("extern:")) {
            throw new Error("State inconsistency in health checker");
          }
          const newId = JSON.parse(id.slice("extern:".length));
          parsedResponse.id = newId;
        }
        return stringify(parsedResponse);
      };
      update = (startNow) => {
        if (startNow && this.__internal__currentHealthTimeout) {
          clearTimeout(this.__internal__currentHealthTimeout);
          this.__internal__currentHealthTimeout = null;
        }
        if (!this.__internal__currentHealthTimeout) {
          const startHealthRequest = () => {
            this.__internal__currentHealthTimeout = null;
            if (this.__internal__currentHealthCheckId) {
              return;
            }
            this.__internal__currentHealthCheckId = `health-checker:${this.__internal__nextRequestId}`;
            this.__internal__nextRequestId += 1;
            this.__internal__requestToSmoldot({
              id: this.__internal__currentHealthCheckId,
              jsonrpc: "2.0",
              method: "system_health",
              params: []
            });
          };
          if (startNow) {
            startHealthRequest();
          } else {
            this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1e3);
          }
        }
        if (this.__internal__isSyncing && !this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {
          this.startSubscription();
        }
        if (!this.__internal__isSyncing && this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {
          this.endSubscription();
        }
      };
      startSubscription = () => {
        if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {
          throw new Error("Internal error in health checker");
        }
        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;
        this.__internal__nextRequestId += 1;
        this.__internal__requestToSmoldot({
          id: this.__internal__currentSubunsubRequestId,
          jsonrpc: "2.0",
          method: "chain_subscribeNewHeads",
          params: []
        });
      };
      endSubscription = () => {
        if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {
          throw new Error("Internal error in health checker");
        }
        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;
        this.__internal__nextRequestId += 1;
        this.__internal__requestToSmoldot({
          id: this.__internal__currentSubunsubRequestId,
          jsonrpc: "2.0",
          method: "chain_unsubscribeNewHeads",
          params: [this.__internal__currentSubscriptionId]
        });
      };
      destroy = () => {
        if (this.__internal__currentHealthTimeout) {
          clearTimeout(this.__internal__currentHealthTimeout);
          this.__internal__currentHealthTimeout = null;
        }
      };
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/substrate-connect/index.js
var l2, subscriptionUnsubscriptionMethods, scClients, ScProvider;
var init_substrate_connect = __esm({
  "../../node_modules/@polkadot/rpc-provider/substrate-connect/index.js"() {
    init_eventemitter3();
    init_util();
    init_coder();
    init_Health();
    l2 = logger("api-substrate-connect");
    subscriptionUnsubscriptionMethods = /* @__PURE__ */ new Map([
      ["author_submitAndWatchExtrinsic", "author_unwatchExtrinsic"],
      ["chain_subscribeAllHeads", "chain_unsubscribeAllHeads"],
      ["chain_subscribeFinalizedHeads", "chain_unsubscribeFinalizedHeads"],
      ["chain_subscribeFinalisedHeads", "chain_subscribeFinalisedHeads"],
      ["chain_subscribeNewHeads", "chain_unsubscribeNewHeads"],
      ["chain_subscribeNewHead", "chain_unsubscribeNewHead"],
      ["chain_subscribeRuntimeVersion", "chain_unsubscribeRuntimeVersion"],
      ["subscribe_newHead", "unsubscribe_newHead"],
      ["state_subscribeRuntimeVersion", "state_unsubscribeRuntimeVersion"],
      ["state_subscribeStorage", "state_unsubscribeStorage"]
    ]);
    scClients = /* @__PURE__ */ new WeakMap();
    ScProvider = class {
      __internal__Sc;
      __internal__coder = new RpcCoder();
      __internal__spec;
      __internal__sharedSandbox;
      __internal__subscriptions = /* @__PURE__ */ new Map();
      __internal__resubscribeMethods = /* @__PURE__ */ new Map();
      __internal__requests = /* @__PURE__ */ new Map();
      __internal__wellKnownChains;
      __internal__eventemitter = new import_index3.default();
      __internal__chain = null;
      __internal__isChainReady = false;
      constructor(Sc, spec2, sharedSandbox) {
        if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {
          throw new Error("Expected an @substrate/connect interface as first parameter to ScProvider");
        }
        this.__internal__Sc = Sc;
        this.__internal__spec = spec2;
        this.__internal__sharedSandbox = sharedSandbox;
        this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));
      }
      get hasSubscriptions() {
        return true;
      }
      get isClonable() {
        return false;
      }
      get isConnected() {
        return !!this.__internal__chain && this.__internal__isChainReady;
      }
      clone() {
        throw new Error("clone() is not supported.");
      }
      // Config details can be found in @substrate/connect repo following the link:
      // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts
      async connect(config3, checkerFactory = healthChecker) {
        if (this.isConnected) {
          throw new Error("Already connected!");
        }
        if (this.__internal__chain) {
          await this.__internal__chain;
          return;
        }
        if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {
          await this.__internal__sharedSandbox.connect();
        }
        const client = this.__internal__sharedSandbox ? scClients.get(this.__internal__sharedSandbox) : this.__internal__Sc.createScClient(config3);
        if (!client) {
          throw new Error("Unknown ScProvider!");
        }
        scClients.set(this, client);
        const hc = checkerFactory();
        const onResponse = (res) => {
          const hcRes = hc.responsePassThrough(res);
          if (!hcRes) {
            return;
          }
          const response = JSON.parse(hcRes);
          let decodedResponse;
          try {
            decodedResponse = this.__internal__coder.decodeResponse(response);
          } catch (e2) {
            decodedResponse = e2;
          }
          if (response.params?.subscription === void 0 || !response.method) {
            return this.__internal__requests.get(response.id)?.(decodedResponse);
          }
          const subscriptionId = `${response.method}::${response.params.subscription}`;
          const callback = this.__internal__subscriptions.get(subscriptionId)?.[0];
          callback?.(decodedResponse);
        };
        const addChain = this.__internal__sharedSandbox ? async (...args) => {
          const source = this.__internal__sharedSandbox;
          return (await source.__internal__chain).addChain(...args);
        } : this.__internal__wellKnownChains.has(this.__internal__spec) ? client.addWellKnownChain : client.addChain;
        this.__internal__chain = addChain(this.__internal__spec, onResponse).then((chain2) => {
          hc.setSendJsonRpc(chain2.sendJsonRpc);
          this.__internal__isChainReady = false;
          const cleanup = () => {
            const disconnectionError = new Error("Disconnected");
            this.__internal__requests.forEach((cb) => cb(disconnectionError));
            this.__internal__subscriptions.forEach(([cb]) => cb(disconnectionError));
            this.__internal__subscriptions.clear();
          };
          const staleSubscriptions = [];
          const killStaleSubscriptions = () => {
            if (staleSubscriptions.length === 0) {
              return;
            }
            const stale = staleSubscriptions.pop();
            if (!stale) {
              throw new Error("Unable to get stale subscription");
            }
            const { id, unsubscribeMethod } = stale;
            Promise.race([
              this.send(unsubscribeMethod, [id]).catch(noop),
              new Promise((resolve) => setTimeout(resolve, 500))
            ]).then(killStaleSubscriptions).catch(noop);
          };
          hc.start((health) => {
            const isReady2 = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);
            if (this.__internal__isChainReady === isReady2) {
              return;
            }
            this.__internal__isChainReady = isReady2;
            if (!isReady2) {
              [...this.__internal__subscriptions.values()].forEach((s2) => {
                staleSubscriptions.push(s2[1]);
              });
              cleanup();
              this.__internal__eventemitter.emit("disconnected");
            } else {
              killStaleSubscriptions();
              this.__internal__eventemitter.emit("connected");
              if (this.__internal__resubscribeMethods.size) {
                this.__internal__resubscribe();
              }
            }
          });
          return objectSpread({}, chain2, {
            remove: () => {
              hc.stop();
              chain2.remove();
              cleanup();
            },
            sendJsonRpc: hc.sendJsonRpc.bind(hc)
          });
        });
        try {
          await this.__internal__chain;
        } catch (e2) {
          this.__internal__chain = null;
          this.__internal__eventemitter.emit("error", e2);
          throw e2;
        }
      }
      __internal__resubscribe = () => {
        const promises = [];
        this.__internal__resubscribeMethods.forEach((subDetails) => {
          if (subDetails.type.startsWith("author_")) {
            return;
          }
          try {
            const promise = new Promise((resolve) => {
              this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));
              resolve();
            });
            promises.push(promise);
          } catch (error) {
            l2.error(error);
          }
        });
        Promise.all(promises).catch((err) => l2.log(err));
      };
      async disconnect() {
        if (!this.__internal__chain) {
          return;
        }
        const chain2 = await this.__internal__chain;
        this.__internal__chain = null;
        this.__internal__isChainReady = false;
        try {
          chain2.remove();
        } catch (_) {
        }
        this.__internal__eventemitter.emit("disconnected");
      }
      on(type, sub) {
        if (type === "connected" && this.isConnected) {
          sub();
        }
        this.__internal__eventemitter.on(type, sub);
        return () => {
          this.__internal__eventemitter.removeListener(type, sub);
        };
      }
      async send(method, params) {
        if (!this.isConnected || !this.__internal__chain) {
          throw new Error("Provider is not connected");
        }
        const chain2 = await this.__internal__chain;
        const [id, json] = this.__internal__coder.encodeJson(method, params);
        const result = new Promise((resolve, reject) => {
          this.__internal__requests.set(id, (response) => {
            (isError(response) ? reject : resolve)(response);
          });
          try {
            chain2.sendJsonRpc(json);
          } catch (e2) {
            this.__internal__chain = null;
            try {
              chain2.remove();
            } catch (_) {
            }
            this.__internal__eventemitter.emit("error", e2);
          }
        });
        try {
          return await result;
        } finally {
          this.__internal__requests.delete(id);
        }
      }
      async subscribe(type, method, params, callback) {
        if (!subscriptionUnsubscriptionMethods.has(method)) {
          throw new Error(`Unsupported subscribe method: ${method}`);
        }
        const id = await this.send(method, params);
        const subscriptionId = `${type}::${id}`;
        const cb = (response) => {
          if (response instanceof Error) {
            callback(response, void 0);
          } else {
            callback(null, response);
          }
        };
        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);
        if (!unsubscribeMethod) {
          throw new Error("Invalid unsubscribe method found");
        }
        this.__internal__resubscribeMethods.set(subscriptionId, { callback, method, params, type });
        this.__internal__subscriptions.set(subscriptionId, [cb, { id, unsubscribeMethod }]);
        return id;
      }
      unsubscribe(type, method, id) {
        if (!this.isConnected) {
          throw new Error("Provider is not connected");
        }
        const subscriptionId = `${type}::${id}`;
        if (!this.__internal__subscriptions.has(subscriptionId)) {
          return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));
        }
        this.__internal__resubscribeMethods.delete(subscriptionId);
        this.__internal__subscriptions.delete(subscriptionId);
        return this.send(method, [id]);
      }
    };
  }
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// ../../node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf = list[i2];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i2 = 0; i2 < length; i2++) {
        output[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i2 = 0; i2 < buffer.length; i2++) {
        buffer[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e2) {
      }
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8: isUtf82 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || // Overlong
          buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || // Overlong
          buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob2(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob: isBlob2,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf82) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf82(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e2) {
      }
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix2, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix2 ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver2;
  }
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP: NOOP2 } = require_constants();
    var { isBlob: isBlob2, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP2;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i2 = 0; i2 < sender._queue.length; i2++) {
        const params = sender._queue[i2];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse6(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        code = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (i2 !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1) start = i2;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i2;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i2;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse6 };
  }
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https2 = require("https");
    var http3 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes2, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { isBlob: isBlob2 } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP: NOOP2
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse6 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket3 = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes2(16).toString("base64");
      const request = isSecure ? https2.request : http3.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location2, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location2}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse6(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob2(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP2);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket3.CLOSED) return;
      if (websocket.readyState === WebSocket3.OPEN) {
        websocket._readyState = WebSocket3.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP2);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../../node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse6(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header.length; i2++) {
        const code = header.charCodeAt(i2);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i2;
        } else if (i2 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i2;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1) end = i2;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse6 };
  }
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http3 = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http3.createServer((req, res) => {
            const body = http3.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info6 = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info6, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info6)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map79) {
      for (const event of Object.keys(map79)) server.on(event, map79[event]);
      return function removeListeners() {
        for (const event of Object.keys(map79)) {
          server.removeListener(event, map79[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http3.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http3.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// ../../node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm({
  "../../node_modules/ws/wrapper.mjs"() {
    import_stream = __toESM(require_stream(), 1);
    import_receiver = __toESM(require_receiver(), 1);
    import_sender = __toESM(require_sender(), 1);
    import_websocket = __toESM(require_websocket(), 1);
    import_websocket_server = __toESM(require_websocket_server(), 1);
    wrapper_default = import_websocket.default;
  }
});

// ../../node_modules/@polkadot/x-ws/node.js
var WebSocket2;
var init_node5 = __esm({
  "../../node_modules/@polkadot/x-ws/node.js"() {
    init_wrapper();
    init_x_global();
    WebSocket2 = /* @__PURE__ */ extractGlobal("WebSocket", wrapper_default);
  }
});

// ../../node_modules/@polkadot/rpc-provider/ws/errors.js
function getWSErrorString(code) {
  if (code >= 0 && code <= 999) {
    return "(Unused)";
  } else if (code >= 1016) {
    if (code <= 1999) {
      return "(For WebSocket standard)";
    } else if (code <= 2999) {
      return "(For WebSocket extensions)";
    } else if (code <= 3999) {
      return "(For libraries and frameworks)";
    } else if (code <= 4999) {
      return "(For applications)";
    }
  }
  return known[code] || "(Unknown)";
}
var known;
var init_errors = __esm({
  "../../node_modules/@polkadot/rpc-provider/ws/errors.js"() {
    known = {
      1e3: "Normal Closure",
      1001: "Going Away",
      1002: "Protocol Error",
      1003: "Unsupported Data",
      1004: "(For future)",
      1005: "No Status Received",
      1006: "Abnormal Closure",
      1007: "Invalid frame payload data",
      1008: "Policy Violation",
      1009: "Message too big",
      1010: "Missing Extension",
      1011: "Internal Error",
      1012: "Service Restart",
      1013: "Try Again Later",
      1014: "Bad Gateway",
      1015: "TLS Handshake"
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/ws/index.js
function eraseRecord(record, cb) {
  Object.keys(record).forEach((key) => {
    if (cb) {
      cb(record[key]);
    }
    delete record[key];
  });
}
function defaultEndpointStats() {
  return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };
}
var ALIASES, RETRY_DELAY, DEFAULT_TIMEOUT_MS, TIMEOUT_INTERVAL, l3, WsProvider;
var init_ws = __esm({
  "../../node_modules/@polkadot/rpc-provider/ws/index.js"() {
    init_eventemitter3();
    init_util();
    init_x_global();
    init_node5();
    init_coder();
    init_defaults6();
    init_lru();
    init_errors();
    ALIASES = {
      chain_finalisedHead: "chain_finalizedHead",
      chain_subscribeFinalisedHeads: "chain_subscribeFinalizedHeads",
      chain_unsubscribeFinalisedHeads: "chain_unsubscribeFinalizedHeads"
    };
    RETRY_DELAY = 2500;
    DEFAULT_TIMEOUT_MS = 60 * 1e3;
    TIMEOUT_INTERVAL = 5e3;
    l3 = logger("api-ws");
    WsProvider = class _WsProvider {
      __internal__callCache;
      __internal__coder;
      __internal__endpoints;
      __internal__headers;
      __internal__eventemitter;
      __internal__handlers = {};
      __internal__isReadyPromise;
      __internal__stats;
      __internal__waitingForId = {};
      __internal__cacheCapacity;
      __internal__autoConnectMs;
      __internal__endpointIndex;
      __internal__endpointStats;
      __internal__isConnected = false;
      __internal__subscriptions = {};
      __internal__timeoutId = null;
      __internal__websocket;
      __internal__timeout;
      /**
       * @param {string | string[]} endpoint The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.
       * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.
       * @param {Record<string, string>} headers The headers provided to the underlying WebSocket
       * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`
       * @param {number} [cacheCapacity] Custom size of the WsProvider LRUCache. Defaults to `DEFAULT_CAPACITY` (1024)
       */
      constructor(endpoint = defaults_default.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity) {
        const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];
        if (endpoints.length === 0) {
          throw new Error("WsProvider requires at least one Endpoint");
        }
        endpoints.forEach((endpoint2) => {
          if (!/^(wss|ws):\/\//.test(endpoint2)) {
            throw new Error(`Endpoint should start with 'ws://', received '${endpoint2}'`);
          }
        });
        this.__internal__callCache = new LRUCache(cacheCapacity || DEFAULT_CAPACITY);
        this.__internal__cacheCapacity = cacheCapacity || DEFAULT_CAPACITY;
        this.__internal__eventemitter = new import_index3.default();
        this.__internal__autoConnectMs = autoConnectMs || 0;
        this.__internal__coder = new RpcCoder();
        this.__internal__endpointIndex = -1;
        this.__internal__endpoints = endpoints;
        this.__internal__headers = headers;
        this.__internal__websocket = null;
        this.__internal__stats = {
          active: { requests: 0, subscriptions: 0 },
          total: defaultEndpointStats()
        };
        this.__internal__endpointStats = defaultEndpointStats();
        this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;
        if (autoConnectMs && autoConnectMs > 0) {
          this.connectWithRetry().catch(noop);
        }
        this.__internal__isReadyPromise = new Promise((resolve) => {
          this.__internal__eventemitter.once("connected", () => {
            resolve(this);
          });
        });
      }
      /**
       * @summary `true` when this provider supports subscriptions
       */
      get hasSubscriptions() {
        return true;
      }
      /**
       * @summary `true` when this provider supports clone()
       */
      get isClonable() {
        return true;
      }
      /**
       * @summary Whether the node is connected or not.
       * @return {boolean} true if connected
       */
      get isConnected() {
        return this.__internal__isConnected;
      }
      /**
       * @description Promise that resolves the first time we are connected and loaded
       */
      get isReady() {
        return this.__internal__isReadyPromise;
      }
      get endpoint() {
        return this.__internal__endpoints[this.__internal__endpointIndex];
      }
      /**
       * @description Returns a clone of the object
       */
      clone() {
        return new _WsProvider(this.__internal__endpoints);
      }
      selectEndpointIndex(endpoints) {
        return (this.__internal__endpointIndex + 1) % endpoints.length;
      }
      /**
       * @summary Manually connect
       * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
       * connect manually using this method.
       */
      // eslint-disable-next-line @typescript-eslint/require-await
      async connect() {
        if (this.__internal__websocket) {
          throw new Error("WebSocket is already connected");
        }
        try {
          this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);
          this.__internal__websocket = typeof xglobal.WebSocket !== "undefined" && isChildClass(xglobal.WebSocket, WebSocket2) ? new WebSocket2(this.endpoint) : new WebSocket2(this.endpoint, void 0, {
            headers: this.__internal__headers
          });
          if (this.__internal__websocket) {
            this.__internal__websocket.onclose = this.__internal__onSocketClose;
            this.__internal__websocket.onerror = this.__internal__onSocketError;
            this.__internal__websocket.onmessage = this.__internal__onSocketMessage;
            this.__internal__websocket.onopen = this.__internal__onSocketOpen;
          }
          this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);
        } catch (error) {
          l3.error(error);
          this.__internal__emit("error", error);
          throw error;
        }
      }
      /**
       * @description Connect, never throwing an error, but rather forcing a retry
       */
      async connectWithRetry() {
        if (this.__internal__autoConnectMs > 0) {
          try {
            await this.connect();
          } catch {
            setTimeout(() => {
              this.connectWithRetry().catch(noop);
            }, this.__internal__autoConnectMs);
          }
        }
      }
      /**
       * @description Manually disconnect from the connection, clearing auto-connect logic
       */
      // eslint-disable-next-line @typescript-eslint/require-await
      async disconnect() {
        this.__internal__autoConnectMs = 0;
        try {
          if (this.__internal__websocket) {
            this.__internal__websocket.close(1e3);
          }
        } catch (error) {
          l3.error(error);
          this.__internal__emit("error", error);
          throw error;
        }
      }
      /**
       * @description Returns the connection stats
       */
      get stats() {
        return {
          active: {
            requests: Object.keys(this.__internal__handlers).length,
            subscriptions: Object.keys(this.__internal__subscriptions).length
          },
          total: this.__internal__stats.total
        };
      }
      get endpointStats() {
        return this.__internal__endpointStats;
      }
      /**
       * @summary Listens on events after having subscribed using the [[subscribe]] function.
       * @param  {ProviderInterfaceEmitted} type Event
       * @param  {ProviderInterfaceEmitCb}  sub  Callback
       * @return unsubscribe function
       */
      on(type, sub) {
        this.__internal__eventemitter.on(type, sub);
        return () => {
          this.__internal__eventemitter.removeListener(type, sub);
        };
      }
      /**
       * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
       * @param method The RPC methods to execute
       * @param params Encoded parameters as applicable for the method
       * @param subscription Subscription details (internally used)
       */
      send(method, params, isCacheable, subscription) {
        this.__internal__endpointStats.requests++;
        this.__internal__stats.total.requests++;
        const [id, body] = this.__internal__coder.encodeJson(method, params);
        if (this.__internal__cacheCapacity === 0) {
          return this.__internal__send(id, body, method, params, subscription);
        }
        const cacheKey = isCacheable ? `${method}::${stringify(params)}` : "";
        let resultPromise = isCacheable ? this.__internal__callCache.get(cacheKey) : null;
        if (!resultPromise) {
          resultPromise = this.__internal__send(id, body, method, params, subscription);
          if (isCacheable) {
            this.__internal__callCache.set(cacheKey, resultPromise);
          }
        } else {
          this.__internal__endpointStats.cached++;
          this.__internal__stats.total.cached++;
        }
        return resultPromise;
      }
      async __internal__send(id, body, method, params, subscription) {
        return new Promise((resolve, reject) => {
          try {
            if (!this.isConnected || this.__internal__websocket === null) {
              throw new Error("WebSocket is not connected");
            }
            const callback = (error, result) => {
              error ? reject(error) : resolve(result);
            };
            l3.debug(() => ["calling", method, body]);
            this.__internal__handlers[id] = {
              callback,
              method,
              params,
              start: Date.now(),
              subscription
            };
            const bytesSent = body.length;
            this.__internal__endpointStats.bytesSent += bytesSent;
            this.__internal__stats.total.bytesSent += bytesSent;
            this.__internal__websocket.send(body);
          } catch (error) {
            this.__internal__endpointStats.errors++;
            this.__internal__stats.total.errors++;
            reject(error);
          }
        });
      }
      /**
       * @name subscribe
       * @summary Allows subscribing to a specific event.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * const provider = new WsProvider('ws://127.0.0.1:9944');
       * const rpc = new Rpc(provider);
       *
       * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {
       *   console.log(values)
       * }).then((subscriptionId) => {
       *   console.log('balance changes subscription id: ', subscriptionId)
       * })
       * ```
       */
      subscribe(type, method, params, callback) {
        this.__internal__endpointStats.subscriptions++;
        this.__internal__stats.total.subscriptions++;
        return this.send(method, params, false, { callback, type });
      }
      /**
       * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
       */
      async unsubscribe(type, method, id) {
        const subscription = `${type}::${id}`;
        if (isUndefined(this.__internal__subscriptions[subscription])) {
          l3.debug(() => `Unable to find active subscription=${subscription}`);
          return false;
        }
        delete this.__internal__subscriptions[subscription];
        try {
          return this.isConnected && !isNull(this.__internal__websocket) ? this.send(method, [id]) : true;
        } catch {
          return false;
        }
      }
      __internal__emit = (type, ...args) => {
        this.__internal__eventemitter.emit(type, ...args);
      };
      __internal__onSocketClose = (event) => {
        const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);
        if (this.__internal__autoConnectMs > 0) {
          l3.error(error.message);
        }
        this.__internal__isConnected = false;
        if (this.__internal__websocket) {
          this.__internal__websocket.onclose = null;
          this.__internal__websocket.onerror = null;
          this.__internal__websocket.onmessage = null;
          this.__internal__websocket.onopen = null;
          this.__internal__websocket = null;
        }
        if (this.__internal__timeoutId) {
          clearInterval(this.__internal__timeoutId);
          this.__internal__timeoutId = null;
        }
        eraseRecord(this.__internal__handlers, (h2) => {
          try {
            h2.callback(error, void 0);
          } catch (err) {
            l3.error(err);
          }
        });
        eraseRecord(this.__internal__waitingForId);
        this.__internal__endpointStats = defaultEndpointStats();
        this.__internal__emit("disconnected");
        if (this.__internal__autoConnectMs > 0) {
          setTimeout(() => {
            this.connectWithRetry().catch(noop);
          }, this.__internal__autoConnectMs);
        }
      };
      __internal__onSocketError = (error) => {
        l3.debug(() => ["socket error", error]);
        this.__internal__emit("error", error);
      };
      __internal__onSocketMessage = (message) => {
        l3.debug(() => ["received", message.data]);
        const bytesRecv = message.data.length;
        this.__internal__endpointStats.bytesRecv += bytesRecv;
        this.__internal__stats.total.bytesRecv += bytesRecv;
        const response = JSON.parse(message.data);
        return isUndefined(response.method) ? this.__internal__onSocketMessageResult(response) : this.__internal__onSocketMessageSubscribe(response);
      };
      __internal__onSocketMessageResult = (response) => {
        const handler = this.__internal__handlers[response.id];
        if (!handler) {
          l3.debug(() => `Unable to find handler for id=${response.id}`);
          return;
        }
        try {
          const { method, params, subscription } = handler;
          const result = this.__internal__coder.decodeResponse(response);
          handler.callback(null, result);
          if (subscription) {
            const subId = `${subscription.type}::${result}`;
            this.__internal__subscriptions[subId] = objectSpread({}, subscription, {
              method,
              params
            });
            if (this.__internal__waitingForId[subId]) {
              this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);
            }
          }
        } catch (error) {
          this.__internal__endpointStats.errors++;
          this.__internal__stats.total.errors++;
          handler.callback(error, void 0);
        }
        delete this.__internal__handlers[response.id];
      };
      __internal__onSocketMessageSubscribe = (response) => {
        if (!response.method) {
          throw new Error("No method found in JSONRPC response");
        }
        const method = ALIASES[response.method] || response.method;
        const subId = `${method}::${response.params.subscription}`;
        const handler = this.__internal__subscriptions[subId];
        if (!handler) {
          this.__internal__waitingForId[subId] = response;
          l3.debug(() => `Unable to find handler for subscription=${subId}`);
          return;
        }
        delete this.__internal__waitingForId[subId];
        try {
          const result = this.__internal__coder.decodeResponse(response);
          handler.callback(null, result);
        } catch (error) {
          this.__internal__endpointStats.errors++;
          this.__internal__stats.total.errors++;
          handler.callback(error, void 0);
        }
      };
      __internal__onSocketOpen = () => {
        if (this.__internal__websocket === null) {
          throw new Error("WebSocket cannot be null in onOpen");
        }
        l3.debug(() => ["connected to", this.endpoint]);
        this.__internal__isConnected = true;
        this.__internal__resubscribe();
        this.__internal__emit("connected");
        return true;
      };
      __internal__resubscribe = () => {
        const subscriptions = this.__internal__subscriptions;
        this.__internal__subscriptions = {};
        Promise.all(Object.keys(subscriptions).map(async (id) => {
          const { callback, method, params, type } = subscriptions[id];
          if (type.startsWith("author_")) {
            return;
          }
          try {
            await this.subscribe(type, method, params, callback);
          } catch (error) {
            l3.error(error);
          }
        })).catch(l3.error);
      };
      __internal__timeoutHandlers = () => {
        const now = Date.now();
        const ids = Object.keys(this.__internal__handlers);
        for (let i2 = 0, count = ids.length; i2 < count; i2++) {
          const handler = this.__internal__handlers[ids[i2]];
          if (now - handler.start > this.__internal__timeout) {
            try {
              handler.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1e3}s`), void 0);
            } catch {
            }
            this.__internal__endpointStats.timeout++;
            this.__internal__stats.total.timeout++;
            delete this.__internal__handlers[ids[i2]];
          }
        }
      };
    };
  }
});

// ../../node_modules/@polkadot/rpc-provider/bundle.js
var init_bundle8 = __esm({
  "../../node_modules/@polkadot/rpc-provider/bundle.js"() {
    init_http();
    init_lru();
    init_substrate_connect();
    init_ws();
  }
});

// ../../node_modules/@polkadot/rpc-provider/index.js
var init_rpc_provider = __esm({
  "../../node_modules/@polkadot/rpc-provider/index.js"() {
    init_packageDetect9();
    init_bundle8();
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunction = void 0;
    function isFunction2(value) {
      return typeof value === "function";
    }
    exports2.isFunction = isFunction2;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports2.createErrorClass = createErrorClass;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
          return i2 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports2.arrRemove = arrRemove;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSubscription = exports2.EMPTY_SUBSCRIPTION = exports2.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription2 = function() {
      function Subscription3(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription3.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e2) {
              errors = e2 instanceof UnsubscriptionError_1.UnsubscriptionError ? e2.errors : [e2];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription3.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription3) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription3.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription3.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription3.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription3.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription3) {
          teardown._removeParent(this);
        }
      };
      Subscription3.EMPTY = function() {
        var empty2 = new Subscription3();
        empty2.closed = true;
        return empty2;
      }();
      return Subscription3;
    }();
    exports2.Subscription = Subscription2;
    exports2.EMPTY_SUBSCRIPTION = Subscription2.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription2 || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports2.isSubscription = isSubscription;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = void 0;
    exports2.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutProvider = void 0;
    exports2.timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports2.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports2.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports2.reportUnhandledError = reportUnhandledError;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.noop = void 0;
    function noop3() {
    }
    exports2.noop = noop3;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNotification = exports2.nextNotification = exports2.errorNotification = exports2.COMPLETE_NOTIFICATION = void 0;
    exports2.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports2.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports2.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports2.createNotification = createNotification;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.captureError = exports2.errorContext = void 0;
    var config_1 = require_config();
    var context = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
          context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a = context, errorThrown = _a.errorThrown, error = _a.error;
          context = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports2.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
      }
    }
    exports2.captureError = captureError;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports2.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports2.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports2.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports2.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observable = void 0;
    exports2.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = void 0;
    function identity3(x2) {
      return x2;
    }
    exports2.identity = identity3;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pipeFromArray = exports2.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports2.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports2.pipeFromArray = pipeFromArray;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/Observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable4 = function() {
      function Observable5(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable5.prototype.lift = function(operator) {
        var observable = new Observable5();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable5.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable5.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable5.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable5.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable5.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable5.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable5.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x2) {
            return value = x2;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable5.create = function(subscribe) {
        return new Observable5(subscribe);
      };
      return Observable5;
    }();
    exports2.Observable = Observable4;
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operate = exports2.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports2.hasLift = hasLift;
    function operate(init2) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init2(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports2.operate = operate;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperatorSubscriber = exports2.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports2.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports2.OperatorSubscriber = OperatorSubscriber;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount3() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports2.refCount = refCount3;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports2.ConnectableObservable = ConnectableObservable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.performanceTimestampProvider = void 0;
    exports2.performanceTimestampProvider = {
      now: function() {
        return (exports2.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports2.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports2.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp) {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports2.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/Subject.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnonymousSubject = exports2.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports2.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    exports2.AnonymousSubject = AnonymousSubject;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject5 = function(_super) {
      __extends(BehaviorSubject6, _super);
      function BehaviorSubject6(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject6.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject6.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject6.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject6.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject6;
    }(Subject_1.Subject);
    exports2.BehaviorSubject = BehaviorSubject5;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateTimestampProvider = void 0;
    exports2.dateTimestampProvider = {
      now: function() {
        return (exports2.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i2]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last = 0;
          for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
            last = i2;
          }
          last && _buffer.splice(0, last + 1);
        }
      };
      return ReplaySubject2;
    }(Subject_1.Subject);
    exports2.ReplaySubject = ReplaySubject;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports2.AsyncSubject = AsyncSubject;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports2.Action = Action;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intervalProvider = void 0;
    exports2.intervalProvider = {
      setInterval: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports2.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports2.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e2) {
          errored = true;
          errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports2.AsyncAction = AsyncAction;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestTools = exports2.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports2.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports2.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate;
    var clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports2.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          if (scheduler._scheduled === id) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.AsapAction = AsapAction;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports2.Scheduler = Scheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports2.AsyncScheduler = AsyncScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.AsapScheduler = AsapScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asap = exports2.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports2.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports2.asap = exports2.asapScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.async = exports2.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports2.async = exports2.asyncScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && delay > 0 || delay == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.QueueAction = QueueAction;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.QueueScheduler = QueueScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.queue = exports2.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports2.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports2.queue = exports2.queueScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.AnimationFrameAction = AnimationFrameAction;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrame = exports2.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports2.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports2.animationFrame = exports2.animationFrameScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VirtualAction = exports2.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (Number.isFinite(delay)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.VirtualAction = VirtualAction;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.empty = exports2.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty2(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports2.EMPTY;
    }
    exports2.empty = empty2;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports2.isScheduler = isScheduler;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/args.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.popNumber = exports2.popScheduler = exports2.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
    }
    exports2.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
    }
    exports2.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last(args) === "number" ? args.pop() : defaultValue;
    }
    exports2.popNumber = popNumber;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isArrayLike = void 0;
    exports2.isArrayLike = function(x2) {
      return x2 && typeof x2.length === "number" && typeof x2 !== "function";
    };
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports2.isPromise = isPromise;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports2.isInteropObservable = isInteropObservable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports2.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iterator = exports2.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports2.getSymbolIterator = getSymbolIterator;
    exports2.iterator = getSymbolIterator();
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports2.isIterable = isIterable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t2[0] & 1) throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f3, y, t2, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
          if (y = 0, t2) op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y = 0;
        } finally {
          f3 = t2 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n) {
        if (g[n]) i2[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e2) {
          settle(q[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f3, v) {
        if (f3(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReadableStreamLike = exports2.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false) return [3, 8];
              return [4, __await(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done) return [3, 5];
              return [4, __await(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports2.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports2.isReadableStreamLike = isReadableStreamLike;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t2[0] & 1) throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f3, y, t2, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
          if (y = 0, t2) op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y = 0;
        } finally {
          f3 = t2 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o[Symbol.asyncIterator], i2;
      return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v5) {
          resolve({ value: v5, done: d });
        }, reject);
      }
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromReadableStreamLike = exports2.fromAsyncIterable = exports2.fromIterable = exports2.fromPromise = exports2.fromArrayLike = exports2.fromInteropObservable = exports2.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports2.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports2.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
          subscriber.next(array[i2]);
        }
        subscriber.complete();
      });
    }
    exports2.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports2.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports2.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process2(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports2.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports2.fromReadableStreamLike = fromReadableStreamLike;
    function process2(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2) throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
      if (delay === void 0) {
        delay = 0;
      }
      if (repeat === void 0) {
        repeat = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }
    exports2.executeSchedule = executeSchedule;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay);
        }));
      });
    }
    exports2.observeOn = observeOn;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay));
      });
    }
    exports2.subscribeOn = subscribeOn;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports2.scheduleObservable = scheduleObservable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports2.schedulePromise = schedulePromise;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i2 = 0;
        return scheduler.schedule(function() {
          if (i2 === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i2++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports2.scheduleArray = scheduleArray;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports2.scheduleIterable = scheduleIterable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports2.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports2.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports2.scheduled = scheduled;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from4(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports2.from = from4;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of60() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports2.of = of60;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init2 = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init2, 0, subscriber);
      } : init2);
    }
    exports2.throwError = throwError;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/Notification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeNotification = exports2.Notification = exports2.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports2.NotificationKind || (exports2.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports2.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports2.observeNotification = observeNotification;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports2.isObservable = isObservable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom(source, config3) {
      var hasConfig = typeof config3 === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config3.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports2.lastValueFrom = lastValueFrom;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom2(source, config3) {
      var hasConfig = typeof config3 === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config3.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports2.firstValueFrom = firstValueFrom2;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports2.isValidDate = isValidDate;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = exports2.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info6) {
        if (info6 === void 0) {
          info6 = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info6;
      };
    });
    function timeout(config3, schedulerArg) {
      var _a = isDate_1.isValidDate(config3) ? { first: config3 } : typeof config3 === "number" ? { each: config3 } : config3, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
      });
    }
    exports2.timeout = timeout;
    function timeoutErrorFactory(info6) {
      throw new exports2.TimeoutError(info6);
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map79(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports2.map = map79;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray = Array.isArray;
    function callOrApply(fn, args) {
      return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports2.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports2.bindCallbackInternals = bindCallbackInternals;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports2.bindCallback = bindCallback;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports2.bindNodeCallback = bindNodeCallback;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argsArgArrayOrObject = void 0;
    var isArray = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys2 = getKeys(first_1);
          return {
            args: keys2.map(function(key) {
              return first_1[key];
            }),
            keys: keys2
          };
        }
      }
      return { args, keys: null };
    }
    exports2.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createObject = void 0;
    function createObject(keys2, values) {
      return keys2.reduce(function(result, key, i2) {
        return result[key] = values[i2], result;
      }, {});
    }
    exports2.createObject = createObject;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestInit = exports2.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest41() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys2 ? function(values) {
        return createObject_1.createObject(keys2, values);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports2.combineLatest = combineLatest41;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length = observables.length;
          var values = new Array(length);
          var active = length;
          var remainingFirstValues = length;
          var _loop_1 = function(i3) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i3], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i3] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i2 = 0; i2 < length; i2++) {
            _loop_1(i2);
          }
        }, subscriber);
      };
    }
    exports2.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand2 && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand2) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports2.mergeInternals = mergeInternals;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap3(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap3(function(a, i2) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i2, ii);
          })(innerFrom_1.innerFrom(project(a, i2)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports2.mergeMap = mergeMap3;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports2.mergeAll = mergeAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports2.concatAll = concatAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports2.concat = concat;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports2.defer = defer;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config3) {
      if (config3 === void 0) {
        config3 = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config3.connector, _a = config3.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports2.connectable = connectable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys2 = _a.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length = sources.length;
        if (!length) {
          subscriber.complete();
          return;
        }
        var values = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys2 ? createObject_1.createObject(keys2, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports2.forkJoin = forkJoin;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add3 = _a[0], remove = _a[1];
      if (!add3) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add3) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add3(handler);
        return function() {
          return remove(handler);
        };
      });
    }
    exports2.fromEvent = fromEvent;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e2[_i] = arguments[_i];
          }
          return subscriber.next(e2.length === 1 ? e2[0] : e2);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports2.fromEventPattern = fromEventPattern;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t2[0] & 1) throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f3, y, t2, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
          if (y = 0, t2) op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y = 0;
        } finally {
          f3 = t2 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen2() {
        var state;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state))) return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen2(), scheduler);
      } : gen2);
    }
    exports2.generate = generate;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports2.iif = iif;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports2.timer = timer;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports2.interval = interval;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports2.merge = merge;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.never = exports2.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports2.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports2.NEVER;
    }
    exports2.never = never;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argsOrArgArray = void 0;
    var isArray = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray(args[0]) ? args[0] : args;
    }
    exports2.argsOrArgArray = argsOrArgArray;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports2.onErrorResumeNext = onErrorResumeNext;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pairs = void 0;
    var from_1 = require_from();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports2.pairs = pairs;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/util/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.not = void 0;
    function not(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports2.not = not;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports2.filter = filter;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports2.partition = partition;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raceInit = exports2.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports2.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i3) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s2 = 0; s2 < subscriptions.length; s2++) {
                s2 !== i3 && subscriptions[s2].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
          _loop_1(i2);
        }
      };
    }
    exports2.raceInit = raceInit;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count, scheduler) {
      if (count == null) {
        count = start;
        start = 0;
      }
      if (count <= 0) {
        return empty_1.EMPTY;
      }
      var end = count + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports2.range = range;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports2.using = using;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
              if (buffers.some(function(buffer, i2) {
                return !buffer.length && completed[i2];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports2.zip = zip;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports2.audit = audit;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports2.auditTime = auditTime;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports2.buffer = buffer;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports2.bufferCount = bufferCount;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return)) _a2.call(recordsCopy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports2.bufferTime = bufferTime;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports2.bufferToggle = bufferToggle;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports2.bufferWhen = bufferWhen;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError7(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError7(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports2.catchError = catchError7;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i2 = index++;
          state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports2.scanInternals = scanInternals;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports2.reduce = reduce;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray5() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports2.toArray = toArray5;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports2.joinAllInternals = joinAllInternals;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports2.combineLatestAll = combineLatestAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports2.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest41() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest41.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports2.combineLatest = combineLatest41;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports2.combineLatestWith = combineLatestWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports2.concatMap = concatMap;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports2.concatMapTo = concatMapTo;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports2.concat = concat;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports2.concatWith = concatWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports2.fromSubscribable = fromSubscribable;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect(selector, config3) {
      if (config3 === void 0) {
        config3 = DEFAULT_CONFIG;
      }
      var connector = config3.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports2.connect = connect;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.count = void 0;
    var reduce_1 = require_reduce();
    function count(predicate) {
      return reduce_1.reduce(function(total, value, i2) {
        return !predicate || predicate(value, i2) ? total + 1 : total;
      }, 0);
    }
    exports2.count = count;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports2.debounce = debounce;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports2.debounceTime = debounceTime;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports2.defaultIfEmpty = defaultIfEmpty;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count) {
            subscriber.next(value);
            if (count <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports2.take = take;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports2.ignoreElements = ignoreElements;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapTo = void 0;
    var map_1 = require_map();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports2.mapTo = mapTo;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports2.delayWhen = delayWhen;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports2.delay = delay;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports2.dematerialize = dematerialize;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports2.distinct = distinct;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged2(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first2 = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first2 || !comparator(previousKey, currentKey)) {
            first2 = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports2.distinctUntilChanged = distinctUntilChanged2;
    function defaultCompare(a, b) {
      return a === b;
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x2, y) {
        return compare ? compare(x2[key], y[key]) : x2[key] === y[key];
      });
    }
    exports2.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports2.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i2) {
          return i2 === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports2.elementAt = elementAt;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values))));
      };
    }
    exports2.endWith = endWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports2.every = every;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a, i2) {
            return innerFrom_1.innerFrom(project(a, i2)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i2, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports2.exhaustMap = exhaustMap;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports2.exhaustAll = exhaustAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports2.exhaust = exhaustAll_1.exhaustAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand2(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports2.expand = expand2;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports2.finalize = finalize;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFind = exports2.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports2.find = find;
    function createFind(predicate, thisArg, emit) {
      var findIndex = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i2 = index++;
          if (predicate.call(thisArg, value, i2, source)) {
            subscriber.next(findIndex ? i2 : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports2.createFind = createFind;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports2.findIndex = findIndex;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first2(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i2) {
          return predicate(v, i2, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports2.first = first2;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports2.groupBy = groupBy;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports2.isEmpty = isEmpty;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports2.takeLast = takeLast;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i2) {
          return predicate(v, i2, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports2.last = last;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports2.materialize = materialize;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y) {
        return comparer(x2, y) > 0 ? x2 : y;
      } : function(x2, y) {
        return x2 > y ? x2 : y;
      });
    }
    exports2.max = max2;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports2.flatMap = mergeMap_1.mergeMap;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports2.mergeMapTo = mergeMapTo;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports2.mergeScan = mergeScan;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports2.merge = merge;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports2.mergeWith = mergeWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y) {
        return comparer(x2, y) < 0 ? x2 : y;
      } : function(x2, y) {
        return x2 < y ? x2 : y;
      });
    }
    exports2.min = min;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports2.multicast = multicast;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onErrorResumeNext = exports2.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources)));
      };
    }
    exports2.onErrorResumeNextWith = onErrorResumeNextWith;
    exports2.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports2.pairwise = pairwise;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pluck = void 0;
    var map_1 = require_map();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length = properties.length;
      if (length === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x2) {
        var currentProp = x2;
        for (var i2 = 0; i2 < length; i2++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports2.pluck = pluck;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports2.publish = publish;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports2.publishBehavior = publishBehavior;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports2.publishLast = publishLast;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay3(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports2.publishReplay = publishReplay3;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
      });
    }
    exports2.raceWith = raceWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat(countOrConfig) {
      var _a;
      var count = Infinity;
      var delay;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
        } else {
          count = countOrConfig;
        }
      }
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay != null) {
            var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports2.repeat = repeat;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports2.repeatWhen = repeatWhen;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config3;
      if (configOrCount && typeof configOrCount === "object") {
        config3 = configOrCount;
      } else {
        config3 = {
          count: configOrCount
        };
      }
      var _a = config3.count, count = _a === void 0 ? Infinity : _a, delay = config3.delay, _b = config3.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay != null) {
                var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports2.retry = retry;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports2.retryWhen = retryWhen;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports2.sample = sample;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports2.sampleTime = sampleTime;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports2.scan = scan;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports2.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount3 = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount3++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount3--;
            if (refCount3 === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount3 > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports2.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
    }
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount3 = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount3 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount3
      });
    }
    exports2.shareReplay = shareReplay;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports2.single = single;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skip = void 0;
    var filter_1 = require_filter();
    function skip(count) {
      return filter_1.filter(function(_, index) {
        return count <= index;
      });
    }
    exports2.skip = skip;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports2.skipLast = skipLast;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports2.skipUntil = skipUntil;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports2.skipWhile = skipWhile;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith5() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports2.startWith = startWith5;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap51(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports2.switchMap = switchMap51;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports2.switchAll = switchAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports2.switchMapTo = switchMapTo;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports2.switchScan = switchScan;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports2.takeUntil = takeUntil;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports2.takeWhile = takeWhile;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap8(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports2.tap = tap8;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttle = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function throttle(durationSelector, config3) {
      return lift_1.operate(function(source, subscriber) {
        var _a = config3 !== null && config3 !== void 0 ? config3 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports2.throttle = throttle;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config3) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config3);
    }
    exports2.throttleTime = throttleTime;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeInterval = exports2.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last;
          last = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports2.timeInterval = timeInterval;
    var TimeInterval = /* @__PURE__ */ function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports2.TimeInterval = TimeInterval;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first2;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first2 = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first: first2,
        each,
        scheduler,
        with: _with
      });
    }
    exports2.timeoutWith = timeoutWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports2.timestamp = timestamp;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function window2(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports2.window = window2;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          var c = count - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports2.windowCount = windowCount;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window2 = record.window, subs = record.subs;
          window2.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window2 = _a2.window;
            return cb(window2);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports2.windowTime = windowTime;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i2 >= o.length) o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window2 = new Subject_1.Subject();
          windows.push(window2);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window2);
            window2.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window2.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports2.windowToggle = windowToggle;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window2;
        var closingSubscriber;
        var handleError = function(err) {
          window2.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 === null || window2 === void 0 ? void 0 : window2.complete();
          window2 = new Subject_1.Subject();
          subscriber.next(window2.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window2.next(value);
        }, function() {
          window2.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 = null;
        }));
      });
    }
    exports2.windowWhen = windowWhen;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i3) {
          innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i3] = value;
            if (!ready && !hasValue[i3]) {
              hasValue[i3] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i2 = 0; i2 < len; i2++) {
          _loop_1(i2);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray([value], __read(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
          }
        }));
      });
    }
    exports2.withLatestFrom = withLatestFrom;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports2.zipAll = zipAll;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
      });
    }
    exports2.zip = zip;
  }
});

// ../../node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "../../node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i2 = m2.call(o), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from4) {
      for (var i2 = 0, il = from4.length, j = to.length; i2 < il; i2++, j++)
        to[j] = from4[i2];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
    }
    exports2.zipWith = zipWith;
  }
});

// ../../node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/rxjs/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = exports2.iif = exports2.generate = exports2.fromEventPattern = exports2.fromEvent = exports2.from = exports2.forkJoin = exports2.empty = exports2.defer = exports2.connectable = exports2.concat = exports2.combineLatest = exports2.bindNodeCallback = exports2.bindCallback = exports2.UnsubscriptionError = exports2.TimeoutError = exports2.SequenceError = exports2.ObjectUnsubscribedError = exports2.NotFoundError = exports2.EmptyError = exports2.ArgumentOutOfRangeError = exports2.firstValueFrom = exports2.lastValueFrom = exports2.isObservable = exports2.identity = exports2.noop = exports2.pipe = exports2.NotificationKind = exports2.Notification = exports2.Subscriber = exports2.Subscription = exports2.Scheduler = exports2.VirtualAction = exports2.VirtualTimeScheduler = exports2.animationFrameScheduler = exports2.animationFrame = exports2.queueScheduler = exports2.queue = exports2.asyncScheduler = exports2.async = exports2.asapScheduler = exports2.asap = exports2.AsyncSubject = exports2.ReplaySubject = exports2.BehaviorSubject = exports2.Subject = exports2.animationFrames = exports2.observable = exports2.ConnectableObservable = exports2.Observable = void 0;
    exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.combineLatestWith = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = exports2.config = exports2.NEVER = exports2.EMPTY = exports2.scheduled = exports2.zip = exports2.using = exports2.timer = exports2.throwError = exports2.range = exports2.race = exports2.partition = exports2.pairs = exports2.onErrorResumeNext = exports2.of = exports2.never = exports2.merge = void 0;
    exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.pairwise = exports2.onErrorResumeNextWith = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = exports2.mergeAll = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = void 0;
    exports2.zipWith = exports2.zipAll = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports2, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports2, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports2, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports2, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports2, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports2, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports2, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports2, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports2, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports2, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports2, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports2, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports2, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports2, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports2, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports2, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports2, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports2, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports2, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports2, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports2, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports2, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports2, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports2, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports2, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports2, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports2, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports2, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports2, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports2, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports2, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports2, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports2, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports2, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports2, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports2, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports2, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports2, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports2, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from();
    Object.defineProperty(exports2, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports2, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports2, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports2, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports2, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports2, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports2, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports2, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports2, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports2, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports2, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports2, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports2, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(require_types(), exports2);
    var config_1 = require_config();
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// ../../node_modules/@polkadot/api/util/logging.js
var l4;
var init_logging = __esm({
  "../../node_modules/@polkadot/api/util/logging.js"() {
    init_util();
    l4 = /* @__PURE__ */ logger("api/util");
  }
});

// ../../node_modules/@polkadot/api/util/filterEvents.js
function filterEvents(txHash, { block: { extrinsics, header } }, allEvents, status) {
  for (const [txIndex, x2] of extrinsics.entries()) {
    if (x2.hash.eq(txHash)) {
      return {
        blockNumber: isCompact(header.number) ? header.number.unwrap() : header.number,
        events: allEvents.filter(({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eqn(txIndex)),
        txIndex
      };
    }
  }
  if (status.isInBlock) {
    const allHashes = extrinsics.map((x2) => x2.hash.toHex());
    l4.warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${txHash.toHex()} inside ${allHashes.join(", ")}`);
  }
  return {};
}
var init_filterEvents = __esm({
  "../../node_modules/@polkadot/api/util/filterEvents.js"() {
    init_util();
    init_logging();
  }
});

// ../../node_modules/@polkadot/api/util/isKeyringPair.js
function isKeyringPair(account3) {
  return isFunction(account3.sign);
}
var init_isKeyringPair = __esm({
  "../../node_modules/@polkadot/api/util/isKeyringPair.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/api-derive/packageDetect.js
var init_packageDetect10 = __esm({
  "../../node_modules/@polkadot/api-derive/packageDetect.js"() {
    init_util();
    init_packageInfo();
    detectPackage(packageInfo, null, []);
  }
});

// ../../node_modules/@polkadot/rpc-core/packageDetect.js
var init_packageDetect11 = __esm({
  "../../node_modules/@polkadot/rpc-core/packageDetect.js"() {
    init_packageInfo3();
    init_packageInfo4();
    init_util();
    init_packageInfo2();
    detectPackage(packageInfo2, null, [packageInfo3, packageInfo4]);
  }
});

// ../../node_modules/@polkadot/types-codec/packageInfo.js
var import_meta20, packageInfo20;
var init_packageInfo20 = __esm({
  "../../node_modules/@polkadot/types-codec/packageInfo.js"() {
    import_meta20 = {};
    packageInfo20 = { name: "@polkadot/types-codec", path: import_meta20 && import_meta20.url ? new URL(import_meta20.url).pathname.substring(0, new URL(import_meta20.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/types-create/packageInfo.js
var import_meta21, packageInfo21;
var init_packageInfo21 = __esm({
  "../../node_modules/@polkadot/types-create/packageInfo.js"() {
    import_meta21 = {};
    packageInfo21 = { name: "@polkadot/types-create", path: import_meta21 && import_meta21.url ? new URL(import_meta21.url).pathname.substring(0, new URL(import_meta21.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "15.0.1" };
  }
});

// ../../node_modules/@polkadot/types/packageDetect.js
var init_packageDetect12 = __esm({
  "../../node_modules/@polkadot/types/packageDetect.js"() {
    init_packageInfo20();
    init_packageInfo21();
    init_util();
    init_packageInfo4();
    detectPackage(packageInfo4, null, [packageInfo20, packageInfo21]);
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/hashers.js
var AllHashers;
var init_hashers = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/hashers.js"() {
    AllHashers = {
      Blake2_128: null,
      // eslint-disable-line camelcase
      Blake2_256: null,
      // eslint-disable-line camelcase
      Blake2_128Concat: null,
      // eslint-disable-line camelcase
      Twox128: null,
      Twox256: null,
      Twox64Concat: null,
      // new in v11
      Identity: null
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/runtime.js
var META_V1_TO_V2, runtime;
var init_runtime = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/runtime.js"() {
    META_V1_TO_V2 = {
      metadata: {
        description: "Returns the metadata of a runtime",
        params: [],
        type: "OpaqueMetadata"
      }
    };
    runtime = {
      Metadata: [
        {
          methods: {
            metadata_at_version: {
              description: "Returns the metadata at a given version.",
              params: [
                {
                  name: "version",
                  type: "u32"
                }
              ],
              type: "Option<OpaqueMetadata>"
            },
            metadata_versions: {
              description: "Returns the supported metadata versions.",
              params: [],
              type: "Vec<u32>"
            },
            ...META_V1_TO_V2
          },
          version: 2
        },
        {
          methods: {
            ...META_V1_TO_V2
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v9.js
var v9;
var init_v9 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v9.js"() {
    v9 = {
      // v9
      ErrorMetadataV9: {
        name: "Text",
        docs: "Vec<Text>"
      },
      EventMetadataV9: {
        name: "Text",
        args: "Vec<Type>",
        docs: "Vec<Text>"
      },
      FunctionArgumentMetadataV9: {
        name: "Text",
        type: "Type"
      },
      FunctionMetadataV9: {
        name: "Text",
        args: "Vec<FunctionArgumentMetadataV9>",
        docs: "Vec<Text>"
      },
      MetadataV9: {
        modules: "Vec<ModuleMetadataV9>"
      },
      ModuleConstantMetadataV9: {
        name: "Text",
        type: "Type",
        value: "Bytes",
        docs: "Vec<Text>"
      },
      ModuleMetadataV9: {
        name: "Text",
        storage: "Option<StorageMetadataV9>",
        calls: "Option<Vec<FunctionMetadataV9>>",
        events: "Option<Vec<EventMetadataV9>>",
        constants: "Vec<ModuleConstantMetadataV9>",
        errors: "Vec<ErrorMetadataV9>"
      },
      StorageEntryMetadataV9: {
        name: "Text",
        modifier: "StorageEntryModifierV9",
        type: "StorageEntryTypeV9",
        fallback: "Bytes",
        docs: "Vec<Text>"
      },
      StorageEntryModifierV9: {
        _enum: ["Optional", "Default", "Required"]
      },
      StorageEntryTypeV9: {
        _enum: {
          Plain: "Type",
          Map: {
            hasher: "StorageHasherV9",
            key: "Type",
            value: "Type",
            linked: "bool"
          },
          DoubleMap: {
            hasher: "StorageHasherV9",
            key1: "Type",
            key2: "Type",
            value: "Type",
            key2Hasher: "StorageHasherV9"
          }
        }
      },
      StorageHasherV9: {
        _enum: {
          Blake2_128: null,
          // eslint-disable-line camelcase
          Blake2_256: null,
          // eslint-disable-line camelcase
          Twox128: null,
          Twox256: null,
          Twox64Concat: null
        }
      },
      StorageMetadataV9: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV9>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v10.js
var v10;
var init_v10 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v10.js"() {
    v10 = {
      // v10
      ErrorMetadataV10: "ErrorMetadataV9",
      EventMetadataV10: "EventMetadataV9",
      FunctionArgumentMetadataV10: "FunctionArgumentMetadataV9",
      FunctionMetadataV10: "FunctionMetadataV9",
      MetadataV10: {
        modules: "Vec<ModuleMetadataV10>"
      },
      ModuleConstantMetadataV10: "ModuleConstantMetadataV9",
      ModuleMetadataV10: {
        name: "Text",
        storage: "Option<StorageMetadataV10>",
        calls: "Option<Vec<FunctionMetadataV10>>",
        events: "Option<Vec<EventMetadataV10>>",
        constants: "Vec<ModuleConstantMetadataV10>",
        errors: "Vec<ErrorMetadataV10>"
      },
      StorageEntryModifierV10: "StorageEntryModifierV9",
      StorageEntryMetadataV10: {
        name: "Text",
        modifier: "StorageEntryModifierV10",
        type: "StorageEntryTypeV10",
        fallback: "Bytes",
        docs: "Vec<Text>"
      },
      StorageEntryTypeV10: {
        _enum: {
          Plain: "Type",
          Map: {
            hasher: "StorageHasherV10",
            key: "Type",
            value: "Type",
            linked: "bool"
          },
          DoubleMap: {
            hasher: "StorageHasherV10",
            key1: "Type",
            key2: "Type",
            value: "Type",
            key2Hasher: "StorageHasherV10"
          }
        }
      },
      StorageMetadataV10: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV10>"
      },
      StorageHasherV10: {
        _enum: {
          Blake2_128: null,
          // eslint-disable-line camelcase
          Blake2_256: null,
          // eslint-disable-line camelcase
          Blake2_128Concat: null,
          // eslint-disable-line camelcase
          Twox128: null,
          Twox256: null,
          Twox64Concat: null
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v11.js
var v11;
var init_v11 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v11.js"() {
    init_hashers();
    v11 = {
      // v11
      ErrorMetadataV11: "ErrorMetadataV10",
      EventMetadataV11: "EventMetadataV10",
      ExtrinsicMetadataV11: {
        version: "u8",
        signedExtensions: "Vec<Text>"
      },
      FunctionArgumentMetadataV11: "FunctionArgumentMetadataV10",
      FunctionMetadataV11: "FunctionMetadataV10",
      MetadataV11: {
        modules: "Vec<ModuleMetadataV11>",
        extrinsic: "ExtrinsicMetadataV11"
      },
      ModuleConstantMetadataV11: "ModuleConstantMetadataV10",
      ModuleMetadataV11: {
        name: "Text",
        storage: "Option<StorageMetadataV11>",
        calls: "Option<Vec<FunctionMetadataV11>>",
        events: "Option<Vec<EventMetadataV11>>",
        constants: "Vec<ModuleConstantMetadataV11>",
        errors: "Vec<ErrorMetadataV11>"
      },
      StorageEntryModifierV11: "StorageEntryModifierV10",
      StorageEntryMetadataV11: {
        name: "Text",
        modifier: "StorageEntryModifierV11",
        type: "StorageEntryTypeV11",
        fallback: "Bytes",
        docs: "Vec<Text>"
      },
      StorageEntryTypeV11: {
        _enum: {
          Plain: "Type",
          Map: {
            hasher: "StorageHasherV11",
            key: "Type",
            value: "Type",
            linked: "bool"
          },
          DoubleMap: {
            hasher: "StorageHasherV11",
            key1: "Type",
            key2: "Type",
            value: "Type",
            key2Hasher: "StorageHasherV11"
          }
        }
      },
      StorageMetadataV11: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV11>"
      },
      StorageHasherV11: {
        _enum: AllHashers
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v12.js
var v12;
var init_v12 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v12.js"() {
    v12 = {
      // v12
      ErrorMetadataV12: "ErrorMetadataV11",
      EventMetadataV12: "EventMetadataV11",
      ExtrinsicMetadataV12: "ExtrinsicMetadataV11",
      FunctionArgumentMetadataV12: "FunctionArgumentMetadataV11",
      FunctionMetadataV12: "FunctionMetadataV11",
      MetadataV12: {
        modules: "Vec<ModuleMetadataV12>",
        extrinsic: "ExtrinsicMetadataV12"
      },
      ModuleConstantMetadataV12: "ModuleConstantMetadataV11",
      ModuleMetadataV12: {
        name: "Text",
        storage: "Option<StorageMetadataV12>",
        calls: "Option<Vec<FunctionMetadataV12>>",
        events: "Option<Vec<EventMetadataV12>>",
        constants: "Vec<ModuleConstantMetadataV12>",
        errors: "Vec<ErrorMetadataV12>",
        index: "u8"
      },
      StorageEntryModifierV12: "StorageEntryModifierV11",
      StorageEntryMetadataV12: "StorageEntryMetadataV11",
      StorageEntryTypeV12: "StorageEntryTypeV11",
      StorageMetadataV12: "StorageMetadataV11",
      StorageHasherV12: "StorageHasherV11"
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v13.js
var v13;
var init_v13 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v13.js"() {
    v13 = {
      // v13
      ErrorMetadataV13: "ErrorMetadataV12",
      EventMetadataV13: "EventMetadataV12",
      ExtrinsicMetadataV13: "ExtrinsicMetadataV12",
      FunctionArgumentMetadataV13: "FunctionArgumentMetadataV12",
      FunctionMetadataV13: "FunctionMetadataV12",
      MetadataV13: {
        modules: "Vec<ModuleMetadataV13>",
        extrinsic: "ExtrinsicMetadataV13"
      },
      ModuleConstantMetadataV13: "ModuleConstantMetadataV12",
      ModuleMetadataV13: {
        name: "Text",
        storage: "Option<StorageMetadataV13>",
        calls: "Option<Vec<FunctionMetadataV13>>",
        events: "Option<Vec<EventMetadataV13>>",
        constants: "Vec<ModuleConstantMetadataV13>",
        errors: "Vec<ErrorMetadataV13>",
        index: "u8"
      },
      StorageEntryModifierV13: "StorageEntryModifierV12",
      StorageEntryMetadataV13: {
        name: "Text",
        modifier: "StorageEntryModifierV13",
        type: "StorageEntryTypeV13",
        fallback: "Bytes",
        docs: "Vec<Text>"
      },
      StorageEntryTypeV13: {
        _enum: {
          Plain: "Type",
          Map: {
            hasher: "StorageHasherV13",
            key: "Type",
            value: "Type",
            linked: "bool"
          },
          DoubleMap: {
            hasher: "StorageHasherV13",
            key1: "Type",
            key2: "Type",
            value: "Type",
            key2Hasher: "StorageHasherV13"
          },
          NMap: {
            keyVec: "Vec<Type>",
            hashers: "Vec<StorageHasherV13>",
            value: "Type"
          }
        }
      },
      StorageMetadataV13: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV13>"
      },
      StorageHasherV13: "StorageHasherV12"
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/scaleInfo/v1.js
var Si1Variant, v1;
var init_v1 = __esm({
  "../../node_modules/@polkadot/types/interfaces/scaleInfo/v1.js"() {
    Si1Variant = {
      name: "Text",
      fields: "Vec<Si1Field>",
      index: "u8",
      docs: "Vec<Text>"
    };
    v1 = {
      Si1Field: {
        name: "Option<Text>",
        type: "Si1LookupTypeId",
        typeName: "Option<Text>",
        docs: "Vec<Text>"
      },
      Si1LookupTypeId: "Compact<u32>",
      Si1Path: "Si0Path",
      Si1Type: {
        path: "Si1Path",
        params: "Vec<Si1TypeParameter>",
        def: "Si1TypeDef",
        docs: "Vec<Text>"
      },
      Si1TypeDef: {
        _enum: {
          Composite: "Si1TypeDefComposite",
          Variant: "Si1TypeDefVariant",
          Sequence: "Si1TypeDefSequence",
          Array: "Si1TypeDefArray",
          Tuple: "Si1TypeDefTuple",
          Primitive: "Si1TypeDefPrimitive",
          Compact: "Si1TypeDefCompact",
          BitSequence: "Si1TypeDefBitSequence",
          // NOTE: This is specific to the implementation for pre-v14 metadata
          // compatibility (always keep this as the last entry in the enum)
          HistoricMetaCompat: "Type"
        }
      },
      Si1TypeDefArray: {
        len: "u32",
        type: "Si1LookupTypeId"
      },
      Si1TypeDefBitSequence: {
        bitStoreType: "Si1LookupTypeId",
        bitOrderType: "Si1LookupTypeId"
      },
      Si1TypeDefCompact: {
        type: "Si1LookupTypeId"
      },
      Si1TypeDefComposite: {
        fields: "Vec<Si1Field>"
      },
      Si1TypeDefPrimitive: "Si0TypeDefPrimitive",
      Si1TypeDefSequence: {
        type: "Si1LookupTypeId"
      },
      Si1TypeDefTuple: "Vec<Si1LookupTypeId>",
      Si1TypeParameter: {
        name: "Text",
        type: "Option<Si1LookupTypeId>"
      },
      Si1TypeDefVariant: {
        variants: "Vec<Si1Variant>"
      },
      Si1Variant
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v14.js
var v14;
var init_v14 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v14.js"() {
    init_v1();
    v14 = {
      // registry
      PortableTypeV14: {
        id: "Si1LookupTypeId",
        type: "Si1Type"
      },
      // compatibility with earlier layouts, i.e. don't break previous users
      ErrorMetadataV14: {
        ...Si1Variant,
        args: "Vec<Type>"
      },
      EventMetadataV14: {
        ...Si1Variant,
        args: "Vec<Type>"
      },
      FunctionArgumentMetadataV14: {
        name: "Text",
        type: "Type",
        typeName: "Option<Type>"
      },
      FunctionMetadataV14: {
        ...Si1Variant,
        args: "Vec<FunctionArgumentMetadataV14>"
      },
      // V14
      ExtrinsicMetadataV14: {
        type: "SiLookupTypeId",
        version: "u8",
        signedExtensions: "Vec<SignedExtensionMetadataV14>"
      },
      MetadataV14: {
        lookup: "PortableRegistry",
        pallets: "Vec<PalletMetadataV14>",
        extrinsic: "ExtrinsicMetadataV14",
        type: "SiLookupTypeId"
      },
      PalletCallMetadataV14: {
        type: "SiLookupTypeId"
      },
      PalletConstantMetadataV14: {
        name: "Text",
        type: "SiLookupTypeId",
        value: "Bytes",
        docs: "Vec<Text>"
      },
      PalletErrorMetadataV14: {
        type: "SiLookupTypeId"
      },
      PalletEventMetadataV14: {
        type: "SiLookupTypeId"
      },
      PalletMetadataV14: {
        name: "Text",
        storage: "Option<PalletStorageMetadataV14>",
        calls: "Option<PalletCallMetadataV14>",
        events: "Option<PalletEventMetadataV14>",
        constants: "Vec<PalletConstantMetadataV14>",
        errors: "Option<PalletErrorMetadataV14>",
        index: "u8"
      },
      PalletStorageMetadataV14: {
        prefix: "Text",
        // NOTE: Renamed from entries
        items: "Vec<StorageEntryMetadataV14>"
      },
      SignedExtensionMetadataV14: {
        identifier: "Text",
        type: "SiLookupTypeId",
        additionalSigned: "SiLookupTypeId"
      },
      StorageEntryMetadataV14: {
        name: "Text",
        modifier: "StorageEntryModifierV14",
        type: "StorageEntryTypeV14",
        fallback: "Bytes",
        docs: "Vec<Text>"
      },
      StorageEntryModifierV14: "StorageEntryModifierV13",
      StorageEntryTypeV14: {
        _enum: {
          Plain: "SiLookupTypeId",
          Map: {
            hashers: "Vec<StorageHasherV14>",
            key: "SiLookupTypeId",
            // NOTE: Renamed from "keys"
            value: "SiLookupTypeId"
          }
        }
      },
      StorageHasherV14: "StorageHasherV13"
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/v15.js
var v15;
var init_v15 = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/v15.js"() {
    v15 = {
      // new/adjusted in v15
      CustomMetadata15: {
        map: "BTreeMap<Text, CustomValueMetadata15>"
      },
      CustomValueMetadata15: {
        type: "SiLookupTypeId",
        value: "Bytes"
      },
      ExtrinsicMetadataV15: {
        version: "u8",
        addressType: "SiLookupTypeId",
        callType: "SiLookupTypeId",
        signatureType: "SiLookupTypeId",
        extraType: "SiLookupTypeId",
        signedExtensions: "Vec<SignedExtensionMetadataV14>"
      },
      OuterEnums15: {
        callType: "SiLookupTypeId",
        eventType: "SiLookupTypeId",
        errorType: "SiLookupTypeId"
      },
      PalletMetadataV15: {
        name: "Text",
        storage: "Option<PalletStorageMetadataV14>",
        calls: "Option<PalletCallMetadataV14>",
        events: "Option<PalletEventMetadataV14>",
        constants: "Vec<PalletConstantMetadataV14>",
        errors: "Option<PalletErrorMetadataV14>",
        index: "u8",
        docs: "Vec<Text>"
      },
      RuntimeApiMetadataV15: {
        name: "Text",
        methods: "Vec<RuntimeApiMethodMetadataV15>",
        docs: "Vec<Text>"
      },
      RuntimeApiMethodMetadataV15: {
        name: "Text",
        inputs: "Vec<RuntimeApiMethodParamMetadataV15>",
        output: "SiLookupTypeId",
        docs: "Vec<Text>"
      },
      RuntimeApiMethodParamMetadataV15: {
        name: "Text",
        type: "SiLookupTypeId"
      },
      // actual v15 definition
      MetadataV15: {
        lookup: "PortableRegistry",
        pallets: "Vec<PalletMetadataV15>",
        extrinsic: "ExtrinsicMetadataV15",
        type: "SiLookupTypeId",
        apis: "Vec<RuntimeApiMetadataV15>",
        outerEnums: "OuterEnums15",
        custom: "CustomMetadata15"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/metadata/definitions.js
var definitions_default;
var init_definitions = __esm({
  "../../node_modules/@polkadot/types/interfaces/metadata/definitions.js"() {
    init_runtime();
    init_v9();
    init_v10();
    init_v11();
    init_v12();
    init_v13();
    init_v14();
    init_v15();
    definitions_default = {
      rpc: {},
      runtime,
      types: {
        // all known
        ...v9,
        ...v10,
        ...v11,
        ...v12,
        ...v13,
        ...v14,
        ...v15,
        // latest mappings
        // NOTE: For v15, we only added the runtime defintions,
        // hence latest for most pointing to the previous V14
        ErrorMetadataLatest: "ErrorMetadataV14",
        EventMetadataLatest: "EventMetadataV14",
        ExtrinsicMetadataLatest: "ExtrinsicMetadataV15",
        FunctionArgumentMetadataLatest: "FunctionArgumentMetadataV14",
        FunctionMetadataLatest: "FunctionMetadataV14",
        MetadataLatest: "MetadataV15",
        PalletCallMetadataLatest: "PalletCallMetadataV14",
        PalletConstantMetadataLatest: "PalletConstantMetadataV14",
        PalletErrorMetadataLatest: "PalletErrorMetadataV14",
        PalletEventMetadataLatest: "PalletEventMetadataV14",
        PalletMetadataLatest: "PalletMetadataV15",
        PalletStorageMetadataLatest: "PalletStorageMetadataV14",
        PortableType: "PortableTypeV14",
        RuntimeApiMetadataLatest: "RuntimeApiMetadataV15",
        SignedExtensionMetadataLatest: "SignedExtensionMetadataV14",
        StorageEntryMetadataLatest: "StorageEntryMetadataV14",
        StorageEntryModifierLatest: "StorageEntryModifierV14",
        StorageEntryTypeLatest: "StorageEntryTypeV14",
        StorageHasher: "StorageHasherV14",
        // additional types
        OpaqueMetadata: "Opaque<Bytes>",
        // the enum containing all the mappings
        MetadataAll: {
          _enum: {
            V0: "DoNotConstruct<MetadataV0>",
            V1: "DoNotConstruct<MetadataV1>",
            V2: "DoNotConstruct<MetadataV2>",
            V3: "DoNotConstruct<MetadataV3>",
            V4: "DoNotConstruct<MetadataV4>",
            V5: "DoNotConstruct<MetadataV5>",
            V6: "DoNotConstruct<MetadataV6>",
            V7: "DoNotConstruct<MetadataV7>",
            V8: "DoNotConstruct<MetadataV8>",
            // First version on Kusama in V9, dropping will be problematic
            V9: "MetadataV9",
            V10: "MetadataV10",
            V11: "MetadataV11",
            V12: "MetadataV12",
            V13: "MetadataV13",
            V14: "MetadataV14",
            V15: "MetadataV15"
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/runtime/runtime.js
var CORE_V1_TO_V4, CORE_V1_TO_V2, CORE_V2_TO_V4, CORE_V4_VERSION, CORE_V4_TO_V5, runtime2;
var init_runtime2 = __esm({
  "../../node_modules/@polkadot/types/interfaces/runtime/runtime.js"() {
    CORE_V1_TO_V4 = {
      execute_block: {
        description: "Execute the given block.",
        params: [
          {
            name: "block",
            type: "Block"
          }
        ],
        type: "Null"
      }
    };
    CORE_V1_TO_V2 = {
      version: {
        description: "Returns the version of the runtime.",
        params: [],
        type: "RuntimeVersionPre3"
      }
    };
    CORE_V2_TO_V4 = {
      initialize_block: {
        description: "Initialize a block with the given header.",
        params: [
          {
            name: "header",
            type: "Header"
          }
        ],
        type: "Null"
      }
    };
    CORE_V4_VERSION = {
      version: {
        description: "Returns the version of the runtime.",
        params: [],
        type: "RuntimeVersion"
      }
    };
    CORE_V4_TO_V5 = {
      ...CORE_V1_TO_V4,
      initialize_block: {
        description: "Initialize a block with the given header.",
        params: [
          {
            name: "header",
            type: "Header"
          }
        ],
        type: "ExtrinsicInclusionMode"
      }
    };
    runtime2 = {
      Core: [
        {
          methods: {
            ...CORE_V4_VERSION,
            ...CORE_V4_TO_V5
          },
          version: 5
        },
        {
          methods: {
            ...CORE_V4_VERSION,
            ...CORE_V1_TO_V4,
            ...CORE_V2_TO_V4
          },
          version: 4
        },
        {
          methods: {
            version: {
              description: "Returns the version of the runtime.",
              params: [],
              type: "RuntimeVersionPre4"
            },
            ...CORE_V1_TO_V4,
            ...CORE_V2_TO_V4
          },
          version: 3
        },
        {
          methods: {
            ...CORE_V1_TO_V2,
            ...CORE_V1_TO_V4,
            ...CORE_V2_TO_V4
          },
          version: 2
        },
        {
          methods: {
            initialise_block: {
              description: "Initialize a block with the given header.",
              params: [
                {
                  name: "header",
                  type: "Header"
                }
              ],
              type: "Null"
            },
            ...CORE_V1_TO_V2,
            ...CORE_V1_TO_V4
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/runtime/definitions.js
var numberTypes, knownOrigins, definitions_default2;
var init_definitions2 = __esm({
  "../../node_modules/@polkadot/types/interfaces/runtime/definitions.js"() {
    init_runtime2();
    numberTypes = {
      Fixed64: "Int<64, Fixed64>",
      FixedI64: "Int<64, FixedI64>",
      FixedU64: "UInt<64, FixedU64>",
      Fixed128: "Int<128, Fixed128>",
      FixedI128: "Int<128, FixedI128>",
      FixedU128: "UInt<128, FixedU128>",
      I32F32: "Int<64, I32F32>",
      U32F32: "UInt<64, U32F32>",
      PerU16: "UInt<16, PerU16>",
      Perbill: "UInt<32, Perbill>",
      Percent: "UInt<8, Percent>",
      Permill: "UInt<32, Permill>",
      Perquintill: "UInt<64, Perquintill>"
    };
    knownOrigins = {
      //
      // (1) Defaults from Substrate
      //
      Council: "CollectiveOrigin",
      System: "SystemOrigin",
      TechnicalCommittee: "CollectiveOrigin",
      //
      // (2) Defaults from Polkadot
      //
      Xcm: "XcmOrigin",
      XcmPallet: "XcmOrigin",
      //
      // (3) Defaults from Acala
      //
      Authority: "AuthorityOrigin",
      GeneralCouncil: "CollectiveOrigin"
    };
    definitions_default2 = {
      rpc: {},
      runtime: runtime2,
      types: {
        ...numberTypes,
        AccountId: "AccountId32",
        AccountId20: "GenericEthereumAccountId",
        AccountId32: "GenericAccountId32",
        AccountId33: "GenericAccountId33",
        AccountIdOf: "AccountId",
        AccountIndex: "GenericAccountIndex",
        Address: "MultiAddress",
        AssetId: "u32",
        Balance: "UInt<128, Balance>",
        BalanceOf: "Balance",
        Block: "GenericBlock",
        BlockNumber: "u32",
        BlockNumberFor: "BlockNumber",
        BlockNumberOf: "BlockNumber",
        Call: "GenericCall",
        CallHash: "Hash",
        CallHashOf: "CallHash",
        ChangesTrieConfiguration: {
          digestInterval: "u32",
          digestLevels: "u32"
        },
        ChangesTrieSignal: {
          _enum: {
            NewConfiguration: "Option<ChangesTrieConfiguration>"
          }
        },
        ConsensusEngineId: "GenericConsensusEngineId",
        CodecHash: "Hash",
        CrateVersion: {
          major: "u16",
          minor: "u8",
          patch: "u8"
        },
        Digest: {
          logs: "Vec<DigestItem>"
        },
        DigestItem: {
          _enum: {
            Other: "Bytes",
            // 0
            AuthoritiesChange: "Vec<AuthorityId>",
            // 1
            ChangesTrieRoot: "Hash",
            // 2
            SealV0: "SealV0",
            // 3
            Consensus: "Consensus",
            // 4
            Seal: "Seal",
            // 5
            PreRuntime: "PreRuntime",
            // 6
            ChangesTrieSignal: "ChangesTrieSignal",
            // 7
            RuntimeEnvironmentUpdated: "Null"
            // 8
          }
        },
        ExtrinsicsWeight: {
          normal: "Weight",
          operational: "Weight"
        },
        H32: "[u8; 4; H32]",
        H64: "[u8; 8; H64]",
        H128: "[u8; 16; H128]",
        H160: "[u8; 20; H160]",
        H256: "[u8; 32; H256]",
        H512: "[u8; 64; H512]",
        H1024: "[u8; 128; H1024]",
        H2048: "[u8; 256; H2048]",
        Hash: "H256",
        Header: {
          parentHash: "Hash",
          number: "Compact<BlockNumber>",
          stateRoot: "Hash",
          extrinsicsRoot: "Hash",
          digest: "Digest"
        },
        HeaderPartial: {
          parentHash: "Hash",
          // since we only parse JSON with this, having non-compact works
          number: "BlockNumber"
        },
        IndicesLookupSource: "GenericLookupSource",
        Index: "u32",
        Justification: "(ConsensusEngineId, EncodedJustification)",
        EncodedJustification: "Bytes",
        Justifications: "Vec<Justification>",
        KeyValue: "(StorageKey, StorageData)",
        KeyTypeId: "u32",
        LockIdentifier: "[u8; 8]",
        LookupSource: "MultiAddress",
        LookupTarget: "AccountId",
        ModuleId: "LockIdentifier",
        MultiAddress: "GenericMultiAddress",
        MultiSigner: {
          _enum: {
            Ed25519: "[u8; 32]",
            Sr25519: "[u8; 32]",
            Ecdsa: "[u8; 33]"
          }
        },
        Moment: "UInt<64, Moment>",
        OpaqueCall: "Bytes",
        Origin: "DoNotConstruct<Origin>",
        OriginCaller: {
          _enum: {
            // this should be dynamically built from the actual modules, based on index
            System: "SystemOrigin"
          }
        },
        PalletId: "LockIdentifier",
        PalletsOrigin: "OriginCaller",
        PalletVersion: {
          major: "u16",
          minor: "u8",
          patch: "u8"
        },
        Pays: {
          _enum: ["Yes", "No"]
        },
        Phantom: "Null",
        PhantomData: "Null",
        Releases: {
          _enum: ["V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10"]
        },
        RuntimeCall: "Call",
        RuntimeEvent: "Event",
        RuntimeDbWeight: {
          read: "Weight",
          write: "Weight"
        },
        SignedBlock: "SignedBlockWithJustifications",
        SignedBlockWithJustification: {
          block: "Block",
          justification: "Option<EncodedJustification>"
        },
        SignedBlockWithJustifications: {
          block: "Block",
          justifications: "Option<Justifications>"
        },
        Slot: "u64",
        SlotDuration: "u64",
        StorageData: "Bytes",
        StorageInfo: {
          palletName: "Bytes",
          storage_name: "Bytes",
          prefix: "Bytes",
          maxValues: "Option<u32>",
          maxSize: "Option<u32>"
        },
        StorageProof: {
          trieNodes: "Vec<Bytes>"
        },
        TransactionPriority: "u64",
        TransactionLongevity: "u64",
        TransactionTag: "Bytes",
        TransactionInfo: {
          _alias: {
            dataSize: "size"
          },
          chunkRoot: "H256",
          contentHash: "H256",
          dataSize: "u32",
          blockChunks: "u32"
        },
        TransactionStorageProof: {
          chunk: "Vec<u8>",
          proof: "Vec<Vec<u8>>"
        },
        ValidatorId: "AccountId",
        ValidatorIdOf: "ValidatorId",
        WeightV0: "u32",
        WeightV1: "u64",
        WeightV2: {
          refTime: "Compact<u64>",
          proofSize: "Compact<u64>"
        },
        Weight: "WeightV2",
        WeightMultiplier: "Fixed64",
        // digest
        PreRuntime: "(ConsensusEngineId, Bytes)",
        SealV0: "(u64, Signature)",
        Seal: "(ConsensusEngineId, Bytes)",
        Consensus: "(ConsensusEngineId, Bytes)",
        // Type when core initialize_block went from v4 to v5
        ExtrinsicInclusionMode: {
          _enum: ["AllExtrinsics", "OnlyInherents"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/scaleInfo/v0.js
var v0;
var init_v0 = __esm({
  "../../node_modules/@polkadot/types/interfaces/scaleInfo/v0.js"() {
    v0 = {
      Si0Field: {
        name: "Option<Text>",
        type: "Si0LookupTypeId",
        typeName: "Option<Text>",
        docs: "Vec<Text>"
      },
      Si0LookupTypeId: "u32",
      Si0Path: "Vec<Text>",
      Si0Type: {
        path: "Si0Path",
        params: "Vec<Si0LookupTypeId>",
        def: "Si0TypeDef"
      },
      Si0TypeDef: {
        _enum: {
          Composite: "Si0TypeDefComposite",
          Variant: "Si0TypeDefVariant",
          Sequence: "Si0TypeDefSequence",
          Array: "Si0TypeDefArray",
          Tuple: "Si0TypeDefTuple",
          Primitive: "Si0TypeDefPrimitive",
          Compact: "Si0TypeDefCompact",
          Phantom: "Si0TypeDefPhantom",
          BitSequence: "Si0TypeDefBitSequence"
        }
      },
      Si0TypeDefArray: {
        len: "u32",
        type: "Si0LookupTypeId"
      },
      Si0TypeDefBitSequence: {
        bitStoreType: "Si0LookupTypeId",
        bitOrderType: "Si0LookupTypeId"
      },
      Si0TypeDefCompact: {
        type: "Si0LookupTypeId"
      },
      Si0TypeDefComposite: {
        fields: "Vec<Si0Field>"
      },
      Si0TypeDefPhantom: "Null",
      Si0TypeDefVariant: {
        variants: "Vec<Si0Variant>"
      },
      Si0TypeDefPrimitive: {
        _enum: ["Bool", "Char", "Str", "U8", "U16", "U32", "U64", "U128", "U256", "I8", "I16", "I32", "I64", "I128", "I256"]
      },
      Si0TypeDefSequence: {
        type: "Si0LookupTypeId"
      },
      Si0TypeDefTuple: "Vec<Si0LookupTypeId>",
      Si0TypeParameter: {
        name: "Text",
        type: "Option<Si0LookupTypeId>"
      },
      Si0Variant: {
        name: "Text",
        fields: "Vec<Si0Field>",
        index: "Option<u8>",
        discriminant: "Option<u64>",
        docs: "Vec<Text>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/scaleInfo/definitions.js
var definitions_default3;
var init_definitions3 = __esm({
  "../../node_modules/@polkadot/types/interfaces/scaleInfo/definitions.js"() {
    init_v0();
    init_v1();
    definitions_default3 = {
      rpc: {},
      types: {
        ...v0,
        ...v1,
        // latest mappings
        SiField: "Si1Field",
        SiLookupTypeId: "Si1LookupTypeId",
        SiPath: "Si1Path",
        SiType: "Si1Type",
        SiTypeDef: "Si1TypeDef",
        SiTypeDefArray: "Si1TypeDefArray",
        SiTypeDefBitSequence: "Si1TypeDefBitSequence",
        SiTypeDefCompact: "Si1TypeDefCompact",
        SiTypeDefComposite: "Si1TypeDefComposite",
        SiTypeDefPrimitive: "Si1TypeDefPrimitive",
        SiTypeDefSequence: "Si1TypeDefSequence",
        SiTypeDefTuple: "Si1TypeDefTuple",
        SiTypeParameter: "Si1TypeParameter",
        SiTypeDefVariant: "Si1TypeDefVariant",
        SiVariant: "Si1Variant"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/essentials.js
var init_essentials = __esm({
  "../../node_modules/@polkadot/types/interfaces/essentials.js"() {
    init_definitions();
    init_definitions2();
    init_definitions3();
  }
});

// ../../node_modules/@polkadot/types/interfaces/assetConversion/runtime.js
var runtime3;
var init_runtime3 = __esm({
  "../../node_modules/@polkadot/types/interfaces/assetConversion/runtime.js"() {
    runtime3 = {
      AssetConversionApi: [
        {
          methods: {
            get_reserves: {
              description: "Get pool reserves",
              params: [
                {
                  name: "asset1",
                  type: "StagingXcmV3MultiLocation"
                },
                {
                  name: "asset2",
                  type: "StagingXcmV3MultiLocation"
                }
              ],
              type: "Option<(Balance,Balance)>"
            },
            quote_price_exact_tokens_for_tokens: {
              description: "Quote price: exact tokens for tokens",
              params: [
                {
                  name: "asset1",
                  type: "StagingXcmV3MultiLocation"
                },
                {
                  name: "asset2",
                  type: "StagingXcmV3MultiLocation"
                },
                {
                  name: "amount",
                  type: "u128"
                },
                {
                  name: "include_fee",
                  type: "bool"
                }
              ],
              type: "Option<(Balance)>"
            },
            quote_price_tokens_for_exact_tokens: {
              description: "Quote price: tokens for exact tokens",
              params: [
                {
                  name: "asset1",
                  type: "StagingXcmV3MultiLocation"
                },
                {
                  name: "asset2",
                  type: "StagingXcmV3MultiLocation"
                },
                {
                  name: "amount",
                  type: "u128"
                },
                {
                  name: "include_fee",
                  type: "bool"
                }
              ],
              type: "Option<(Balance)>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/assetConversion/definitions.js
var definitions_default4;
var init_definitions4 = __esm({
  "../../node_modules/@polkadot/types/interfaces/assetConversion/definitions.js"() {
    init_runtime3();
    definitions_default4 = {
      rpc: {},
      runtime: runtime3,
      types: {
        TAssetConversion: "Option<MultiLocation>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/assets/runtime.js
var runtime4;
var init_runtime4 = __esm({
  "../../node_modules/@polkadot/types/interfaces/assets/runtime.js"() {
    runtime4 = {
      AssetsApi: [
        {
          methods: {
            account_balances: {
              description: "Return the current set of authorities.",
              params: [
                {
                  name: "account",
                  type: "AccountId"
                }
              ],
              type: "Vec<(u32, TAssetBalance)>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/assets/definitions.js
var definitions_default5;
var init_definitions5 = __esm({
  "../../node_modules/@polkadot/types/interfaces/assets/definitions.js"() {
    init_runtime4();
    definitions_default5 = {
      rpc: {},
      runtime: runtime4,
      types: {
        AssetApprovalKey: {
          owner: "AccountId",
          delegate: "AccountId"
        },
        AssetApproval: {
          amount: "TAssetBalance",
          deposit: "TAssetDepositBalance"
        },
        AssetBalance: {
          balance: "TAssetBalance",
          isFrozen: "bool",
          isSufficient: "bool"
        },
        AssetDestroyWitness: {
          accounts: "Compact<u32>",
          sufficients: "Compact<u32>",
          approvals: "Compact<u32>"
        },
        AssetDetails: {
          owner: "AccountId",
          issuer: "AccountId",
          admin: "AccountId",
          freezer: "AccountId",
          supply: "TAssetBalance",
          deposit: "TAssetDepositBalance",
          minBalance: "TAssetBalance",
          isSufficient: "bool",
          accounts: "u32",
          sufficients: "u32",
          approvals: "u32",
          isFrozen: "bool"
        },
        AssetMetadata: {
          deposit: "TAssetDepositBalance",
          name: "Vec<u8>",
          symbol: "Vec<u8>",
          decimals: "u8",
          isFrozen: "bool"
        },
        TAssetBalance: "u64",
        TAssetDepositBalance: "BalanceOf"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/aura/runtime.js
var runtime5;
var init_runtime5 = __esm({
  "../../node_modules/@polkadot/types/interfaces/aura/runtime.js"() {
    runtime5 = {
      AuraApi: [
        {
          methods: {
            authorities: {
              description: "Return the current set of authorities.",
              params: [],
              type: "Vec<AuthorityId>"
            },
            slot_duration: {
              description: "Returns the slot duration for Aura.",
              params: [],
              type: "SlotDuration"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/aura/definitions.js
var definitions_default6;
var init_definitions6 = __esm({
  "../../node_modules/@polkadot/types/interfaces/aura/definitions.js"() {
    init_runtime5();
    definitions_default6 = {
      rpc: {},
      runtime: runtime5,
      types: {
        RawAuraPreDigest: {
          slotNumber: "u64"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/authorship/definitions.js
var definitions_default7;
var init_definitions7 = __esm({
  "../../node_modules/@polkadot/types/interfaces/authorship/definitions.js"() {
    definitions_default7 = {
      rpc: {},
      types: {
        UncleEntryItem: {
          _enum: {
            InclusionHeight: "BlockNumber",
            Uncle: "(Hash, Option<AccountId>)"
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/babe/rpc.js
var rpc;
var init_rpc = __esm({
  "../../node_modules/@polkadot/types/interfaces/babe/rpc.js"() {
    rpc = {
      epochAuthorship: {
        description: "Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore",
        isUnsafe: true,
        params: [],
        type: "HashMap<AuthorityId, EpochAuthorship>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/babe/runtime.js
var V1_V2_SHARED, runtime6;
var init_runtime6 = __esm({
  "../../node_modules/@polkadot/types/interfaces/babe/runtime.js"() {
    V1_V2_SHARED = {
      current_epoch: {
        description: "Returns information regarding the current epoch.",
        params: [],
        type: "Epoch"
      },
      current_epoch_start: {
        description: "Returns the slot that started the current epoch.",
        params: [],
        type: "Slot"
      },
      generate_key_ownership_proof: {
        description: "Generates a proof of key ownership for the given authority in the current epoch.",
        params: [
          {
            name: "slot",
            type: "Slot"
          },
          {
            name: "authorityId",
            type: "AuthorityId"
          }
        ],
        type: "Option<OpaqueKeyOwnershipProof>"
      },
      next_epoch: {
        description: "Returns information regarding the next epoch (which was already previously announced).",
        params: [],
        type: "Epoch"
      },
      submit_report_equivocation_unsigned_extrinsic: {
        description: "Submits an unsigned extrinsic to report an equivocation.",
        params: [
          {
            name: "equivocationProof",
            type: "BabeEquivocationProof"
          },
          {
            name: "keyOwnerProof",
            type: "OpaqueKeyOwnershipProof"
          }
        ],
        type: "Option<Null>"
      }
    };
    runtime6 = {
      BabeApi: [
        {
          methods: {
            configuration: {
              description: "Return the genesis configuration for BABE. The configuration is only read on genesis.",
              params: [],
              type: "BabeGenesisConfiguration"
            },
            ...V1_V2_SHARED
          },
          version: 2
        },
        {
          methods: {
            configuration: {
              description: "Return the configuration for BABE. Version 1.",
              params: [],
              type: "BabeGenesisConfigurationV1"
            },
            ...V1_V2_SHARED
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/babe/definitions.js
var definitions_default8;
var init_definitions8 = __esm({
  "../../node_modules/@polkadot/types/interfaces/babe/definitions.js"() {
    init_rpc();
    init_runtime6();
    definitions_default8 = {
      rpc,
      runtime: runtime6,
      types: {
        AllowedSlots: {
          _enum: ["PrimarySlots", "PrimaryAndSecondaryPlainSlots", "PrimaryAndSecondaryVRFSlots"]
        },
        BabeAuthorityWeight: "u64",
        BabeEpochConfiguration: {
          c: "(u64, u64)",
          allowedSlots: "AllowedSlots"
        },
        BabeBlockWeight: "u32",
        BabeEquivocationProof: {
          offender: "AuthorityId",
          slotNumber: "SlotNumber",
          firstHeader: "Header",
          secondHeader: "Header"
        },
        BabeGenesisConfiguration: {
          slotDuration: "u64",
          epochLength: "u64",
          c: "(u64, u64)",
          genesisAuthorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
          randomness: "Randomness",
          allowedSlots: "AllowedSlots"
        },
        BabeGenesisConfigurationV1: {
          slotDuration: "u64",
          epochLength: "u64",
          c: "(u64, u64)",
          genesisAuthorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
          randomness: "Randomness",
          secondarySlots: "bool"
        },
        BabeWeight: "u64",
        MaybeRandomness: "Option<Randomness>",
        MaybeVrf: "Option<VrfData>",
        Epoch: {
          epochIndex: "u64",
          startSlot: "Slot",
          duration: "u64",
          authorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
          randomness: "Hash",
          // [u8; VRF_OUTPUT_LENGTH],
          config: "BabeEpochConfiguration"
        },
        EpochAuthorship: {
          primary: "Vec<u64>",
          secondary: "Vec<u64>",
          secondary_vrf: "Vec<u64>"
        },
        NextConfigDescriptor: {
          _enum: {
            V0: "Null",
            V1: "NextConfigDescriptorV1"
          }
        },
        NextConfigDescriptorV1: {
          c: "(u64, u64)",
          allowedSlots: "AllowedSlots"
        },
        OpaqueKeyOwnershipProof: "Bytes",
        Randomness: "Hash",
        // [u8; RANDOMNESS_LENGTH],
        RawBabePreDigest: {
          _enum: {
            Phantom: "Null",
            // index starts at 1... empty slot at 0
            Primary: "RawBabePreDigestPrimary",
            SecondaryPlain: "RawBabePreDigestSecondaryPlain",
            SecondaryVRF: "RawBabePreDigestSecondaryVRF"
          }
        },
        RawBabePreDigestPrimary: {
          authorityIndex: "u32",
          // AuthorityIndex (also in aura)
          slotNumber: "SlotNumber",
          vrfOutput: "VrfOutput",
          vrfProof: "VrfProof"
        },
        RawBabePreDigestSecondaryPlain: {
          authorityIndex: "u32",
          // AuthorityIndex (also in aura)
          slotNumber: "SlotNumber"
        },
        RawBabePreDigestSecondaryVRF: {
          authorityIndex: "u32",
          slotNumber: "SlotNumber",
          vrfOutput: "VrfOutput",
          vrfProof: "VrfProof"
        },
        RawBabePreDigestTo159: {
          _enum: {
            Primary: "RawBabePreDigestPrimaryTo159",
            Secondary: "RawBabePreDigestSecondaryTo159"
          }
        },
        RawBabePreDigestPrimaryTo159: {
          authorityIndex: "u32",
          slotNumber: "SlotNumber",
          weight: "BabeBlockWeight",
          vrfOutput: "VrfOutput",
          vrfProof: "VrfProof"
        },
        RawBabePreDigestSecondaryTo159: {
          authorityIndex: "u32",
          slotNumber: "SlotNumber",
          weight: "BabeBlockWeight"
        },
        // a cross old/new compatible version of the digest, that is _only_ useful
        // for partial parsing and extraction of the author. This assumes that all
        // entries has the authorityIndex in the first position - and that it is all
        // we are interested in
        RawBabePreDigestCompat: {
          _enum: {
            Zero: "u32",
            One: "u32",
            Two: "u32",
            Three: "u32"
          }
        },
        SlotNumber: "u64",
        VrfData: "[u8; 32]",
        VrfOutput: "[u8; 32]",
        VrfProof: "[u8; 64]"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/balances/definitions.js
var definitions_default9;
var init_definitions9 = __esm({
  "../../node_modules/@polkadot/types/interfaces/balances/definitions.js"() {
    definitions_default9 = {
      rpc: {},
      types: {
        AccountData: {
          free: "Balance",
          reserved: "Balance",
          miscFrozen: "Balance",
          feeFrozen: "Balance"
        },
        BalanceLockTo212: {
          id: "LockIdentifier",
          amount: "Balance",
          until: "BlockNumber",
          reasons: "WithdrawReasons"
        },
        BalanceLock: {
          id: "LockIdentifier",
          amount: "Balance",
          reasons: "Reasons"
        },
        BalanceStatus: {
          _enum: ["Free", "Reserved"]
        },
        Reasons: {
          _enum: ["Fee", "Misc", "All"]
        },
        ReserveData: {
          id: "ReserveIdentifier",
          amount: "Balance"
        },
        ReserveIdentifier: "[u8; 8]",
        VestingSchedule: {
          offset: "Balance",
          perBlock: "Balance",
          startingBlock: "BlockNumber"
        },
        WithdrawReasons: {
          _set: {
            TransactionPayment: 1,
            Transfer: 2,
            Reserve: 4,
            Fee: 8,
            Tip: 16
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/beefy/rpc.js
var rpc2;
var init_rpc2 = __esm({
  "../../node_modules/@polkadot/types/interfaces/beefy/rpc.js"() {
    rpc2 = {
      getFinalizedHead: {
        description: "Returns hash of the latest BEEFY finalized block as seen by this client.",
        params: [],
        type: "H256"
      },
      subscribeJustifications: {
        description: "Returns the block most recently finalized by BEEFY, alongside its justification.",
        params: [],
        pubsub: [
          "justifications",
          "subscribeJustifications",
          "unsubscribeJustifications"
        ],
        type: "BeefyVersionedFinalityProof"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/beefy/runtime.js
var BEEFY_V3, BEEFY_V1_V3, BEEFY_V4, BEEFY_MMR_V1, runtime7;
var init_runtime7 = __esm({
  "../../node_modules/@polkadot/types/interfaces/beefy/runtime.js"() {
    BEEFY_V3 = {
      beefy_genesis: {
        description: "Return the block number where BEEFY consensus is enabled/started",
        params: [],
        type: "Option<BlockNumber>"
      },
      generate_key_ownership_proof: {
        description: "Generates a proof of key ownership for the given authority in the given set.",
        params: [
          {
            name: "setId",
            type: "ValidatorSetId"
          },
          {
            name: "authorityId",
            type: "AuthorityId"
          }
        ],
        type: "Option<OpaqueKeyOwnershipProof>"
      },
      validator_set: {
        description: "Return the current active BEEFY validator set",
        params: [],
        type: "Option<ValidatorSet>"
      }
    };
    BEEFY_V1_V3 = {
      ...BEEFY_V3,
      submit_report_equivocation_unsigned_extrinsic: {
        description: "Submits an unsigned extrinsic to report an equivocation.",
        params: [
          {
            name: "equivocationProof",
            type: "BeefyEquivocationProof"
          },
          {
            name: "keyOwnerProof",
            type: "OpaqueKeyOwnershipProof"
          }
        ],
        type: "Option<Null>"
      }
    };
    BEEFY_V4 = {
      ...BEEFY_V3,
      submit_report_double_voting_unsigned_extrinsic: {
        description: "Submits an unsigned extrinsic to report a double voting equivocation.",
        params: [
          {
            name: "equivocationProof",
            type: "SpConsensusBeefyDoubleVotingProof"
          },
          {
            name: "keyOwnerProof",
            type: "OpaqueKeyOwnershipProof"
          }
        ],
        type: "Option<Null>"
      }
    };
    BEEFY_MMR_V1 = {
      authority_set_proof: {
        description: "Return the currently active BEEFY authority set proof.",
        params: [],
        type: "BeefyAuthoritySet"
      },
      next_authority_set_proof: {
        description: "Return the next/queued BEEFY authority set proof.",
        params: [],
        type: "BeefyNextAuthoritySet"
      }
    };
    runtime7 = {
      BeefyApi: [
        {
          methods: BEEFY_V4,
          version: 4
        },
        {
          methods: BEEFY_V1_V3,
          version: 3
        },
        {
          methods: BEEFY_V1_V3,
          version: 2
        },
        {
          methods: BEEFY_V1_V3,
          version: 1
        }
      ],
      BeefyMmrApi: [
        {
          methods: BEEFY_MMR_V1,
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/beefy/definitions.js
var definitions_default10;
var init_definitions10 = __esm({
  "../../node_modules/@polkadot/types/interfaces/beefy/definitions.js"() {
    init_rpc2();
    init_runtime7();
    definitions_default10 = {
      rpc: rpc2,
      runtime: runtime7,
      types: {
        BeefyAuthoritySet: {
          id: "u64",
          len: "u32",
          root: "H256"
        },
        BeefyCommitment: {
          payload: "BeefyPayload",
          blockNumber: "BlockNumber",
          validatorSetId: "ValidatorSetId"
        },
        BeefyId: "[u8; 33]",
        BeefyEquivocationProof: {
          first: "BeefyVoteMessage",
          second: "BeefyVoteMessage"
        },
        BeefyCompactSignedCommitment: {
          commitment: "BeefyCommitment",
          signaturesFrom: "Vec<u8>",
          validatorSetLen: "u32",
          signaturesCompact: "Vec<EcdsaSignature>"
        },
        BeefySignedCommitment: {
          commitment: "BeefyCommitment",
          signatures: "Vec<Option<EcdsaSignature>>"
        },
        BeefyVersionedFinalityProof: {
          _enum: {
            V0: "Null",
            V1: "BeefyCompactSignedCommitment"
          }
        },
        BeefyNextAuthoritySet: {
          id: "u64",
          len: "u32",
          root: "H256"
        },
        BeefyPayload: "Vec<(BeefyPayloadId, Bytes)>",
        BeefyPayloadId: "[u8;2]",
        BeefyVoteMessage: {
          commitment: "BeefyCommitment",
          id: "AuthorityId",
          signature: "Signature"
        },
        MmrRootHash: "H256",
        ValidatorSetId: "u64",
        ValidatorSet: {
          validators: "Vec<AuthorityId>",
          id: "ValidatorSetId"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/benchmark/runtime.js
var runtime8;
var init_runtime8 = __esm({
  "../../node_modules/@polkadot/types/interfaces/benchmark/runtime.js"() {
    runtime8 = {
      Benchmark: [
        {
          methods: {
            benchmark_metadata: {
              description: "Get the benchmark metadata available for this runtime.",
              params: [
                {
                  name: "extra",
                  type: "bool"
                }
              ],
              type: "(Vec<BenchmarkList>, Vec<StorageInfo>)"
            },
            dispatch_benchmark: {
              description: "Dispatch the given benchmark.",
              params: [
                {
                  name: "config",
                  type: "BenchmarkConfig"
                }
              ],
              type: "Result<Vec<BenchmarkBatch>, Text>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/benchmark/definitions.js
var definitions_default11;
var init_definitions11 = __esm({
  "../../node_modules/@polkadot/types/interfaces/benchmark/definitions.js"() {
    init_runtime8();
    definitions_default11 = {
      rpc: {},
      runtime: runtime8,
      types: {
        BenchmarkBatch: {
          pallet: "Text",
          instance: "Text",
          benchmark: "Text",
          results: "Vec<BenchmarkResult>"
        },
        BenchmarkConfig: {
          pallet: "Bytes",
          benchmark: "Bytes",
          selectedComponents: "Vec<(BenchmarkParameter, u32)>",
          verify: "bool",
          internalRepeats: "u32"
        },
        BenchmarkList: {
          pallet: "Bytes",
          instance: "Bytes",
          benchmarks: "Vec<BenchmarkMetadata>"
        },
        BenchmarkMetadata: {
          name: "Bytes",
          components: "Vec<(BenchmarkParameter, u32, u32)>"
        },
        BenchmarkParameter: {
          _enum: ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
        },
        BenchmarkResult: {
          components: "Vec<(BenchmarkParameter, u32)>",
          extrinsicTime: "u128",
          storageRootTime: "u128",
          reads: "u32",
          repeatReads: "u32",
          writes: "u32",
          repeatWrites: "u32",
          proofSize: "u32",
          benchKeys: "Vec<(Vec<u8>, u32, u32, bool)>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/blockbuilder/runtime.js
var BB_V2_TO_V4, BB_V2_TO_V5, BB_V2_TO_V6, BB_V3_TO_V6, runtime9;
var init_runtime9 = __esm({
  "../../node_modules/@polkadot/types/interfaces/blockbuilder/runtime.js"() {
    BB_V2_TO_V4 = {
      // this was removed after V4
      random_seed: {
        description: "Generate a random seed.",
        params: [],
        type: "Hash"
      }
    };
    BB_V2_TO_V5 = {
      apply_extrinsic: {
        description: "Apply the given extrinsic.",
        params: [
          {
            name: "extrinsic",
            type: "Extrinsic"
          }
        ],
        type: "ApplyExtrinsicResultPre6"
      }
    };
    BB_V2_TO_V6 = {
      check_inherents: {
        description: "Check that the inherents are valid.",
        params: [
          {
            name: "block",
            type: "Block"
          },
          {
            name: "data",
            type: "InherentData"
          }
        ],
        type: "CheckInherentsResult"
      },
      inherent_extrinsics: {
        description: "Generate inherent extrinsics.",
        params: [
          {
            name: "inherent",
            type: "InherentData"
          }
        ],
        type: "Vec<Extrinsic>"
      }
    };
    BB_V3_TO_V6 = {
      // renamed in v3 from finalize_block
      finalize_block: {
        description: "Finish the current block.",
        params: [],
        type: "Header"
      }
    };
    runtime9 = {
      BlockBuilder: [
        {
          methods: {
            apply_extrinsic: {
              description: "Apply the given extrinsic.",
              params: [
                {
                  name: "extrinsic",
                  type: "Extrinsic"
                }
              ],
              type: "ApplyExtrinsicResult"
            },
            ...BB_V2_TO_V6,
            ...BB_V3_TO_V6
          },
          version: 6
        },
        {
          methods: {
            // apply_extrinsic result changed in 6
            ...BB_V2_TO_V5,
            ...BB_V2_TO_V6,
            ...BB_V3_TO_V6
          },
          version: 5
        },
        {
          methods: {
            // random_seed removed
            ...BB_V2_TO_V4,
            ...BB_V2_TO_V5,
            ...BB_V2_TO_V6,
            ...BB_V3_TO_V6
          },
          version: 4
        },
        {
          methods: {
            // finalize_block renamed
            ...BB_V2_TO_V4,
            ...BB_V2_TO_V6,
            ...BB_V3_TO_V6
          },
          version: 3
        },
        {
          methods: {
            finalise_block: {
              description: "Finish the current block.",
              params: [],
              type: "Header"
            },
            ...BB_V2_TO_V4,
            ...BB_V2_TO_V6
          },
          version: 2
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/blockbuilder/definitions.js
var definitions_default12;
var init_definitions12 = __esm({
  "../../node_modules/@polkadot/types/interfaces/blockbuilder/definitions.js"() {
    init_runtime9();
    definitions_default12 = {
      rpc: {},
      runtime: runtime9,
      types: {
        CheckInherentsResult: {
          okay: "bool",
          fatalError: "bool",
          errors: "InherentData"
        },
        InherentData: {
          data: "BTreeMap<InherentIdentifier, Bytes>"
        },
        InherentIdentifier: "[u8; 8]"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/collective/definitions.js
var definitions_default13;
var init_definitions13 = __esm({
  "../../node_modules/@polkadot/types/interfaces/collective/definitions.js"() {
    definitions_default13 = {
      rpc: {},
      types: {
        CollectiveOrigin: {
          _enum: {
            Members: "(MemberCount, MemberCount)",
            Member: "AccountId"
          }
        },
        MemberCount: "u32",
        ProposalIndex: "u32",
        VotesTo230: {
          index: "ProposalIndex",
          threshold: "MemberCount",
          ayes: "Vec<AccountId>",
          nays: "Vec<AccountId>"
        },
        Votes: {
          index: "ProposalIndex",
          threshold: "MemberCount",
          ayes: "Vec<AccountId>",
          nays: "Vec<AccountId>",
          end: "BlockNumber"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/consensus/definitions.js
var definitions_default14;
var init_definitions14 = __esm({
  "../../node_modules/@polkadot/types/interfaces/consensus/definitions.js"() {
    definitions_default14 = {
      rpc: {},
      types: {
        AuthorityId: "AccountId",
        RawVRFOutput: "[u8; 32]"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/contracts/rpc.js
var rpc3;
var init_rpc3 = __esm({
  "../../node_modules/@polkadot/types/interfaces/contracts/rpc.js"() {
    rpc3 = {
      call: {
        deprecated: "Use the runtime interface `api.call.contractsApi.call` instead",
        description: "Executes a call to a contract",
        params: [
          {
            name: "callRequest",
            type: "ContractCallRequest"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "ContractExecResult"
      },
      getStorage: {
        deprecated: "Use the runtime interface `api.call.contractsApi.getStorage` instead",
        description: "Returns the value under a specified storage key in a contract",
        params: [
          {
            name: "address",
            type: "AccountId"
          },
          {
            name: "key",
            type: "H256"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Option<Bytes>"
      },
      instantiate: {
        deprecated: "Use the runtime interface `api.call.contractsApi.instantiate` instead",
        description: "Instantiate a new contract",
        params: [
          {
            name: "request",
            type: "InstantiateRequestV1"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "ContractInstantiateResult"
      },
      rentProjection: {
        deprecated: "Not available in newer versions of the contracts interfaces",
        description: "Returns the projected time a given contract will be able to sustain paying its rent",
        params: [
          {
            name: "address",
            type: "AccountId"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Option<BlockNumber>"
      },
      uploadCode: {
        deprecated: "Use the runtime interface `api.call.contractsApi.uploadCode` instead",
        description: "Upload new code without instantiating a contract from it",
        // The RPC here is terribly misnamed - somebody forgot how the RPCs
        // are actually done, ie. <module>_<camelCasedMethod>
        endpoint: "contracts_upload_code",
        params: [
          {
            name: "uploadRequest",
            type: "CodeUploadRequest"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "CodeUploadResult"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/contracts/runtime.js
var SHARED_V1_V2, runtime10;
var init_runtime10 = __esm({
  "../../node_modules/@polkadot/types/interfaces/contracts/runtime.js"() {
    SHARED_V1_V2 = {
      get_storage: {
        description: "Query a given storage key in a given contract.",
        params: [
          {
            name: "address",
            type: "AccountId"
          },
          {
            name: "key",
            type: "Bytes"
          }
        ],
        type: "Option<Bytes>"
      },
      upload_code: {
        description: "Upload new code without instantiating a contract from it.",
        params: [
          {
            name: "origin",
            type: "AccountId"
          },
          {
            name: "code",
            type: "Bytes"
          },
          {
            name: "storageDepositLimit",
            type: "Option<Balance>"
          }
        ],
        type: "CodeUploadResult"
      }
    };
    runtime10 = {
      ContractsApi: [
        {
          methods: {
            call: {
              description: "Perform a call from a specified account to a given contract.",
              params: [
                {
                  name: "origin",
                  type: "AccountId"
                },
                {
                  name: "dest",
                  type: "AccountId"
                },
                {
                  name: "value",
                  type: "Balance"
                },
                {
                  name: "gasLimit",
                  type: "Option<WeightV2>"
                },
                {
                  name: "storageDepositLimit",
                  type: "Option<Balance>"
                },
                {
                  name: "inputData",
                  type: "Vec<u8>"
                }
              ],
              type: "ContractExecResult"
            },
            instantiate: {
              description: "Instantiate a new contract.",
              params: [
                {
                  name: "origin",
                  type: "AccountId"
                },
                {
                  name: "value",
                  type: "Balance"
                },
                {
                  name: "gasLimit",
                  type: "Option<WeightV2>"
                },
                {
                  name: "storageDepositLimit",
                  type: "Option<Balance>"
                },
                {
                  name: "code",
                  type: "CodeSource"
                },
                {
                  name: "data",
                  type: "Bytes"
                },
                {
                  name: "salt",
                  type: "Bytes"
                }
              ],
              type: "ContractInstantiateResult"
            },
            ...SHARED_V1_V2
          },
          version: 2
        },
        {
          methods: {
            call: {
              description: "Perform a call from a specified account to a given contract.",
              params: [
                {
                  name: "origin",
                  type: "AccountId"
                },
                {
                  name: "dest",
                  type: "AccountId"
                },
                {
                  name: "value",
                  type: "Balance"
                },
                {
                  name: "gasLimit",
                  type: "u64"
                },
                {
                  name: "storageDepositLimit",
                  type: "Option<Balance>"
                },
                {
                  name: "inputData",
                  type: "Vec<u8>"
                }
              ],
              type: "ContractExecResultU64"
            },
            instantiate: {
              description: "Instantiate a new contract.",
              params: [
                {
                  name: "origin",
                  type: "AccountId"
                },
                {
                  name: "value",
                  type: "Balance"
                },
                {
                  name: "gasLimit",
                  type: "u64"
                },
                {
                  name: "storageDepositLimit",
                  type: "Option<Balance>"
                },
                {
                  name: "code",
                  type: "CodeSource"
                },
                {
                  name: "data",
                  type: "Bytes"
                },
                {
                  name: "salt",
                  type: "Bytes"
                }
              ],
              type: "ContractInstantiateResultU64"
            },
            ...SHARED_V1_V2
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/contracts/definitions.js
var definitions_default15;
var init_definitions15 = __esm({
  "../../node_modules/@polkadot/types/interfaces/contracts/definitions.js"() {
    init_rpc3();
    init_runtime10();
    definitions_default15 = {
      rpc: rpc3,
      runtime: runtime10,
      types: {
        AliveContractInfo: {
          trieId: "TrieId",
          storageSize: "u32",
          pairCount: "u32",
          codeHash: "CodeHash",
          rentAllowance: "Balance",
          rentPaid: "Balance",
          deductBlock: "BlockNumber",
          lastWrite: "Option<BlockNumber>",
          _reserved: "Option<Null>"
        },
        CodeHash: "Hash",
        CodeSource: {
          _enum: {
            Upload: "Bytes",
            Existing: "Hash"
          }
        },
        CodeUploadRequest: {
          origin: "AccountId",
          code: "Bytes",
          storageDepositLimit: "Option<Balance>"
        },
        CodeUploadResult: "Result<CodeUploadResultValue, DispatchError>",
        CodeUploadResultValue: {
          codeHash: "CodeHash",
          deposit: "Balance"
        },
        ContractCallRequest: {
          origin: "AccountId",
          dest: "AccountId",
          value: "Balance",
          gasLimit: "u64",
          storageDepositLimit: "Option<Balance>",
          inputData: "Bytes"
        },
        ContractExecResultSuccessTo255: {
          status: "u8",
          data: "Raw"
        },
        ContractExecResultTo255: {
          _enum: {
            Success: "ContractExecResultSuccessTo255",
            Error: "Null"
          }
        },
        ContractExecResultSuccessTo260: {
          flags: "ContractReturnFlags",
          data: "Bytes",
          gasConsumed: "u64"
        },
        ContractExecResultTo260: {
          _enum: {
            Success: "ContractExecResultSuccessTo260",
            Error: "Null"
          }
        },
        ContractExecResultOk: {
          flags: "ContractReturnFlags",
          data: "Bytes"
        },
        ContractExecResultResult: "Result<ContractExecResultOk, DispatchError>",
        ContractExecResultTo267: {
          gasConsumed: "u64",
          debugMessage: "Text",
          result: "ContractExecResultResult"
        },
        ContractExecResult: {
          gasConsumed: "Weight",
          gasRequired: "Weight",
          storageDeposit: "StorageDeposit",
          debugMessage: "Text",
          result: "ContractExecResultResult"
        },
        ContractExecResultU64: {
          gasConsumed: "u64",
          gasRequired: "u64",
          storageDeposit: "StorageDeposit",
          debugMessage: "Text",
          result: "ContractExecResultResult"
        },
        ContractInfo: {
          _enum: {
            Alive: "AliveContractInfo",
            Tombstone: "TombstoneContractInfo"
          }
        },
        ContractCallFlags: {
          _set: {
            _bitLength: 32,
            ForwardInput: 1,
            CloneInput: 2,
            TailCall: 4,
            AllowReentry: 8
          }
        },
        ContractReturnFlags: {
          _set: {
            _bitLength: 32,
            Revert: 1
          }
        },
        ContractStorageKey: "[u8; 32]",
        DeletedContract: {
          pairCount: "u32",
          trieId: "TrieId"
        },
        ExecReturnValue: {
          flags: "ContractReturnFlags",
          data: "Bytes"
        },
        Gas: "u64",
        HostFnWeightsTo264: {
          caller: "Weight",
          address: "Weight",
          gasLeft: "Weight",
          balance: "Weight",
          valueTransferred: "Weight",
          minimumBalance: "Weight",
          tombstoneDeposit: "Weight",
          rentAllowance: "Weight",
          blockNumber: "Weight",
          now: "Weight",
          weightToFee: "Weight",
          gas: "Weight",
          input: "Weight",
          inputPerByte: "Weight",
          return: "Weight",
          returnPerByte: "Weight",
          terminate: "Weight",
          restoreTo: "Weight",
          restoreToPerDelta: "Weight",
          random: "Weight",
          depositEvent: "Weight",
          depositEventPerTopic: "Weight",
          depositEventPerByte: "Weight",
          setRentAllowance: "Weight",
          setStorage: "Weight",
          setStoragePerByte: "Weight",
          clearStorage: "Weight",
          getStorage: "Weight",
          getStoragePerByte: "Weight",
          transfer: "Weight",
          call: "Weight",
          callTransferSurcharge: "Weight",
          callPerInputByte: "Weight",
          callPerOutputByte: "Weight",
          instantiate: "Weight",
          instantiatePerInputByte: "Weight",
          instantiatePerOutputByte: "Weight",
          hashSha2256: "Weight",
          hashSha2256PerByte: "Weight",
          hashKeccak256: "Weight",
          hashKeccak256PerByte: "Weight",
          hashBlake2256: "Weight",
          hashBlake2256PerByte: "Weight",
          hashBlake2128: "Weight",
          hashBlake2128PerByte: "Weight"
        },
        HostFnWeights: {
          caller: "Weight",
          address: "Weight",
          gasLeft: "Weight",
          balance: "Weight",
          valueTransferred: "Weight",
          minimumBalance: "Weight",
          tombstoneDeposit: "Weight",
          rentAllowance: "Weight",
          blockNumber: "Weight",
          now: "Weight",
          weightToFee: "Weight",
          gas: "Weight",
          input: "Weight",
          inputPerByte: "Weight",
          return: "Weight",
          returnPerByte: "Weight",
          terminate: "Weight",
          terminatePerCodeByte: "Weight",
          restoreTo: "Weight",
          restoreToPerCallerCodeByte: "Weight",
          restoreToPerTombstoneCodeByte: "Weight",
          restoreToPerDelta: "Weight",
          random: "Weight",
          depositEvent: "Weight",
          depositEventPerTopic: "Weight",
          depositEventPerByte: "Weight",
          setRentAllowance: "Weight",
          setStorage: "Weight",
          setStoragePerByte: "Weight",
          clearStorage: "Weight",
          getStorage: "Weight",
          getStoragePerByte: "Weight",
          transfer: "Weight",
          call: "Weight",
          callPerCodeByte: "Weight",
          callTransferSurcharge: "Weight",
          callPerInputByte: "Weight",
          callPerOutputByte: "Weight",
          instantiate: "Weight",
          instantiatePerCodeByte: "Weight",
          instantiatePerInputByte: "Weight",
          instantiatePerOutputByte: "Weight",
          instantiatePerSaltByte: "Weight",
          hashSha2256: "Weight",
          hashSha2256PerByte: "Weight",
          hashKeccak256: "Weight",
          hashKeccak256PerByte: "Weight",
          hashBlake2256: "Weight",
          hashBlake2256PerByte: "Weight",
          hashBlake2128: "Weight",
          hashBlake2128PerByte: "Weight",
          rentParams: "Weight"
        },
        InstantiateRequestV1: {
          origin: "AccountId",
          value: "Balance",
          gasLimit: "Gas",
          code: "Bytes",
          data: "Bytes",
          salt: "Bytes"
        },
        InstantiateRequestV2: {
          _fallback: "InstantiateRequestV1",
          origin: "AccountId",
          value: "Balance",
          gasLimit: "Gas",
          storageDepositLimit: "Option<Balance>",
          code: "Bytes",
          data: "Bytes",
          salt: "Bytes"
        },
        InstantiateRequest: {
          _fallback: "InstantiateRequestV2",
          origin: "AccountId",
          value: "Balance",
          gasLimit: "Gas",
          storageDepositLimit: "Option<Balance>",
          code: "CodeSource",
          data: "Bytes",
          salt: "Bytes"
        },
        ContractInstantiateResultTo267: "Result<InstantiateReturnValueTo267, Null>",
        ContractInstantiateResultTo299: "Result<InstantiateReturnValueOk, Null>",
        ContractInstantiateResult: {
          gasConsumed: "WeightV2",
          gasRequired: "WeightV2",
          storageDeposit: "StorageDeposit",
          debugMessage: "Text",
          result: "InstantiateReturnValue"
        },
        ContractInstantiateResultU64: {
          // only this one can fail, the current version (above) _should_ be correctly
          // versioned now, aka no more deprecated RPCs involved, only runtime calls
          _fallback: "ContractInstantiateResultTo299",
          gasConsumed: "u64",
          gasRequired: "u64",
          storageDeposit: "StorageDeposit",
          debugMessage: "Text",
          result: "InstantiateReturnValue"
        },
        InstantiateReturnValueTo267: {
          result: "ExecReturnValue",
          accountId: "AccountId",
          rentProjection: "Option<RentProjection>"
        },
        InstantiateReturnValueOk: {
          result: "ExecReturnValue",
          accountId: "AccountId"
        },
        InstantiateReturnValue: "Result<InstantiateReturnValueOk, DispatchError>",
        InstructionWeights: {
          i64const: "u32",
          i64load: "u32",
          i64store: "u32",
          select: "u32",
          rIf: "u32",
          br: "u32",
          brIf: "u32",
          brIable: "u32",
          brIablePerEntry: "u32",
          call: "u32",
          callIndirect: "u32",
          callIndirectPerParam: "u32",
          localGet: "u32",
          localSet: "u32",
          local_tee: "u32",
          globalGet: "u32",
          globalSet: "u32",
          memoryCurrent: "u32",
          memoryGrow: "u32",
          i64clz: "u32",
          i64ctz: "u32",
          i64popcnt: "u32",
          i64eqz: "u32",
          i64extendsi32: "u32",
          i64extendui32: "u32",
          i32wrapi64: "u32",
          i64eq: "u32",
          i64ne: "u32",
          i64lts: "u32",
          i64ltu: "u32",
          i64gts: "u32",
          i64gtu: "u32",
          i64les: "u32",
          i64leu: "u32",
          i64ges: "u32",
          i64geu: "u32",
          i64add: "u32",
          i64sub: "u32",
          i64mul: "u32",
          i64divs: "u32",
          i64divu: "u32",
          i64rems: "u32",
          i64remu: "u32",
          i64and: "u32",
          i64or: "u32",
          i64xor: "u32",
          i64shl: "u32",
          i64shrs: "u32",
          i64shru: "u32",
          i64rotl: "u32",
          i64rotr: "u32"
        },
        LimitsTo264: {
          eventTopics: "u32",
          stackHeight: "u32",
          globals: "u32",
          parameters: "u32",
          memoryPages: "u32",
          tableSize: "u32",
          brTableSize: "u32",
          subjectLen: "u32",
          codeSize: "u32"
        },
        Limits: {
          eventTopics: "u32",
          stackHeight: "u32",
          globals: "u32",
          parameters: "u32",
          memoryPages: "u32",
          tableSize: "u32",
          brTableSize: "u32",
          subjectLen: "u32"
        },
        PrefabWasmModule: {
          scheduleVersion: "Compact<u32>",
          initial: "Compact<u32>",
          maximum: "Compact<u32>",
          refcount: "Compact<u64>",
          _reserved: "Option<Null>",
          code: "Bytes",
          originalCodeLen: "u32"
        },
        RentProjection: {
          _enum: {
            EvictionAt: "BlockNumber",
            NoEviction: "Null"
          }
        },
        ScheduleTo212: {
          version: "u32",
          putCodePerByteCost: "Gas",
          growMemCost: "Gas",
          regularOpCost: "Gas",
          returnDataPerByteCost: "Gas",
          eventDataPerByteCost: "Gas",
          eventPerTopicCost: "Gas",
          eventBaseCost: "Gas",
          sandboxDataReadCost: "Gas",
          sandboxDataWriteCost: "Gas",
          maxEventTopics: "u32",
          maxStackHeight: "u32",
          maxMemoryPages: "u32",
          enablePrintln: "bool",
          maxSubjectLen: "u32"
        },
        ScheduleTo258: {
          version: "u32",
          putCodePerByteCost: "Gas",
          growMemCost: "Gas",
          regularOpCost: "Gas",
          returnDataPerByteCost: "Gas",
          eventDataPerByteCost: "Gas",
          eventPerTopicCost: "Gas",
          eventBaseCost: "Gas",
          sandboxDataReadCost: "Gas",
          sandboxDataWriteCost: "Gas",
          transferCost: "Gas",
          maxEventTopics: "u32",
          maxStackHeight: "u32",
          maxMemoryPages: "u32",
          enablePrintln: "bool",
          maxSubjectLen: "u32"
        },
        ScheduleTo264: {
          version: "u32",
          enablePrintln: "bool",
          limits: "LimitsTo264",
          instructionWeights: "InstructionWeights",
          hostFnWeights: "HostFnWeightsTo264"
        },
        Schedule: {
          version: "u32",
          enablePrintln: "bool",
          limits: "Limits",
          instructionWeights: "InstructionWeights",
          hostFnWeights: "HostFnWeights"
        },
        SeedOf: "Hash",
        StorageDeposit: {
          _enum: {
            Refund: "Balance",
            Charge: "Balance"
          }
        },
        TombstoneContractInfo: "Hash",
        TrieId: "Bytes"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/democracy/definitions.js
var AllConvictions, definitions_default16;
var init_definitions16 = __esm({
  "../../node_modules/@polkadot/types/interfaces/democracy/definitions.js"() {
    AllConvictions = [
      // 0.1x votes, unlocked.
      "None",
      // 1x votes, locked for an enactment period following a successful vote.
      "Locked1x",
      // 2x votes, locked for 2x enactment periods following a successful vote.
      "Locked2x",
      // 3x votes, locked for 4x...
      "Locked3x",
      // 4x votes, locked for 8x...
      "Locked4x",
      // 5x votes, locked for 16x...
      "Locked5x",
      // 6x votes, locked for 32x...
      "Locked6x"
    ];
    definitions_default16 = {
      rpc: {},
      types: {
        AccountVote: {
          _enum: {
            Standard: "AccountVoteStandard",
            Split: "AccountVoteSplit"
          }
        },
        AccountVoteSplit: {
          aye: "Balance",
          nay: "Balance"
        },
        AccountVoteStandard: {
          vote: "Vote",
          balance: "Balance"
        },
        Conviction: {
          _enum: AllConvictions
        },
        Delegations: {
          votes: "Balance",
          capital: "Balance"
        },
        PreimageStatus: {
          _enum: {
            Missing: "BlockNumber",
            Available: "PreimageStatusAvailable"
          }
        },
        PreimageStatusAvailable: {
          data: "Bytes",
          provider: "AccountId",
          deposit: "Balance",
          since: "BlockNumber",
          expiry: "Option<BlockNumber>"
        },
        PriorLock: "(BlockNumber, Balance)",
        PropIndex: "u32",
        Proposal: "Call",
        ProxyState: {
          _enum: {
            Open: "AccountId",
            Active: "AccountId"
          }
        },
        ReferendumIndex: "u32",
        ReferendumInfoTo239: {
          end: "BlockNumber",
          proposalHash: "Hash",
          threshold: "VoteThreshold",
          delay: "BlockNumber"
        },
        ReferendumInfo: {
          _enum: {
            Ongoing: "ReferendumStatus",
            Finished: "ReferendumInfoFinished"
          }
        },
        ReferendumInfoFinished: {
          approved: "bool",
          end: "BlockNumber"
        },
        ReferendumStatus: {
          end: "BlockNumber",
          proposalHash: "Hash",
          threshold: "VoteThreshold",
          delay: "BlockNumber",
          tally: "Tally"
        },
        Tally: {
          ayes: "Balance",
          nays: "Balance",
          turnout: "Balance"
        },
        Voting: {
          _enum: {
            Direct: "VotingDirect",
            Delegating: "VotingDelegating"
          }
        },
        VotingDirect: {
          votes: "Vec<VotingDirectVote>",
          delegations: "Delegations",
          prior: "PriorLock"
        },
        VotingDirectVote: "(ReferendumIndex, AccountVote)",
        VotingDelegating: {
          balance: "Balance",
          target: "AccountId",
          conviction: "Conviction",
          delegations: "Delegations",
          prior: "PriorLock"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/dev/rpc.js
var rpc4;
var init_rpc4 = __esm({
  "../../node_modules/@polkadot/types/interfaces/dev/rpc.js"() {
    rpc4 = {
      getBlockStats: {
        description: "Reexecute the specified `block_hash` and gather statistics while doing so",
        isUnsafe: true,
        params: [
          {
            isHistoric: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Option<BlockStats>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/dev/definitions.js
var definitions_default17;
var init_definitions17 = __esm({
  "../../node_modules/@polkadot/types/interfaces/dev/definitions.js"() {
    init_rpc4();
    definitions_default17 = {
      rpc: rpc4,
      types: {
        BlockStats: {
          witnessLen: "u64",
          witnessCompactLen: "u64",
          blockLen: "u64",
          blockNumExtrinsics: "u64"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/discovery/runtime.js
var runtime11;
var init_runtime11 = __esm({
  "../../node_modules/@polkadot/types/interfaces/discovery/runtime.js"() {
    runtime11 = {
      AuthorityDiscoveryApi: [
        {
          methods: {
            authorities: {
              description: "Retrieve authority identifiers of the current and next authority set.",
              params: [],
              type: "Vec<AuthorityId>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/discovery/definitions.js
var definitions_default18;
var init_definitions18 = __esm({
  "../../node_modules/@polkadot/types/interfaces/discovery/definitions.js"() {
    init_runtime11();
    definitions_default18 = {
      rpc: {},
      runtime: runtime11,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/elections/definitions.js
var definitions_default19;
var init_definitions19 = __esm({
  "../../node_modules/@polkadot/types/interfaces/elections/definitions.js"() {
    definitions_default19 = {
      rpc: {},
      types: {
        ApprovalFlag: "u32",
        DefunctVoter: {
          who: "AccountId",
          voteCount: "Compact<u32>",
          candidateCount: "Compact<u32>"
        },
        Renouncing: {
          _enum: {
            Member: "Null",
            RunnerUp: "Null",
            Candidate: "Compact<u32>"
          }
        },
        SetIndex: "u32",
        Vote: "GenericVote",
        VoteIndex: "u32",
        VoterInfo: {
          lastActive: "VoteIndex",
          lastWin: "VoteIndex",
          pot: "Balance",
          stake: "Balance"
        },
        VoteThreshold: {
          _enum: [
            "Super Majority Approve",
            "Super Majority Against",
            "Simple Majority"
          ]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/engine/rpc.js
var rpc5;
var init_rpc5 = __esm({
  "../../node_modules/@polkadot/types/interfaces/engine/rpc.js"() {
    rpc5 = {
      createBlock: {
        description: "Instructs the manual-seal authorship task to create a new block",
        params: [
          {
            name: "createEmpty",
            type: "bool"
          },
          {
            name: "finalize",
            type: "bool"
          },
          {
            isOptional: true,
            name: "parentHash",
            type: "BlockHash"
          }
        ],
        type: "CreatedBlock"
      },
      finalizeBlock: {
        description: "Instructs the manual-seal authorship task to finalize a block",
        params: [
          {
            name: "hash",
            type: "BlockHash"
          },
          {
            isOptional: true,
            name: "justification",
            type: "Justification"
          }
        ],
        type: "bool"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/engine/definitions.js
var definitions_default20;
var init_definitions20 = __esm({
  "../../node_modules/@polkadot/types/interfaces/engine/definitions.js"() {
    init_rpc5();
    definitions_default20 = {
      rpc: rpc5,
      types: {
        CreatedBlock: {
          _alias: {
            blockHash: "hash"
          },
          blockHash: "BlockHash",
          aux: "ImportedAux"
        },
        ImportedAux: {
          headerOnly: "bool",
          clearJustificationRequests: "bool",
          needsJustification: "bool",
          badJustification: "bool",
          needsFinalityProof: "bool",
          isNewBest: "bool"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/evm/definitions.js
var definitions_default21;
var init_definitions21 = __esm({
  "../../node_modules/@polkadot/types/interfaces/evm/definitions.js"() {
    definitions_default21 = {
      rpc: {},
      types: {
        EvmAccount: {
          nonce: "u256",
          balance: "u256"
        },
        EvmCallInfo: {
          exitReason: "ExitReason",
          value: "Bytes",
          usedGas: "U256",
          logs: "Vec<EvmLog>"
        },
        EvmCreateInfo: {
          exitReason: "ExitReason",
          value: "H160",
          usedGas: "U256",
          logs: "Vec<EvmLog>"
        },
        EvmCallInfoV2: {
          exitReason: "ExitReason",
          value: "Bytes",
          usedGas: "U256",
          weightInfo: "Option<EvmWeightInfo>",
          logs: "Vec<EvmLog>"
        },
        EvmCreateInfoV2: {
          exitReason: "ExitReason",
          value: "H160",
          usedGas: "U256",
          weightInfo: "Option<EvmWeightInfo>",
          logs: "Vec<EvmLog>"
        },
        EvmLog: {
          address: "H160",
          topics: "Vec<H256>",
          data: "Bytes"
        },
        EvmVicinity: {
          gasPrice: "u256",
          origin: "H160"
        },
        EvmWeightInfo: {
          refTimeLimit: "Option<u64>",
          proofSizeLimit: "Option<u64>",
          refTimeUsage: "Option<u64>",
          proofSizeUsage: "Option<u64>"
        },
        ExitError: {
          _enum: {
            StackUnderflow: "Null",
            StackOverflow: "Null",
            InvalidJump: "Null",
            InvalidRange: "Null",
            DesignatedInvalid: "Null",
            CallTooDeep: "Null",
            CreateCollision: "Null",
            CreateContractLimit: "Null",
            OutOfOffset: "Null",
            OutOfGas: "Null",
            OutOfFund: "Null",
            PCUnderflow: "Null",
            CreateEmpty: "Null",
            Other: "Text"
          }
        },
        ExitFatal: {
          _enum: {
            NotSupported: "Null",
            UnhandledInterrupt: "Null",
            CallErrorAsFatal: "ExitError",
            Other: "Text"
          }
        },
        ExitReason: {
          _enum: {
            Succeed: "ExitSucceed",
            Error: "ExitError",
            Revert: "ExitRevert",
            Fatal: "ExitFatal"
          }
        },
        ExitRevert: {
          _enum: ["Reverted"]
        },
        ExitSucceed: {
          _enum: ["Stopped", "Returned", "Suicided"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/extrinsics/definitions.js
var definitions_default22;
var init_definitions22 = __esm({
  "../../node_modules/@polkadot/types/interfaces/extrinsics/definitions.js"() {
    definitions_default22 = {
      rpc: {},
      types: {
        Extrinsic: "GenericExtrinsic",
        ExtrinsicEra: "GenericExtrinsicEra",
        ExtrinsicPayload: "GenericExtrinsicPayload",
        ExtrinsicSignature: "MultiSignature",
        ExtrinsicV4: "GenericExtrinsicV4",
        ExtrinsicPayloadV4: "GenericExtrinsicPayloadV4",
        ExtrinsicSignatureV4: "GenericExtrinsicSignatureV4",
        ExtrinsicUnknown: "GenericExtrinsicUnknown",
        ExtrinsicPayloadUnknown: "GenericExtrinsicPayloadUnknown",
        ExtrinsicV5: "GenericExtrinsicV5",
        ExtrinsicPayloadV5: "GenericExtrinsicPayloadV5",
        ExtrinsicSignatureV5: "GenericExtrinsicSignatureV5",
        // eras
        Era: "ExtrinsicEra",
        ImmortalEra: "GenericImmortalEra",
        MortalEra: "GenericMortalEra",
        // signatures & signer
        AnySignature: "H512",
        MultiSignature: {
          _enum: {
            Ed25519: "Ed25519Signature",
            Sr25519: "Sr25519Signature",
            Ecdsa: "EcdsaSignature"
          }
        },
        Signature: "H512",
        SignerPayload: "GenericSignerPayload",
        EcdsaSignature: "[u8; 65]",
        Ed25519Signature: "H512",
        Sr25519Signature: "H512"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/fungibles/runtime.js
var runtime12;
var init_runtime12 = __esm({
  "../../node_modules/@polkadot/types/interfaces/fungibles/runtime.js"() {
    runtime12 = {
      FungiblesApi: [
        {
          methods: {
            query_account_balances: {
              description: "Returns the list of all `MultiAsset` that an `AccountId` has",
              params: [
                {
                  name: "account",
                  type: "AccountId"
                }
              ],
              type: "Result<Vec<XcmV3MultiAsset>, FungiblesAccessError>"
            }
          },
          version: 1
        },
        {
          methods: {
            query_account_balances: {
              description: "Returns the list of all `MultiAsset` that an `AccountId` has",
              params: [
                {
                  name: "account",
                  type: "AccountId"
                }
              ],
              type: "Result<XcmVersionedAssets, FungiblesAccessError>"
            }
          },
          version: 2
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/fungibles/definitions.js
var definitions_default23;
var init_definitions23 = __esm({
  "../../node_modules/@polkadot/types/interfaces/fungibles/definitions.js"() {
    init_runtime12();
    definitions_default23 = {
      rpc: {},
      runtime: runtime12,
      types: {
        FungiblesAccessError: {
          _enum: ["AssetIdConversionFailed", "AmountToBalanceConversionFailed"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/genericAsset/definitions.js
var definitions_default24;
var init_definitions24 = __esm({
  "../../node_modules/@polkadot/types/interfaces/genericAsset/definitions.js"() {
    definitions_default24 = {
      rpc: {},
      types: {
        AssetOptions: {
          initalIssuance: "Compact<Balance>",
          permissions: "PermissionLatest"
        },
        Owner: {
          _enum: {
            None: "Null",
            Address: "AccountId"
          }
        },
        PermissionsV1: {
          update: "Owner",
          mint: "Owner",
          burn: "Owner"
        },
        PermissionVersions: {
          _enum: {
            V1: "PermissionsV1"
          }
        },
        PermissionLatest: "PermissionsV1"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/genesisBuilder/runtime.js
var runtime13;
var init_runtime13 = __esm({
  "../../node_modules/@polkadot/types/interfaces/genesisBuilder/runtime.js"() {
    runtime13 = {
      GenesisBuilder: [
        {
          methods: {
            build_config: {
              description: "Build `RuntimeGenesisConfig` from a JSON blob not using any defaults and store it in the storage.",
              params: [
                {
                  name: "json",
                  type: "Vec<u8>"
                }
              ],
              type: "Result<(), GenesisBuildErr>"
            },
            create_default_config: {
              description: "Creates the default `RuntimeGenesisConfig` and returns it as a JSON blob.",
              params: [],
              type: "Vec<u8>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/genesisBuilder/definitions.js
var definitions_default25;
var init_definitions25 = __esm({
  "../../node_modules/@polkadot/types/interfaces/genesisBuilder/definitions.js"() {
    init_runtime13();
    definitions_default25 = {
      rpc: {},
      runtime: runtime13,
      types: {
        GenesisBuildErr: "Text"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/gilt/definitions.js
var definitions_default26;
var init_definitions26 = __esm({
  "../../node_modules/@polkadot/types/interfaces/gilt/definitions.js"() {
    definitions_default26 = {
      rpc: {},
      types: {
        ActiveGilt: {
          proportion: "Perquintill",
          amount: "Balance",
          who: "AccountId",
          expiry: "BlockNumber"
        },
        ActiveGiltsTotal: {
          frozen: "Balance",
          proportion: "Perquintill",
          index: "ActiveIndex",
          target: "Perquintill"
        },
        ActiveIndex: "u32",
        GiltBid: {
          amount: "Balance",
          who: "AccountId"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/grandpa/rpc.js
var rpc6;
var init_rpc6 = __esm({
  "../../node_modules/@polkadot/types/interfaces/grandpa/rpc.js"() {
    rpc6 = {
      proveFinality: {
        description: "Prove finality for the given block number, returning the Justification for the last block in the set.",
        params: [
          {
            name: "blockNumber",
            type: "BlockNumber"
          }
        ],
        type: "Option<EncodedFinalityProofs>"
      },
      roundState: {
        description: "Returns the state of the current best round state as well as the ongoing background rounds",
        params: [],
        type: "ReportedRoundStates"
      },
      subscribeJustifications: {
        description: "Subscribes to grandpa justifications",
        params: [],
        pubsub: [
          "justifications",
          "subscribeJustifications",
          "unsubscribeJustifications"
        ],
        type: "JustificationNotification"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/grandpa/runtime.js
var GRANDPA_V2_V3, runtime14;
var init_runtime14 = __esm({
  "../../node_modules/@polkadot/types/interfaces/grandpa/runtime.js"() {
    GRANDPA_V2_V3 = {
      generate_key_ownership_proof: {
        description: "Generates a proof of key ownership for the given authority in the given set.",
        params: [
          {
            name: "setId",
            type: "SetId"
          },
          {
            name: "authorityId",
            type: "AuthorityId"
          }
        ],
        type: "Option<OpaqueKeyOwnershipProof>"
      },
      grandpa_authorities: {
        description: "Get the current GRANDPA authorities and weights. This should not change except for when changes are scheduled and the corresponding delay has passed.",
        params: [],
        type: "AuthorityList"
      },
      submit_report_equivocation_unsigned_extrinsic: {
        description: "Submits an unsigned extrinsic to report an equivocation.",
        params: [
          {
            name: "equivocationProof",
            type: "GrandpaEquivocationProof"
          },
          {
            name: "keyOwnerProof",
            type: "OpaqueKeyOwnershipProof"
          }
        ],
        type: "Option<Null>"
      }
    };
    runtime14 = {
      GrandpaApi: [
        {
          methods: {
            current_set_id: {
              description: "Get current GRANDPA authority set id.",
              params: [],
              type: "SetId"
            },
            ...GRANDPA_V2_V3
          },
          version: 3
        },
        {
          methods: GRANDPA_V2_V3,
          version: 2
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/grandpa/definitions.js
var definitions_default27;
var init_definitions27 = __esm({
  "../../node_modules/@polkadot/types/interfaces/grandpa/definitions.js"() {
    init_rpc6();
    init_runtime14();
    definitions_default27 = {
      rpc: rpc6,
      runtime: runtime14,
      types: {
        AuthorityIndex: "u64",
        AuthorityList: "Vec<NextAuthority>",
        AuthoritySet: {
          currentAuthorities: "AuthorityList",
          setId: "u64",
          pendingStandardChanges: "ForkTreePendingChange",
          pendingForcedChanges: "Vec<PendingChange>",
          authoritySetChanges: "AuthoritySetChanges"
        },
        ForkTreePendingChange: {
          roots: "Vec<ForkTreePendingChangeNode>",
          bestFinalizedNumber: "Option<BlockNumber>"
        },
        ForkTreePendingChangeNode: {
          hash: "BlockHash",
          number: "BlockNumber",
          data: "PendingChange",
          // actual data, here PendingChange
          children: "Vec<ForkTreePendingChangeNode>"
        },
        AuthoritySetChange: "(U64, BlockNumber)",
        AuthoritySetChanges: "Vec<AuthoritySetChange>",
        AuthorityWeight: "u64",
        DelayKind: {
          _enum: {
            Finalized: "Null",
            Best: "DelayKindBest"
          }
        },
        DelayKindBest: {
          medianLastFinalized: "BlockNumber"
        },
        EncodedFinalityProofs: "Bytes",
        GrandpaEquivocation: {
          _enum: {
            Prevote: "GrandpaEquivocationValue",
            Precommit: "GrandpaEquivocationValue"
          }
        },
        GrandpaEquivocationProof: {
          setId: "SetId",
          equivocation: "GrandpaEquivocation"
        },
        GrandpaEquivocationValue: {
          roundNumber: "u64",
          identity: "AuthorityId",
          first: "(GrandpaPrevote, AuthoritySignature)",
          second: "(GrandpaPrevote, AuthoritySignature)"
        },
        GrandpaPrevote: {
          targetHash: "Hash",
          targetNumber: "BlockNumber"
        },
        GrandpaCommit: {
          targetHash: "BlockHash",
          targetNumber: "BlockNumber",
          precommits: "Vec<GrandpaSignedPrecommit>"
        },
        GrandpaPrecommit: {
          targetHash: "BlockHash",
          targetNumber: "BlockNumber"
        },
        GrandpaSignedPrecommit: {
          precommit: "GrandpaPrecommit",
          signature: "AuthoritySignature",
          id: "AuthorityId"
        },
        GrandpaJustification: {
          round: "u64",
          commit: "GrandpaCommit",
          votesAncestries: "Vec<Header>"
        },
        JustificationNotification: "Bytes",
        KeyOwnerProof: "MembershipProof",
        NextAuthority: "(AuthorityId, AuthorityWeight)",
        PendingChange: {
          nextAuthorities: "AuthorityList",
          delay: "BlockNumber",
          canonHeight: "BlockNumber",
          canonHash: "BlockHash",
          delayKind: "DelayKind"
        },
        PendingPause: {
          scheduledAt: "BlockNumber",
          delay: "BlockNumber"
        },
        PendingResume: {
          scheduledAt: "BlockNumber",
          delay: "BlockNumber"
        },
        Precommits: {
          currentWeight: "u32",
          missing: "BTreeSet<AuthorityId>"
        },
        Prevotes: {
          currentWeight: "u32",
          missing: "BTreeSet<AuthorityId>"
        },
        ReportedRoundStates: {
          setId: "u32",
          best: "RoundState",
          background: "Vec<RoundState>"
        },
        RoundState: {
          round: "u32",
          totalWeight: "u32",
          thresholdWeight: "u32",
          prevotes: "Prevotes",
          precommits: "Precommits"
        },
        SetId: "u64",
        StoredPendingChange: {
          scheduledAt: "BlockNumber",
          delay: "BlockNumber",
          nextAuthorities: "AuthorityList"
        },
        StoredState: {
          _enum: {
            Live: "Null",
            PendingPause: "PendingPause",
            Paused: "Null",
            PendingResume: "PendingResume"
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/identity/definitions.js
var definitions_default28;
var init_definitions28 = __esm({
  "../../node_modules/@polkadot/types/interfaces/identity/definitions.js"() {
    definitions_default28 = {
      rpc: {},
      types: {
        IdentityFields: {
          _set: {
            _bitLength: 64,
            // Mapped here to 32 bits, in Rust these are 64-bit values
            Display: 1,
            Legal: 2,
            Web: 4,
            Riot: 8,
            Email: 16,
            PgpFingerprint: 32,
            Image: 64,
            Twitter: 128
          }
        },
        IdentityInfoAdditional: "(Data, Data)",
        IdentityInfoTo198: {
          additional: "Vec<IdentityInfoAdditional>",
          display: "Data",
          legal: "Data",
          web: "Data",
          riot: "Data",
          email: "Data",
          pgpFingerprint: "Option<H160>",
          image: "Data"
        },
        IdentityInfo: {
          _fallback: "IdentityInfoTo198",
          additional: "Vec<IdentityInfoAdditional>",
          display: "Data",
          legal: "Data",
          web: "Data",
          riot: "Data",
          email: "Data",
          pgpFingerprint: "Option<H160>",
          image: "Data",
          twitter: "Data"
        },
        IdentityJudgement: {
          _enum: {
            Unknown: "Null",
            FeePaid: "Balance",
            Reasonable: "Null",
            KnownGood: "Null",
            OutOfDate: "Null",
            LowQuality: "Null",
            Erroneous: "Null"
          }
        },
        RegistrationJudgement: "(RegistrarIndex, IdentityJudgement)",
        RegistrationTo198: {
          judgements: "Vec<RegistrationJudgement>",
          deposit: "Balance",
          info: "IdentityInfoTo198"
        },
        Registration: {
          _fallback: "RegistrationTo198",
          judgements: "Vec<RegistrationJudgement>",
          deposit: "Balance",
          info: "IdentityInfo"
        },
        RegistrarIndex: "u32",
        RegistrarInfo: {
          account: "AccountId",
          fee: "Balance",
          fields: "IdentityFields"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/imOnline/definitions.js
var definitions_default29;
var init_definitions29 = __esm({
  "../../node_modules/@polkadot/types/interfaces/imOnline/definitions.js"() {
    definitions_default29 = {
      rpc: {},
      types: {
        AuthIndex: "u32",
        AuthoritySignature: "Signature",
        Heartbeat: {
          blockNumber: "BlockNumber",
          networkState: "OpaqueNetworkState",
          sessionIndex: "SessionIndex",
          authorityIndex: "AuthIndex",
          validatorsLen: "u32"
        },
        HeartbeatTo244: {
          blockNumber: "BlockNumber",
          networkState: "OpaqueNetworkState",
          sessionIndex: "SessionIndex",
          authorityIndex: "AuthIndex"
        },
        OpaqueMultiaddr: "Opaque<Bytes>",
        OpaquePeerId: "Opaque<Bytes>",
        OpaqueNetworkState: {
          peerId: "OpaquePeerId",
          externalAddresses: "Vec<OpaqueMultiaddr>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/lottery/definitions.js
var definitions_default30;
var init_definitions30 = __esm({
  "../../node_modules/@polkadot/types/interfaces/lottery/definitions.js"() {
    definitions_default30 = {
      rpc: {},
      types: {
        CallIndex: "(u8, u8)",
        LotteryConfig: {
          price: "Balance",
          start: "BlockNumber",
          length: "BlockNumber",
          delay: "BlockNumber",
          repeat: "bool"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/mixnet/runtime.js
var runtime15;
var init_runtime15 = __esm({
  "../../node_modules/@polkadot/types/interfaces/mixnet/runtime.js"() {
    runtime15 = {
      MixnetApi: [
        {
          methods: {
            current_mixnodes: {
              description: "Get the index and phase of the current session.",
              params: [],
              type: "Result<Mixnode, MixnodesErr>"
            },
            maybe_register: {
              description: "Try to register a mixnode for the next session.",
              params: [
                {
                  name: "session_index",
                  type: "u32"
                },
                {
                  name: "mixnode",
                  type: "Mixnode"
                }
              ],
              type: "bool"
            },
            prev_mixnodes: {
              description: "Get the index and phase of the current session.",
              params: [],
              type: "Result<Mixnode, MixnodesErr>"
            },
            session_status: {
              description: "Get the index and phase of the current session.",
              params: [],
              type: "SessionStatus"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/mixnet/definitions.js
var definitions_default31;
var init_definitions31 = __esm({
  "../../node_modules/@polkadot/types/interfaces/mixnet/definitions.js"() {
    init_runtime15();
    definitions_default31 = {
      rpc: {},
      runtime: runtime15,
      types: {
        Mixnode: {
          externalAddresses: "Vec<Bytes>",
          kxPublic: "[u8; 32]",
          peerId: "[u8; 32]"
        },
        MixnodesErr: {
          _enum: {
            InsufficientRegistrations: {
              min: "u32",
              num: "u32"
            }
          }
        },
        SessionPhase: {
          _enum: ["CoverToCurrent", "RequestsToCurrent", "CoverToPrev", "DisconnectFromPrev"]
        },
        SessionStatus: {
          currentIndex: "u32",
          phase: "SessionPhase"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/mmr/rpc.js
var rpc7;
var init_rpc7 = __esm({
  "../../node_modules/@polkadot/types/interfaces/mmr/rpc.js"() {
    rpc7 = {
      generateProof: {
        description: "Generate MMR proof for the given block numbers.",
        params: [
          {
            name: "blockNumbers",
            type: "Vec<u64>"
          },
          {
            isOptional: true,
            name: "bestKnownBlockNumber",
            type: "u64"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "MmrLeafBatchProof"
      },
      root: {
        description: "Get the MMR root hash for the current best block.",
        params: [
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "MmrHash"
      },
      verifyProof: {
        description: "Verify an MMR proof",
        params: [
          {
            name: "proof",
            type: "MmrLeafBatchProof"
          }
        ],
        type: "bool"
      },
      verifyProofStateless: {
        description: "Verify an MMR proof statelessly given an mmr_root",
        params: [
          {
            name: "root",
            type: "MmrHash"
          },
          {
            name: "proof",
            type: "MmrLeafBatchProof"
          }
        ],
        type: "bool"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/mmr/runtime.js
var MMR_V2, MMR_V1, runtime16;
var init_runtime16 = __esm({
  "../../node_modules/@polkadot/types/interfaces/mmr/runtime.js"() {
    MMR_V2 = {
      generate_proof: {
        description: "Generate MMR proof for the given block numbers.",
        params: [
          {
            name: "blockNumbers",
            type: "Vec<BlockNumber>"
          },
          {
            name: "bestKnownBlockNumber",
            type: "Option<BlockNumber>"
          }
        ],
        type: "Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>"
      },
      mmr_leaf_count: {
        description: "Return the number of MMR blocks in the chain.",
        params: [],
        type: "Result<U64, MmrError>"
      },
      mmr_root: {
        description: "Return the on-chain MMR root hash.",
        params: [],
        type: "Result<Hash, MmrError>"
      },
      verify_proof: {
        description: "Verify MMR proof against on-chain MMR.",
        params: [
          {
            name: "leaves",
            type: "Vec<MmrEncodableOpaqueLeaf>"
          },
          {
            name: "proof",
            type: "MmrBatchProof"
          }
        ],
        type: "Result<(), MmrError>"
      },
      verify_proof_stateless: {
        description: "Verify MMR proof against given root hash.",
        params: [
          {
            name: "root",
            type: "Hash"
          },
          {
            name: "leaves",
            type: "Vec<MmrEncodableOpaqueLeaf>"
          },
          {
            name: "proof",
            type: "MmrBatchProof"
          }
        ],
        type: "Result<(), MmrError>"
      }
    };
    MMR_V1 = {
      generate_batch_proof: {
        description: "Generate MMR proof for a series of leaves under given indices.",
        params: [
          {
            name: "leafIndices",
            type: "Vec<MmrLeafIndex>"
          }
        ],
        type: "Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>"
      },
      generate_proof: {
        description: "Generate MMR proof for a leaf under given index.",
        params: [
          {
            name: "leafIndex",
            type: "MmrLeafIndex"
          }
        ],
        type: "Result<(MmrEncodableOpaqueLeaf, MmrProof), MmrError>"
      },
      mmr_root: {
        description: "Return the on-chain MMR root hash.",
        params: [],
        type: "Result<Hash, MmrError>"
      },
      verify_batch_proof: {
        description: "Verify MMR proof against on-chain MMR for a batch of leaves.",
        params: [
          {
            name: "leaves",
            type: "Vec<MmrEncodableOpaqueLeaf>"
          },
          {
            name: "proof",
            type: "MmrBatchProof"
          }
        ],
        type: "Result<(), MmrError>"
      },
      verify_batch_proof_stateless: {
        description: "Verify MMR proof against given root hash or a batch of leaves.",
        params: [
          {
            name: "root",
            type: "Hash"
          },
          {
            name: "leaves",
            type: "Vec<MmrEncodableOpaqueLeaf>"
          },
          {
            name: "proof",
            type: "MmrBatchProof"
          }
        ],
        type: "Result<(), MmrError>"
      },
      verify_proof: {
        description: "Verify MMR proof against on-chain MMR.",
        params: [
          {
            name: "leaf",
            type: "MmrEncodableOpaqueLeaf"
          },
          {
            name: "proof",
            type: "MmrProof"
          }
        ],
        type: "Result<(), MmrError>"
      },
      verify_proof_stateless: {
        description: "Verify MMR proof against given root hash.",
        params: [
          {
            name: "root",
            type: "Hash"
          },
          {
            name: "leaf",
            type: "MmrEncodableOpaqueLeaf"
          },
          {
            name: "proof",
            type: "MmrProof"
          }
        ],
        type: "Result<(), MmrError>"
      }
    };
    runtime16 = {
      MmrApi: [
        {
          methods: MMR_V2,
          version: 2
        },
        {
          methods: MMR_V1,
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/mmr/definitions.js
var definitions_default32;
var init_definitions32 = __esm({
  "../../node_modules/@polkadot/types/interfaces/mmr/definitions.js"() {
    init_rpc7();
    init_runtime16();
    definitions_default32 = {
      rpc: rpc7,
      runtime: runtime16,
      types: {
        MmrBatchProof: {
          leafIndices: "Vec<MmrLeafIndex>",
          leafCount: "MmrNodeIndex",
          items: "Vec<Hash>"
        },
        MmrEncodableOpaqueLeaf: "Bytes",
        MmrError: {
          _enum: ["InvalidNumericOp", "Push", "GetRoot", "Commit", "GenerateProof", "Verify", "LeafNotFound", " PalletNotIncluded", "InvalidLeafIndex", "InvalidBestKnownBlock"]
        },
        MmrHash: "Hash",
        MmrLeafBatchProof: {
          blockHash: "BlockHash",
          leaves: "Bytes",
          proof: "Bytes"
        },
        MmrLeafIndex: "u64",
        MmrLeafProof: {
          blockHash: "BlockHash",
          leaf: "Bytes",
          proof: "Bytes"
        },
        MmrNodeIndex: "u64",
        MmrProof: {
          leafIndex: "MmrLeafIndex",
          leafCount: "MmrNodeIndex",
          items: "Vec<Hash>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/nfts/runtime.js
var runtime17;
var init_runtime17 = __esm({
  "../../node_modules/@polkadot/types/interfaces/nfts/runtime.js"() {
    runtime17 = {
      NftsApi: [
        {
          methods: {
            attribute: {
              description: "An attribute",
              params: [
                {
                  name: "collection",
                  type: "NftCollectionId"
                },
                {
                  name: "item",
                  type: "NftItemId"
                },
                {
                  name: "key",
                  type: "Bytes"
                }
              ],
              type: "Option<Bytes>"
            },
            collection_attribute: {
              description: "A collection attribute",
              params: [
                {
                  name: "collection",
                  type: "NftCollectionId"
                },
                {
                  name: "key",
                  type: "Bytes"
                }
              ],
              type: "Option<Bytes>"
            },
            collection_owner: {
              description: "A collection owner",
              params: [
                {
                  name: "collection",
                  type: "NftCollectionId"
                }
              ],
              type: "Option<AccountId>"
            },
            custom_attribute: {
              description: "A custom attribute",
              params: [
                {
                  name: "account",
                  type: "AccountId"
                },
                {
                  name: "collection",
                  type: "NftCollectionId"
                },
                {
                  name: "item",
                  type: "NftItemId"
                },
                {
                  name: "key",
                  type: "Bytes"
                }
              ],
              type: "Option<Bytes>"
            },
            owner: {
              description: "Collection owner",
              params: [
                {
                  name: "collection",
                  type: "NftCollectionId"
                },
                {
                  name: "item",
                  type: "NftItemId"
                }
              ],
              type: "Option<AccountId>"
            },
            system_attribute: {
              description: "System attribute",
              params: [
                {
                  name: "collection",
                  type: "NftCollectionId"
                },
                {
                  name: "item",
                  type: "NftItemId"
                },
                {
                  name: "key",
                  type: "Bytes"
                }
              ],
              type: "Option<Bytes>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/nfts/definitions.js
var definitions_default33;
var init_definitions33 = __esm({
  "../../node_modules/@polkadot/types/interfaces/nfts/definitions.js"() {
    init_runtime17();
    definitions_default33 = {
      rpc: {},
      runtime: runtime17,
      types: {
        NftCollectionId: "u32",
        NftItemId: "u32"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/nompools/runtime.js
var runtime18;
var init_runtime18 = __esm({
  "../../node_modules/@polkadot/types/interfaces/nompools/runtime.js"() {
    runtime18 = {
      NominationPoolsApi: [
        {
          methods: {
            balance_to_points: {
              description: "Returns the equivalent points of `new_funds` for a given pool.",
              params: [
                {
                  name: "poolId",
                  type: "NpPoolId"
                },
                {
                  name: "newFunds",
                  type: "Balance"
                }
              ],
              type: "Balance"
            },
            pending_rewards: {
              description: "Returns the pending rewards for the given member.",
              params: [
                {
                  name: "member",
                  type: "AccountId"
                }
              ],
              type: "Balance"
            },
            points_to_balance: {
              description: "Returns the equivalent balance of `points` for a given pool.",
              params: [
                {
                  name: "poolId",
                  type: "NpPoolId"
                },
                {
                  name: "points",
                  type: "Balance"
                }
              ],
              type: "Balance"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/nompools/definitions.js
var definitions_default34;
var init_definitions34 = __esm({
  "../../node_modules/@polkadot/types/interfaces/nompools/definitions.js"() {
    init_runtime18();
    definitions_default34 = {
      rpc: {},
      runtime: runtime18,
      types: {
        NpApiError: {
          _enum: ["MemberNotFound", "OverflowInPendingRewards"]
        },
        NpPoolId: "u32"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/offences/definitions.js
var definitions_default35;
var init_definitions35 = __esm({
  "../../node_modules/@polkadot/types/interfaces/offences/definitions.js"() {
    definitions_default35 = {
      rpc: {},
      types: {
        DeferredOffenceOf: "(Vec<OffenceDetails>, Vec<Perbill>, SessionIndex)",
        Kind: "[u8; 16]",
        OffenceDetails: {
          offender: "Offender",
          reporters: "Vec<Reporter>"
        },
        Offender: "IdentificationTuple",
        OpaqueTimeSlot: "Bytes",
        ReportIdOf: "Hash",
        Reporter: "AccountId"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/pow/runtime.js
var runtime19;
var init_runtime19 = __esm({
  "../../node_modules/@polkadot/types/interfaces/pow/runtime.js"() {
    runtime19 = {
      DifficultyApi: [
        {
          methods: {
            difficulty: {
              description: "Return the target difficulty of the next block.",
              params: [],
              // This is Difficulty in the original, however this is chain-specific
              type: "Raw"
            }
          },
          version: 1
        }
      ],
      TimestampApi: [
        {
          methods: {
            timestamp: {
              description: "API necessary for timestamp-based difficulty adjustment algorithms.",
              params: [],
              type: "Moment"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/pow/definitions.js
var definitions_default36;
var init_definitions36 = __esm({
  "../../node_modules/@polkadot/types/interfaces/pow/definitions.js"() {
    init_runtime19();
    definitions_default36 = {
      rpc: {},
      runtime: runtime19,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/proxy/definitions.js
var definitions_default37;
var init_definitions37 = __esm({
  "../../node_modules/@polkadot/types/interfaces/proxy/definitions.js"() {
    definitions_default37 = {
      rpc: {},
      types: {
        ProxyDefinition: {
          delegate: "AccountId",
          proxyType: "ProxyType",
          delay: "BlockNumber"
        },
        ProxyType: {
          _enum: ["Any", "NonTransfer", "Governance", "Staking"]
        },
        ProxyAnnouncement: {
          real: "AccountId",
          callHash: "Hash",
          height: "BlockNumber"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/recovery/definitions.js
var definitions_default38;
var init_definitions38 = __esm({
  "../../node_modules/@polkadot/types/interfaces/recovery/definitions.js"() {
    definitions_default38 = {
      rpc: {},
      types: {
        ActiveRecovery: {
          created: "BlockNumber",
          deposit: "Balance",
          friends: "Vec<AccountId>"
        },
        RecoveryConfig: {
          delayPeriod: "BlockNumber",
          deposit: "Balance",
          friends: "Vec<AccountId>",
          threshold: "u16"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/scheduler/definitions.js
var definitions_default39;
var init_definitions39 = __esm({
  "../../node_modules/@polkadot/types/interfaces/scheduler/definitions.js"() {
    definitions_default39 = {
      rpc: {},
      types: {
        Period: "(BlockNumber, u32)",
        Priority: "u8",
        SchedulePeriod: "Period",
        SchedulePriority: "Priority",
        Scheduled: {
          maybeId: "Option<Bytes>",
          priority: "SchedulePriority",
          call: "Call",
          maybePeriodic: "Option<SchedulePeriod>",
          origin: "PalletsOrigin"
        },
        ScheduledTo254: {
          maybeId: "Option<Bytes>",
          priority: "SchedulePriority",
          call: "Call",
          maybePeriodic: "Option<SchedulePeriod>"
        },
        TaskAddress: "(BlockNumber, u32)"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/session/runtime.js
var runtime20;
var init_runtime20 = __esm({
  "../../node_modules/@polkadot/types/interfaces/session/runtime.js"() {
    runtime20 = {
      SessionKeys: [
        {
          methods: {
            decode_session_keys: {
              description: "Decode the given public session keys.",
              params: [
                {
                  name: "encoded",
                  type: "Bytes"
                }
              ],
              type: "Option<Vec<(Bytes, KeyTypeId)>>"
            },
            generate_session_keys: {
              description: "Generate a set of session keys with optionally using the given seed.",
              params: [
                {
                  name: "seed",
                  type: "Option<Bytes>"
                }
              ],
              type: "Bytes"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/session/definitions.js
var keyTypes, definitions_default40;
var init_definitions40 = __esm({
  "../../node_modules/@polkadot/types/interfaces/session/definitions.js"() {
    init_runtime20();
    keyTypes = {
      // key for beefy
      BeefyKey: "[u8; 33]",
      // default to Substrate master defaults, 4 keys (polkadot master, 5 keys)
      Keys: "SessionKeys4",
      SessionKeys1: "(AccountId)",
      SessionKeys2: "(AccountId, AccountId)",
      SessionKeys3: "(AccountId, AccountId, AccountId)",
      SessionKeys4: "(AccountId, AccountId, AccountId, AccountId)",
      SessionKeys5: "(AccountId, AccountId, AccountId, AccountId, AccountId)",
      SessionKeys6: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
      SessionKeys6B: "(AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
      SessionKeys7: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
      SessionKeys7B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
      SessionKeys8: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
      SessionKeys8B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
      SessionKeys9: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
      SessionKeys9B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
      SessionKeys10: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
      SessionKeys10B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)"
    };
    definitions_default40 = {
      rpc: {},
      runtime: runtime20,
      types: {
        ...keyTypes,
        FullIdentification: "Exposure",
        IdentificationTuple: "(ValidatorId, FullIdentification)",
        MembershipProof: {
          session: "SessionIndex",
          trieNodes: "Vec<Bytes>",
          validatorCount: "ValidatorCount"
        },
        SessionIndex: "u32",
        ValidatorCount: "u32"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/society/definitions.js
var definitions_default41;
var init_definitions41 = __esm({
  "../../node_modules/@polkadot/types/interfaces/society/definitions.js"() {
    definitions_default41 = {
      rpc: {},
      types: {
        Bid: {
          who: "AccountId",
          kind: "BidKind",
          value: "Balance"
        },
        BidKind: {
          _enum: {
            Deposit: "Balance",
            Vouch: "(AccountId, Balance)"
          }
        },
        // a society-specific Judgement (not the same as identity Judgement)
        SocietyJudgement: {
          _enum: ["Rebid", "Reject", "Approve"]
        },
        // a society-specific Vote
        SocietyVote: {
          _enum: ["Skeptic", "Reject", "Approve"]
        },
        StrikeCount: "u32",
        VouchingStatus: {
          _enum: ["Vouching", "Banned"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/staking/runtime.js
var runtime21;
var init_runtime21 = __esm({
  "../../node_modules/@polkadot/types/interfaces/staking/runtime.js"() {
    runtime21 = {
      StakingApi: [
        {
          methods: {
            nominations_quota: {
              description: "Returns the nominations quota for a nominator with a given balance.",
              params: [
                {
                  name: "balance",
                  type: "Balance"
                }
              ],
              type: "u32"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/staking/definitions.js
var deprecated, phragmen, definitions_default42;
var init_definitions42 = __esm({
  "../../node_modules/@polkadot/types/interfaces/staking/definitions.js"() {
    init_runtime21();
    deprecated = {
      Points: "u32",
      EraPoints: {
        total: "Points",
        individual: "Vec<Points>"
      }
    };
    phragmen = {
      CompactAssignments: "CompactAssignmentsWith16",
      CompactAssignmentsWith16: {
        votes1: "Vec<(NominatorIndexCompact, ValidatorIndexCompact)>",
        votes2: "Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>",
        votes3: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>",
        votes4: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>",
        votes5: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>",
        votes6: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>",
        votes7: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>",
        votes8: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>",
        votes9: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>",
        votes10: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>",
        votes11: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>",
        votes12: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>",
        votes13: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>",
        votes14: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>",
        votes15: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>",
        votes16: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>"
      },
      CompactAssignmentsWith24: {
        votes1: "Vec<(NominatorIndexCompact, ValidatorIndexCompact)>",
        votes2: "Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>",
        votes3: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>",
        votes4: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>",
        votes5: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>",
        votes6: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>",
        votes7: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>",
        votes8: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>",
        votes9: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>",
        votes10: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>",
        votes11: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>",
        votes12: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>",
        votes13: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>",
        votes14: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>",
        votes15: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>",
        votes16: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>",
        votes17: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 16], ValidatorIndexCompact)>",
        votes18: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 17], ValidatorIndexCompact)>",
        votes19: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 18], ValidatorIndexCompact)>",
        votes20: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 19], ValidatorIndexCompact)>",
        votes21: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 20], ValidatorIndexCompact)>",
        votes22: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 21], ValidatorIndexCompact)>",
        votes23: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 22], ValidatorIndexCompact)>",
        votes24: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 23], ValidatorIndexCompact)>"
      },
      CompactAssignmentsTo265: "CompactAssignmentsWith16",
      CompactAssignmentsTo257: {
        votes1: "Vec<(NominatorIndex, [CompactScore; 0], ValidatorIndex)>",
        votes2: "Vec<(NominatorIndex, [CompactScore; 1], ValidatorIndex)>",
        votes3: "Vec<(NominatorIndex, [CompactScore; 2], ValidatorIndex)>",
        votes4: "Vec<(NominatorIndex, [CompactScore; 3], ValidatorIndex)>",
        votes5: "Vec<(NominatorIndex, [CompactScore; 4], ValidatorIndex)>",
        votes6: "Vec<(NominatorIndex, [CompactScore; 5], ValidatorIndex)>",
        votes7: "Vec<(NominatorIndex, [CompactScore; 6], ValidatorIndex)>",
        votes8: "Vec<(NominatorIndex, [CompactScore; 7], ValidatorIndex)>",
        votes9: "Vec<(NominatorIndex, [CompactScore; 8], ValidatorIndex)>",
        votes10: "Vec<(NominatorIndex, [CompactScore; 9], ValidatorIndex)>",
        votes11: "Vec<(NominatorIndex, [CompactScore; 10], ValidatorIndex)>",
        votes12: "Vec<(NominatorIndex, [CompactScore; 11], ValidatorIndex)>",
        votes13: "Vec<(NominatorIndex, [CompactScore; 12], ValidatorIndex)>",
        votes14: "Vec<(NominatorIndex, [CompactScore; 13], ValidatorIndex)>",
        votes15: "Vec<(NominatorIndex, [CompactScore; 14], ValidatorIndex)>",
        votes16: "Vec<(NominatorIndex, [CompactScore; 15], ValidatorIndex)>"
      },
      CompactScore: "(ValidatorIndex, OffchainAccuracy)",
      CompactScoreCompact: "(ValidatorIndexCompact, OffchainAccuracyCompact)",
      ElectionCompute: {
        // in previous versions the last entry was "AuthorityId"
        // (since no data attached, and it is via SCALE can rename)
        _enum: ["OnChain", "Signed", "Unsigned"]
      },
      ElectionPhase: {
        _enum: {
          Off: null,
          Signed: null,
          Unsigned: "(bool, BlockNumber)",
          Emergency: null
        }
      },
      ElectionResult: {
        compute: "ElectionCompute",
        slotStake: "Balance",
        electedStashes: "Vec<AccountId>",
        exposures: "Vec<(AccountId, Exposure)>"
      },
      ElectionScore: "[u128; 3]",
      ElectionSize: {
        validators: "Compact<ValidatorIndex>",
        nominators: "Compact<NominatorIndex>"
      },
      ElectionStatus: {
        _enum: {
          Close: "Null",
          Open: "BlockNumber"
        }
      },
      ExtendedBalance: "u128",
      RawSolution: "RawSolutionWith16",
      RawSolutionWith16: {
        compact: "CompactAssignmentsWith16",
        score: "ElectionScore",
        round: "u32"
      },
      RawSolutionWith24: {
        compact: "CompactAssignmentsWith24",
        score: "ElectionScore",
        round: "u32"
      },
      RawSolutionTo265: "RawSolutionWith16",
      ReadySolution: {
        supports: "SolutionSupports",
        score: "ElectionScore",
        compute: "ElectionCompute"
      },
      RoundSnapshot: {
        voters: "Vec<(AccountId, VoteWeight, Vec<AccountId>)>",
        targets: "Vec<AccountId>"
      },
      SeatHolder: {
        who: "AccountId",
        stake: "Balance",
        deposit: "Balance"
      },
      SignedSubmission: {
        _fallback: "SignedSubmissionTo276",
        who: "AccountId",
        deposit: "Balance",
        solution: "RawSolution",
        reward: "Balance"
      },
      SignedSubmissionTo276: {
        who: "AccountId",
        deposit: "Balance",
        solution: "RawSolution"
      },
      SignedSubmissionOf: "SignedSubmission",
      SolutionOrSnapshotSize: {
        voters: "Compact<u32>",
        targets: "Compact<u32>"
      },
      SolutionSupport: {
        total: "ExtendedBalance",
        voters: "Vec<(AccountId, ExtendedBalance)>"
      },
      SolutionSupports: "Vec<(AccountId, SolutionSupport)>",
      Supports: "SolutionSupports",
      SubmissionIndicesOf: "BTreeMap<ElectionScore, u32>",
      Voter: {
        votes: "Vec<AccountId>",
        stake: "Balance",
        deposit: "Balance"
      },
      VoteWeight: "u64"
    };
    definitions_default42 = {
      rpc: {},
      runtime: runtime21,
      types: {
        ...deprecated,
        ...phragmen,
        ActiveEraInfo: {
          index: "EraIndex",
          start: "Option<Moment>"
        },
        EraIndex: "u32",
        EraRewardPoints: {
          total: "RewardPoint",
          individual: "BTreeMap<AccountId, RewardPoint>"
        },
        EraRewards: {
          total: "u32",
          rewards: "Vec<u32>"
        },
        Exposure: {
          total: "Compact<Balance>",
          own: "Compact<Balance>",
          others: "Vec<IndividualExposure>"
        },
        Forcing: {
          _enum: [
            "NotForcing",
            "ForceNew",
            "ForceNone",
            "ForceAlways"
          ]
        },
        IndividualExposure: {
          who: "AccountId",
          value: "Compact<Balance>"
        },
        KeyType: "AccountId",
        MomentOf: "Moment",
        Nominations: {
          targets: "Vec<AccountId>",
          submittedIn: "EraIndex",
          suppressed: "bool"
        },
        NominatorIndex: "u32",
        NominatorIndexCompact: "Compact<NominatorIndex>",
        OffchainAccuracy: "PerU16",
        OffchainAccuracyCompact: "Compact<OffchainAccuracy>",
        PhragmenScore: "[u128; 3]",
        Points: "u32",
        RewardDestination: {
          _enum: {
            Staked: "Null",
            Stash: "Null",
            Controller: "Null",
            Account: "AccountId",
            None: "Null"
          }
        },
        RewardPoint: "u32",
        SlashJournalEntry: {
          who: "AccountId",
          amount: "Balance",
          ownSlash: "Balance"
        },
        SlashingSpansTo204: {
          spanIndex: "SpanIndex",
          lastStart: "EraIndex",
          prior: "Vec<EraIndex>"
        },
        SlashingSpans: {
          spanIndex: "SpanIndex",
          lastStart: "EraIndex",
          lastNonzeroSlash: "EraIndex",
          prior: "Vec<EraIndex>"
        },
        SpanIndex: "u32",
        SpanRecord: {
          slashed: "Balance",
          paidOut: "Balance"
        },
        StakingLedgerTo223: {
          stash: "AccountId",
          total: "Compact<Balance>",
          active: "Compact<Balance>",
          unlocking: "Vec<UnlockChunk>"
        },
        StakingLedgerTo240: {
          _fallback: "StakingLedgerTo223",
          stash: "AccountId",
          total: "Compact<Balance>",
          active: "Compact<Balance>",
          unlocking: "Vec<UnlockChunk>",
          lastReward: "Option<EraIndex>"
        },
        StakingLedger: {
          stash: "AccountId",
          total: "Compact<Balance>",
          active: "Compact<Balance>",
          unlocking: "Vec<UnlockChunk>",
          claimedRewards: "Vec<EraIndex>"
        },
        UnappliedSlashOther: "(AccountId, Balance)",
        UnappliedSlash: {
          validator: "AccountId",
          own: "Balance",
          others: "Vec<UnappliedSlashOther>",
          reporters: "Vec<AccountId>",
          payout: "Balance"
        },
        UnlockChunk: {
          value: "Compact<Balance>",
          era: "Compact<BlockNumber>"
        },
        ValidatorIndex: "u16",
        ValidatorIndexCompact: "Compact<ValidatorIndex>",
        ValidatorPrefs: "ValidatorPrefsWithBlocked",
        ValidatorPrefsWithCommission: {
          commission: "Compact<Perbill>"
        },
        ValidatorPrefsWithBlocked: {
          commission: "Compact<Perbill>",
          blocked: "bool"
        },
        ValidatorPrefsTo196: {
          validatorPayment: "Compact<Balance>"
        },
        ValidatorPrefsTo145: {
          unstakeThreshold: "Compact<u32>",
          validatorPayment: "Compact<Balance>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/statement/runtime.js
var runtime22;
var init_runtime22 = __esm({
  "../../node_modules/@polkadot/types/interfaces/statement/runtime.js"() {
    runtime22 = {
      ValidateStatement: [
        {
          methods: {
            valdate_statement: {
              description: "Validate the statement.",
              params: [
                {
                  name: "source",
                  type: "StatementStoreStatementSource"
                },
                {
                  name: "statement",
                  type: "SpStatementStoreStatement"
                }
              ],
              type: "Result<StatementStoreValidStatement, StatementStoreInvalidStatement>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/statement/definitions.js
var definitions_default43;
var init_definitions43 = __esm({
  "../../node_modules/@polkadot/types/interfaces/statement/definitions.js"() {
    init_runtime22();
    definitions_default43 = {
      rpc: {},
      runtime: runtime22,
      types: {
        StatementStoreStatementSource: {
          _enum: ["Chain", "Network", "Local"]
        },
        StatementStoreValidStatement: {
          maxCount: "u32",
          maxSize: "u32"
        },
        StatementStoreInvalidStatement: {
          _enum: ["BadProof", "NoProof", "InternalError"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/support/definitions.js
var definitions_default44;
var init_definitions44 = __esm({
  "../../node_modules/@polkadot/types/interfaces/support/definitions.js"() {
    definitions_default44 = {
      rpc: {},
      types: {
        WeightToFeeCoefficient: {
          coeffInteger: "Balance",
          coeffFrac: "Perbill",
          negative: "bool",
          degree: "u8"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/syncstate/rpc.js
var rpc8;
var init_rpc8 = __esm({
  "../../node_modules/@polkadot/types/interfaces/syncstate/rpc.js"() {
    rpc8 = {
      genSyncSpec: {
        description: "Returns the json-serialized chainspec running the node, with a sync state.",
        endpoint: "sync_state_genSyncSpec",
        params: [
          {
            name: "raw",
            type: "bool"
          }
        ],
        type: "Json"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/syncstate/definitions.js
var definitions_default45;
var init_definitions45 = __esm({
  "../../node_modules/@polkadot/types/interfaces/syncstate/definitions.js"() {
    init_rpc8();
    definitions_default45 = {
      rpc: rpc8,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/system/rpc.js
var rpc9;
var init_rpc9 = __esm({
  "../../node_modules/@polkadot/types/interfaces/system/rpc.js"() {
    rpc9 = {
      accountNextIndex: {
        alias: ["account_nextIndex"],
        description: "Retrieves the next accountIndex as available on the node",
        params: [
          {
            name: "accountId",
            type: "AccountId"
          }
        ],
        type: "Index"
      },
      addLogFilter: {
        description: "Adds the supplied directives to the current log filter",
        isUnsafe: true,
        params: [
          {
            name: "directives",
            type: "Text"
          }
        ],
        type: "Null"
      },
      addReservedPeer: {
        description: "Adds a reserved peer",
        isUnsafe: true,
        params: [
          {
            name: "peer",
            type: "Text"
          }
        ],
        type: "Text"
      },
      chain: {
        description: "Retrieves the chain",
        params: [],
        type: "Text"
      },
      chainType: {
        description: "Retrieves the chain type",
        params: [],
        type: "ChainType"
      },
      dryRun: {
        alias: ["system_dryRunAt"],
        description: "Dry run an extrinsic at a given block",
        isUnsafe: true,
        params: [
          {
            name: "extrinsic",
            type: "Bytes"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "ApplyExtrinsicResult"
      },
      health: {
        description: "Return health status of the node",
        noErrorLog: true,
        params: [],
        type: "Health"
      },
      localListenAddresses: {
        description: "The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example",
        params: [],
        type: "Vec<Text>"
      },
      localPeerId: {
        description: "Returns the base58-encoded PeerId of the node",
        params: [],
        type: "Text"
      },
      name: {
        description: "Retrieves the node name",
        params: [],
        type: "Text"
      },
      networkState: {
        alias: ["system_unstable_networkState"],
        description: "Returns current state of the network",
        isUnsafe: true,
        params: [],
        type: "NetworkState"
      },
      nodeRoles: {
        description: "Returns the roles the node is running as",
        params: [],
        type: "Vec<NodeRole>"
      },
      peers: {
        description: "Returns the currently connected peers",
        isUnsafe: true,
        params: [],
        type: "Vec<PeerInfo>"
      },
      properties: {
        description: "Get a custom set of properties as a JSON object, defined in the chain spec",
        params: [],
        type: "ChainProperties"
      },
      removeReservedPeer: {
        description: "Remove a reserved peer",
        isUnsafe: true,
        params: [
          {
            name: "peerId",
            type: "Text"
          }
        ],
        type: "Text"
      },
      reservedPeers: {
        description: "Returns the list of reserved peers",
        params: [],
        type: "Vec<Text>"
      },
      resetLogFilter: {
        description: "Resets the log filter to Substrate defaults",
        isUnsafe: true,
        params: [],
        type: "Null"
      },
      syncState: {
        description: "Returns the state of the syncing of the node",
        params: [],
        type: "SyncState"
      },
      version: {
        description: "Retrieves the version of the node",
        params: [],
        type: "Text"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/system/runtime.js
var runtime23;
var init_runtime23 = __esm({
  "../../node_modules/@polkadot/types/interfaces/system/runtime.js"() {
    runtime23 = {
      AccountNonceApi: [
        {
          methods: {
            account_nonce: {
              description: "The API to query account nonce (aka transaction index)",
              params: [
                {
                  name: "accountId",
                  type: "AccountId"
                }
              ],
              type: "Index"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/system/definitions.js
var definitions_default46;
var init_definitions46 = __esm({
  "../../node_modules/@polkadot/types/interfaces/system/definitions.js"() {
    init_rpc9();
    init_runtime23();
    definitions_default46 = {
      rpc: rpc9,
      runtime: runtime23,
      types: {
        AccountInfo: "AccountInfoWithTripleRefCount",
        AccountInfoWithRefCountU8: {
          nonce: "Index",
          refcount: "u8",
          data: "AccountData"
        },
        AccountInfoWithRefCount: {
          _fallback: "AccountInfoWithRefCountU8",
          nonce: "Index",
          refcount: "RefCount",
          data: "AccountData"
        },
        AccountInfoWithDualRefCount: {
          _fallback: "AccountInfoWithRefCount",
          nonce: "Index",
          consumers: "RefCount",
          providers: "RefCount",
          data: "AccountData"
        },
        // original naming
        AccountInfoWithProviders: "AccountInfoWithDualRefCount",
        AccountInfoWithTripleRefCount: {
          _fallback: "AccountInfoWithDualRefCount",
          nonce: "Index",
          consumers: "RefCount",
          providers: "RefCount",
          sufficients: "RefCount",
          data: "AccountData"
        },
        ApplyExtrinsicResult: "Result<DispatchOutcome, TransactionValidityError>",
        ApplyExtrinsicResultPre6: "Result<DispatchOutcomePre6, TransactionValidityError>",
        ArithmeticError: {
          _enum: [
            "Underflow",
            "Overflow",
            "DivisionByZero"
          ]
        },
        BlockLength: {
          max: "PerDispatchClassU32"
        },
        BlockWeights: {
          baseBlock: "Weight",
          maxBlock: "Weight",
          perClass: "PerDispatchClassWeightsPerClass"
        },
        ChainProperties: "GenericChainProperties",
        ChainType: {
          _enum: {
            Development: "Null",
            Local: "Null",
            Live: "Null",
            Custom: "Text"
          }
        },
        ConsumedWeight: "PerDispatchClassWeight",
        DigestOf: "Digest",
        DispatchClass: {
          _enum: ["Normal", "Operational", "Mandatory"]
        },
        DispatchError: {
          _enum: {
            Other: "Null",
            CannotLookup: "Null",
            BadOrigin: "Null",
            Module: "DispatchErrorModule",
            ConsumerRemaining: "Null",
            NoProviders: "Null",
            TooManyConsumers: "Null",
            Token: "TokenError",
            Arithmetic: "ArithmeticError",
            Transactional: "TransactionalError",
            Exhausted: "Null",
            Corruption: "Null",
            Unavailable: "Null"
          }
        },
        DispatchErrorPre6: {
          _enum: {
            Other: "Null",
            CannotLookup: "Null",
            BadOrigin: "Null",
            Module: "DispatchErrorModulePre6",
            ConsumerRemaining: "Null",
            NoProviders: "Null",
            TooManyConsumers: "Null",
            Token: "TokenError",
            Arithmetic: "ArithmeticError",
            Transactional: "TransactionalError"
          }
        },
        DispatchErrorPre6First: {
          // The enum was modified mid-flight, affecting asset chains -
          // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
          _enum: {
            Other: "Null",
            CannotLookup: "Null",
            BadOrigin: "Null",
            Module: "DispatchErrorModulePre6",
            ConsumerRemaining: "Null",
            NoProviders: "Null",
            Token: "TokenError",
            Arithmetic: "ArithmeticError",
            Transactional: "TransactionalError"
          }
        },
        DispatchErrorModuleU8: {
          index: "u8",
          error: "u8"
        },
        DispatchErrorModuleU8a: {
          index: "u8",
          error: "[u8; 4]"
        },
        DispatchErrorModule: "DispatchErrorModuleU8a",
        DispatchErrorModulePre6: "DispatchErrorModuleU8",
        DispatchErrorTo198: {
          module: "Option<u8>",
          error: "u8"
        },
        DispatchInfo: {
          weight: "Weight",
          class: "DispatchClass",
          paysFee: "Pays"
        },
        DispatchInfoTo190: {
          weight: "Weight",
          class: "DispatchClass"
        },
        DispatchInfoTo244: {
          weight: "Weight",
          class: "DispatchClass",
          paysFee: "bool"
        },
        DispatchOutcome: "Result<(), DispatchError>",
        DispatchOutcomePre6: "Result<(), DispatchErrorPre6>",
        DispatchResult: "Result<(), DispatchError>",
        DispatchResultOf: "DispatchResult",
        DispatchResultTo198: "Result<(), Text>",
        Event: "GenericEvent",
        EventId: "[u8; 2]",
        EventIndex: "u32",
        EventRecord: {
          phase: "Phase",
          event: "Event",
          topics: "Vec<Hash>"
        },
        Health: {
          peers: "u64",
          isSyncing: "bool",
          shouldHavePeers: "bool"
        },
        InvalidTransaction: {
          _enum: {
            Call: "Null",
            Payment: "Null",
            Future: "Null",
            Stale: "Null",
            BadProof: "Null",
            AncientBirthBlock: "Null",
            ExhaustsResources: "Null",
            Custom: "u8",
            BadMandatory: "Null",
            MandatoryDispatch: "Null",
            BadSigner: "Null"
          }
        },
        Key: "Bytes",
        LastRuntimeUpgradeInfo: {
          specVersion: "Compact<u32>",
          specName: "Text"
        },
        NetworkState: {
          peerId: "Text",
          listenedAddresses: "Vec<Text>",
          externalAddresses: "Vec<Text>",
          connectedPeers: "HashMap<Text, Peer>",
          notConnectedPeers: "HashMap<Text, NotConnectedPeer>",
          averageDownloadPerSec: "u64",
          averageUploadPerSec: "u64",
          peerset: "NetworkStatePeerset"
        },
        NetworkStatePeerset: {
          messageQueue: "u64",
          nodes: "HashMap<Text, NetworkStatePeersetInfo>"
        },
        NetworkStatePeersetInfo: {
          connected: "bool",
          reputation: "i32"
        },
        NodeRole: {
          _enum: {
            Full: "Null",
            LightClient: "Null",
            Authority: "Null",
            UnknownRole: "u8"
          }
        },
        NotConnectedPeer: {
          knownAddresses: "Vec<Text>",
          latestPingTime: "Option<PeerPing>",
          versionString: "Option<Text>"
        },
        Peer: {
          enabled: "bool",
          endpoint: "PeerEndpoint",
          knownAddresses: "Vec<Text>",
          latestPingTime: "PeerPing",
          open: "bool",
          versionString: "Text"
        },
        PeerEndpoint: {
          listening: "PeerEndpointAddr"
        },
        PeerEndpointAddr: {
          _alias: {
            localAddr: "local_addr",
            sendBackAddr: "send_back_addr"
          },
          localAddr: "Text",
          sendBackAddr: "Text"
        },
        PeerPing: {
          nanos: "u64",
          secs: "u64"
        },
        PeerInfo: {
          peerId: "Text",
          roles: "Text",
          protocolVersion: "u32",
          bestHash: "Hash",
          bestNumber: "BlockNumber"
        },
        PerDispatchClassU32: {
          normal: "u32",
          operational: "u32",
          mandatory: "u32"
        },
        PerDispatchClassWeight: {
          normal: "Weight",
          operational: "Weight",
          mandatory: "Weight"
        },
        PerDispatchClassWeightsPerClass: {
          normal: "WeightPerClass",
          operational: "WeightPerClass",
          mandatory: "WeightPerClass"
        },
        Phase: {
          _enum: {
            ApplyExtrinsic: "u32",
            Finalization: "Null",
            Initialization: "Null"
          }
        },
        RawOrigin: {
          _enum: {
            Root: "Null",
            Signed: "AccountId",
            None: "Null"
          }
        },
        RefCount: "u32",
        RefCountTo259: "u8",
        SyncState: {
          startingBlock: "BlockNumber",
          currentBlock: "BlockNumber",
          highestBlock: "Option<BlockNumber>"
        },
        SystemOrigin: "RawOrigin",
        TokenError: {
          _enum: [
            "NoFunds",
            "WouldDie",
            "BelowMinimum",
            "CannotCreate",
            "UnknownAsset",
            "Frozen",
            "Unsupported",
            // these are dropped, but still in older versions
            // (if this adjusts, will need to take a re-look)
            "Underflow",
            "Overflow"
          ]
        },
        TransactionValidityError: {
          _enum: {
            Invalid: "InvalidTransaction",
            Unknown: "UnknownTransaction"
          }
        },
        TransactionalError: {
          _enum: [
            "LimitReached",
            "NoLayer"
          ]
        },
        UnknownTransaction: {
          _enum: {
            CannotLookup: "Null",
            NoUnsignedValidator: "Null",
            Custom: "u8"
          }
        },
        WeightPerClass: {
          baseExtrinsic: "Weight",
          maxExtrinsic: "Option<Weight>",
          maxTotal: "Option<Weight>",
          reserved: "Option<Weight>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/treasury/definitions.js
var definitions_default47;
var init_definitions47 = __esm({
  "../../node_modules/@polkadot/types/interfaces/treasury/definitions.js"() {
    definitions_default47 = {
      rpc: {},
      types: {
        Bounty: {
          proposer: "AccountId",
          value: "Balance",
          fee: "Balance",
          curatorDeposit: "Balance",
          bond: "Balance",
          status: "BountyStatus"
        },
        BountyIndex: "u32",
        BountyStatus: {
          _enum: {
            Proposed: "Null",
            Approved: "Null",
            Funded: "Null",
            CuratorProposed: "BountyStatusCuratorProposed",
            Active: "BountyStatusActive",
            PendingPayout: "BountyStatusPendingPayout"
          }
        },
        BountyStatusActive: {
          curator: "AccountId",
          updateDue: "BlockNumber"
        },
        BountyStatusCuratorProposed: {
          curator: "AccountId"
        },
        BountyStatusPendingPayout: {
          curator: "AccountId",
          beneficiary: "AccountId",
          unlockAt: "BlockNumber"
        },
        OpenTip: {
          reason: "Hash",
          who: "AccountId",
          finder: "AccountId",
          deposit: "Balance",
          closes: "Option<BlockNumber>",
          tips: "Vec<OpenTipTip>",
          findersFee: "bool"
        },
        OpenTipTo225: {
          reason: "Hash",
          who: "AccountId",
          finder: "Option<OpenTipFinderTo225>",
          closes: "Option<BlockNumber>",
          tips: "Vec<OpenTipTip>"
        },
        OpenTipFinderTo225: "(AccountId, Balance)",
        OpenTipTip: "(AccountId, Balance)",
        TreasuryProposal: {
          proposer: "AccountId",
          value: "Balance",
          beneficiary: "AccountId",
          bond: "Balance"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/txpayment/definitions.js
var definitions_default48;
var init_definitions48 = __esm({
  "../../node_modules/@polkadot/types/interfaces/txpayment/definitions.js"() {
    definitions_default48 = {
      rpc: {},
      types: {
        Multiplier: "Fixed128"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/txqueue/runtime.js
var runtime24;
var init_runtime24 = __esm({
  "../../node_modules/@polkadot/types/interfaces/txqueue/runtime.js"() {
    runtime24 = {
      TaggedTransactionQueue: [
        {
          methods: {
            validate_transaction: {
              description: "Validate the transaction.",
              params: [
                {
                  name: "source",
                  type: "TransactionSource"
                },
                {
                  name: "tx",
                  type: "Extrinsic"
                },
                {
                  name: "blockHash",
                  type: "BlockHash"
                }
              ],
              type: "TransactionValidity"
            }
          },
          version: 3
        },
        {
          methods: {
            validate_transaction: {
              description: "Validate the transaction.",
              params: [
                {
                  name: "source",
                  type: "TransactionSource"
                },
                {
                  name: "tx",
                  type: "Extrinsic"
                }
              ],
              type: "TransactionValidity"
            }
          },
          version: 2
        },
        {
          methods: {
            validate_transaction: {
              description: "Validate the transaction.",
              params: [
                {
                  name: "tx",
                  type: "Extrinsic"
                }
              ],
              type: "TransactionValidity"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/txqueue/definitions.js
var definitions_default49;
var init_definitions49 = __esm({
  "../../node_modules/@polkadot/types/interfaces/txqueue/definitions.js"() {
    init_runtime24();
    definitions_default49 = {
      rpc: {},
      runtime: runtime24,
      types: {
        TransactionSource: {
          _enum: ["InBlock", "Local", "External"]
        },
        TransactionValidity: "Result<ValidTransaction, TransactionValidityError>",
        ValidTransaction: {
          priority: "TransactionPriority",
          requires: "Vec<TransactionTag>",
          provides: "Vec<TransactionTag>",
          longevity: "TransactionLongevity",
          propagate: "bool"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/uniques/definitions.js
var definitions_default50;
var init_definitions50 = __esm({
  "../../node_modules/@polkadot/types/interfaces/uniques/definitions.js"() {
    definitions_default50 = {
      rpc: {},
      types: {
        ClassId: "u32",
        InstanceId: "u32",
        DepositBalance: "Balance",
        DepositBalanceOf: "Balance",
        ClassDetails: {
          owner: "AccountId",
          issuer: "AccountId",
          admin: "AccountId",
          freezer: "AccountId",
          totalDeposit: "DepositBalance",
          freeHolding: "bool",
          instances: "u32",
          instanceMetadatas: "u32",
          attributes: "u32",
          isFrozen: "bool"
        },
        DestroyWitness: {
          instances: "Compact<u32>",
          instanceMetadatas: "Compact<u32>",
          attributes: "Compact<u32>"
        },
        InstanceDetails: {
          owner: "AccountId",
          approved: "Option<AccountId>",
          isFrozen: "bool",
          deposit: "DepositBalance"
        },
        ClassMetadata: {
          deposit: "DepositBalance",
          data: "Vec<u8>",
          isFrozen: "bool"
        },
        InstanceMetadata: {
          deposit: "DepositBalance",
          data: "Vec<u8>",
          isFrozen: "bool"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/utility/definitions.js
var definitions_default51;
var init_definitions51 = __esm({
  "../../node_modules/@polkadot/types/interfaces/utility/definitions.js"() {
    definitions_default51 = {
      rpc: {},
      types: {
        Multisig: {
          when: "Timepoint",
          deposit: "Balance",
          depositor: "AccountId",
          approvals: "Vec<AccountId>"
        },
        Timepoint: {
          height: "BlockNumber",
          index: "u32"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/vesting/definitions.js
var definitions_default52;
var init_definitions52 = __esm({
  "../../node_modules/@polkadot/types/interfaces/vesting/definitions.js"() {
    definitions_default52 = {
      rpc: {},
      types: {
        VestingInfo: {
          locked: "Balance",
          perBlock: "Balance",
          startingBlock: "BlockNumber"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/attestations/definitions.js
var definitions_default53;
var init_definitions53 = __esm({
  "../../node_modules/@polkadot/types/interfaces/attestations/definitions.js"() {
    definitions_default53 = {
      rpc: {},
      types: {
        BlockAttestations: {
          receipt: "CandidateReceipt",
          valid: "Vec<AccountId>",
          invalid: "Vec<AccountId>"
        },
        IncludedBlocks: {
          actualNumber: "BlockNumber",
          session: "SessionIndex",
          randomSeed: "H256",
          activeParachains: "Vec<ParaId>",
          paraBlocks: "Vec<Hash>"
        },
        MoreAttestations: {}
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/bridges/definitions.js
var definitions_default54;
var init_definitions54 = __esm({
  "../../node_modules/@polkadot/types/interfaces/bridges/definitions.js"() {
    definitions_default54 = {
      rpc: {},
      types: {
        BridgedBlockHash: "H256",
        BridgedBlockNumber: "BlockNumber",
        BridgedHeader: "Header",
        BridgeMessageId: "(LaneId, MessageNonce)",
        CallOrigin: {
          _enum: {
            SourceRoot: "Null",
            TargetAccount: "(AccountId, MultiSigner, MultiSignature)",
            SourceAccount: "AccountId"
          }
        },
        ChainId: "[u8; 4]",
        DeliveredMessages: {
          begin: "MessageNonce",
          end: "MessageNonce",
          // pub type DispatchResultsBitVec = BitVec<Msb0, u8>;
          dispatchResults: "BitVec"
        },
        DispatchFeePayment: {
          _enum: ["AtSourceChain", "AtTargetChain"]
        },
        InboundLaneData: {
          relayers: "Vec<UnrewardedRelayer>",
          lastConfirmedNonce: "MessageNonce"
        },
        InboundRelayer: "AccountId",
        InitializationData: {
          header: "Header",
          authorityList: "AuthorityList",
          setId: "SetId",
          isHalted: "bool"
        },
        LaneId: "[u8; 4]",
        MessageData: {
          payload: "Bytes",
          fee: "Balance"
        },
        MessagesDeliveryProofOf: {
          bridgedHeaderHash: "BlockHash",
          storageProof: "Vec<Bytes>",
          lane: "LaneId"
        },
        MessageKey: {
          laneId: "LaneId",
          nonce: "MessageNonce"
        },
        MessageNonce: "u64",
        MessagesProofOf: {
          bridgedHeaderHash: "BridgedBlockHash",
          storageProof: "Vec<Bytes>",
          lane: "LaneId",
          noncesStart: "MessageNonce",
          noncesEnd: "MessageNonce"
        },
        OperatingMode: {
          _enum: ["Normal", "RejectingOutboundMessages", "Halted"]
        },
        OutboundLaneData: {
          oldestUnprunedNonce: "MessageNonce",
          latestReceivedNonce: "MessageNonce",
          latestGeneratedNonce: "MessageNonce"
        },
        OutboundMessageFee: "Balance",
        OutboundPayload: {
          specVersion: "u32",
          weight: "Weight",
          origin: "CallOrigin",
          dispatchFeePayment: "DispatchFeePayment",
          call: "Bytes"
        },
        Parameter: "Null",
        RelayerId: "AccountId",
        UnrewardedRelayer: {
          relayer: "RelayerId",
          messages: "DeliveredMessages"
        },
        UnrewardedRelayersState: {
          unrewardedRelayer_Entries: "MessageNonce",
          messagesInOldestEntry: "MessageNonce",
          totalMessages: "MessageNonce"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/claims/definitions.js
var definitions_default55;
var init_definitions55 = __esm({
  "../../node_modules/@polkadot/types/interfaces/claims/definitions.js"() {
    definitions_default55 = {
      rpc: {},
      types: {
        StatementKind: {
          _enum: ["Regular", "Saft"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/crowdloan/definitions.js
var definitions_default56;
var init_definitions56 = __esm({
  "../../node_modules/@polkadot/types/interfaces/crowdloan/definitions.js"() {
    definitions_default56 = {
      rpc: {},
      types: {
        FundIndex: "u32",
        LastContribution: {
          _enum: {
            Never: "Null",
            PreEnding: "u32",
            Ending: "BlockNumber"
          }
        },
        FundInfo: {
          depositor: "AccountId",
          verifier: "Option<MultiSigner>",
          deposit: "Balance",
          raised: "Balance",
          end: "BlockNumber",
          cap: "Balance",
          lastContribution: "LastContribution",
          firstPeriod: "LeasePeriod",
          lastPeriod: "LeasePeriod",
          trieIndex: "TrieIndex"
        },
        TrieIndex: "u32"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/cumulus/runtime.js
var runtime25;
var init_runtime25 = __esm({
  "../../node_modules/@polkadot/types/interfaces/cumulus/runtime.js"() {
    runtime25 = {
      AuraUnincludedSegmentApi: [
        {
          methods: {
            can_build_upon: {
              description: "Whether it is legal to extend the chain",
              params: [
                {
                  name: "includedHash",
                  type: "BlockHash"
                },
                {
                  name: "slot",
                  type: "Slot"
                }
              ],
              type: "bool"
            }
          },
          version: 1
        }
      ],
      CollectCollationInfo: [
        {
          methods: {
            collect_collation_info: {
              description: "Collect information about a collation.",
              params: [
                {
                  name: "header",
                  type: "Header"
                }
              ],
              type: "CollationInfo"
            }
          },
          version: 2
        },
        {
          methods: {
            collect_collation_info: {
              description: "Collect information about a collation.",
              params: [],
              type: "CollationInfoV1"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/cumulus/definitions.js
var dmpQueue, definitions_default57;
var init_definitions57 = __esm({
  "../../node_modules/@polkadot/types/interfaces/cumulus/definitions.js"() {
    init_runtime25();
    dmpQueue = {
      CollationInfo: {
        upwardMessages: "Vec<UpwardMessage>",
        horizontalMessages: "Vec<OutboundHrmpMessage>",
        newValidationCode: "Option<ValidationCode>",
        processedDownwardMessages: "u32",
        hrmpWatermark: "RelayBlockNumber",
        headData: "HeadData"
      },
      CollationInfoV1: {
        upwardMessages: "Vec<UpwardMessage>",
        horizontalMessages: "Vec<OutboundHrmpMessage>",
        newValidationCode: "Option<ValidationCode>",
        processedDownwardMessages: "u32",
        hrmpWatermark: "RelayBlockNumber"
      },
      ConfigData: {
        maxIndividual: "Weight"
      },
      MessageId: "[u8; 32]",
      OverweightIndex: "u64",
      PageCounter: "u32",
      PageIndexData: {
        beginUsed: "PageCounter",
        endUsed: "PageCounter",
        overweightCount: "OverweightIndex"
      }
    };
    definitions_default57 = {
      rpc: {},
      runtime: runtime25,
      types: dmpQueue
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/finality/runtime.js
var finalityV1, runtime26;
var init_runtime26 = __esm({
  "../../node_modules/@polkadot/types/interfaces/finality/runtime.js"() {
    finalityV1 = {
      methods: {
        best_finalized: {
          description: "Returns number and hash of the best finalized header known to the bridge module.",
          params: [],
          type: "(BlockNumber, Hash)"
        }
      },
      version: 1
    };
    runtime26 = {
      KusamaFinalityApi: [finalityV1],
      PolkadotFinalityApi: [finalityV1],
      RococoFinalityApi: [finalityV1],
      WestendFinalityApi: [finalityV1]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/finality/definitions.js
var definitions_default58;
var init_definitions58 = __esm({
  "../../node_modules/@polkadot/types/interfaces/finality/definitions.js"() {
    init_runtime26();
    definitions_default58 = {
      rpc: {},
      runtime: runtime26,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/parachains/hrmp.js
var hrmp_default;
var init_hrmp = __esm({
  "../../node_modules/@polkadot/types/interfaces/parachains/hrmp.js"() {
    hrmp_default = {
      HrmpChannel: {
        maxCapacity: "u32",
        maxTotalSize: "u32",
        maxMessageSize: "u32",
        msgCount: "u32",
        totalSize: "u32",
        mqcHead: "Option<Hash>",
        senderDeposit: "Balance",
        recipientDeposit: "Balance"
      },
      HrmpChannelId: {
        sender: "u32",
        receiver: "u32"
      },
      HrmpOpenChannelRequest: {
        confirmed: "bool",
        age: "SessionIndex",
        senderDeposit: "Balance",
        maxMessageSize: "u32",
        maxCapacity: "u32",
        maxTotalSize: "u32"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/parachains/runtime.js
var PH_V1_TO_V2, PH_V2_TO_V3, PH_V3, PH_V4, PH_V5, PH_V6, PH_V7, PH_V8, PH_V9, PH_V10, PH_V11, runtime27;
var init_runtime27 = __esm({
  "../../node_modules/@polkadot/types/interfaces/parachains/runtime.js"() {
    PH_V1_TO_V2 = {
      assumed_validation_data: {
        description: "Returns the persisted validation data for the given `ParaId` along with the corresponding validation code hash.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          },
          {
            name: "hash",
            type: "Hash"
          }
        ],
        type: "Option<(PersistedValidationData, ValidationCodeHash)>"
      },
      availability_cores: {
        description: "Yields information on all availability cores as relevant to the child block.",
        params: [],
        type: "Vec<CoreState>"
      },
      candidate_events: {
        description: "Get a vector of events concerning candidates that occurred within a block.",
        params: [],
        type: "Vec<CandidateEvent>"
      },
      candidate_pending_availability: {
        description: "Get the receipt of a candidate pending availability.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          }
        ],
        type: "Option<CommittedCandidateReceipt>"
      },
      check_validation_outputs: {
        description: "Checks if the given validation outputs pass the acceptance criteria.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          },
          {
            name: "outputs",
            type: "CandidateCommitments"
          }
        ],
        type: "bool"
      },
      dmq_contents: {
        description: "Get all the pending inbound messages in the downward message queue for a para.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          }
        ],
        type: "Vec<InboundDownwardMessage>"
      },
      inbound_hrmp_channels_contents: {
        description: "Get the contents of all channels addressed to the given recipient.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          }
        ],
        type: "Vec<InboundHrmpMessage>"
      },
      on_chain_votes: {
        description: "Scrape dispute relevant from on-chain, backing votes and resolved disputes.",
        params: [],
        type: "Option<ScrapedOnChainVotes>"
      },
      persisted_validation_data: {
        description: "Yields the persisted validation data for the given `ParaId` along with an assumption that should be used if the para currently occupies a core.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          },
          {
            name: "assumption",
            type: "OccupiedCoreAssumption"
          }
        ],
        type: "Option<PersistedValidationData>"
      },
      session_index_for_child: {
        description: "Returns the session index expected at a child of the block.",
        params: [],
        type: "SessionIndex"
      },
      validation_code: {
        description: "Fetch the validation code used by a para, making the given `OccupiedCoreAssumption`.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          },
          {
            name: "assumption",
            type: "OccupiedCoreAssumption"
          }
        ],
        type: "Option<ValidationCode>"
      },
      validation_code_by_hash: {
        description: "Get the validation code from its hash.",
        params: [
          {
            name: "hash",
            type: "ValidationCodeHash"
          }
        ],
        type: "Option<ValidationCode>"
      },
      validator_groups: {
        description: "Returns the validator groups and rotation info localized based on the hypothetical child of a block whose state  this is invoked on",
        params: [],
        type: "(Vec<Vec<ParaValidatorIndex>>, GroupRotationInfo)"
      },
      validators: {
        description: "Get the current validators.",
        params: [],
        type: "Vec<ValidatorId>"
      }
    };
    PH_V2_TO_V3 = {
      pvfs_require_precheck: {
        description: "Returns code hashes of PVFs that require pre-checking by validators in the active set.",
        params: [],
        type: "Vec<ValidationCodeHash>"
      },
      session_info: {
        description: "Get the session info for the given session, if stored.",
        params: [
          {
            name: "index",
            type: "SessionIndex"
          }
        ],
        type: "Option<SessionInfo>"
      },
      submit_pvf_check_statement: {
        description: "Submits a PVF pre-checking statement into the transaction pool.",
        params: [
          {
            name: "stmt",
            type: "PvfCheckStatement"
          },
          {
            name: "signature",
            type: "ValidatorSignature"
          }
        ],
        type: "Null"
      },
      validation_code_hash: {
        description: "Fetch the hash of the validation code used by a para, making the given `OccupiedCoreAssumption`.",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          },
          {
            name: "assumption",
            type: "OccupiedCoreAssumption"
          }
        ],
        type: "Option<ValidationCodeHash>"
      }
    };
    PH_V3 = {
      disputes: {
        description: "Returns all onchain disputes.",
        params: [],
        type: "Vec<(SessionIndex, CandidateHash, DisputeState)>"
      }
    };
    PH_V4 = {
      session_executor_params: {
        description: "Returns execution parameters for the session.",
        params: [
          {
            name: "sessionIndex",
            type: "SessionIndex"
          }
        ],
        type: "Option<ExecutorParams>"
      }
    };
    PH_V5 = {
      key_ownership_proof: {
        description: "Returns a merkle proof of a validator session key",
        params: [
          {
            name: "validatorId",
            type: "ValidatorId"
          }
        ],
        type: "Option<OpaqueKeyOwnershipProof>"
      },
      submit_report_dispute_lost: {
        description: "Submit an unsigned extrinsic to slash validators who lost a dispute about a candidate of a past session",
        params: [
          {
            name: "disputeProof",
            type: "DisputeProof"
          },
          {
            name: "keyOwnershipProof",
            type: "OpaqueKeyOwnershipProof"
          }
        ],
        type: "Option<Null>"
      },
      unapplied_slashes: {
        description: "Returns a list of validators that lost a past session dispute and need to be slashed",
        params: [],
        type: "Vec<(SessionIndex, CandidateHash, PendingSlashes)>"
      }
    };
    PH_V6 = {
      minimum_backing_votes: {
        description: "Get the minimum number of backing votes for a parachain candidate. This is a staging method! Do not use on production runtimes!",
        params: [],
        type: "u32"
      }
    };
    PH_V7 = {
      async_backing_params: {
        description: "Returns candidate's acceptance limitations for asynchronous backing for a relay parent",
        params: [],
        type: "AsyncBackingParams"
      },
      para_backing_state: {
        description: "Returns the state of parachain backing for a given para",
        params: [
          {
            name: "paraId",
            type: "ParaId"
          }
        ],
        type: "Option<BackingState>"
      }
    };
    PH_V8 = {
      disabled_validators: {
        description: "Returns a list of all disabled validators at the given block",
        params: [],
        type: "ValidatorIndex"
      }
    };
    PH_V9 = {
      node_features: {
        description: "Get node features. This is a staging method! Do not use on production runtimes!",
        params: [],
        type: "NodeFeatures"
      }
    };
    PH_V10 = {
      approval_voting_params: {
        description: "Approval voting configuration parameters",
        params: [],
        type: "ApprovalVotingParams"
      }
    };
    PH_V11 = {
      claim_queue: {
        description: "Claim queue",
        params: [],
        type: "BTreeMap<CoreIndex, Vec<u32>>"
      }
    };
    runtime27 = {
      ParachainHost: [
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5,
            ...PH_V6,
            ...PH_V7,
            ...PH_V8,
            ...PH_V9,
            ...PH_V10,
            ...PH_V11
          },
          version: 11
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5,
            ...PH_V6,
            ...PH_V7,
            ...PH_V8,
            ...PH_V9,
            ...PH_V10
          },
          version: 10
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5,
            ...PH_V6,
            ...PH_V7,
            ...PH_V8,
            ...PH_V9
          },
          version: 9
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5,
            ...PH_V6,
            ...PH_V7,
            ...PH_V8
          },
          version: 8
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5,
            ...PH_V6,
            ...PH_V7
          },
          version: 7
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5,
            ...PH_V6
          },
          version: 6
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4,
            ...PH_V5
          },
          version: 5
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3,
            ...PH_V4
          },
          version: 4
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3,
            ...PH_V3
          },
          version: 3
        },
        {
          methods: {
            ...PH_V1_TO_V2,
            ...PH_V2_TO_V3
          },
          version: 2
        },
        {
          methods: {
            session_info: {
              description: "Get the session info for the given session, if stored.",
              params: [
                {
                  name: "index",
                  type: "SessionIndex"
                }
              ],
              type: "Option<OldV1SessionInfo>"
            },
            ...PH_V1_TO_V2
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/parachains/slots.js
var SlotRange10, SlotRange, oldTypes, slots_default;
var init_slots = __esm({
  "../../node_modules/@polkadot/types/interfaces/parachains/slots.js"() {
    SlotRange10 = {
      _enum: ["ZeroZero", "ZeroOne", "ZeroTwo", "ZeroThree", "OneOne", "OneTwo", "OneThree", "TwoTwo", "TwoThree", "ThreeThree"]
    };
    SlotRange = {
      _enum: ["ZeroZero", "ZeroOne", "ZeroTwo", "ZeroThree", "ZeroFour", "ZeroFive", "ZeroSix", "ZeroSeven", "OneOne", "OneTwo", "OneThree", "OneFour", "OneFive", "OneSix", "OneSeven", "TwoTwo", "TwoThree", "TwoFour", "TwoFive", "TwoSix", "TwoSeven", "ThreeThree", "ThreeFour", "ThreeFive", "ThreeSix", "ThreeSeven", "FourFour", "FourFive", "FourSix", "FourSeven", "FiveFive", "FiveSix", "FiveSeven", "SixSix", "SixSeven", "SevenSeven"]
    };
    oldTypes = {
      Bidder: {
        _enum: {
          New: "NewBidder",
          Existing: "ParaId"
        }
      },
      IncomingParachain: {
        _enum: {
          Unset: "NewBidder",
          Fixed: "IncomingParachainFixed",
          Deploy: "IncomingParachainDeploy"
        }
      },
      IncomingParachainDeploy: {
        code: "ValidationCode",
        initialHeadData: "HeadData"
      },
      IncomingParachainFixed: {
        codeHash: "Hash",
        codeSize: "u32",
        initialHeadData: "HeadData"
      },
      NewBidder: {
        who: "AccountId",
        sub: "SubId"
      },
      SubId: "u32"
    };
    slots_default = {
      ...oldTypes,
      AuctionIndex: "u32",
      LeasePeriod: "BlockNumber",
      LeasePeriodOf: "BlockNumber",
      SlotRange10,
      SlotRange,
      WinningData10: `[WinningDataEntry; ${SlotRange10._enum.length}]`,
      WinningData: `[WinningDataEntry; ${SlotRange._enum.length}]`,
      WinningDataEntry: "Option<(AccountId, ParaId, BalanceOf)>",
      WinnersData10: "Vec<WinnersDataTuple10>",
      WinnersData: "Vec<WinnersDataTuple>",
      WinnersDataTuple10: "(AccountId, ParaId, BalanceOf, SlotRange10)",
      WinnersDataTuple: "(AccountId, ParaId, BalanceOf, SlotRange)"
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/parachains/definitions.js
var proposeTypes, cumulusTypes, disputeTypes, definitions_default59;
var init_definitions59 = __esm({
  "../../node_modules/@polkadot/types/interfaces/parachains/definitions.js"() {
    init_hrmp();
    init_runtime27();
    init_slots();
    proposeTypes = {
      ParachainProposal: {
        proposer: "AccountId",
        genesisHead: "HeadData",
        validators: "Vec<ValidatorId>",
        name: "Bytes",
        balance: "Balance"
      },
      RegisteredParachainInfo: {
        validators: "Vec<ValidatorId>",
        proposer: "AccountId"
      }
    };
    cumulusTypes = {
      ServiceQuality: {
        _enum: ["Ordered", "Fast"]
      }
    };
    disputeTypes = {
      DisputeLocation: {
        _enum: ["Local", "Remote"]
      },
      DisputeResult: {
        _enum: ["Valid", "Invalid"]
      },
      DisputeState: {
        validatorsFor: "BitVec",
        validatorsAgainst: "BitVec",
        start: "BlockNumber",
        concludedAt: "Option<BlockNumber>"
      },
      DisputeStatement: {
        _enum: {
          Valid: "ValidDisputeStatementKind",
          Invalid: "InvalidDisputeStatementKind"
        }
      },
      DisputeStatementSet: {
        candidateHash: "CandidateHash",
        session: "SessionIndex",
        statements: "Vec<(DisputeStatement, ParaValidatorIndex, ValidatorSignature)>"
      },
      ExecutorParam: {
        _enum: {
          Phantom: "Null",
          // index starts at 1... empty slot at 0
          MaxMemoryPages: "u32",
          StackLogicalMax: "u32",
          StackNativeMax: "u32",
          PrecheckingMaxMemory: "u64",
          PvfPrepTimeout: "(PvfPrepTimeoutKind, u64)",
          PvfExecTimeout: "(PvfExecTimeoutKind, u64)"
        }
      },
      ExecutorParamsHash: "Hash",
      ExecutorParams: "Vec<ExecutorParam>",
      ExplicitDisputeStatement: {
        valid: "bool",
        candidateHash: "CandidateHash",
        session: "SessionIndex"
      },
      InvalidDisputeStatementKind: {
        _enum: ["Explicit"]
      },
      MultiDisputeStatementSet: "Vec<DisputeStatementSet>",
      PvfExecTimeoutKind: {
        _enum: ["Backing", "Approval"]
      },
      PvfPrepTimeoutKind: {
        _enum: ["Precheck", "Lenient"]
      },
      ValidDisputeStatementKind: {
        _enum: {
          Explicit: "Null",
          BackingSeconded: "Hash",
          BackingValid: "Hash",
          ApprovalChecking: "Null"
        }
      }
    };
    definitions_default59 = {
      rpc: {},
      runtime: runtime27,
      types: {
        ...cumulusTypes,
        ...disputeTypes,
        ...hrmp_default,
        ...proposeTypes,
        ...slots_default,
        AbridgedCandidateReceipt: {
          parachainIndex: "ParaId",
          relayParent: "Hash",
          headData: "HeadData",
          collator: "CollatorId",
          signature: "CollatorSignature",
          povBlockHash: "Hash",
          commitments: "CandidateCommitments"
        },
        AbridgedHostConfiguration: {
          maxCodeSize: "u32",
          maxHeadDataSize: "u32",
          maxUpwardQueueCount: "u32",
          maxUpwardQueueSize: "u32",
          maxUpwardMessageSize: "u32",
          maxUpwardMessageNumPerCandidate: "u32",
          hrmpMaxMessageNumPerCandidate: "u32",
          validationUpgradeFrequency: "BlockNumber",
          validationUpgradeDelay: "BlockNumber"
        },
        AbridgedHrmpChannel: {
          maxCapacity: "u32",
          maxTotalSize: "u32",
          maxMessageSize: "u32",
          msgCount: "u32",
          totalSize: "u32",
          mqcHead: "Option<Hash>"
        },
        ApprovalVotingParams: {
          maxApprovalCoalesceCount: "u32"
        },
        AssignmentId: "AccountId",
        AssignmentKind: {
          _enum: {
            Parachain: "Null",
            Parathread: "(CollatorId, u32)"
          }
        },
        AsyncBackingParams: {
          maxCandidateDepth: "u32",
          allowedAncestryLen: "u32"
        },
        AttestedCandidate: {
          candidate: "AbridgedCandidateReceipt",
          validityVotes: "Vec<ValidityAttestation>",
          validatorIndices: "BitVec"
        },
        AuthorityDiscoveryId: "AccountId",
        AvailabilityBitfield: "BitVec",
        AvailabilityBitfieldRecord: {
          bitfield: "AvailabilityBitfield",
          submittedTt: "BlockNumber"
        },
        BackedCandidate: {
          candidate: "CommittedCandidateReceipt",
          validityVotes: "Vec<ValidityAttestation>",
          validatorIndices: "BitVec"
        },
        BackingState: {
          constraints: "Constraints",
          pendingAvailability: "Vec<CandidatePendingAvailability>"
        },
        BufferedSessionChange: {
          applyAt: "BlockNumber",
          validators: "Vec<ValidatorId>",
          queued: "Vec<ValidatorId>",
          sessionIndex: "SessionIndex"
        },
        CandidateCommitments: {
          upwardMessages: "Vec<UpwardMessage>",
          horizontalMessages: "Vec<OutboundHrmpMessage>",
          newValidationCode: "Option<ValidationCode>",
          headData: "HeadData",
          processedDownwardMessages: "u32",
          hrmpWatermark: "BlockNumber"
        },
        CandidateDescriptor: {
          paraId: "ParaId",
          relayParent: "RelayChainHash",
          collatorId: "CollatorId",
          persistedValidationDataHash: "Hash",
          povHash: "Hash",
          erasureRoot: "Hash",
          signature: "CollatorSignature",
          paraHead: "Hash",
          validationCodeHash: "ValidationCodeHash"
        },
        CandidateEvent: {
          _enum: {
            CandidateBacked: "(CandidateReceipt, HeadData, CoreIndex, GroupIndex)",
            CandidateIncluded: "(CandidateReceipt, HeadData, CoreIndex, GroupIndex)",
            CandidateTimedOut: "(CandidateReceipt, HeadData, CoreIndex)"
          }
        },
        CandidateHash: "Hash",
        CandidateInfo: {
          who: "AccountId",
          deposit: "Balance"
        },
        CandidatePendingAvailability: {
          core: "CoreIndex",
          hash: "CandidateHash",
          descriptor: "CandidateDescriptor",
          availabilityVotes: "BitVec",
          backers: "BitVec",
          relayParentNumber: "BlockNumber",
          backedInNumber: "BlockNumber",
          backingGroup: "GroupIndex"
        },
        CandidateReceipt: {
          descriptor: "CandidateDescriptor",
          commitmentsHash: "Hash"
        },
        GlobalValidationData: {
          maxCodeSize: "u32",
          maxHeadDataSize: "u32",
          blockNumber: "BlockNumber"
        },
        CollatorId: "H256",
        CollatorSignature: "Signature",
        CommittedCandidateReceipt: {
          descriptor: "CandidateDescriptor",
          commitments: "CandidateCommitments"
        },
        Constraints: {
          minRelayParentNumber: "BlockNumber",
          maxPovSize: "u32",
          maxCodeSize: "u32",
          umpRemaining: "u32",
          umpRemainingBytes: "u32",
          maxUmpNumPerCandidate: "u32",
          dmpRemainingMessages: "Vec<BlockNumber>",
          hrmpInbound: "InboundHrmpLimitations",
          hrmpChannelsOut: "HashMap<ParaId, OutboundHrmpChannelLimitations>",
          maxHrmpNumPerCandidate: "u32",
          requiredParent: "HeadData",
          validationCodeHash: "ValidationCodeHash",
          upgradeRestriction: "Option<UpgradeRestriction>",
          futureValidationCode: "Option<(BlockNumber, ValidationCodeHash)>"
        },
        CoreAssignment: {
          core: "CoreIndex",
          paraId: "ParaId",
          kind: "AssignmentKind",
          groupIdx: "GroupIndex"
        },
        CoreIndex: "u32",
        CoreOccupied: {
          _enum: {
            Parathread: "ParathreadEntry",
            Parachain: "Null"
          }
        },
        CoreState: {
          _enum: {
            Occupied: "OccupiedCore",
            Scheduled: "ScheduledCore",
            Free: "Null"
          }
        },
        DisputeProof: {
          timeSlot: "DisputesTimeSlot",
          kind: "SlashingOffenceKind",
          validatorIndex: "ValidatorIndex",
          validatorId: "ValidatorId"
        },
        DisputesTimeSlot: {
          sessionIndex: "SessionIndex",
          candidateHash: "CandidateHash"
        },
        DoubleVoteReport: {
          identity: "ValidatorId",
          first: "(Statement, ValidatorSignature)",
          second: "(Statement, ValidatorSignature)",
          proof: "MembershipProof",
          signingContext: "SigningContext"
        },
        DownwardMessage: "Bytes",
        GroupIndex: "u32",
        GroupRotationInfo: {
          sessionStartBlock: "BlockNumber",
          groupRotationFrequency: "BlockNumber",
          now: "BlockNumber"
        },
        GlobalValidationSchedule: {
          maxCodeSize: "u32",
          maxHeadDataSize: "u32",
          blockNumber: "BlockNumber"
        },
        HeadData: "Bytes",
        HostConfiguration: {
          maxCodeSize: "u32",
          maxHeadDataSize: "u32",
          maxUpwardQueueCount: "u32",
          maxUpwardQueueSize: "u32",
          maxUpwardMessageSize: "u32",
          maxUpwardMessageNumPerCandidate: "u32",
          hrmpMaxMessageNumPerCandidate: "u32",
          validationUpgradeFrequency: "BlockNumber",
          validationUpgradeDelay: "BlockNumber",
          maxPovSize: "u32",
          maxDownwardMessageSize: "u32",
          preferredDispatchableUpwardMessagesStepWeight: "Weight",
          hrmpMaxParachainOutboundChannels: "u32",
          hrmpMaxParathreadOutboundChannels: "u32",
          hrmpOpenRequestTtl: "u32",
          hrmpSenderDeposit: "Balance",
          hrmpRecipientDeposit: "Balance",
          hrmpChannelMaxCapacity: "u32",
          hrmpChannelMaxTotalSize: "u32",
          hrmpMaxParachainInboundChannels: "u32",
          hrmpMaxParathreadInboundChannels: "u32",
          hrmpChannelMaxMessageSize: "u32",
          codeRetentionPeriod: "BlockNumber",
          parathreadCores: "u32",
          parathreadRetries: "u32",
          groupRotationFrequency: "BlockNumber",
          chainAvailabilityPeriod: "BlockNumber",
          threadAvailabilityPeriod: "BlockNumber",
          schedulingLookahead: "u32",
          maxValidatorsPerCore: "Option<u32>",
          maxValidators: "Option<u32>",
          disputePeriod: "SessionIndex",
          disputePostConclusionAcceptancePeriod: "BlockNumber",
          disputeMaxSpamSlots: "u32",
          disputeConclusionByTimeOutPeriod: "BlockNumber",
          noShowSlots: "u32",
          nDelayTranches: "u32",
          zerothDelayTrancheWidth: "u32",
          neededApprovals: "u32",
          relayVrfModuloSamples: "u32"
        },
        InboundDownwardMessage: {
          pubSentAt: "BlockNumber",
          pubMsg: "DownwardMessage"
        },
        InboundHrmpMessage: {
          sentAt: "BlockNumber",
          data: "Bytes"
        },
        InboundHrmpLimitations: {
          validWatermarks: "Vec<BlockNumber>"
        },
        InboundHrmpMessages: "Vec<InboundHrmpMessage>",
        LocalValidationData: {
          parentHead: "HeadData",
          balance: "Balance",
          codeUpgradeAllowed: "Option<BlockNumber>"
        },
        MessageIngestionType: {
          downwardMessages: "Vec<InboundDownwardMessage>",
          horizontalMessages: "BTreeMap<ParaId, InboundHrmpMessages>"
        },
        MessageQueueChain: "RelayChainHash",
        NodeFeatures: "BitVec",
        OccupiedCore: {
          nextUpOnAvailable: "Option<ScheduledCore>",
          occupiedSince: "BlockNumber",
          timeOutAt: "BlockNumber",
          nextUpOnTimeOut: "Option<ScheduledCore>",
          availability: "BitVec",
          groupResponsible: "GroupIndex",
          candidateHash: "CandidateHash",
          candidateDescriptor: "CandidateDescriptor"
        },
        OccupiedCoreAssumption: {
          _enum: ["Included,", "TimedOut", "Free"]
        },
        OutboundHrmpChannelLimitations: {
          bytesRemaining: "u32",
          messagesRemaining: "u32"
        },
        OutboundHrmpMessage: {
          recipient: "u32",
          data: "Bytes"
        },
        PendingSlashes: {
          _alias: {
            slashKeys: "keys"
          },
          slashKeys: "BTreeMap<ValidatorIndex, ValidatorId>",
          kind: "SlashingOffenceKind"
        },
        ParachainDispatchOrigin: {
          _enum: ["Signed", "Parachain", "Root"]
        },
        ParachainInherentData: {
          validationData: "PersistedValidationData",
          relayChainState: "StorageProof",
          downwardMessages: "Vec<InboundDownwardMessage>",
          horizontalMessages: "BTreeMap<ParaId, VecInboundHrmpMessage>"
        },
        ParachainsInherentData: {
          bitfields: "SignedAvailabilityBitfields",
          backedCandidates: "Vec<BackedCandidate>",
          disputes: "MultiDisputeStatementSet",
          parentHeader: "Header"
        },
        ParaGenesisArgs: {
          genesisHead: "Bytes",
          validationCode: "Bytes",
          parachain: "bool"
        },
        ParaId: "u32",
        ParaInfo: {
          manager: "AccountId",
          deposit: "Balance",
          locked: "bool"
        },
        ParaLifecycle: {
          _enum: ["Onboarding", "Parathread", "Parachain", "UpgradingToParachain", "DowngradingToParathread", "OutgoingParathread", "OutgoingParachain"]
        },
        ParaPastCodeMeta: {
          upgradeTimes: "Vec<ReplacementTimes>",
          lastPruned: "Option<BlockNumber>"
        },
        ParaScheduling: {
          _enum: ["Always", "Dynamic"]
        },
        ParathreadClaim: "(ParaId, CollatorId)",
        ParathreadClaimQueue: {
          queue: "Vec<QueuedParathread>",
          nextCoreOffset: "u32"
        },
        ParathreadEntry: {
          claim: "ParathreadClaim",
          retries: "u32"
        },
        ParaValidatorIndex: "u32",
        PersistedValidationData: {
          parentHead: "HeadData",
          relayParentNumber: "RelayChainBlockNumber",
          relayParentStorageRoot: "Hash",
          maxPovSize: "u32"
        },
        PvfCheckStatement: {
          accept: "bool",
          subject: "ValidationCodeHash",
          sessionIndex: "SessionIndex",
          validatorIndex: "ParaValidatorIndex"
        },
        QueuedParathread: {
          claim: "ParathreadEntry",
          coreOffset: "u32"
        },
        RelayBlockNumber: "u32",
        RelayChainBlockNumber: "RelayBlockNumber",
        RelayHash: "Hash",
        RelayChainHash: "RelayHash",
        Remark: "[u8; 32]",
        ReplacementTimes: {
          expectedAt: "BlockNumber",
          activatedAt: "BlockNumber"
        },
        Retriable: {
          _enum: {
            Never: "Null",
            WithRetries: "u32"
          }
        },
        ScheduledCore: {
          paraId: "ParaId",
          collator: "Option<CollatorId>"
        },
        Scheduling: {
          _enum: ["Always", "Dynamic"]
        },
        ScrapedOnChainVotes: {
          session: "SessionIndex",
          backingValidatorsPerCandidate: "Vec<(CandidateReceipt, Vec<(ParaValidatorIndex, ValidityAttestation)>)>",
          disputes: "MultiDisputeStatementSet"
        },
        SessionInfo: {
          activeValidatorIndices: "Vec<ParaValidatorIndex>",
          randomSeed: "[u8; 32]",
          disputePeriod: "SessionIndex",
          validators: "Vec<ValidatorId>",
          discoveryKeys: "Vec<AuthorityDiscoveryId>",
          assignmentKeys: "Vec<AssignmentId>",
          validatorGroups: "Vec<Vec<ValidatorIndex>>",
          nCores: "u32",
          zerothDelayTrancheWidth: "u32",
          relayVrfModuloSamples: "u32",
          nDelayTranches: "u32",
          noShowSlots: "u32",
          neededApprovals: "u32"
        },
        OldV1SessionInfo: {
          validators: "Vec<ValidatorId>",
          discoveryKeys: "Vec<AuthorityDiscoveryId>",
          assignmentKeys: "Vec<AssignmentId>",
          validatorGroups: "Vec<Vec<ParaValidatorIndex>>",
          nCores: "u32",
          zerothDelayTrancheWidth: "u32",
          relayVrfModuloSamples: "u32",
          nDelayTranches: "u32",
          noShowSlots: "u32",
          neededApprovals: "u32"
        },
        SessionInfoValidatorGroup: "Vec<ParaValidatorIndex>",
        SignedAvailabilityBitfield: {
          payload: "BitVec",
          validatorIndex: "ParaValidatorIndex",
          signature: "ValidatorSignature"
        },
        SignedAvailabilityBitfields: "Vec<SignedAvailabilityBitfield>",
        SigningContext: {
          sessionIndex: "SessionIndex",
          parentHash: "Hash"
        },
        SlashingOffenceKind: {
          _enum: ["ForInvalid", "AgainstValid"]
        },
        Statement: {
          _enum: {
            Never: "Null",
            // starts at 1
            Candidate: "Hash",
            Valid: "Hash",
            Invalid: "Hash"
          }
        },
        TransientValidationData: {
          maxCodeSize: "u32",
          maxHeadDataSize: "u32",
          balance: "Balance",
          codeUpgradeAllowed: "Option<BlockNumber>",
          dmqLength: "u32"
        },
        UpgradeGoAhead: {
          _enum: ["Abort", "GoAhead"]
        },
        UpgradeRestriction: {
          _enum: ["Present"]
        },
        UpwardMessage: "Bytes",
        ValidationFunctionParams: {
          maxCodeSize: "u32",
          relayChainHeight: "RelayChainBlockNumber",
          codeUpgradeAllowed: "Option<RelayChainBlockNumber>"
        },
        ValidationCode: "Bytes",
        ValidationCodeHash: "Hash",
        ValidationData: {
          persisted: "PersistedValidationData",
          transient: "TransientValidationData"
        },
        ValidationDataType: {
          validationData: "ValidationData",
          relayChainState: "Vec<Bytes>"
        },
        ValidatorSignature: "Signature",
        ValidityAttestation: {
          _enum: {
            Never: "Null",
            // starts at 1
            Implicit: "ValidatorSignature",
            Explicit: "ValidatorSignature"
          }
        },
        MessagingStateSnapshot: {
          relayDispatchQueueSize: "(u32, u32)",
          egressChannels: "Vec<MessagingStateSnapshotEgressEntry>"
        },
        MessagingStateSnapshotEgressEntry: "(ParaId, AbridgedHrmpChannel)",
        SystemInherentData: "ParachainInherentData",
        VecInboundHrmpMessage: "Vec<InboundHrmpMessage>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/poll/definitions.js
var definitions_default60;
var init_definitions60 = __esm({
  "../../node_modules/@polkadot/types/interfaces/poll/definitions.js"() {
    definitions_default60 = {
      rpc: {},
      types: {
        Approvals: "[bool; 4]"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/purchase/definitions.js
var definitions_default61;
var init_definitions61 = __esm({
  "../../node_modules/@polkadot/types/interfaces/purchase/definitions.js"() {
    definitions_default61 = {
      rpc: {},
      types: {
        AccountStatus: {
          validity: "AccountValidity",
          freeBalance: "Balance",
          lockedBalance: "Balance",
          signature: "Vec<u8>",
          vat: "Permill"
        },
        AccountValidity: {
          _enum: ["Invalid", "Initiated", "Pending", "ValidLow", "ValidHigh", "Completed"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/dryRunApi/runtime.js
var runtime28;
var init_runtime28 = __esm({
  "../../node_modules/@polkadot/types/interfaces/dryRunApi/runtime.js"() {
    runtime28 = {
      DryRunApi: [
        {
          methods: {
            dry_run_call: {
              description: "Dry run call",
              params: [
                {
                  name: "origin",
                  type: "OriginCaller"
                },
                {
                  name: "call",
                  type: "RuntimeCall"
                }
              ],
              type: "Result<CallDryRunEffects, XcmDryRunApiError>"
            },
            dry_run_xcm: {
              description: "Dry run XCM program",
              params: [
                {
                  name: "originLocation",
                  type: "VersionedMultiLocation"
                },
                {
                  name: "xcm",
                  type: "VersionedXcm"
                }
              ],
              type: "Result<XcmDryRunEffects, XcmDryRunApiError>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/dryRunApi/definitions.js
var definitions_default62;
var init_definitions62 = __esm({
  "../../node_modules/@polkadot/types/interfaces/dryRunApi/definitions.js"() {
    init_runtime28();
    definitions_default62 = {
      rpc: {},
      runtime: runtime28,
      types: {
        PostDispatchInfo: {
          actualWeight: "Option<Weight>",
          paysFee: "Pays"
        },
        DispatchResultWithPostInfo: "Result<PostDispatchInfo, DispatchError>",
        CallDryRunEffects: {
          executionResult: "DispatchResultWithPostInfo",
          emittedEvents: "Vec<Event>",
          localXcm: "Option<VersionedXcm>",
          forwardedXcms: "Vec<(VersionedMultiLocation, Vec<VersionedXcm>)>"
        },
        XcmDryRunEffects: {
          executionResult: "OutcomeV4",
          emittedEvents: "Vec<Event>",
          forwardedXcms: "Vec<(VersionedMultiLocation, Vec<VersionedXcm>)>"
        },
        XcmDryRunApiError: {
          _enum: [
            "Unimplemented",
            "VersionedConversionFailed"
          ]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types-create/packageDetect.js
var init_packageDetect13 = __esm({
  "../../node_modules/@polkadot/types-create/packageDetect.js"() {
    init_packageInfo20();
    init_util();
    init_packageInfo21();
    detectPackage(packageInfo21, null, [packageInfo20]);
  }
});

// ../../node_modules/@polkadot/types-create/types/lookup.js
var init_lookup = __esm({
  "../../node_modules/@polkadot/types-create/types/lookup.js"() {
  }
});

// ../../node_modules/@polkadot/types-create/types/types.js
var TypeDefInfo;
var init_types = __esm({
  "../../node_modules/@polkadot/types-create/types/types.js"() {
    (function(TypeDefInfo2) {
      TypeDefInfo2[TypeDefInfo2["BTreeMap"] = 0] = "BTreeMap";
      TypeDefInfo2[TypeDefInfo2["BTreeSet"] = 1] = "BTreeSet";
      TypeDefInfo2[TypeDefInfo2["Compact"] = 2] = "Compact";
      TypeDefInfo2[TypeDefInfo2["DoNotConstruct"] = 3] = "DoNotConstruct";
      TypeDefInfo2[TypeDefInfo2["Enum"] = 4] = "Enum";
      TypeDefInfo2[TypeDefInfo2["HashMap"] = 5] = "HashMap";
      TypeDefInfo2[TypeDefInfo2["Int"] = 6] = "Int";
      TypeDefInfo2[TypeDefInfo2["Linkage"] = 7] = "Linkage";
      TypeDefInfo2[TypeDefInfo2["Null"] = 8] = "Null";
      TypeDefInfo2[TypeDefInfo2["Option"] = 9] = "Option";
      TypeDefInfo2[TypeDefInfo2["Plain"] = 10] = "Plain";
      TypeDefInfo2[TypeDefInfo2["Range"] = 11] = "Range";
      TypeDefInfo2[TypeDefInfo2["RangeInclusive"] = 12] = "RangeInclusive";
      TypeDefInfo2[TypeDefInfo2["Result"] = 13] = "Result";
      TypeDefInfo2[TypeDefInfo2["Set"] = 14] = "Set";
      TypeDefInfo2[TypeDefInfo2["Si"] = 15] = "Si";
      TypeDefInfo2[TypeDefInfo2["Struct"] = 16] = "Struct";
      TypeDefInfo2[TypeDefInfo2["Tuple"] = 17] = "Tuple";
      TypeDefInfo2[TypeDefInfo2["UInt"] = 18] = "UInt";
      TypeDefInfo2[TypeDefInfo2["Vec"] = 19] = "Vec";
      TypeDefInfo2[TypeDefInfo2["VecFixed"] = 20] = "VecFixed";
      TypeDefInfo2[TypeDefInfo2["WrapperKeepOpaque"] = 21] = "WrapperKeepOpaque";
      TypeDefInfo2[TypeDefInfo2["WrapperOpaque"] = 22] = "WrapperOpaque";
    })(TypeDefInfo || (TypeDefInfo = {}));
  }
});

// ../../node_modules/@polkadot/types-create/types/index.js
var init_types2 = __esm({
  "../../node_modules/@polkadot/types-create/types/index.js"() {
    init_lookup();
    init_types();
  }
});

// ../../node_modules/@polkadot/types-codec/packageDetect.js
var init_packageDetect14 = __esm({
  "../../node_modules/@polkadot/types-codec/packageDetect.js"() {
    init_util();
    init_packageInfo20();
    detectPackage(packageInfo20, null, []);
  }
});

// ../../node_modules/@polkadot/types-codec/utils/util.js
function hasEq(o) {
  return isFunction(o.eq);
}
var init_util2 = __esm({
  "../../node_modules/@polkadot/types-codec/utils/util.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/compareArray.js
function compareArray(a, b) {
  if (Array.isArray(b)) {
    return a.length === b.length && isUndefined(a.find((v, index) => hasEq(v) ? !v.eq(b[index]) : v !== b[index]));
  }
  return false;
}
var init_compareArray = __esm({
  "../../node_modules/@polkadot/types-codec/utils/compareArray.js"() {
    init_util();
    init_util2();
  }
});

// ../../node_modules/@polkadot/types-codec/abstract/Array.js
var AbstractArray;
var init_Array = __esm({
  "../../node_modules/@polkadot/types-codec/abstract/Array.js"() {
    init_util();
    init_compareArray();
    AbstractArray = class extends Array {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      /**
       * @description This ensures that operators such as clice, filter, map, etc. return
       * new Array instances (without this we need to apply overrides)
       */
      static get [Symbol.species]() {
        return Array;
      }
      constructor(registry, length) {
        super(length);
        this.registry = registry;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        const count = this.length;
        let total = compactToU8a(count).length;
        for (let i2 = 0; i2 < count; i2++) {
          total += this[i2].encodedLength;
        }
        return total;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.length === 0;
      }
      /**
       * @description The length of the value
       */
      get length() {
        return super.length;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return compareArray(this, other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          inner: this.inspectInner(),
          outer: [compactToU8a(this.length)]
        };
      }
      /**
       * @internal
       * @description Internal per-item inspection of internal values
       */
      inspectInner() {
        const count = this.length;
        const inner = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          inner[i2] = this[i2].inspect();
        }
        return inner;
      }
      /**
       * @description Converts the Object to an standard JavaScript Array
       */
      toArray() {
        return Array.from(this);
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        const count = this.length;
        const result = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          result[i2] = this[i2] && this[i2].toHuman(isExtended, disableAscii);
        }
        return result;
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        const count = this.length;
        const result = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          result[i2] = this[i2] && this[i2].toJSON();
        }
        return result;
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        const count = this.length;
        const result = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          result[i2] = this[i2] && this[i2].toPrimitive(disableAscii);
        }
        return result;
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        const count = this.length;
        const result = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          result[i2] = this[i2].toString();
        }
        return `[${result.join(", ")}]`;
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = this.toU8aInner();
        return isBare ? u8aConcatStrict(encoded) : u8aConcatStrict([compactToU8a(this.length), ...encoded]);
      }
      /**
       * @internal
       * @description Internal per-item SCALE encoding of contained values
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8aInner(isBare) {
        const count = this.length;
        const encoded = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          encoded[i2] = this[i2].toU8a(isBare);
        }
        return encoded;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/abstract/Base.js
var AbstractBase;
var init_Base = __esm({
  "../../node_modules/@polkadot/types-codec/abstract/Base.js"() {
    AbstractBase = class {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__raw;
      constructor(registry, value, initialU8aLength) {
        this.initialU8aLength = initialU8aLength;
        this.__internal__raw = value;
        this.registry = registry;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description returns the inner (wrapped value)
       */
      get inner() {
        return this.__internal__raw;
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.__internal__raw.isEmpty;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return this.__internal__raw.eq(other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return this.__internal__raw.inspect();
      }
      /**
       * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
       */
      toHex(isLe) {
        return this.__internal__raw.toHex(isLe);
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        return this.__internal__raw.toHuman(isExtended, disableAscii);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.__internal__raw.toJSON();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        return this.__internal__raw.toPrimitive(disableAscii);
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.__internal__raw.toString();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return this.__internal__raw.toU8a(isBare);
      }
      /**
       * @description Returns the inner wrapped value (equivalent to valueOf)
       */
      unwrap() {
        return this.__internal__raw;
      }
      /**
       * @description Returns the inner wrapped value
       */
      valueOf() {
        return this.__internal__raw;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/abstract/Int.js
function isToBn2(value) {
  return isFunction(value.toBn);
}
function toPercentage(value, divisor) {
  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;
}
function decodeAbstractInt(value, isNegative) {
  if (isNumber(value)) {
    if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {
      throw new Error("Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1");
    }
    return value;
  } else if (isString(value)) {
    if (isHex(value, -1, true)) {
      return hexToBn(value, { isLe: false, isNegative }).toString();
    }
    if (value.includes(".") || value.includes(",") || value.includes("e")) {
      throw new Error("String should not contain decimal points or scientific notation");
    }
    return value;
  } else if (isBn(value) || isBigInt(value)) {
    return value.toString();
  } else if (isObject(value)) {
    if (isToBn2(value)) {
      return value.toBn().toString();
    }
    const keys2 = Object.keys(value);
    if (keys2.length !== 1) {
      throw new Error("Unable to construct number from multi-key object");
    }
    return decodeAbstractInt(value[keys2[0]], isNegative);
  } else if (!value) {
    return 0;
  }
  throw new Error(`Unable to create BN from unknown type ${typeof value}`);
}
var DEFAULT_UINT_BITS, MAX_NUMBER_BITS, MUL_P, FORMATTERS, AbstractInt;
var init_Int = __esm({
  "../../node_modules/@polkadot/types-codec/abstract/Int.js"() {
    init_util();
    DEFAULT_UINT_BITS = 64;
    MAX_NUMBER_BITS = 52;
    MUL_P = new import_bn.default(1e4);
    FORMATTERS = [
      ["Perquintill", BN_QUINTILL],
      ["Perbill", BN_BILLION],
      ["Permill", BN_MILLION],
      ["Percent", BN_HUNDRED]
    ];
    AbstractInt = class extends import_bn.default {
      registry;
      encodedLength;
      isUnsigned;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__bitLength;
      constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {
        super(
          // shortcut isU8a as used in SCALE decoding
          isU8a(value) ? bitLength <= 48 ? u8aToNumber(value.subarray(0, bitLength / 8), { isNegative: isSigned }) : u8aToBn(value.subarray(0, bitLength / 8), { isLe: true, isNegative: isSigned }).toString() : decodeAbstractInt(value, isSigned)
        );
        this.registry = registry;
        this.__internal__bitLength = bitLength;
        this.encodedLength = this.__internal__bitLength / 8;
        this.initialU8aLength = this.__internal__bitLength / 8;
        this.isUnsigned = !isSigned;
        const isNegative = this.isNeg();
        const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);
        if (isNegative && !isSigned) {
          throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);
        } else if (super.bitLength() > maxBits) {
          throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);
        }
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is a zero value (align elsewhere)
       */
      get isEmpty() {
        return this.isZero();
      }
      /**
       * @description Returns the number of bits in the value
       */
      bitLength() {
        return this.__internal__bitLength;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      eq(other) {
        return super.eq(isHex(other) ? hexToBn(other.toString(), { isLe: false, isNegative: !this.isUnsigned }) : bnToBn(other));
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [this.toU8a()]
        };
      }
      /**
       * @description True if this value is the max of the type
       */
      isMax() {
        const u8a = this.toU8a().filter((b) => b === 255);
        return u8a.length === this.__internal__bitLength / 8;
      }
      /**
       * @description Returns a BigInt representation of the number
       */
      toBigInt() {
        return BigInt(this.toString());
      }
      /**
       * @description Returns the BN representation of the number. (Compatibility)
       */
      toBn() {
        return this;
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex(isLe = false) {
        return bnToHex(this, {
          bitLength: this.bitLength(),
          isLe,
          isNegative: !this.isUnsigned
        });
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(_isExpanded) {
        const rawType = this.toRawType();
        if (rawType === "Balance") {
          return this.isMax() ? "everything" : formatBalance(this, { decimals: this.registry.chainDecimals[0], withSi: true, withUnit: this.registry.chainTokens[0] });
        }
        const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];
        return divisor ? toPercentage(this, divisor) : formatNumber(this);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON(onlyHex = false) {
        return onlyHex || this.__internal__bitLength > 128 || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();
      }
      /**
       * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise
       */
      toPrimitive() {
        return super.bitLength() > MAX_NUMBER_BITS ? this.toString() : this.toNumber();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return this instanceof this.registry.createClassUnsafe("Balance") ? "Balance" : `${this.isUnsigned ? "u" : "i"}${this.bitLength()}`;
      }
      /**
       * @description Returns the string representation of the value
       * @param base The base to use for the conversion
       */
      toString(base) {
        return super.toString(base);
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return bnToU8a(this, {
          bitLength: this.bitLength(),
          isLe: true,
          isNegative: !this.isUnsigned
        });
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/abstract/index.js
var init_abstract = __esm({
  "../../node_modules/@polkadot/types-codec/abstract/index.js"() {
    init_Base();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/compareMap.js
function hasMismatch(a, b) {
  return isUndefined(a) || (hasEq(a) ? !a.eq(b) : a !== b);
}
function notEntry(value) {
  return !Array.isArray(value) || value.length !== 2;
}
function compareMapArray(a, b) {
  return a.size === b.length && !b.some((e2) => notEntry(e2) || hasMismatch(a.get(e2[0]), e2[1]));
}
function compareMap(a, b) {
  if (Array.isArray(b)) {
    return compareMapArray(a, b);
  } else if (b instanceof Map) {
    return compareMapArray(a, [...b.entries()]);
  } else if (isObject(b)) {
    return compareMapArray(a, Object.entries(b));
  }
  return false;
}
var init_compareMap = __esm({
  "../../node_modules/@polkadot/types-codec/utils/compareMap.js"() {
    init_util();
    init_util2();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/compareSet.js
function compareSetArray(a, b) {
  return a.size === b.length && !b.some((e2) => !a.has(e2));
}
function compareSet(a, b) {
  if (Array.isArray(b)) {
    return compareSetArray(a, b);
  } else if (b instanceof Set) {
    return compareSetArray(a, [...b.values()]);
  } else if (isObject(b)) {
    return compareSetArray(a, Object.values(b));
  }
  return false;
}
var init_compareSet = __esm({
  "../../node_modules/@polkadot/types-codec/utils/compareSet.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/decodeU8a.js
function formatFailure(registry, fn, _result, { message }, u8a, i2, count, Type2, key) {
  let type = "";
  try {
    type = `: ${new Type2(registry).toRawType()}`;
  } catch {
  }
  return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}\u2026${key ? ` on ${key}` : ""} (index ${i2 + 1}/${count})${type}:: ${message}`;
}
function decodeU8a(registry, result, u8a, [Types, keys2]) {
  const count = result.length;
  let offset = 0;
  let i2 = 0;
  try {
    while (i2 < count) {
      const value = new Types[i2](registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i2] = value;
      i2++;
    }
  } catch (error) {
    throw new Error(formatFailure(registry, "decodeU8a", result, error, u8a.subarray(offset), i2, count, Types[i2], keys2[i2]));
  }
  return [result, offset];
}
function decodeU8aStruct(registry, result, u8a, [Types, keys2]) {
  const count = result.length;
  let offset = 0;
  let i2 = 0;
  try {
    while (i2 < count) {
      const value = new Types[i2](registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i2] = [keys2[i2], value];
      i2++;
    }
  } catch (error) {
    throw new Error(formatFailure(registry, "decodeU8aStruct", result, error, u8a.subarray(offset), i2, count, Types[i2], keys2[i2]));
  }
  return [result, offset];
}
function decodeU8aVec(registry, result, u8a, startAt, Type2) {
  const count = result.length;
  let offset = startAt;
  let i2 = 0;
  try {
    while (i2 < count) {
      const value = new Type2(registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i2] = value;
      i2++;
    }
  } catch (error) {
    throw new Error(formatFailure(registry, "decodeU8aVec", result, error, u8a.subarray(offset), i2, count, Type2));
  }
  return [offset, offset - startAt];
}
var init_decodeU8a = __esm({
  "../../node_modules/@polkadot/types-codec/utils/decodeU8a.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/sanitize.js
function trim() {
  return (value) => value.trim();
}
function findClosing(value, start) {
  let depth = 0;
  for (let i2 = start, count = value.length; i2 < count; i2++) {
    if (value[i2] === ">") {
      if (!depth) {
        return i2;
      }
      depth--;
    } else if (value[i2] === "<") {
      depth++;
    }
  }
  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);
}
function alias(src, dest, withChecks = true) {
  const from4 = new RegExp(`(^${src}|${BOX_PRECEDING.map((box) => `\\${box}${src}`).join("|")})`, "g");
  const to = (src2) => {
    from4.lastIndex = 0;
    return withChecks && BOX_PRECEDING.includes(src2[0]) ? `${src2[0]}${dest}` : dest;
  };
  return (value) => value.replace(from4, to);
}
function cleanupCompact() {
  return (value) => {
    if (value.includes(" as HasCompact")) {
      for (let i2 = 0, count = value.length; i2 < count; i2++) {
        if (value[i2] === "<") {
          const end = findClosing(value, i2 + 1) - 14;
          if (value.substring(end, end + 14) === " as HasCompact") {
            value = `Compact<${value.substring(i2 + 1, end)}>`;
          }
        }
      }
    }
    return value;
  };
}
function flattenSingleTuple() {
  const from1 = /,\)/g;
  const from22 = /\(([^,]+)\)/;
  return (value) => {
    from1.lastIndex = 0;
    return value.replace(from1, ")").replace(from22, "$1");
  };
}
function replaceTagWith(value, matcher, replacer2) {
  let index = -1;
  while (true) {
    index = value.indexOf(matcher, index + 1);
    if (index === -1) {
      return value;
    }
    const start = index + matcher.length;
    const end = findClosing(value, start);
    value = `${value.substring(0, index)}${replacer2(value.substring(start, end))}${value.substring(end + 1)}`;
  }
}
function removeExtensions(type, isSized) {
  return (value) => {
    for (let i2 = 0, count = BOUNDED.length; i2 < count; i2++) {
      const tag = BOUNDED[i2];
      value = replaceTagWith(value, `${type}${tag}<`, (v) => {
        const parts = v.split(",").map((s2) => s2.trim()).filter((s2) => s2);
        if (isSized) {
          parts.pop();
        }
        return `${tag}<${parts.join(",")}>`;
      });
    }
    return value;
  };
}
function removeColons() {
  return (value) => {
    let index = 0;
    while (index !== -1) {
      index = value.indexOf("::");
      if (index === 0) {
        value = value.substring(2);
      } else if (index !== -1) {
        let start = index;
        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {
          start--;
        }
        value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;
      }
    }
    return value;
  };
}
function removeGenerics() {
  return (value) => {
    for (let i2 = 0, count = value.length; i2 < count; i2++) {
      if (value[i2] === "<") {
        const box = ALLOWED_BOXES.find((box2) => {
          const start = i2 - box2.length;
          return start >= 0 && value.substring(start, i2) === box2 && // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>
          (start === 0 || BOX_PRECEDING.includes(value[start - 1]));
        });
        if (!box) {
          const end = findClosing(value, i2 + 1);
          value = `${value.substring(0, i2)}${value.substring(end + 1)}`;
        }
      }
    }
    return value;
  };
}
function removePairOf() {
  const replacer2 = (v) => `(${v},${v})`;
  return (value) => replaceTagWith(value, "PairOf<", replacer2);
}
function removeTraits() {
  const from1 = /\s/g;
  const from22 = /(T|Self)::/g;
  const from32 = /<(T|Self)asTrait>::/g;
  const from4 = /<Tas[a-z]+::Trait>::/g;
  const from5 = /<LookupasStaticLookup>/g;
  const from6 = /::Type/g;
  return (value) => {
    from1.lastIndex = 0;
    from22.lastIndex = 0;
    from32.lastIndex = 0;
    from4.lastIndex = 0;
    from5.lastIndex = 0;
    from6.lastIndex = 0;
    return value.replace(from1, "").replace(from22, "").replace(from32, "").replace(from4, "").replace(from5, "Lookup").replace(from6, "");
  };
}
function removeWrap(check) {
  const replacer2 = (v) => v;
  return (value) => replaceTagWith(value, check, replacer2);
}
function sanitize(value) {
  const startValue = value.toString();
  const memoized2 = sanitizeMap.get(startValue);
  if (memoized2) {
    return memoized2;
  }
  let result = startValue;
  for (let i2 = 0, count = mappings.length; i2 < count; i2++) {
    result = mappings[i2](result);
  }
  sanitizeMap.set(startValue, result);
  return result;
}
var BOUNDED, ALLOWED_BOXES, BOX_PRECEDING, mappings, sanitizeMap;
var init_sanitize = __esm({
  "../../node_modules/@polkadot/types-codec/utils/sanitize.js"() {
    BOUNDED = ["BTreeMap", "BTreeSet", "HashMap", "Vec"];
    ALLOWED_BOXES = BOUNDED.concat(["Compact", "DoNotConstruct", "Int", "Linkage", "Range", "RangeInclusive", "Result", "Opaque", "Option", "UInt", "WrapperKeepOpaque", "WrapperOpaque"]);
    BOX_PRECEDING = ["<", "(", "[", '"', ",", " "];
    mappings = [
      // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport
      alias("<T::InherentOfflineReport as InherentOfflineReport>::Inherent", "InherentOfflineReport", false),
      alias("VecDeque<", "Vec<", false),
      // <T::Balance as HasCompact>
      cleanupCompact(),
      // Change BoundedVec<Type, Size> to Vec<Type>
      removeExtensions("Bounded", true),
      // Change WeakVec<Type> to Vec<Type>
      removeExtensions("Weak", false),
      // Remove all the trait prefixes
      removeTraits(),
      // remove PairOf<T> -> (T, T)
      removePairOf(),
      // remove boxing, `Box<Proposal>` -> `Proposal`
      removeWrap("Box<"),
      // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`
      removeGenerics(),
      // alias String -> Text (compat with jsonrpc methods)
      alias("String", "Text"),
      // alias Vec<u8> -> Bytes
      alias("Vec<u8>", "Bytes"),
      alias("&\\[u8\\]", "Bytes"),
      alias("&'static\\[u8\\]", "Bytes"),
      // alias RawAddress -> Address
      alias("RawAddress", "Address"),
      // lookups, mapped to Address/AccountId as appropriate in runtime
      alias("Lookup::Source", "LookupSource"),
      alias("Lookup::Target", "LookupTarget"),
      // HACK duplication between contracts & primitives, however contracts prefixed with exec
      alias("exec::StorageKey", "ContractStorageKey"),
      // flattens tuples with one value, `(AccountId)` -> `AccountId`
      flattenSingleTuple(),
      // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal
      removeColons(),
      // remove all trailing spaces - this should always be the last
      trim()
    ];
    sanitizeMap = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/sortValues.js
function isArrayLike(arg) {
  return arg instanceof Uint8Array || Array.isArray(arg);
}
function isEnum(arg) {
  return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);
}
function isOption(arg) {
  return isCodec(arg) && isBoolean(arg.isSome) && isCodec(arg.value);
}
function isNumberLike(arg) {
  return isNumber(arg) || isBn(arg) || isBigInt(arg);
}
function sortArray(a, b) {
  let sortRes = 0;
  const minLen = Math.min(a.length, b.length);
  for (let i2 = 0; i2 < minLen; ++i2) {
    sortRes = sortAsc(a[i2], b[i2]);
    if (sortRes !== 0) {
      return sortRes;
    }
  }
  return a.length - b.length;
}
function checkForDuplicates(container, seen, arg) {
  if (isCodec(arg)) {
    const hex2 = arg.toHex();
    if (seen.has(hex2)) {
      throw new Error(`Duplicate value in ${container}: ${stringify(arg)}`);
    }
    seen.add(hex2);
  }
  return true;
}
function sortAsc(a, b) {
  if (isNumberLike(a) && isNumberLike(b)) {
    return bnToBn(a).cmp(bnToBn(b));
  } else if (a instanceof Map && b instanceof Map) {
    return sortAsc(Array.from(a.values()), Array.from(b.values()));
  } else if (isEnum(a) && isEnum(b)) {
    return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);
  } else if (isOption(a) && isOption(b)) {
    return sortAsc(a.isNone ? 0 : 1, b.isNone ? 0 : 1) || sortAsc(a.value, b.value);
  } else if (isArrayLike(a) && isArrayLike(b)) {
    return sortArray(a, b);
  } else if (isCodec(a) && isCodec(b)) {
    return sortAsc(a.toU8a(true), b.toU8a(true));
  }
  throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);
}
function sortSet(set) {
  const seen = /* @__PURE__ */ new Set();
  return new Set(Array.from(set).filter((value) => checkForDuplicates("BTreeSet", seen, value)).sort(sortAsc));
}
function sortMap(map79) {
  const seen = /* @__PURE__ */ new Set();
  return new Map(Array.from(map79.entries()).filter(([key]) => checkForDuplicates("BTreeMap", seen, key)).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));
}
var init_sortValues = __esm({
  "../../node_modules/@polkadot/types-codec/utils/sortValues.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types-codec/utils/toConstructors.js
function typeToConstructor(registry, type) {
  return typeof type === "function" ? type : registry.createClassUnsafe(type);
}
function typesToConstructors(registry, types4) {
  const count = types4.length;
  const result = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    result[i2] = typeToConstructor(registry, types4[i2]);
  }
  return result;
}
function mapToTypeMap(registry, input) {
  const entries = Object.entries(input);
  const count = entries.length;
  const output = [new Array(count), new Array(count)];
  for (let i2 = 0; i2 < count; i2++) {
    output[1][i2] = entries[i2][0];
    output[0][i2] = typeToConstructor(registry, entries[i2][1]);
  }
  return output;
}
var init_toConstructors = __esm({
  "../../node_modules/@polkadot/types-codec/utils/toConstructors.js"() {
  }
});

// ../../node_modules/@polkadot/types-codec/utils/typesToMap.js
function typesToMap(registry, [Types, keys2]) {
  const result = {};
  for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
    result[keys2[i2]] = registry.getClassName(Types[i2]) || new Types[i2](registry).toRawType();
  }
  return result;
}
var init_typesToMap = __esm({
  "../../node_modules/@polkadot/types-codec/utils/typesToMap.js"() {
  }
});

// ../../node_modules/@polkadot/types-codec/utils/index.js
var init_utils4 = __esm({
  "../../node_modules/@polkadot/types-codec/utils/index.js"() {
    init_compareArray();
    init_compareMap();
    init_compareSet();
    init_decodeU8a();
    init_sanitize();
    init_sortValues();
    init_toConstructors();
    init_typesToMap();
  }
});

// ../../node_modules/@polkadot/types-codec/base/Compact.js
function decodeCompact(registry, Type2, value) {
  if (isU8a(value)) {
    const [decodedLength, bn] = (value[0] & 3) < 3 ? compactFromU8aLim(value) : compactFromU8a(value);
    return [new Type2(registry, bn), decodedLength];
  } else if (value instanceof Compact) {
    const raw = value.unwrap();
    return raw instanceof Type2 ? [raw, 0] : [new Type2(registry, raw), 0];
  } else if (value instanceof Type2) {
    return [value, 0];
  }
  return [new Type2(registry, value), 0];
}
var Compact;
var init_Compact = __esm({
  "../../node_modules/@polkadot/types-codec/base/Compact.js"() {
    init_util();
    init_utils4();
    Compact = class _Compact {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__Type;
      __internal__raw;
      constructor(registry, Type2, value = 0, { definition, setDefinition = identity } = {}) {
        this.registry = registry;
        this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type2));
        const [raw, decodedLength] = decodeCompact(registry, this.__internal__Type, value);
        this.initialU8aLength = decodedLength;
        this.__internal__raw = raw;
      }
      static with(Type2) {
        let definition;
        const setDefinition = (d) => definition = d;
        return class extends _Compact {
          constructor(registry, value) {
            super(registry, Type2, value, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.__internal__raw.isEmpty;
      }
      /**
       * @description Returns the number of bits in the value
       */
      bitLength() {
        return this.__internal__raw.bitLength();
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return this.__internal__raw.eq(other instanceof _Compact ? other.__internal__raw : other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [this.toU8a()]
        };
      }
      /**
       * @description Returns a BigInt representation of the number
       */
      toBigInt() {
        return this.__internal__raw.toBigInt();
      }
      /**
       * @description Returns the BN representation of the number
       */
      toBn() {
        return this.__internal__raw.toBn();
      }
      /**
       * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
       */
      toHex(isLe) {
        return this.__internal__raw.toHex(isLe);
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        return this.__internal__raw.toHuman(isExtended, disableAscii);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.__internal__raw.toJSON();
      }
      /**
       * @description Returns the number representation for the value
       */
      toNumber() {
        return this.__internal__raw.toNumber();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        return this.__internal__raw.toPrimitive(disableAscii);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `Compact<${this.registry.getClassName(this.__internal__Type) || this.__internal__raw.toRawType()}>`;
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.__internal__raw.toString();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return compactToU8a(this.__internal__raw.toBn());
      }
      /**
       * @description Returns the embedded [[UInt]] or [[Moment]] value
       */
      unwrap() {
        return this.__internal__raw;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/DoNotConstruct.js
var DoNotConstruct;
var init_DoNotConstruct = __esm({
  "../../node_modules/@polkadot/types-codec/base/DoNotConstruct.js"() {
    DoNotConstruct = class _DoNotConstruct {
      registry;
      createdAtHash;
      isStorageFallback;
      __internal__neverError;
      constructor(registry, typeName = "DoNotConstruct") {
        this.registry = registry;
        this.__internal__neverError = new Error(`DoNotConstruct: Cannot construct unknown type ${typeName}`);
        throw this.__internal__neverError;
      }
      static with(typeName) {
        return class extends _DoNotConstruct {
          constructor(registry) {
            super(registry, typeName);
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        throw this.__internal__neverError;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        throw this.__internal__neverError;
      }
      /**
       * @description Checks if the value is an empty value (always true)
       */
      get isEmpty() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      eq() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      inspect() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toHex() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toHuman() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toJSON() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toPrimitive() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toRawType() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toString() {
        throw this.__internal__neverError;
      }
      /**
       * @description Unimplemented
       */
      toU8a() {
        throw this.__internal__neverError;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Null.js
var Null;
var init_Null = __esm({
  "../../node_modules/@polkadot/types-codec/base/Null.js"() {
    init_util();
    Null = class _Null {
      encodedLength = 0;
      isEmpty = true;
      registry;
      createdAtHash;
      initialU8aLength = 0;
      isStorageFallback;
      constructor(registry) {
        this.registry = registry;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        throw new Error(".hash is not implemented on Null");
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return other instanceof _Null || isNull(other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {};
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return "0x";
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return null;
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return null;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Null";
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return "";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return new Uint8Array();
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Enum.js
function isRustEnum(def) {
  const defValues = Object.values(def);
  if (defValues.some((v) => isNumber(v))) {
    if (!defValues.every((v) => isNumber(v) && v >= 0 && v <= 255)) {
      throw new Error("Invalid number-indexed enum definition");
    }
    return false;
  }
  return true;
}
function extractDef(registry, _def) {
  const def = {};
  let isBasic;
  let isIndexed;
  if (Array.isArray(_def)) {
    for (let i2 = 0, count = _def.length; i2 < count; i2++) {
      def[_def[i2]] = { Type: Null, index: i2 };
    }
    isBasic = true;
    isIndexed = false;
  } else if (isRustEnum(_def)) {
    const [Types, keys2] = mapToTypeMap(registry, _def);
    for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
      def[keys2[i2]] = { Type: Types[i2], index: i2 };
    }
    isBasic = !Object.values(def).some(({ Type: Type2 }) => Type2 !== Null);
    isIndexed = false;
  } else {
    const entries = Object.entries(_def);
    for (let i2 = 0, count = entries.length; i2 < count; i2++) {
      const [key, index] = entries[i2];
      def[key] = { Type: Null, index };
    }
    isBasic = true;
    isIndexed = true;
  }
  return {
    def,
    isBasic,
    isIndexed
  };
}
function getEntryType(def, checkIdx) {
  const values = Object.values(def);
  for (let i2 = 0, count = values.length; i2 < count; i2++) {
    const { Type: Type2, index } = values[i2];
    if (index === checkIdx) {
      return Type2;
    }
  }
  throw new Error(`Unable to create Enum via index ${checkIdx}, in ${Object.keys(def).join(", ")}`);
}
function createFromU8a(registry, def, index, value) {
  const Type2 = getEntryType(def, index);
  return {
    index,
    value: new Type2(registry, value)
  };
}
function createFromValue(registry, def, index = 0, value) {
  const Type2 = getEntryType(def, index);
  return {
    index,
    value: value instanceof Type2 ? value : new Type2(registry, value)
  };
}
function decodeFromJSON(registry, def, key, value) {
  const keys2 = Object.keys(def).map((k) => k.toLowerCase());
  const keyLower = key.toLowerCase();
  const index = keys2.indexOf(keyLower);
  if (index === -1) {
    throw new Error(`Cannot map Enum JSON, unable to find '${key}' in ${keys2.join(", ")}`);
  }
  try {
    return createFromValue(registry, def, Object.values(def)[index].index, value);
  } catch (error) {
    throw new Error(`Enum(${key}):: ${error.message}`);
  }
}
function decodeEnum(registry, def, value, index) {
  if (isNumber(index)) {
    return createFromValue(registry, def, index, value);
  } else if (isU8a(value) || isHex(value)) {
    const u8a = u8aToU8a(value);
    if (u8a.length) {
      return createFromU8a(registry, def, u8a[0], u8a.subarray(1));
    }
  } else if (value instanceof Enum) {
    return createFromValue(registry, def, value.index, value.value);
  } else if (isNumber(value)) {
    return createFromValue(registry, def, value);
  } else if (isString(value)) {
    return decodeFromJSON(registry, def, value.toString());
  } else if (isObject(value)) {
    const key = Object.keys(value)[0];
    return decodeFromJSON(registry, def, key, value[key]);
  }
  return createFromValue(registry, def, Object.values(def)[0].index);
}
var Enum;
var init_Enum = __esm({
  "../../node_modules/@polkadot/types-codec/base/Enum.js"() {
    init_util();
    init_utils4();
    init_Null();
    Enum = class _Enum {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__def;
      __internal__entryIndex;
      __internal__indexes;
      __internal__isBasic;
      __internal__isIndexed;
      __internal__raw;
      constructor(registry, Types, value, index, { definition, setDefinition = identity } = {}) {
        const { def, isBasic, isIndexed } = definition || setDefinition(extractDef(registry, Types));
        const decoded = isU8a(value) && value.length && !isNumber(index) ? createFromU8a(registry, def, value[0], value.subarray(1)) : decodeEnum(registry, def, value, index);
        this.registry = registry;
        this.__internal__def = def;
        this.__internal__isBasic = isBasic;
        this.__internal__isIndexed = isIndexed;
        this.__internal__indexes = Object.values(def).map(({ index: index2 }) => index2);
        this.__internal__entryIndex = this.__internal__indexes.indexOf(decoded.index);
        this.__internal__raw = decoded.value;
        if (this.__internal__raw.initialU8aLength) {
          this.initialU8aLength = 1 + this.__internal__raw.initialU8aLength;
        }
      }
      static with(Types) {
        let definition;
        const setDefinition = (d) => definition = d;
        return class extends _Enum {
          static {
            const keys2 = Array.isArray(Types) ? Types : Object.keys(Types);
            const count = keys2.length;
            const asKeys = new Array(count);
            const isKeys = new Array(count);
            for (let i2 = 0; i2 < count; i2++) {
              const name = stringPascalCase(keys2[i2]);
              asKeys[i2] = `as${name}`;
              isKeys[i2] = `is${name}`;
            }
            objectProperties(this.prototype, isKeys, (_, i2, self2) => self2.type === keys2[i2]);
            objectProperties(this.prototype, asKeys, (k, i2, self2) => {
              if (self2.type !== keys2[i2]) {
                throw new Error(`Cannot convert '${self2.type}' via ${k}`);
              }
              return self2.value;
            });
          }
          constructor(registry, value, index) {
            super(registry, Types, value, index, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return 1 + this.__internal__raw.encodedLength;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description The index of the enum value
       */
      get index() {
        return this.__internal__indexes[this.__internal__entryIndex];
      }
      /**
       * @description The value of the enum
       */
      get inner() {
        return this.__internal__raw;
      }
      /**
       * @description true if this is a basic enum (no values)
       */
      get isBasic() {
        return this.__internal__isBasic;
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.__internal__raw.isEmpty;
      }
      /**
       * @description Checks if the Enum points to a [[Null]] type
       */
      get isNone() {
        return this.__internal__raw instanceof Null;
      }
      /**
       * @description The available keys for this enum
       */
      get defIndexes() {
        return this.__internal__indexes;
      }
      /**
       * @description The available keys for this enum
       */
      get defKeys() {
        return Object.keys(this.__internal__def);
      }
      /**
       * @description The name of the type this enum value represents
       */
      get type() {
        return this.defKeys[this.__internal__entryIndex];
      }
      /**
       * @description The value of the enum
       */
      get value() {
        return this.__internal__raw;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        if (isU8a(other)) {
          return !this.toU8a().some((entry, index) => entry !== other[index]);
        } else if (isNumber(other)) {
          return this.toNumber() === other;
        } else if (this.__internal__isBasic && isString(other)) {
          return this.type === other;
        } else if (isHex(other)) {
          return this.toHex() === other;
        } else if (other instanceof _Enum) {
          return this.index === other.index && this.value.eq(other.value);
        } else if (isObject(other)) {
          return this.value.eq(other[this.type]);
        }
        return this.value.eq(other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        if (this.__internal__isBasic) {
          return { outer: [new Uint8Array([this.index])] };
        }
        const { inner, outer = [] } = this.__internal__raw.inspect();
        return {
          inner,
          outer: [new Uint8Array([this.index]), ...outer]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        return this.__internal__isBasic || this.isNone ? this.type : { [this.type]: this.__internal__raw.toHuman(isExtended, disableAscii) };
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.__internal__isBasic ? this.type : { [stringCamelCase(this.type)]: this.__internal__raw.toJSON() };
      }
      /**
       * @description Returns the number representation for the value
       */
      toNumber() {
        return this.index;
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        return this.__internal__isBasic ? this.type : { [stringCamelCase(this.type)]: this.__internal__raw.toPrimitive(disableAscii) };
      }
      /**
       * @description Returns a raw struct representation of the enum types
       */
      _toRawStruct() {
        if (this.__internal__isBasic) {
          return this.__internal__isIndexed ? this.defKeys.reduce((out, key, index) => {
            out[key] = this.__internal__indexes[index];
            return out;
          }, {}) : this.defKeys;
        }
        const entries = Object.entries(this.__internal__def);
        return typesToMap(this.registry, entries.reduce((out, [key, { Type: Type2 }], i2) => {
          out[0][i2] = Type2;
          out[1][i2] = key;
          return out;
        }, [new Array(entries.length), new Array(entries.length)]));
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return stringify({ _enum: this._toRawStruct() });
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.isNone ? this.type : stringify(this.toJSON());
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return isBare ? this.__internal__raw.toU8a(isBare) : u8aConcatStrict([
          new Uint8Array([this.index]),
          this.__internal__raw.toU8a(isBare)
        ]);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Int.js
var Int;
var init_Int2 = __esm({
  "../../node_modules/@polkadot/types-codec/base/Int.js"() {
    init_Int();
    Int = class _Int extends AbstractInt {
      constructor(registry, value = 0, bitLength) {
        super(registry, value, bitLength, true);
      }
      static with(bitLength, typeName) {
        return class extends _Int {
          constructor(registry, value) {
            super(registry, value, bitLength);
          }
          toRawType() {
            return typeName || super.toRawType();
          }
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Option.js
function decodeOption(registry, Type2, value) {
  if (value instanceof Type2) {
    return value;
  } else if (value instanceof Option) {
    if (value.value instanceof Type2) {
      return value.value;
    } else if (value.isNone) {
      return new None(registry);
    }
    return new Type2(registry, value.value);
  } else if (isNull(value) || isUndefined(value) || value === "0x" || value instanceof None) {
    return new None(registry);
  } else if (isU8a(value)) {
    return !value.length || value[0] === 0 ? new None(registry) : new Type2(registry, value.subarray(1));
  }
  return new Type2(registry, value);
}
var None, Option;
var init_Option = __esm({
  "../../node_modules/@polkadot/types-codec/base/Option.js"() {
    init_util();
    init_utils4();
    init_Null();
    None = class extends Null {
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "None";
      }
    };
    Option = class _Option {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__Type;
      __internal__raw;
      constructor(registry, typeName, value, { definition, setDefinition = identity } = {}) {
        const Type2 = definition || setDefinition(typeToConstructor(registry, typeName));
        const decoded = isU8a(value) && value.length && !isCodec(value) ? value[0] === 0 ? new None(registry) : new Type2(registry, value.subarray(1)) : decodeOption(registry, Type2, value);
        this.registry = registry;
        this.__internal__Type = Type2;
        this.__internal__raw = decoded;
        if (decoded?.initialU8aLength) {
          this.initialU8aLength = 1 + decoded.initialU8aLength;
        }
      }
      static with(Type2) {
        let definition;
        const setDefinition = (d) => {
          definition = d;
          return d;
        };
        return class extends _Option {
          constructor(registry, value) {
            super(registry, Type2, value, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return 1 + this.__internal__raw.encodedLength;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the Option has no value
       */
      get isEmpty() {
        return this.isNone;
      }
      /**
       * @description Checks if the Option has no value
       */
      get isNone() {
        return this.__internal__raw instanceof None;
      }
      /**
       * @description Checks if the Option has a value
       */
      get isSome() {
        return !this.isNone;
      }
      /**
       * @description The actual value for the Option
       */
      get value() {
        return this.__internal__raw;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        if (other instanceof _Option) {
          return this.isSome === other.isSome && this.value.eq(other.value);
        }
        return this.value.eq(other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        if (this.isNone) {
          return { outer: [new Uint8Array([0])] };
        }
        const { inner, outer = [] } = this.__internal__raw.inspect();
        return {
          inner,
          outer: [new Uint8Array([1]), ...outer]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return this.isNone ? "0x" : u8aToHex(this.toU8a().subarray(1));
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        return this.__internal__raw.toHuman(isExtended, disableAscii);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.isNone ? null : this.__internal__raw.toJSON();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        return this.isNone ? null : this.__internal__raw.toPrimitive(disableAscii);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType(isBare) {
        const wrapped = this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType();
        return isBare ? wrapped : `Option<${wrapped}>`;
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.__internal__raw.toString();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        if (isBare) {
          return this.__internal__raw.toU8a(true);
        }
        const u8a = new Uint8Array(this.encodedLength);
        if (this.isSome) {
          u8a.set([1]);
          u8a.set(this.__internal__raw.toU8a(), 1);
        }
        return u8a;
      }
      /**
       * @description Returns the value that the Option represents (if available), throws if null
       */
      unwrap() {
        if (this.isNone) {
          throw new Error("Option: unwrapping a None value");
        }
        return this.__internal__raw;
      }
      /**
       * @description Returns the value that the Option represents (if available) or defaultValue if none
       * @param defaultValue The value to return if the option isNone
       */
      unwrapOr(defaultValue) {
        return this.isSome ? this.unwrap() : defaultValue;
      }
      /**
       * @description Returns the value that the Option represents (if available) or defaultValue if none
       * @param defaultValue The value to return if the option isNone
       */
      unwrapOrDefault() {
        return this.isSome ? this.unwrap() : new this.__internal__Type(this.registry);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Result.js
var Result;
var init_Result = __esm({
  "../../node_modules/@polkadot/types-codec/base/Result.js"() {
    init_Enum();
    Result = class _Result extends Enum {
      constructor(registry, Ok, Err, value) {
        super(registry, { Ok, Err }, value);
      }
      static with(Types) {
        return class extends _Result {
          constructor(registry, value) {
            super(registry, Types.Ok, Types.Err, value);
          }
        };
      }
      /**
       * @description Returns the wrapper Err value (if isErr)
       */
      get asErr() {
        if (!this.isErr) {
          throw new Error("Cannot extract Err value from Ok result, check isErr first");
        }
        return this.value;
      }
      /**
       * @description Returns the wrapper Ok value (if isOk)
       */
      get asOk() {
        if (!this.isOk) {
          throw new Error("Cannot extract Ok value from Err result, check isOk first");
        }
        return this.value;
      }
      /**
       * @description Checks if the Result has no value
       */
      get isEmpty() {
        return this.isOk && this.value.isEmpty;
      }
      /**
       * @description Checks if the Result wraps an Err value
       */
      get isErr() {
        return !this.isOk;
      }
      /**
       * @description Checks if the Result wraps an Ok value
       */
      get isOk() {
        return this.index === 0;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        const Types = this._toRawStruct();
        return `Result<${Types.Ok},${Types.Err}>`;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Tuple.js
function decodeTuple(registry, result, value, Classes) {
  if (Array.isArray(value)) {
    const Types = Classes[0];
    for (let i2 = 0, count = Types.length; i2 < count; i2++) {
      try {
        const entry = value?.[i2];
        result[i2] = entry instanceof Types[i2] ? entry : new Types[i2](registry, entry);
      } catch (error) {
        throw new Error(`Tuple: failed on ${i2}:: ${error.message}`);
      }
    }
    return [result, 0];
  } else if (isHex(value)) {
    return decodeU8a(registry, result, u8aToU8a(value), Classes);
  } else if (!value || !result.length) {
    const Types = Classes[0];
    for (let i2 = 0, count = Types.length; i2 < count; i2++) {
      result[i2] = new Types[i2](registry);
    }
    return [result, 0];
  }
  throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);
}
var Tuple;
var init_Tuple = __esm({
  "../../node_modules/@polkadot/types-codec/base/Tuple.js"() {
    init_util();
    init_Array();
    init_utils4();
    Tuple = class _Tuple extends AbstractArray {
      __internal__Types;
      constructor(registry, Types, value, { definition, setDefinition = identity } = {}) {
        const Classes = definition || setDefinition(Array.isArray(Types) ? [typesToConstructors(registry, Types), []] : isFunction(Types) || isString(Types) ? [[typeToConstructor(registry, Types)], []] : mapToTypeMap(registry, Types));
        super(registry, Classes[0].length);
        this.initialU8aLength = (isU8a(value) ? decodeU8a(registry, this, value, Classes) : decodeTuple(registry, this, value, Classes))[1];
        this.__internal__Types = Classes;
      }
      static with(Types) {
        let definition;
        const setDefinition = (d) => definition = d;
        return class extends _Tuple {
          constructor(registry, value) {
            super(registry, Types, value, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        let total = 0;
        for (let i2 = 0, count = this.length; i2 < count; i2++) {
          total += this[i2].encodedLength;
        }
        return total;
      }
      /**
       * @description The types definition of the tuple
       */
      get Types() {
        return this.__internal__Types[1].length ? this.__internal__Types[1] : this.__internal__Types[0].map((T) => new T(this.registry).toRawType());
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          inner: this.inspectInner()
        };
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        const types4 = this.__internal__Types[0].map((T) => this.registry.getClassName(T) || new T(this.registry).toRawType());
        return `(${types4.join(",")})`;
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return stringify(this.toJSON());
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return u8aConcatStrict(this.toU8aInner(isBare));
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/UInt.js
var UInt;
var init_UInt = __esm({
  "../../node_modules/@polkadot/types-codec/base/UInt.js"() {
    init_Int();
    UInt = class _UInt extends AbstractInt {
      static with(bitLength, typeName) {
        return class extends _UInt {
          constructor(registry, value) {
            super(registry, value, bitLength);
          }
          toRawType() {
            return typeName || super.toRawType();
          }
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/Vec.js
function decodeVecLength(value) {
  if (Array.isArray(value)) {
    return [value, value.length, 0];
  } else if (isU8a(value) || isHex(value)) {
    const u8a = u8aToU8a(value);
    const [startAt, length] = compactFromU8aLim(u8a);
    if (length > MAX_LENGTH) {
      throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);
    }
    return [u8a, length, startAt];
  } else if (!value) {
    return [null, 0, 0];
  }
  throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);
}
function decodeVec(registry, result, value, startAt, Type2) {
  if (Array.isArray(value)) {
    const count = result.length;
    for (let i2 = 0; i2 < count; i2++) {
      const entry = value[i2];
      try {
        result[i2] = entry instanceof Type2 ? entry : new Type2(registry, entry);
      } catch (error) {
        l5.error(`Unable to decode on index ${i2}`, error.message);
        throw error;
      }
    }
    return [0, 0];
  } else if (!value) {
    return [0, 0];
  }
  return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type2);
}
var MAX_LENGTH, l5, Vec;
var init_Vec = __esm({
  "../../node_modules/@polkadot/types-codec/base/Vec.js"() {
    init_util();
    init_Array();
    init_utils4();
    MAX_LENGTH = 512 * 1024;
    l5 = logger("Vec");
    Vec = class _Vec extends AbstractArray {
      __internal__Type;
      constructor(registry, Type2, value = [], { definition, setDefinition = identity } = {}) {
        const [decodeFrom, length, startAt] = decodeVecLength(value);
        super(registry, length);
        this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type2));
        this.initialU8aLength = (isU8a(decodeFrom) ? decodeU8aVec(registry, this, decodeFrom, startAt, this.__internal__Type) : decodeVec(registry, this, decodeFrom, startAt, this.__internal__Type))[0];
      }
      static with(Type2) {
        let definition;
        const setDefinition = (d) => definition = d;
        return class extends _Vec {
          constructor(registry, value) {
            super(registry, Type2, value, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The type for the items
       */
      get Type() {
        return this.__internal__Type.name;
      }
      /**
       * @description Finds the index of the value in the array
       */
      indexOf(other) {
        const check = other instanceof this.__internal__Type ? other : new this.__internal__Type(this.registry, other);
        for (let i2 = 0, count = this.length; i2 < count; i2++) {
          if (check.eq(this[i2])) {
            return i2;
          }
        }
        return -1;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `Vec<${this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType()}>`;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/VecFixed.js
var VecFixed;
var init_VecFixed = __esm({
  "../../node_modules/@polkadot/types-codec/base/VecFixed.js"() {
    init_util();
    init_Array();
    init_utils4();
    init_Vec();
    VecFixed = class _VecFixed extends AbstractArray {
      __internal__Type;
      constructor(registry, Type2, length, value = [], { definition, setDefinition = identity } = {}) {
        super(registry, length);
        this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type2));
        this.initialU8aLength = (isU8a(value) ? decodeU8aVec(registry, this, value, 0, this.__internal__Type) : decodeVec(registry, this, value, 0, this.__internal__Type))[1];
      }
      static with(Type2, length) {
        let definition;
        const setDefinition = (d) => definition = d;
        return class extends _VecFixed {
          constructor(registry, value) {
            super(registry, Type2, length, value, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The type for the items
       */
      get Type() {
        return new this.__internal__Type(this.registry).toRawType();
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        let total = 0;
        for (let i2 = 0, count = this.length; i2 < count; i2++) {
          total += this[i2].encodedLength;
        }
        return total;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          inner: this.inspectInner()
        };
      }
      toU8a() {
        const encoded = this.toU8aInner();
        return encoded.length ? u8aConcatStrict(encoded) : new Uint8Array([]);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `[${this.Type};${this.length}]`;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/base/index.js
var init_base2 = __esm({
  "../../node_modules/@polkadot/types-codec/base/index.js"() {
    init_Compact();
    init_DoNotConstruct();
    init_Enum();
    init_Int2();
    init_Null();
    init_Option();
    init_Result();
    init_Tuple();
    init_UInt();
    init_Vec();
    init_VecFixed();
  }
});

// ../../node_modules/@polkadot/types-codec/native/Raw.js
var Raw;
var init_Raw = __esm({
  "../../node_modules/@polkadot/types-codec/native/Raw.js"() {
    init_util();
    Raw = class extends Uint8Array {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      /**
       * @description This ensures that operators such as clice, filter, map, etc. return
       * new Array instances (without this we need to apply overrides)
       */
      static get [Symbol.species]() {
        return Uint8Array;
      }
      constructor(registry, value, initialU8aLength) {
        super(u8aToU8a(value));
        this.registry = registry;
        this.initialU8aLength = initialU8aLength;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.length;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Returns true if the wrapped value contains only ASCII printable characters
       */
      get isAscii() {
        return isAscii(this);
      }
      /**
       * @description Returns true if the type wraps an empty/default all-0 value
       */
      get isEmpty() {
        return !this.length || isUndefined(this.find((b) => !!b));
      }
      /**
       * @description Returns true if the wrapped value contains only utf8 characters
       */
      get isUtf8() {
        return isUtf8(this);
      }
      /**
       * @description Returns the number of bits in the value
       */
      bitLength() {
        return this.length * 8;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        if (other instanceof Uint8Array) {
          return this.length === other.length && !this.some((b, index) => b !== other[index]);
        }
        return this.eq(u8aToU8a(other));
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [this.toU8a()]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this);
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(_isExtended, disableAscii) {
        return this.toPrimitive(disableAscii);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toHex();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        if (!disableAscii && this.isAscii) {
          const text = this.toUtf8();
          if (isAscii(text)) {
            return text;
          }
        }
        return this.toJSON();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Raw";
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.toHex();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return Uint8Array.from(this);
      }
      /**
       * @description Returns the wrapped data as a UTF-8 string
       */
      toUtf8() {
        if (!this.isUtf8) {
          throw new Error("The character sequence is not a valid Utf8 string");
        }
        return u8aToString(this);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/BitVec.js
function decodeBitVecU8a(value) {
  if (!value?.length) {
    return [0, new Uint8Array()];
  }
  const [offset, length] = compactFromU8aLim(value);
  const total = offset + Math.ceil(length / 8);
  if (total > value.length) {
    throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);
  }
  return [length, value.subarray(offset, total)];
}
function decodeBitVec(value) {
  if (Array.isArray(value) || isString(value)) {
    const u8a = u8aToU8a(value);
    return [u8a.length / 8, u8a];
  }
  return decodeBitVecU8a(value);
}
var BitVec;
var init_BitVec = __esm({
  "../../node_modules/@polkadot/types-codec/extended/BitVec.js"() {
    init_util();
    init_Raw();
    BitVec = class extends Raw {
      __internal__decodedLength;
      __internal__isMsb;
      // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming
      // we are dealing with Lsb, which is the default (as of writing) BitVec format used
      // in the Polkadot code (this only affects the toHuman displays)
      constructor(registry, value, isMsb = false) {
        const [decodedLength, u8a] = decodeBitVec(value);
        super(registry, u8a);
        this.__internal__decodedLength = decodedLength;
        this.__internal__isMsb = isMsb;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.length + compactToU8a(this.__internal__decodedLength).length;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [compactToU8a(this.__internal__decodedLength), super.toU8a()]
        };
      }
      /**
       * @description Creates a boolean array of the bit values
       */
      toBoolArray() {
        const map79 = [...this.toU8a(true)].map((v) => [
          !!(v & 128),
          !!(v & 64),
          !!(v & 32),
          !!(v & 16),
          !!(v & 8),
          !!(v & 4),
          !!(v & 2),
          !!(v & 1)
        ]);
        const count = map79.length;
        const result = new Array(8 * count);
        for (let i2 = 0; i2 < count; i2++) {
          const off = i2 * 8;
          const v = map79[i2];
          for (let j = 0; j < 8; j++) {
            result[off + j] = this.__internal__isMsb ? v[j] : v[7 - j];
          }
        }
        return result;
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return `0b${[...this.toU8a(true)].map((d) => `00000000${d.toString(2)}`.slice(-8)).map((s2) => this.__internal__isMsb ? s2 : s2.split("").reverse().join("")).join("_")}`;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "BitVec";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const bitVec = super.toU8a(isBare);
        return isBare ? bitVec : u8aConcatStrict([compactToU8a(this.__internal__decodedLength), bitVec]);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/native/Struct.js
function noopSetDefinition(d) {
  return d;
}
function decodeStructFromObject(registry, [Types, keys2], value, jsonMap) {
  let jsonObj;
  const typeofArray = Array.isArray(value);
  const typeofMap = value instanceof Map;
  const count = keys2.length;
  if (!typeofArray && !typeofMap && !isObject(value)) {
    throw new Error(`Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);
  } else if (typeofArray && value.length !== count) {
    throw new Error(`Struct: Unable to map ${stringify(value)} array to object with known keys ${keys2.join(", ")}`);
  }
  const raw = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const key = keys2[i2];
    const jsonKey = jsonMap.get(key) || key;
    const Type2 = Types[i2];
    let assign;
    try {
      if (typeofArray) {
        assign = value[i2];
      } else if (typeofMap) {
        assign = jsonKey && value.get(jsonKey);
      } else {
        assign = jsonKey && value[jsonKey];
        if (isUndefined(assign)) {
          if (isUndefined(jsonObj)) {
            const entries = Object.entries(value);
            jsonObj = {};
            for (let e2 = 0, ecount = entries.length; e2 < ecount; e2++) {
              jsonObj[stringCamelCase(entries[e2][0])] = entries[e2][1];
            }
          }
          assign = jsonKey && jsonObj[jsonKey];
        }
      }
      raw[i2] = [
        key,
        assign instanceof Type2 ? assign : new Type2(registry, assign)
      ];
    } catch (error) {
      let type = Type2.name;
      try {
        type = new Type2(registry).toRawType();
      } catch {
      }
      throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);
    }
  }
  return [raw, 0];
}
var Struct;
var init_Struct = __esm({
  "../../node_modules/@polkadot/types-codec/native/Struct.js"() {
    init_util();
    init_utils4();
    Struct = class _Struct extends Map {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__jsonMap;
      __internal__Types;
      constructor(registry, Types, value, jsonMap = /* @__PURE__ */ new Map(), { definition, setDefinition = noopSetDefinition } = {}) {
        const typeMap = definition || setDefinition(mapToTypeMap(registry, Types));
        const [decoded, decodedLength] = isU8a(value) || isHex(value) ? decodeU8aStruct(registry, new Array(typeMap[0].length), u8aToU8a(value), typeMap) : value instanceof _Struct ? [value, 0] : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);
        super(decoded);
        this.initialU8aLength = decodedLength;
        this.registry = registry;
        this.__internal__jsonMap = jsonMap;
        this.__internal__Types = typeMap;
      }
      static with(Types, jsonMap) {
        let definition;
        const setDefinition = (d) => definition = d;
        return class extends _Struct {
          static {
            const keys2 = Object.keys(Types);
            objectProperties(this.prototype, keys2, (k, _, self2) => self2.get(k));
          }
          constructor(registry, value) {
            super(registry, Types, value, jsonMap, { definition, setDefinition });
          }
        };
      }
      /**
       * @description The available keys for this struct
       */
      get defKeys() {
        return this.__internal__Types[1];
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        for (const v of this.values()) {
          if (!v.isEmpty) {
            return false;
          }
        }
        return true;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        let total = 0;
        for (const v of this.values()) {
          total += v.encodedLength;
        }
        return total;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Returns the Type description of the structure
       */
      get Type() {
        const result = {};
        const [Types, keys2] = this.__internal__Types;
        for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
          result[keys2[i2]] = new Types[i2](this.registry).toRawType();
        }
        return result;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return compareMap(this, other);
      }
      /**
       * @description Returns a specific names entry in the structure
       * @param key The name of the entry to retrieve
       */
      get(key) {
        return super.get(key);
      }
      /**
       * @description Returns the values of a member at a specific index (Rather use get(name) for performance)
       */
      getAtIndex(index) {
        return this.toArray()[index];
      }
      /**
       * @description Returns the a types value by name
       */
      getT(key) {
        return super.get(key);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect(isBare) {
        const inner = [];
        for (const [k, v] of this.entries()) {
          inner.push({
            ...v.inspect(!isBare || isBoolean(isBare) ? isBare : isBare[k]),
            name: stringCamelCase(k)
          });
        }
        return {
          inner
        };
      }
      /**
       * @description Converts the Object to an standard JavaScript Array
       */
      toArray() {
        return [...this.values()];
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        const json = {};
        for (const [k, v] of this.entries()) {
          json[k] = v.toHuman(isExtended, disableAscii);
        }
        return json;
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        const json = {};
        for (const [k, v] of this.entries()) {
          json[this.__internal__jsonMap.get(k) || k] = v.toJSON();
        }
        return json;
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        const json = {};
        for (const [k, v] of this.entries()) {
          json[k] = v.toPrimitive(disableAscii);
        }
        return json;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return stringify(typesToMap(this.registry, this.__internal__Types));
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return stringify(this.toJSON());
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = [];
        for (const [k, v] of this.entries()) {
          encoded.push(v.toU8a(!isBare || isBoolean(isBare) ? isBare : isBare[k]));
        }
        return u8aConcatStrict(encoded);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/Map.js
function decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {
  const output = /* @__PURE__ */ new Map();
  const [offset, count] = compactFromU8aLim(u8a);
  const types4 = [];
  for (let i2 = 0; i2 < count; i2++) {
    types4.push(KeyClass, ValClass);
  }
  const [values, decodedLength] = decodeU8a(registry, new Array(types4.length), u8a.subarray(offset), [types4, []]);
  for (let i2 = 0, count2 = values.length; i2 < count2; i2 += 2) {
    output.set(values[i2], values[i2 + 1]);
  }
  return [KeyClass, ValClass, output, offset + decodedLength];
}
function decodeMapFromMap(registry, KeyClass, ValClass, value) {
  const output = /* @__PURE__ */ new Map();
  for (const [key, val] of value.entries()) {
    const isComplex = KeyClass.prototype instanceof AbstractArray || KeyClass.prototype instanceof Struct || KeyClass.prototype instanceof Enum;
    try {
      output.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex && typeof key === "string" ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));
    } catch (error) {
      l6.error("Failed to decode key or value:", error.message);
      throw error;
    }
  }
  return [KeyClass, ValClass, output, 0];
}
function decodeMap(registry, keyType, valType, value) {
  const KeyClass = typeToConstructor(registry, keyType);
  const ValClass = typeToConstructor(registry, valType);
  if (!value) {
    return [KeyClass, ValClass, /* @__PURE__ */ new Map(), 0];
  } else if (isU8a(value) || isHex(value)) {
    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));
  } else if (value instanceof Map) {
    return decodeMapFromMap(registry, KeyClass, ValClass, value);
  } else if (isObject(value)) {
    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));
  }
  throw new Error("Map: cannot decode type");
}
var l6, CodecMap;
var init_Map = __esm({
  "../../node_modules/@polkadot/types-codec/extended/Map.js"() {
    init_util();
    init_Array();
    init_Enum();
    init_Raw();
    init_Struct();
    init_utils4();
    l6 = logger("Map");
    CodecMap = class extends Map {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__KeyClass;
      __internal__ValClass;
      __internal__type;
      constructor(registry, keyType, valType, rawValue, type = "HashMap") {
        const [KeyClass, ValClass, decoded, decodedLength] = decodeMap(registry, keyType, valType, rawValue);
        super(type === "BTreeMap" ? sortMap(decoded) : decoded);
        this.registry = registry;
        this.initialU8aLength = decodedLength;
        this.__internal__KeyClass = KeyClass;
        this.__internal__ValClass = ValClass;
        this.__internal__type = type;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        let len = compactToU8a(this.size).length;
        for (const [k, v] of this.entries()) {
          len += k.encodedLength + v.encodedLength;
        }
        return len;
      }
      /**
       * @description Returns a hash of the value
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.size === 0;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return compareMap(this, other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        const inner = [];
        for (const [k, v] of this.entries()) {
          inner.push(k.inspect());
          inner.push(v.inspect());
        }
        return {
          inner,
          outer: [compactToU8a(this.size)]
        };
      }
      /**
       * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        const json = {};
        for (const [k, v] of this.entries()) {
          json[k instanceof Raw && !disableAscii && k.isAscii ? k.toUtf8() : k.toString()] = v.toHuman(isExtended, disableAscii);
        }
        return json;
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        const json = {};
        for (const [k, v] of this.entries()) {
          json[k.toString()] = v.toJSON();
        }
        return json;
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        const json = {};
        for (const [k, v] of this.entries()) {
          json[k instanceof Raw && !disableAscii && k.isAscii ? k.toUtf8() : k.toString()] = v.toPrimitive(disableAscii);
        }
        return json;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `${this.__internal__type}<${this.registry.getClassName(this.__internal__KeyClass) || new this.__internal__KeyClass(this.registry).toRawType()},${this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType()}>`;
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return stringify(this.toJSON());
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = [];
        if (!isBare) {
          encoded.push(compactToU8a(this.size));
        }
        for (const [k, v] of this.entries()) {
          encoded.push(k.toU8a(isBare), v.toU8a(isBare));
        }
        return u8aConcatStrict(encoded);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/BTreeMap.js
var BTreeMap;
var init_BTreeMap = __esm({
  "../../node_modules/@polkadot/types-codec/extended/BTreeMap.js"() {
    init_Map();
    BTreeMap = class _BTreeMap extends CodecMap {
      static with(keyType, valType) {
        return class extends _BTreeMap {
          constructor(registry, value) {
            super(registry, keyType, valType, value, "BTreeMap");
          }
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/BTreeSet.js
function decodeSetFromU8a(registry, ValClass, u8a) {
  const output = /* @__PURE__ */ new Set();
  const [offset, count] = compactFromU8aLim(u8a);
  const result = new Array(count);
  const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);
  for (let i2 = 0; i2 < count; i2++) {
    output.add(result[i2]);
  }
  return [ValClass, output, decodedLength];
}
function decodeSetFromSet(registry, ValClass, value) {
  const output = /* @__PURE__ */ new Set();
  value.forEach((val) => {
    try {
      output.add(val instanceof ValClass ? val : new ValClass(registry, val));
    } catch (error) {
      l7.error("Failed to decode key or value:", error.message);
      throw error;
    }
  });
  return [ValClass, output, 0];
}
function decodeSet(registry, valType, value) {
  const ValClass = typeToConstructor(registry, valType);
  if (!value) {
    return [ValClass, /* @__PURE__ */ new Set(), 0];
  } else if (isU8a(value) || isHex(value)) {
    return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));
  } else if (Array.isArray(value) || value instanceof Set) {
    return decodeSetFromSet(registry, ValClass, value);
  }
  throw new Error("BTreeSet: cannot decode type");
}
var l7, BTreeSet;
var init_BTreeSet = __esm({
  "../../node_modules/@polkadot/types-codec/extended/BTreeSet.js"() {
    init_util();
    init_utils4();
    l7 = logger("BTreeSet");
    BTreeSet = class _BTreeSet extends Set {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__ValClass;
      constructor(registry, valType, rawValue) {
        const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);
        super(sortSet(values));
        this.registry = registry;
        this.initialU8aLength = decodedLength;
        this.__internal__ValClass = ValClass;
      }
      static with(valType) {
        return class extends _BTreeSet {
          constructor(registry, value) {
            super(registry, valType, value);
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        let len = compactToU8a(this.size).length;
        for (const v of this.values()) {
          len += v.encodedLength;
        }
        return len;
      }
      /**
       * @description Returns a hash of the value
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.size === 0;
      }
      /**
       * @description The actual set values as a string[]
       */
      get strings() {
        return [...super.values()].map((v) => v.toString());
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return compareSet(this, other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        const inner = [];
        for (const v of this.values()) {
          inner.push(v.inspect());
        }
        return {
          inner,
          outer: [compactToU8a(this.size)]
        };
      }
      /**
       * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        const json = [];
        for (const v of this.values()) {
          json.push(v.toHuman(isExtended, disableAscii));
        }
        return json;
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        const json = [];
        for (const v of this.values()) {
          json.push(v.toJSON());
        }
        return json;
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `BTreeSet<${this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType()}>`;
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        const json = [];
        for (const v of this.values()) {
          json.push(v.toPrimitive(disableAscii));
        }
        return json;
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return stringify(this.toJSON());
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = [];
        if (!isBare) {
          encoded.push(compactToU8a(this.size));
        }
        for (const v of this.values()) {
          encoded.push(v.toU8a(isBare));
        }
        return u8aConcatStrict(encoded);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/Bytes.js
function decodeBytesU8a(value) {
  if (!value.length) {
    return [new Uint8Array(), 0];
  }
  const [offset, length] = compactFromU8aLim(value);
  const total = offset + length;
  if (length > MAX_LENGTH2) {
    throw new Error(`Bytes length ${length.toString()} exceeds ${MAX_LENGTH2}`);
  } else if (total > value.length) {
    throw new Error(`Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);
  }
  return [value.subarray(offset, total), total];
}
var MAX_LENGTH2, Bytes;
var init_Bytes = __esm({
  "../../node_modules/@polkadot/types-codec/extended/Bytes.js"() {
    init_util();
    init_Raw();
    MAX_LENGTH2 = 10 * 1024 * 1024;
    Bytes = class extends Raw {
      constructor(registry, value) {
        const [u8a, decodedLength] = isU8a(value) && !(value instanceof Raw) ? decodeBytesU8a(value) : Array.isArray(value) || isString(value) ? [u8aToU8a(value), 0] : [value, 0];
        super(registry, u8a, decodedLength);
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.length + compactToU8a(this.length).length;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect(isBare) {
        const clength = compactToU8a(this.length);
        return {
          outer: isBare ? [super.toU8a()] : this.length ? [clength, super.toU8a()] : [clength]
        };
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Bytes";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return isBare ? super.toU8a(isBare) : compactAddLength(this);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/HashMap.js
var HashMap;
var init_HashMap = __esm({
  "../../node_modules/@polkadot/types-codec/extended/HashMap.js"() {
    init_Map();
    HashMap = class _HashMap extends CodecMap {
      static with(keyType, valType) {
        return class extends _HashMap {
          constructor(registry, value) {
            super(registry, keyType, valType, value);
          }
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/native/Bool.js
var bool;
var init_Bool = __esm({
  "../../node_modules/@polkadot/types-codec/native/Bool.js"() {
    init_util();
    bool = class extends Boolean {
      registry;
      createdAtHash;
      initialU8aLength = 1;
      isStorageFallback;
      constructor(registry, value = false) {
        super(isU8a(value) ? value[0] === 1 : value instanceof Boolean ? value.valueOf() : !!value);
        this.registry = registry;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return 1 | 0;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value (true when it wraps false/default)
       */
      get isEmpty() {
        return this.isFalse;
      }
      /**
       * @description Checks if the value is an empty value (always false)
       */
      get isFalse() {
        return !this.isTrue;
      }
      /**
       * @description Checks if the value is an empty value (always false)
       */
      get isTrue() {
        return this.valueOf();
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return this.valueOf() === (other instanceof Boolean ? other.valueOf() : other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [this.toU8a()]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.valueOf();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toJSON();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "bool";
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.toJSON().toString();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return new Uint8Array([this.valueOf() ? 1 : 0]);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/OptionBool.js
function decodeU8a2(registry, value) {
  return value[0] === 0 ? null : new bool(registry, value[0] === 1);
}
var OptionBool;
var init_OptionBool = __esm({
  "../../node_modules/@polkadot/types-codec/extended/OptionBool.js"() {
    init_util();
    init_Option();
    init_Bool();
    OptionBool = class extends Option {
      constructor(registry, value) {
        super(registry, bool, isU8a(value) || isHex(value) ? decodeU8a2(registry, u8aToU8a(value)) : value);
        this.initialU8aLength = 1;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return 1 | 0;
      }
      /**
       * @description Checks if the value is an empty value (always false)
       */
      get isFalse() {
        return this.isSome ? !this.value.valueOf() : false;
      }
      /**
       * @description Checks if the value is an empty value (always false)
       */
      get isTrue() {
        return this.isSome ? this.value.valueOf() : false;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return { outer: [this.toU8a()] };
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType(isBare) {
        return isBare ? "bool" : "Option<bool>";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        if (isBare) {
          return super.toU8a(true);
        }
        return this.isSome ? new Uint8Array([this.isTrue ? 1 : 2]) : new Uint8Array([0]);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/Range.js
var Range;
var init_Range = __esm({
  "../../node_modules/@polkadot/types-codec/extended/Range.js"() {
    init_Tuple();
    Range = class _Range extends Tuple {
      __internal__rangeName;
      constructor(registry, Type2, value, { rangeName = "Range" } = {}) {
        super(registry, [Type2, Type2], value);
        this.__internal__rangeName = rangeName;
      }
      static with(Type2) {
        return class extends _Range {
          constructor(registry, value) {
            super(registry, Type2, value);
          }
        };
      }
      /**
       * @description Returns the starting range value
       */
      get start() {
        return this[0];
      }
      /**
       * @description Returns the ending range value
       */
      get end() {
        return this[1];
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `${this.__internal__rangeName}<${this.start.toRawType()}>`;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/RangeInclusive.js
var RangeInclusive;
var init_RangeInclusive = __esm({
  "../../node_modules/@polkadot/types-codec/extended/RangeInclusive.js"() {
    init_Range();
    RangeInclusive = class _RangeInclusive extends Range {
      constructor(registry, Type2, value) {
        super(registry, Type2, value, { rangeName: "RangeInclusive" });
      }
      static with(Type2) {
        return class extends _RangeInclusive {
          constructor(registry, value) {
            super(registry, Type2, value);
          }
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/native/Text.js
function decodeText(value) {
  if (isU8a(value)) {
    if (!value.length) {
      return ["", 0];
    }
    if (value instanceof Raw) {
      return [u8aToString(value), 0];
    }
    const [offset, length] = compactFromU8aLim(value);
    const total = offset + length;
    if (length > MAX_LENGTH3) {
      throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH3}`);
    } else if (total > value.length) {
      throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);
    }
    return [u8aToString(value.subarray(offset, total)), total];
  } else if (isHex(value)) {
    return [u8aToString(hexToU8a(value)), 0];
  }
  return [value ? value.toString() : "", 0];
}
var MAX_LENGTH3, Text;
var init_Text = __esm({
  "../../node_modules/@polkadot/types-codec/native/Text.js"() {
    init_util();
    init_Raw();
    MAX_LENGTH3 = 128 * 1024;
    Text = class extends String {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__override = null;
      constructor(registry, value) {
        const [str, decodedLength] = decodeText(value);
        super(str);
        this.registry = registry;
        this.initialU8aLength = decodedLength;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return this.length === 0;
      }
      /**
       * @description The length of the value
       */
      get length() {
        return super.length;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return isString(other) ? this.toString() === other.toString() : false;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        const value = stringToU8a(super.toString());
        return {
          outer: value.length ? [compactToU8a(value.length), value] : [compactToU8a(value.length)]
        };
      }
      /**
       * @description Set an override value for this
       */
      setOverride(override) {
        this.__internal__override = override;
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a(true));
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toString();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toJSON();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Text";
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.__internal__override || super.toString();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = stringToU8a(super.toString());
        return isBare ? encoded : compactAddLength(encoded);
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/Type.js
var Type;
var init_Type = __esm({
  "../../node_modules/@polkadot/types-codec/extended/Type.js"() {
    init_Text();
    init_utils4();
    Type = class extends Text {
      constructor(registry, value = "") {
        super(registry, value);
        this.setOverride(sanitize(this.toString()));
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Type";
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/U8aFixed.js
function decodeU8aFixed(value, bitLength) {
  const u8a = u8aToU8a(value);
  const byteLength = bitLength / 8;
  if (!u8a.length) {
    return [new Uint8Array(byteLength), 0];
  }
  if (isU8a(value) ? u8a.length < byteLength : u8a.length !== byteLength) {
    throw new Error(`Expected input with ${byteLength} bytes (${bitLength} bits), found ${u8a.length} bytes`);
  }
  return [u8a.subarray(0, byteLength), byteLength];
}
var U8aFixed;
var init_U8aFixed = __esm({
  "../../node_modules/@polkadot/types-codec/extended/U8aFixed.js"() {
    init_util();
    init_Raw();
    U8aFixed = class _U8aFixed extends Raw {
      constructor(registry, value = new Uint8Array(), bitLength = 256) {
        const [u8a, decodedLength] = decodeU8aFixed(value, bitLength);
        super(registry, u8a, decodedLength);
      }
      static with(bitLength, typeName) {
        return class extends _U8aFixed {
          constructor(registry, value) {
            super(registry, value, bitLength);
          }
          toRawType() {
            return typeName || super.toRawType();
          }
        };
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `[u8;${this.length}]`;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/WrapperKeepOpaque.js
function decodeRaw(registry, typeName, value) {
  const Type2 = typeToConstructor(registry, typeName);
  if (isU8a(value) || isHex(value)) {
    try {
      const [, u8a] = isHex(value) ? [0, u8aToU8a(value)] : value instanceof Raw ? [0, value.subarray()] : compactStripLength(value);
      return [Type2, new Type2(registry, u8a), value];
    } catch {
      return [Type2, null, value];
    }
  }
  const instance = new Type2(registry, value);
  return [Type2, instance, compactAddLength(instance.toU8a())];
}
var WrapperKeepOpaque;
var init_WrapperKeepOpaque = __esm({
  "../../node_modules/@polkadot/types-codec/extended/WrapperKeepOpaque.js"() {
    init_util();
    init_Raw();
    init_utils4();
    init_Bytes();
    WrapperKeepOpaque = class _WrapperKeepOpaque extends Bytes {
      __internal__Type;
      __internal__decoded;
      __internal__opaqueName;
      constructor(registry, typeName, value, { opaqueName = "WrapperKeepOpaque" } = {}) {
        const [Type2, decoded, u8a] = decodeRaw(registry, typeName, value);
        super(registry, u8a);
        this.__internal__Type = Type2;
        this.__internal__decoded = decoded;
        this.__internal__opaqueName = opaqueName;
      }
      static with(Type2) {
        return class extends _WrapperKeepOpaque {
          constructor(registry, value) {
            super(registry, Type2, value);
          }
        };
      }
      /**
       * @description Checks if the wrapper is decodable
       */
      get isDecoded() {
        return !!this.__internal__decoded;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return this.__internal__decoded ? {
          inner: [this.__internal__decoded.inspect()],
          outer: [compactToU8a(this.length)]
        } : {
          outer: [compactToU8a(this.length), this.toU8a(true)]
        };
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        return this.__internal__decoded ? this.__internal__decoded.toHuman(isExtended, disableAscii) : super.toHuman(isExtended, disableAscii);
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        return this.__internal__decoded ? this.__internal__decoded.toPrimitive(disableAscii) : super.toPrimitive(disableAscii);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `${this.__internal__opaqueName}<${this.registry.getClassName(this.__internal__Type) || (this.__internal__decoded ? this.__internal__decoded.toRawType() : new this.__internal__Type(this.registry).toRawType())}>`;
      }
      /**
       * @description Converts the Object to to a string (either decoded or bytes)
       */
      toString() {
        return this.__internal__decoded ? this.__internal__decoded.toString() : super.toString();
      }
      /**
       * @description Returns the decoded that the WrapperKeepOpaque represents (if available), throws if non-decodable
       */
      unwrap() {
        if (!this.__internal__decoded) {
          throw new Error(`${this.__internal__opaqueName}: unwrapping an undecodable value`);
        }
        return this.__internal__decoded;
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/WrapperOpaque.js
var WrapperOpaque;
var init_WrapperOpaque = __esm({
  "../../node_modules/@polkadot/types-codec/extended/WrapperOpaque.js"() {
    init_WrapperKeepOpaque();
    WrapperOpaque = class _WrapperOpaque extends WrapperKeepOpaque {
      constructor(registry, typeName, value) {
        super(registry, typeName, value, { opaqueName: "WrapperOpaque" });
      }
      static with(Type2) {
        return class extends _WrapperOpaque {
          constructor(registry, value) {
            super(registry, Type2, value);
          }
        };
      }
      /**
       * @description The inner value for this wrapper, in all cases it _should_ be decodable (unlike KeepOpaque)
       */
      get inner() {
        return this.unwrap();
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/extended/index.js
var init_extended = __esm({
  "../../node_modules/@polkadot/types-codec/extended/index.js"() {
    init_BitVec();
    init_BTreeMap();
    init_BTreeSet();
    init_Bytes();
    init_HashMap();
    init_OptionBool();
    init_Range();
    init_RangeInclusive();
    init_Type();
    init_U8aFixed();
    init_WrapperKeepOpaque();
    init_WrapperOpaque();
  }
});

// ../../node_modules/@polkadot/types-codec/native/Float.js
var Float;
var init_Float = __esm({
  "../../node_modules/@polkadot/types-codec/native/Float.js"() {
    init_util();
    Float = class _Float extends Number {
      encodedLength;
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__bitLength;
      constructor(registry, value, { bitLength = 32 } = {}) {
        super(isU8a(value) || isHex(value) ? value.length === 0 ? 0 : u8aToFloat(u8aToU8a(value), { bitLength }) : value || 0);
        this.__internal__bitLength = bitLength;
        this.encodedLength = bitLength / 8;
        this.initialU8aLength = this.encodedLength;
        this.registry = registry;
      }
      static with(bitLength) {
        return class extends _Float {
          constructor(registry, value) {
            super(registry, value, { bitLength });
          }
        };
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Returns true if the type wraps an empty/default all-0 value
       */
      get isEmpty() {
        return this.valueOf() === 0;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return this.valueOf() === Number(other);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [this.toU8a()]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toString();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toHex();
      }
      /**
       * @description Returns the number representation (Same as valueOf)
       */
      toNumber() {
        return this.valueOf();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toNumber();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return `f${this.__internal__bitLength}`;
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return floatToU8a(this, {
          bitLength: this.__internal__bitLength
        });
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/native/Json.js
function decodeJson(value) {
  return Object.entries(value || {});
}
var Json;
var init_Json = __esm({
  "../../node_modules/@polkadot/types-codec/native/Json.js"() {
    init_util();
    init_utils4();
    Json = class extends Map {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      constructor(registry, value) {
        const decoded = decodeJson(value);
        super(decoded);
        this.registry = registry;
        objectProperties(this, decoded.map(([k]) => k), (k) => this.get(k));
      }
      /**
       * @description Always 0, never encodes as a Uint8Array
       */
      get encodedLength() {
        return 0 | 0;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description Checks if the value is an empty value
       */
      get isEmpty() {
        return [...this.keys()].length === 0;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return compareMap(this, other);
      }
      /**
       * @description Returns a typed value from the internal map
       */
      getT(key) {
        return this.get(key);
      }
      /**
       * @description Unimplemented, will throw
       */
      inspect() {
        throw new Error("Unimplemented");
      }
      /**
       * @description Unimplemented, will throw
       */
      toHex() {
        throw new Error("Unimplemented");
      }
      /**
       * @description Converts the Object to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return [...this.entries()].reduce((json, [key, value]) => {
          json[key] = isFunction(value?.toHuman) ? value.toHuman() : value;
          return json;
        }, {});
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return [...this.entries()].reduce((json, [key, value]) => {
          json[key] = value;
          return json;
        }, {});
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive(disableAscii) {
        return [...this.entries()].reduce((json, [key, value]) => {
          json[key] = isFunction(value.toPrimitive) ? value.toPrimitive(disableAscii) : value;
          return json;
        }, {});
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Json";
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return stringify(this.toJSON());
      }
      /**
       * @description Unimplemented, will throw
       */
      toU8a(_isBare) {
        throw new Error("Unimplemented");
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/native/Set.js
function encodeSet(setValues, values) {
  const encoded = new import_bn.default(0);
  for (let i2 = 0, count = values.length; i2 < count; i2++) {
    encoded.ior(bnToBn(setValues[values[i2]] || 0));
  }
  return encoded;
}
function decodeSetArray(setValues, values) {
  const count = values.length;
  const result = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const key = values[i2];
    if (isUndefined(setValues[key])) {
      throw new Error(`Set: Invalid key '${key}' passed to Set, allowed ${Object.keys(setValues).join(", ")}`);
    }
    result[i2] = key;
  }
  return result;
}
function decodeSetNumber(setValues, _value) {
  const bn = bnToBn(_value);
  const keys2 = Object.keys(setValues);
  const result = [];
  for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
    const key = keys2[i2];
    if (bn.and(bnToBn(setValues[key])).eq(bnToBn(setValues[key]))) {
      result.push(key);
    }
  }
  const computed = encodeSet(setValues, result);
  if (!bn.eq(computed)) {
    throw new Error(`Set: Mismatch decoding '${bn.toString()}', computed as '${computed.toString()}' with ${result.join(", ")}`);
  }
  return result;
}
function decodeSet2(setValues, value = 0, bitLength) {
  if (bitLength % 8 !== 0) {
    throw new Error(`Expected valid bitLength, power of 8, found ${bitLength}`);
  }
  const byteLength = bitLength / 8;
  if (isU8a(value)) {
    return value.length === 0 ? [] : decodeSetNumber(setValues, u8aToBn(value.subarray(0, byteLength), { isLe: true }));
  } else if (isString(value)) {
    return decodeSet2(setValues, u8aToU8a(value), byteLength);
  } else if (value instanceof Set || Array.isArray(value)) {
    const input = Array.isArray(value) ? value : [...value.values()];
    return decodeSetArray(setValues, input);
  }
  return decodeSetNumber(setValues, value);
}
var CodecSet;
var init_Set = __esm({
  "../../node_modules/@polkadot/types-codec/native/Set.js"() {
    init_util();
    init_utils4();
    CodecSet = class _CodecSet extends Set {
      registry;
      createdAtHash;
      initialU8aLength;
      isStorageFallback;
      __internal__allowed;
      __internal__byteLength;
      constructor(registry, setValues, value, bitLength = 8) {
        super(decodeSet2(setValues, value, bitLength));
        this.registry = registry;
        this.__internal__allowed = setValues;
        this.__internal__byteLength = bitLength / 8;
      }
      static with(values, bitLength) {
        return class extends _CodecSet {
          static {
            const keys2 = Object.keys(values);
            const count = keys2.length;
            const isKeys = new Array(count);
            for (let i2 = 0; i2 < count; i2++) {
              isKeys[i2] = `is${stringPascalCase(keys2[i2])}`;
            }
            objectProperties(this.prototype, isKeys, (_, i2, self2) => self2.strings.includes(keys2[i2]));
          }
          constructor(registry, value) {
            super(registry, values, value, bitLength);
          }
        };
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.__internal__byteLength;
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description true is the Set contains no values
       */
      get isEmpty() {
        return this.size === 0;
      }
      /**
       * @description The actual set values as a string[]
       */
      get strings() {
        return [...super.values()];
      }
      /**
       * @description The encoded value for the set members
       */
      get valueEncoded() {
        return encodeSet(this.__internal__allowed, this.strings);
      }
      /**
       * @description adds a value to the Set (extended to allow for validity checking)
       */
      add = (key) => {
        if (this.__internal__allowed && isUndefined(this.__internal__allowed[key])) {
          throw new Error(`Set: Invalid key '${key}' on add`);
        }
        super.add(key);
        return this;
      };
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        if (Array.isArray(other)) {
          return compareArray(this.strings.sort(), other.sort());
        } else if (other instanceof Set) {
          return this.eq([...other.values()]);
        } else if (isNumber(other) || isBn(other)) {
          return this.valueEncoded.eq(bnToBn(other));
        }
        return false;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return {
          outer: [this.toU8a()]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.strings;
      }
      /**
       * @description The encoded value for the set members
       */
      toNumber() {
        return this.valueEncoded.toNumber();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toJSON();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return stringify({ _set: this.__internal__allowed });
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return `[${this.strings.join(", ")}]`;
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a(_isBare) {
        return bnToU8a(this.valueEncoded, {
          bitLength: this.__internal__byteLength * 8,
          isLe: true
        });
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/native/index.js
var init_native = __esm({
  "../../node_modules/@polkadot/types-codec/native/index.js"() {
    init_Bool();
    init_Json();
    init_Raw();
    init_Set();
    init_Struct();
    init_Text();
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/F32.js
var f32;
var init_F32 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/F32.js"() {
    init_Float();
    f32 = class extends Float.with(32) {
      // NOTE without this, we cannot properly determine extensions
      __FloatType = "f32";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/F64.js
var f64;
var init_F64 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/F64.js"() {
    init_Float();
    f64 = class extends Float.with(64) {
      // NOTE without this, we cannot properly determine extensions
      __FloatType = "f64";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/I8.js
var i8;
var init_I8 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/I8.js"() {
    init_Int2();
    i8 = class extends Int.with(8) {
      // NOTE without this, we cannot properly determine extensions
      __IntType = "i8";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/I16.js
var i16;
var init_I16 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/I16.js"() {
    init_Int2();
    i16 = class extends Int.with(16) {
      // NOTE without this, we cannot properly determine extensions
      __IntType = "i16";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/I32.js
var i32;
var init_I32 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/I32.js"() {
    init_Int2();
    i32 = class extends Int.with(32) {
      // NOTE without this, we cannot properly determine extensions
      __IntType = "i32";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/I64.js
var i64;
var init_I64 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/I64.js"() {
    init_Int2();
    i64 = class extends Int.with(64) {
      // NOTE without this, we cannot properly determine extensions
      __IntType = "i64";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/I128.js
var i128;
var init_I128 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/I128.js"() {
    init_Int2();
    i128 = class extends Int.with(128) {
      // NOTE without this, we cannot properly determine extensions
      __IntType = "i128";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/I256.js
var i256;
var init_I256 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/I256.js"() {
    init_Int2();
    i256 = class extends Int.with(256) {
      // NOTE without this, we cannot properly determine extensions
      __IntType = "i256";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/ISize.js
var isize;
var init_ISize = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/ISize.js"() {
    init_I32();
    isize = class extends i32 {
      constructor(registry, value) {
        super(registry, value);
        throw new Error("The `isize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally i64) and WASM (always i32) code. Use one of the `i32` or `i64` types explicitly.");
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/U8.js
var u82;
var init_U8 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/U8.js"() {
    init_UInt();
    u82 = class extends UInt.with(8) {
      // NOTE without this, we cannot properly determine extensions
      __UIntType = "u8";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/U16.js
var u162;
var init_U16 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/U16.js"() {
    init_UInt();
    u162 = class extends UInt.with(16) {
      // NOTE without this, we cannot properly determine extensions
      __UIntType = "u16";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/U32.js
var u323;
var init_U32 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/U32.js"() {
    init_UInt();
    u323 = class extends UInt.with(32) {
      // NOTE without this, we cannot properly determine extensions
      __UIntType = "u32";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/U64.js
var u643;
var init_U64 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/U64.js"() {
    init_UInt();
    u643 = class extends UInt.with(64) {
      // NOTE without this, we cannot properly determine extensions
      __UIntType = "u64";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/U128.js
var u128;
var init_U128 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/U128.js"() {
    init_UInt();
    u128 = class extends UInt.with(128) {
      // NOTE without this, we cannot properly determine extensions
      __UIntType = "u128";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/U256.js
var u256;
var init_U256 = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/U256.js"() {
    init_UInt();
    u256 = class extends UInt.with(256) {
      // NOTE without this, we cannot properly determine extensions
      __UIntType = "u256";
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/USize.js
var usize;
var init_USize = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/USize.js"() {
    init_U32();
    usize = class extends u323 {
      constructor(registry, value) {
        super(registry, value);
        throw new Error("The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.");
      }
    };
  }
});

// ../../node_modules/@polkadot/types-codec/primitive/index.js
var init_primitive = __esm({
  "../../node_modules/@polkadot/types-codec/primitive/index.js"() {
    init_F32();
    init_F64();
    init_I8();
    init_I16();
    init_I32();
    init_I64();
    init_I128();
    init_I256();
    init_ISize();
    init_U8();
    init_U16();
    init_U32();
    init_U64();
    init_U128();
    init_U256();
    init_USize();
  }
});

// ../../node_modules/@polkadot/types-codec/bundle.js
var init_bundle9 = __esm({
  "../../node_modules/@polkadot/types-codec/bundle.js"() {
    init_abstract();
    init_base2();
    init_extended();
    init_native();
    init_primitive();
    init_utils4();
  }
});

// ../../node_modules/@polkadot/types-codec/index.js
var init_types_codec = __esm({
  "../../node_modules/@polkadot/types-codec/index.js"() {
    init_packageDetect14();
    init_bundle9();
  }
});

// ../../node_modules/@polkadot/types-create/util/typeSplit.js
function typeSplit(type) {
  const result = [];
  let c = 0;
  let f3 = 0;
  let s2 = 0;
  let t2 = 0;
  let start = 0;
  for (let i2 = 0, count = type.length; i2 < count; i2++) {
    switch (type[i2]) {
      // if we are not nested, add the type
      case ",": {
        if (!(c || f3 || s2 || t2)) {
          result.push(type.substring(start, i2).trim());
          start = i2 + 1;
        }
        break;
      }
      // adjust compact/vec (and friends) depth
      case "<":
        c++;
        break;
      case ">":
        c--;
        break;
      // adjust fixed vec depths
      case "[":
        f3++;
        break;
      case "]":
        f3--;
        break;
      // adjust struct depth
      case "{":
        s2++;
        break;
      case "}":
        s2--;
        break;
      // adjust tuple depth
      case "(":
        t2++;
        break;
      case ")":
        t2--;
        break;
    }
  }
  if (c || f3 || s2 || t2) {
    throw new Error(`Invalid definition (missing terminators) found in ${type}`);
  }
  result.push(type.substring(start, type.length).trim());
  return result;
}
var init_typeSplit = __esm({
  "../../node_modules/@polkadot/types-create/util/typeSplit.js"() {
  }
});

// ../../node_modules/@polkadot/types-create/util/getTypeDef.js
function getTypeString(typeOrObj) {
  return isString(typeOrObj) ? typeOrObj.toString() : stringify(typeOrObj);
}
function isRustEnum2(details) {
  const values = Object.values(details);
  if (values.some((v) => isNumber(v))) {
    if (!values.every((v) => isNumber(v) && v >= 0 && v <= 255)) {
      throw new Error("Invalid number-indexed enum definition");
    }
    return false;
  }
  return true;
}
function _decodeEnum(value, details, count, fallbackType) {
  value.info = TypeDefInfo.Enum;
  value.fallbackType = fallbackType;
  if (Array.isArray(details)) {
    value.sub = details.map((name, index) => ({
      index,
      info: TypeDefInfo.Plain,
      name,
      type: "Null"
    }));
  } else if (isRustEnum2(details)) {
    value.sub = Object.entries(details).map(([name, typeOrObj], index) => objectSpread({}, getTypeDef(getTypeString(typeOrObj || "Null"), { name }, count), { index }));
  } else {
    value.sub = Object.entries(details).map(([name, index]) => ({
      index,
      info: TypeDefInfo.Plain,
      name,
      type: "Null"
    }));
  }
  return value;
}
function _decodeSet(value, details, fallbackType) {
  value.info = TypeDefInfo.Set;
  value.fallbackType = fallbackType;
  value.length = details._bitLength;
  value.sub = Object.entries(details).filter(([name]) => !name.startsWith("_")).map(([name, index]) => ({
    index,
    info: TypeDefInfo.Plain,
    name,
    type: "Null"
  }));
  return value;
}
function _decodeStruct(value, type, _, count) {
  const parsed = JSON.parse(type);
  const keys2 = Object.keys(parsed);
  if (parsed._enum) {
    return _decodeEnum(value, parsed._enum, count, parsed._fallback);
  } else if (parsed._set) {
    return _decodeSet(value, parsed._set, parsed._fallback);
  }
  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : void 0;
  value.fallbackType = parsed._fallback;
  value.sub = keys2.filter((name) => !KNOWN_INTERNALS.includes(name)).map((name) => getTypeDef(getTypeString(parsed[name]), { name }, count));
  return value;
}
function _decodeFixedVec(value, type, _, count) {
  const max2 = type.length - 1;
  let index = -1;
  let inner = 0;
  for (let i2 = 1; i2 < max2 && index === -1; i2++) {
    switch (type[i2]) {
      case ";": {
        if (inner === 0) {
          index = i2;
        }
        break;
      }
      case "[":
      case "(":
      case "<":
        inner++;
        break;
      case "]":
      case ")":
      case ">":
        inner--;
        break;
    }
  }
  if (index === -1) {
    throw new Error(`${type}: Unable to extract location of ';'`);
  }
  const vecType = type.substring(1, index);
  const [strLength, displayName] = type.substring(index + 1, max2).split(";");
  const length = parseInt(strLength.trim(), 10);
  if (length > 2048) {
    throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);
  }
  value.displayName = displayName;
  value.length = length;
  value.sub = getTypeDef(vecType, {}, count);
  return value;
}
function _decodeTuple(value, _, subType, count) {
  value.sub = subType.length === 0 ? [] : typeSplit(subType).map((inner) => getTypeDef(inner, {}, count));
  return value;
}
function _decodeAnyInt(value, type, _, clazz) {
  const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(",");
  const length = parseInt(strLength.trim(), 10);
  if (length > 8192 || length % 8) {
    throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);
  }
  value.displayName = displayName;
  value.length = length;
  return value;
}
function _decodeInt(value, type, subType) {
  return _decodeAnyInt(value, type, subType, "Int");
}
function _decodeUInt(value, type, subType) {
  return _decodeAnyInt(value, type, subType, "UInt");
}
function _decodeDoNotConstruct(value, type, _) {
  const NAME_LENGTH = "DoNotConstruct".length;
  value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);
  return value;
}
function hasWrapper(type, [start, end]) {
  return type.startsWith(start) && type.slice(-1 * end.length) === end;
}
function extractSubType(type, [start, end]) {
  return type.substring(start.length, type.length - end.length);
}
function getTypeDef(_type, { displayName, name } = {}, count = 0) {
  const type = sanitize(_type);
  const value = { displayName, info: TypeDefInfo.Plain, name, type };
  if (++count > 64) {
    throw new Error("getTypeDef: Maximum nested limit reached");
  }
  const nested = nestedExtraction.find((nested2) => hasWrapper(type, nested2));
  if (nested) {
    value.info = nested[2];
    return nested[3](value, type, extractSubType(type, nested), count);
  }
  const wrapped = wrappedExtraction.find((wrapped2) => hasWrapper(type, wrapped2));
  if (wrapped) {
    value.info = wrapped[2];
    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);
  }
  return value;
}
var KNOWN_INTERNALS, nestedExtraction, wrappedExtraction;
var init_getTypeDef = __esm({
  "../../node_modules/@polkadot/types-create/util/getTypeDef.js"() {
    init_types_codec();
    init_util();
    init_types2();
    init_typeSplit();
    KNOWN_INTERNALS = ["_alias", "_fallback"];
    nestedExtraction = [
      ["[", "]", TypeDefInfo.VecFixed, _decodeFixedVec],
      ["{", "}", TypeDefInfo.Struct, _decodeStruct],
      ["(", ")", TypeDefInfo.Tuple, _decodeTuple],
      // the inner for these are the same as tuple, multiple values
      ["BTreeMap<", ">", TypeDefInfo.BTreeMap, _decodeTuple],
      ["HashMap<", ">", TypeDefInfo.HashMap, _decodeTuple],
      ["Int<", ">", TypeDefInfo.Int, _decodeInt],
      ["Result<", ">", TypeDefInfo.Result, _decodeTuple],
      ["UInt<", ">", TypeDefInfo.UInt, _decodeUInt],
      ["DoNotConstruct<", ">", TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]
    ];
    wrappedExtraction = [
      ["BTreeSet<", ">", TypeDefInfo.BTreeSet],
      ["Compact<", ">", TypeDefInfo.Compact],
      ["Linkage<", ">", TypeDefInfo.Linkage],
      ["Opaque<", ">", TypeDefInfo.WrapperOpaque],
      ["Option<", ">", TypeDefInfo.Option],
      ["Range<", ">", TypeDefInfo.Range],
      ["RangeInclusive<", ">", TypeDefInfo.RangeInclusive],
      ["Vec<", ">", TypeDefInfo.Vec],
      ["WrapperKeepOpaque<", ">", TypeDefInfo.WrapperKeepOpaque],
      ["WrapperOpaque<", ">", TypeDefInfo.WrapperOpaque]
    ];
  }
});

// ../../node_modules/@polkadot/types-create/create/class.js
function getTypeDefType({ lookupName, type }) {
  return lookupName || type;
}
function getSubDefArray(value) {
  if (!Array.isArray(value.sub)) {
    throw new Error(`Expected subtype as TypeDef[] in ${stringify(value)}`);
  }
  return value.sub;
}
function getSubDef(value) {
  if (!value.sub || Array.isArray(value.sub)) {
    throw new Error(`Expected subtype as TypeDef in ${stringify(value)}`);
  }
  return value.sub;
}
function getSubType(value) {
  return getTypeDefType(getSubDef(value));
}
function getTypeClassMap(value) {
  const subs = getSubDefArray(value);
  const map79 = {};
  for (let i2 = 0, count = subs.length; i2 < count; i2++) {
    const sub = subs[i2];
    if (!sub.name) {
      throw new Error(`No name found in definition ${stringify(sub)}`);
    }
    map79[sub.name] = getTypeDefType(sub);
  }
  return map79;
}
function getTypeClassArray(value) {
  return getSubDefArray(value).map(getTypeDefType);
}
function createInt(Clazz, { displayName, length }) {
  if (!isNumber(length)) {
    throw new Error(`Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
  }
  return Clazz.with(length, displayName);
}
function createHashMap(Clazz, value) {
  const [keyType, valueType] = getTypeClassArray(value);
  return Clazz.with(keyType, valueType);
}
function createWithSub(Clazz, value) {
  return Clazz.with(getSubType(value));
}
function constructTypeClass(registry, typeDef) {
  try {
    const Type2 = infoMapping[typeDef.info](registry, typeDef);
    if (!Type2) {
      throw new Error("No class created");
    }
    if (!Type2.__fallbackType && typeDef.fallbackType) {
      Type2.__fallbackType = typeDef.fallbackType;
    }
    return Type2;
  } catch (error) {
    throw new Error(`Unable to construct class from ${stringify(typeDef)}: ${error.message}`);
  }
}
function getTypeClass(registry, typeDef) {
  return registry.getUnsafe(typeDef.type, false, typeDef);
}
function createClassUnsafe(registry, type) {
  return (
    // just retrieve via name, no creation via typeDef
    registry.getUnsafe(type) || // we don't have an existing type, create the class via typeDef
    getTypeClass(registry, registry.isLookupType(type) ? registry.lookup.getTypeDef(type) : getTypeDef(type))
  );
}
var infoMapping;
var init_class2 = __esm({
  "../../node_modules/@polkadot/types-create/create/class.js"() {
    init_types_codec();
    init_util();
    init_types2();
    init_getTypeDef();
    infoMapping = {
      [TypeDefInfo.BTreeMap]: (_registry, value) => createHashMap(BTreeMap, value),
      [TypeDefInfo.BTreeSet]: (_registry, value) => createWithSub(BTreeSet, value),
      [TypeDefInfo.Compact]: (_registry, value) => createWithSub(Compact, value),
      [TypeDefInfo.DoNotConstruct]: (_registry, value) => DoNotConstruct.with(value.displayName || value.type),
      [TypeDefInfo.Enum]: (_registry, value) => {
        const subs = getSubDefArray(value);
        return Enum.with(subs.every(({ type }) => type === "Null") ? subs.reduce((out, { index, name }, count) => {
          if (!name) {
            throw new Error("No name found in sub definition");
          }
          out[name] = index || count;
          return out;
        }, {}) : getTypeClassMap(value));
      },
      [TypeDefInfo.HashMap]: (_registry, value) => createHashMap(HashMap, value),
      [TypeDefInfo.Int]: (_registry, value) => createInt(Int, value),
      // We have circular deps between Linkage & Struct
      [TypeDefInfo.Linkage]: (_registry, value) => {
        const type = `Option<${getSubType(value)}>`;
        const Clazz = Struct.with({ previous: type, next: type });
        Clazz.prototype.toRawType = function() {
          return `Linkage<${this.next.toRawType(true)}>`;
        };
        return Clazz;
      },
      [TypeDefInfo.Null]: (_registry, _value) => Null,
      [TypeDefInfo.Option]: (_registry, value) => {
        if (!value.sub || Array.isArray(value.sub)) {
          throw new Error("Expected type information for Option");
        }
        return createWithSub(Option, value);
      },
      [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),
      [TypeDefInfo.Range]: (_registry, value) => createWithSub(Range, value),
      [TypeDefInfo.RangeInclusive]: (_registry, value) => createWithSub(RangeInclusive, value),
      [TypeDefInfo.Result]: (_registry, value) => {
        const [Ok, Err] = getTypeClassArray(value);
        return Result.with({ Err, Ok });
      },
      [TypeDefInfo.Set]: (_registry, value) => CodecSet.with(getSubDefArray(value).reduce((result, { index, name }) => {
        if (!name || !isNumber(index)) {
          throw new Error("No name found in sub definition");
        }
        result[name] = index;
        return result;
      }, {}), value.length),
      [TypeDefInfo.Si]: (registry, value) => getTypeClass(registry, registry.lookup.getTypeDef(value.type)),
      [TypeDefInfo.Struct]: (_registry, value) => Struct.with(getTypeClassMap(value), value.alias),
      [TypeDefInfo.Tuple]: (_registry, value) => Tuple.with(getTypeClassArray(value)),
      [TypeDefInfo.UInt]: (_registry, value) => createInt(UInt, value),
      [TypeDefInfo.Vec]: (_registry, { sub }) => {
        if (!sub || Array.isArray(sub)) {
          throw new Error("Expected type information for vector");
        }
        return sub.type === "u8" ? Bytes : Vec.with(getTypeDefType(sub));
      },
      [TypeDefInfo.VecFixed]: (_registry, { displayName, length, sub }) => {
        if (!isNumber(length) || !sub || Array.isArray(sub)) {
          throw new Error("Expected length & type information for fixed vector");
        }
        return sub.type === "u8" ? U8aFixed.with(length * 8, displayName) : VecFixed.with(getTypeDefType(sub), length);
      },
      [TypeDefInfo.WrapperKeepOpaque]: (_registry, value) => createWithSub(WrapperKeepOpaque, value),
      [TypeDefInfo.WrapperOpaque]: (_registry, value) => createWithSub(WrapperOpaque, value)
    };
  }
});

// ../../node_modules/@polkadot/types-create/create/type.js
function checkInstance(created, matcher) {
  const u8a = created.toU8a();
  const rawType = created.toRawType();
  const isOk = (
    // full match, all ok
    u8aEq(u8a, matcher) || // on a length-prefixed type, just check the actual length
    ["Bytes", "Text", "Type"].includes(rawType) && matcher.length === created.length || // when the created is empty and matcher is also empty, let it slide...
    created.isEmpty && matcher.every((v) => !v)
  );
  if (!isOk) {
    throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);
  }
}
function checkPedantic(created, [value]) {
  if (isU8a(value)) {
    checkInstance(created, value);
  } else if (isHex(value)) {
    checkInstance(created, u8aToU8a(value));
  }
}
function initType(registry, Type2, params = [], { blockHash, isFallback, isOptional, isPedantic } = {}) {
  const created = new (isOptional ? Option.with(Type2) : Type2)(registry, ...params);
  isPedantic && checkPedantic(created, params);
  if (blockHash) {
    created.createdAtHash = createTypeUnsafe(registry, "BlockHash", [blockHash]);
  }
  if (isFallback) {
    created.isStorageFallback = true;
  }
  return created;
}
function createTypeUnsafe(registry, type, params = [], options = {}) {
  let Clazz = null;
  let firstError = null;
  try {
    Clazz = createClassUnsafe(registry, type);
    return initType(registry, Clazz, params, options);
  } catch (error) {
    firstError = new Error(`createType(${type}):: ${error.message}`);
  }
  if (Clazz?.__fallbackType) {
    try {
      Clazz = createClassUnsafe(registry, Clazz.__fallbackType);
      return initType(registry, Clazz, params, options);
    } catch {
    }
  }
  throw firstError;
}
var init_type = __esm({
  "../../node_modules/@polkadot/types-create/create/type.js"() {
    init_types_codec();
    init_util();
    init_class2();
  }
});

// ../../node_modules/@polkadot/types-create/create/index.js
var init_create = __esm({
  "../../node_modules/@polkadot/types-create/create/index.js"() {
    init_class2();
    init_type();
  }
});

// ../../node_modules/@polkadot/types-create/util/encodeTypes.js
function paramsNotation(outer, inner, transform = stringIdentity) {
  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(", ")}>` : ""}`;
}
function encodeWithParams(registry, typeDef, outer) {
  const { info: info6, sub } = typeDef;
  switch (info6) {
    case TypeDefInfo.BTreeMap:
    case TypeDefInfo.BTreeSet:
    case TypeDefInfo.Compact:
    case TypeDefInfo.HashMap:
    case TypeDefInfo.Linkage:
    case TypeDefInfo.Option:
    case TypeDefInfo.Range:
    case TypeDefInfo.RangeInclusive:
    case TypeDefInfo.Result:
    case TypeDefInfo.Vec:
    case TypeDefInfo.WrapperKeepOpaque:
    case TypeDefInfo.WrapperOpaque:
      return paramsNotation(outer, sub, (p) => encodeTypeDef(registry, p));
  }
  throw new Error(`Unable to encode ${stringify(typeDef)} with params`);
}
function encodeSubTypes(registry, sub, asEnum, extra) {
  const names = sub.map(({ name }) => name);
  if (!names.every((n) => !!n)) {
    throw new Error(`Subtypes does not have consistent names, ${names.join(", ")}`);
  }
  const inner = objectSpread({}, extra);
  for (let i2 = 0, count = sub.length; i2 < count; i2++) {
    const def = sub[i2];
    if (!def.name) {
      throw new Error(`No name found in ${stringify(def)}`);
    }
    inner[def.name] = encodeTypeDef(registry, def);
  }
  return stringify(asEnum ? { _enum: inner } : inner);
}
function encodeType(registry, typeDef, withLookup = true) {
  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);
}
function encodeTypeDef(registry, typeDef) {
  return typeDef.displayName && !INFO_WRAP.some((i2) => typeDef.displayName === i2) ? typeDef.displayName : encodeType(registry, typeDef);
}
function withTypeString(registry, typeDef) {
  return objectSpread({}, typeDef, {
    type: encodeType(registry, typeDef, false)
  });
}
var stringIdentity, INFO_WRAP, encoders;
var init_encodeTypes = __esm({
  "../../node_modules/@polkadot/types-create/util/encodeTypes.js"() {
    init_util();
    init_types2();
    stringIdentity = (value) => value.toString();
    INFO_WRAP = ["BTreeMap", "BTreeSet", "Compact", "HashMap", "Option", "Result", "Vec"];
    encoders = {
      [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, "BTreeMap"),
      [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, "BTreeSet"),
      [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Compact"),
      [TypeDefInfo.DoNotConstruct]: (registry, { displayName, lookupIndex, lookupName }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? "Unknown" : registry.createLookupType(lookupIndex))}>`,
      [TypeDefInfo.Enum]: (registry, { sub }) => {
        if (!Array.isArray(sub)) {
          throw new Error("Unable to encode Enum type");
        }
        return sub.every(({ type }) => type === "Null") ? stringify({ _enum: sub.map(({ name }, index) => `${name || `Empty${index}`}`) }) : encodeSubTypes(registry, sub, true);
      },
      [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, "HashMap"),
      [TypeDefInfo.Int]: (_registry, { length = 32 }) => `Int<${length}>`,
      [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Linkage"),
      [TypeDefInfo.Null]: (_registry, _typeDef) => "Null",
      [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Option"),
      [TypeDefInfo.Plain]: (_registry, { displayName, type }) => displayName || type,
      [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Range"),
      [TypeDefInfo.RangeInclusive]: (registry, typeDef) => encodeWithParams(registry, typeDef, "RangeInclusive"),
      [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Result"),
      [TypeDefInfo.Set]: (_registry, { length = 8, sub }) => {
        if (!Array.isArray(sub)) {
          throw new Error("Unable to encode Set type");
        }
        return stringify({
          _set: sub.reduce((all3, { index, name }, count) => objectSpread(all3, { [`${name || `Unknown${index || count}`}`]: index || count }), { _bitLength: length || 8 })
        });
      },
      [TypeDefInfo.Si]: (_registry, { lookupName, type }) => lookupName || type,
      [TypeDefInfo.Struct]: (registry, { alias: alias2, sub }) => {
        if (!Array.isArray(sub)) {
          throw new Error("Unable to encode Struct type");
        }
        return encodeSubTypes(registry, sub, false, alias2 ? {
          _alias: [...alias2.entries()].reduce((all3, [k, v]) => objectSpread(all3, { [k]: v }), {})
        } : {});
      },
      [TypeDefInfo.Tuple]: (registry, { sub }) => {
        if (!Array.isArray(sub)) {
          throw new Error("Unable to encode Tuple type");
        }
        return `(${sub.map((type) => encodeTypeDef(registry, type)).join(",")})`;
      },
      [TypeDefInfo.UInt]: (_registry, { length = 32 }) => `UInt<${length}>`,
      [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Vec"),
      [TypeDefInfo.VecFixed]: (_registry, { length, sub }) => {
        if (!isNumber(length) || !sub || Array.isArray(sub)) {
          throw new Error("Unable to encode VecFixed type");
        }
        return `[${sub.type};${length}]`;
      },
      [TypeDefInfo.WrapperKeepOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, "WrapperKeepOpaque"),
      [TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, "WrapperOpaque")
    };
  }
});

// ../../node_modules/@polkadot/types-create/util/xcm.js
function mapXcmTypes(version) {
  return XCM_MAPPINGS.reduce((all3, key) => objectSpread(all3, { [key]: `${key}${version}` }), {});
}
var XCM_MAPPINGS;
var init_xcm = __esm({
  "../../node_modules/@polkadot/types-create/util/xcm.js"() {
    init_util();
    XCM_MAPPINGS = ["AssetInstance", "Fungibility", "Junction", "Junctions", "MultiAsset", "MultiAssetFilter", "MultiLocation", "Response", "WildFungibility", "WildMultiAsset", "Xcm", "XcmError"];
  }
});

// ../../node_modules/@polkadot/types-create/util/index.js
var init_util3 = __esm({
  "../../node_modules/@polkadot/types-create/util/index.js"() {
    init_encodeTypes();
    init_getTypeDef();
    init_typeSplit();
    init_xcm();
  }
});

// ../../node_modules/@polkadot/types-create/exports.js
var init_exports = __esm({
  "../../node_modules/@polkadot/types-create/exports.js"() {
    init_create();
    init_util3();
  }
});

// ../../node_modules/@polkadot/types-create/bundle.js
var init_bundle10 = __esm({
  "../../node_modules/@polkadot/types-create/bundle.js"() {
    init_types2();
    init_exports();
  }
});

// ../../node_modules/@polkadot/types-create/index.js
var init_types_create = __esm({
  "../../node_modules/@polkadot/types-create/index.js"() {
    init_packageDetect13();
    init_bundle10();
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcm/v0.js
var v02;
var init_v02 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcm/v0.js"() {
    v02 = {
      FungibilityV0: "FungibilityV1",
      WildFungibilityV0: "WildFungibilityV1",
      AssetInstanceV0: {
        _enum: {
          Undefined: "Null",
          Index8: "u8",
          Index16: "Compact<u16>",
          Index32: "Compact<u32>",
          Index64: "Compact<u64>",
          Index128: "Compact<u128>",
          Array4: "[u8; 4]",
          Array8: "[u8; 8]",
          Array16: "[u8; 16]",
          Array32: "[u8; 32]",
          Blob: "Vec<u8>"
        }
      },
      JunctionV0: {
        _enum: {
          Parent: "Null",
          Parachain: "Compact<u32>",
          AccountId32: {
            network: "NetworkId",
            id: "AccountId"
          },
          AccountIndex64: {
            network: "NetworkId",
            index: "Compact<u64>"
          },
          AccountKey20: {
            network: "NetworkId",
            key: "[u8; 20]"
          },
          PalletInstance: "u8",
          GeneralIndex: "Compact<u128>",
          GeneralKey: "Vec<u8>",
          OnlyChild: "Null",
          Plurality: {
            id: "BodyId",
            part: "BodyPart"
          }
        }
      },
      MultiAssetV0: {
        _enum: {
          None: "Null",
          All: "Null",
          AllFungible: "Null",
          AllNonFungible: "Null",
          AllAbstractFungible: "Vec<u8>",
          AllAbstractNonFungible: "Vec<u8>",
          AllConcreteFungible: "MultiLocationV0",
          AllConcreteNonFungible: "MultiLocationV0",
          AbstractFungible: {
            id: "Vec<u8>",
            instance: "Compact<u128>"
          },
          AbstractNonFungible: {
            class: "Vec<u8>",
            instance: "AssetInstanceV0"
          },
          ConcreteFungible: {
            id: "MultiLocationV0",
            amount: "Compact<u128>"
          },
          ConcreteNonFungible: {
            class: "MultiLocationV0",
            instance: "AssetInstanceV0"
          }
        }
      },
      MultiLocationV0: {
        _enum: {
          Here: "Null",
          X1: "JunctionV0",
          X2: "(JunctionV0, JunctionV0)",
          X3: "(JunctionV0, JunctionV0, JunctionV0)",
          X4: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
          X5: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
          X6: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
          X7: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
          X8: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)"
        }
      },
      OriginKindV0: {
        _enum: ["Native", "SovereignAccount", "Superuser", "Xcm"]
      },
      ResponseV0: {
        _enum: {
          Assets: "Vec<MultiAssetV0>"
        }
      },
      XcmV0: {
        _enum: {
          WithdrawAsset: {
            assets: "Vec<MultiAssetV0>",
            effects: "Vec<XcmOrderV0>"
          },
          ReserveAssetDeposit: {
            assets: "Vec<MultiAssetV0>",
            effects: "Vec<XcmOrderV0>"
          },
          ReceiveTeleportedAsset: {
            assets: "Vec<MultiAssetV0>",
            effects: "Vec<XcmOrderV0>"
          },
          QueryResponse: {
            queryId: "Compact<u64>",
            response: "ResponseV0"
          },
          TransferAsset: {
            assets: "Vec<MultiAssetV0>",
            dest: "MultiLocationV0"
          },
          TransferReserveAsset: {
            assets: "Vec<MultiAssetV0>",
            dest: "MultiLocationV0",
            effects: "Vec<XcmOrderV0>"
          },
          Transact: {
            originType: "XcmOriginKind",
            requireWeightAtMost: "u64",
            call: "DoubleEncodedCall"
          },
          HrmpNewChannelOpenRequest: {
            sender: "Compact<u32>",
            maxMessageSize: "Compact<u32>",
            maxCapacity: "Compact<u32>"
          },
          HrmpChannelAccepted: {
            recipient: "Compact<u32>"
          },
          HrmpChannelClosing: {
            initiator: "Compact<u32>",
            sender: "Compact<u32>",
            recipient: "Compact<u32>"
          },
          RelayedFrom: {
            who: "MultiLocationV0",
            message: "XcmV0"
          }
        }
      },
      XcmErrorV0: {
        _enum: {
          Undefined: "Null",
          Overflow: "Null",
          Unimplemented: "Null",
          UnhandledXcmVersion: "Null",
          UnhandledXcmMessage: "Null",
          UnhandledEffect: "Null",
          EscalationOfPrivilege: "Null",
          UntrustedReserveLocation: "Null",
          UntrustedTeleportLocation: "Null",
          DestinationBufferOverflow: "Null",
          SendFailed: "Null",
          CannotReachDestination: "(MultiLocation, Xcm)",
          MultiLocationFull: "Null",
          FailedToDecode: "Null",
          BadOrigin: "Null",
          ExceedsMaxMessageSize: "Null",
          FailedToTransactAsset: "Null",
          WeightLimitReached: "Weight",
          Wildcard: "Null",
          TooMuchWeightRequired: "Null",
          NotHoldingFees: "Null",
          WeightNotComputable: "Null",
          Barrier: "Null",
          NotWithdrawable: "Null",
          LocationCannotHold: "Null",
          TooExpensive: "Null",
          AssetNotFound: "Null",
          RecursionLimitReached: "Null"
        }
      },
      XcmOrderV0: {
        _enum: {
          Null: "Null",
          DepositAsset: {
            assets: "Vec<MultiAssetV0>",
            dest: "MultiLocationV0"
          },
          DepositReserveAsset: {
            assets: "Vec<MultiAssetV0>",
            dest: "MultiLocationV0",
            effects: "Vec<XcmOrderV0>"
          },
          ExchangeAsset: {
            give: "Vec<MultiAssetV0>",
            receive: "Vec<MultiAssetV0>"
          },
          InitiateReserveWithdraw: {
            assets: "Vec<MultiAssetV0>",
            reserve: "MultiLocationV0",
            effects: "Vec<XcmOrderV0>"
          },
          InitiateTeleport: {
            assets: "Vec<MultiAssetV0>",
            dest: "MultiLocationV0",
            effects: "Vec<XcmOrderV0>"
          },
          QueryHolding: {
            queryId: "Compact<u64>",
            dest: "MultiLocationV0",
            assets: "Vec<MultiAssetV0>"
          },
          BuyExecution: {
            fees: "MultiAssetV0",
            weight: "u64",
            debt: "u64",
            haltOnError: "bool",
            xcm: "Vec<XcmV0>"
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcm/v1.js
var v16;
var init_v16 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcm/v1.js"() {
    v16 = {
      AssetInstanceV1: {
        _enum: {
          Undefined: "Null",
          Index: "Compact<u128>",
          Array4: "[u8; 4]",
          Array8: "[u8; 8]",
          Array16: "[u8; 16]",
          Array32: "[u8; 32]",
          Blob: "Bytes"
        }
      },
      FungibilityV1: {
        _enum: {
          Fungible: "Compact<u128>",
          NonFungible: "AssetInstanceV1"
        }
      },
      JunctionV1: {
        _enum: {
          Parachain: "Compact<u32>",
          AccountId32: {
            network: "NetworkId",
            id: "AccountId"
          },
          AccountIndex64: {
            network: "NetworkId",
            index: "Compact<u64>"
          },
          AccountKey20: {
            network: "NetworkId",
            key: "[u8; 20]"
          },
          PalletInstance: "u8",
          GeneralIndex: "Compact<u128>",
          GeneralKey: "Vec<u8>",
          OnlyChild: "Null",
          Plurality: {
            id: "BodyId",
            part: "BodyPart"
          }
        }
      },
      JunctionsV1: {
        _enum: {
          Here: "Null",
          X1: "JunctionV1",
          X2: "(JunctionV1, JunctionV1)",
          X3: "(JunctionV1, JunctionV1, JunctionV1)",
          X4: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
          X5: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
          X6: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
          X7: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
          X8: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)"
        }
      },
      MultiAssetsV1: "Vec<MultiAssetV1>",
      MultiAssetV1: {
        id: "XcmAssetId",
        fungibility: "FungibilityV1"
      },
      MultiAssetFilterV1: {
        _enum: {
          Definite: "MultiAssetsV1",
          Wild: "WildMultiAssetV1"
        }
      },
      MultiLocationV1: {
        parents: "u8",
        interior: "JunctionsV1"
      },
      OriginKindV1: "OriginKindV0",
      ResponseV1: {
        _enum: {
          Assets: "MultiAssetsV1"
        }
      },
      WildFungibilityV1: {
        _enum: ["Fungible", "NonFungible"]
      },
      WildMultiAssetV1: {
        _enum: {
          All: "Null",
          AllOf: {
            id: "XcmAssetId",
            fungibility: "WildFungibilityV1"
          }
        }
      },
      XcmV1: {
        _enum: {
          WithdrawAsset: {
            assets: "MultiAssetsV1",
            effects: "Vec<XcmOrderV1>"
          },
          ReserveAssetDeposit: {
            assets: "MultiAssetsV1",
            effects: "Vec<XcmOrderV1>"
          },
          ReceiveTeleportedAsset: {
            assets: "MultiAssetsV1",
            effects: "Vec<XcmOrderV1>"
          },
          QueryResponse: {
            queryId: "Compact<u64>",
            response: "ResponseV1"
          },
          TransferAsset: {
            assets: "MultiAssetsV1",
            dest: "MultiLocationV1"
          },
          TransferReserveAsset: {
            assets: "MultiAssetsV1",
            dest: "MultiLocationV1",
            effects: "Vec<XcmOrderV1>"
          },
          Transact: {
            originType: "XcmOriginKind",
            requireWeightAtMost: "u64",
            call: "DoubleEncodedCall"
          },
          HrmpNewChannelOpenRequest: {
            sender: "Compact<u32>",
            maxMessageSize: "Compact<u32>",
            maxCapacity: "Compact<u32>"
          },
          HrmpChannelAccepted: {
            recipient: "Compact<u32>"
          },
          HrmpChannelClosing: {
            initiator: "Compact<u32>",
            sender: "Compact<u32>",
            recipient: "Compact<u32>"
          },
          RelayedFrom: {
            who: "MultiLocationV1",
            message: "XcmV1"
          }
        }
      },
      XcmErrorV1: {
        _enum: {
          Undefined: "Null",
          Overflow: "Null",
          Unimplemented: "Null",
          UnhandledXcmVersion: "Null",
          UnhandledXcmMessage: "Null",
          UnhandledEffect: "Null",
          EscalationOfPrivilege: "Null",
          UntrustedReserveLocation: "Null",
          UntrustedTeleportLocation: "Null",
          DestinationBufferOverflow: "Null",
          SendFailed: "Null",
          CannotReachDestination: "(MultiLocationV1, XcmV1)",
          MultiLocationFull: "Null",
          FailedToDecode: "Null",
          BadOrigin: "Null",
          ExceedsMaxMessageSize: "Null",
          FailedToTransactAsset: "Null",
          WeightLimitReached: "Weight",
          Wildcard: "Null",
          TooMuchWeightRequired: "Null",
          NotHoldingFees: "Null",
          WeightNotComputable: "Null",
          Barrier: "Null",
          NotWithdrawable: "Null",
          LocationCannotHold: "Null",
          TooExpensive: "Null",
          AssetNotFound: "Null",
          DestinationUnsupported: "Null",
          RecursionLimitReached: "Null"
        }
      },
      XcmOrderV1: {
        _enum: {
          Noop: "Null",
          DepositAsset: {
            assets: "MultiAssetFilterV1",
            maxAssets: "u32",
            beneficiary: "MultiLocationV1"
          },
          DepositReserveAsset: {
            assets: "MultiAssetFilterV1",
            maxAssets: "u32",
            dest: "MultiLocationV1",
            effects: "Vec<XcmOrderV1>"
          },
          ExchangeAsset: {
            give: "MultiAssetFilterV1",
            receive: "MultiAssetsV1"
          },
          InitiateReserveWithdraw: {
            assets: "MultiAssetFilterV1",
            reserve: "MultiLocationV1",
            effects: "Vec<XcmOrderV1>"
          },
          InitiateTeleport: {
            assets: "MultiAssetFilterV1",
            dest: "MultiLocationV1",
            effects: "Vec<XcmOrderV1>"
          },
          QueryHolding: {
            queryId: "Compact<u64>",
            dest: "MultiLocationV1",
            assets: "MultiAssetFilterV1"
          },
          BuyExecution: {
            fees: "MultiAssetV1",
            weight: "u64",
            debt: "u64",
            haltOnError: "bool",
            instructions: "Vec<XcmV1>"
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcm/v2.js
var v2;
var init_v2 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcm/v2.js"() {
    v2 = {
      AssetIdV2: {
        _enum: {
          Concrete: "MultiLocationV2",
          Abstract: "Bytes"
        }
      },
      AssetInstanceV2: {
        _enum: {
          Undefined: "Null",
          Index: "Compact<u128>",
          Array4: "[u8;4]",
          Array8: "[u8;8]",
          Array16: "[u8;16]",
          Array32: "[u8;32]",
          Blob: "Bytes"
        }
      },
      BodyIdV2: {
        _enum: {
          Unit: "Null",
          Named: "Bytes",
          Index: "Compact<u32>",
          Executive: "Null",
          Technical: "Null",
          Legislative: "Null",
          Judicial: "Null",
          Defense: "Null",
          Administration: "Null",
          Treasury: "Null"
        }
      },
      BodyPartV2: {
        _enum: {
          Voice: "Null",
          Members: {
            count: "Compact<u32>"
          },
          Fraction: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          },
          AtLeastProportion: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          },
          MoreThanProportion: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          }
        }
      },
      NetworkIdV2: {
        _enum: {
          Any: "Null",
          Named: "Bytes",
          Polkadot: "Null",
          Kusama: "Null"
        }
      },
      JunctionV2: {
        _enum: {
          Parachain: "Compact<u32>",
          AccountId32: {
            network: "NetworkIdV2",
            id: "[u8; 32]"
          },
          AccountIndex64: {
            network: "NetworkIdV2",
            index: "Compact<u64>"
          },
          AccountKey20: {
            network: "NetworkIdV2",
            key: "[u8; 20]"
          },
          PalletInstance: "u8",
          GeneralIndex: "Compact<u128>",
          GeneralKey: "Bytes",
          OnlyChild: "Null",
          Plurality: {
            id: "BodyIdV2",
            part: "BodyPartV2"
          }
        }
      },
      JunctionsV2: {
        _enum: {
          Here: "Null",
          X1: "JunctionV2",
          X2: "(JunctionV2, JunctionV2)",
          X3: "(JunctionV2, JunctionV2, JunctionV2)",
          X4: "(JunctionV2, JunctionV2, JunctionV2, JunctionV2)",
          X5: "(JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2)",
          X6: "(JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2)",
          X7: "(JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2)",
          X8: "(JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2, JunctionV2)"
        }
      },
      FungibilityV2: {
        _enum: {
          Fungible: "Compact<u128>",
          NonFungible: "AssetInstanceV2"
        }
      },
      InteriorMultiLocationV2: "JunctionsV2",
      MultiAssetV2: {
        id: "AssetIdV2",
        fun: "FungibilityV2"
      },
      MultiAssetsV2: "Vec<MultiAssetV2>",
      MultiAssetFilterV2: {
        _enum: {
          Definite: "MultiAssetsV2",
          Wild: "WildMultiAssetV2"
        }
      },
      MultiLocationV2: {
        parents: "u8",
        interior: "JunctionsV2"
      },
      OriginKindV2: {
        _enum: {
          Native: "Null",
          SovereignAccount: "Null",
          Superuser: "Null",
          Xcm: "Null"
        }
      },
      WildFungibilityV2: {
        _enum: {
          Fungible: "Null",
          NonFungible: "Null"
        }
      },
      ResponseV2: {
        _enum: {
          Null: "Null",
          Assets: "MultiAssetsV2",
          ExecutionResult: "Option<(u32, XcmErrorV2)>",
          Version: "u32"
        }
      },
      ResponseV2Error: "(u32, XcmErrorV2)",
      WeightLimitV2: {
        _enum: {
          Unlimited: "Null",
          Limited: "Compact<u64>"
        }
      },
      InstructionV2: {
        _enum: {
          WithdrawAsset: "MultiAssetsV2",
          ReserveAssetDeposited: "MultiAssetsV2",
          ReceiveTeleportedAsset: "MultiAssetsV2",
          QueryResponse: {
            queryId: "Compact<u64>",
            response: "ResponseV2",
            maxWeight: "Compact<u64>"
          },
          TransferAsset: {
            assets: "MultiAssetsV2",
            beneficiary: "MultiLocationV2"
          },
          TransferReserveAsset: {
            assets: "MultiAssetsV2",
            dest: "MultiLocationV2",
            xcm: "XcmV2"
          },
          Transact: {
            originType: "XcmOriginKind",
            requireWeightAtMost: "Compact<u64>",
            call: "DoubleEncodedCall"
          },
          HrmpNewChannelOpenRequest: {
            sender: "Compact<u32>",
            maxMessageSize: "Compact<u32>",
            maxCapacity: "Compact<u32>"
          },
          HrmpChannelAccepted: {
            recipient: "Compact<u32>"
          },
          HrmpChannelClosing: {
            initiator: "Compact<u32>",
            sender: "Compact<u32>",
            recipient: "Compact<u32>"
          },
          ClearOrigin: "Null",
          DescendOrigin: "InteriorMultiLocationV2",
          ReportError: {
            queryId: "Compact<u64>",
            dest: "MultiLocationV2",
            maxResponseWeight: "Compact<u64>"
          },
          DepositAsset: {
            assets: "MultiAssetFilterV2",
            maxAssets: "Compact<u32>",
            beneficiary: "MultiLocationV2"
          },
          DepositReserveAsset: {
            assets: "MultiAssetFilterV2",
            maxAssets: "Compact<u32>",
            dest: "MultiLocationV2",
            xcm: "XcmV2"
          },
          ExchangeAsset: {
            give: "MultiAssetFilterV2",
            receive: "MultiAssetsV2"
          },
          InitiateReserveWithdraw: {
            assets: "MultiAssetFilterV2",
            reserve: "MultiLocationV2",
            xcm: "XcmV2"
          },
          InitiateTeleport: {
            assets: "MultiAssetFilterV2",
            dest: "MultiLocationV2",
            xcm: "XcmV2"
          },
          QueryHolding: {
            queryId: "Compact<u64>",
            dest: "MultiLocationV2",
            assets: "MultiAssetFilterV2",
            maxResponseWeight: "Compact<u64>"
          },
          BuyExecution: {
            fees: "MultiAssetV2",
            weightLimit: "WeightLimitV2"
          },
          RefundSurplus: "Null",
          SetErrorHandler: "XcmV2<RuntimeCall>",
          SetAppendix: "XcmV2<RuntimeCall>",
          ClearError: "Null",
          ClaimAsset: {
            assets: "MultiAssetsV2",
            ticket: "MultiLocationV2"
          },
          Trap: "Compact<u64>",
          SubscribeVersion: {
            queryId: "Compact<u64>",
            maxResponseWeight: "Compact<u64>"
          },
          UnsubscribeVersion: "Null"
        }
      },
      WildMultiAssetV2: {
        _enum: {
          All: "Null",
          AllOf: {
            id: "AssetIdV2",
            fun: "WildFungibilityV2"
          }
        }
      },
      XcmV2: "Vec<InstructionV2>",
      XcmErrorV2: {
        _enum: {
          Overflow: "Null",
          Unimplemented: "Null",
          UntrustedReserveLocation: "Null",
          UntrustedTeleportLocation: "Null",
          MultiLocationFull: "Null",
          MultiLocationNotInvertible: "Null",
          BadOrigin: "Null",
          InvalidLocation: "Null",
          AssetNotFound: "Null",
          FailedToTransactAsset: "Null",
          NotWithdrawable: "Null",
          LocationCannotHold: "Null",
          ExceedsMaxMessageSize: "Null",
          DestinationUnsupported: "Null",
          Transport: "Null",
          Unroutable: "Null",
          UnknownClaim: "Null",
          FailedToDecode: "Null",
          MaxWeightInvalid: "Null",
          NotHoldingFees: "Null",
          TooExpensive: "Null",
          Trap: "u64",
          UnhandledXcmVersion: "Null",
          WeightLimitReached: "Weight",
          Barrier: "Null",
          WeightNotComputable: "Null"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcm/v3.js
var v3;
var init_v3 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcm/v3.js"() {
    v3 = {
      AssetIdV3: {
        _enum: {
          Concrete: "MultiLocationV3",
          Abstract: "Bytes"
        }
      },
      BodyIdV3: {
        _enum: {
          Unit: "Null",
          Moniker: "[u8;4]",
          Index: "Compact<u32>",
          Executive: "Null",
          Technical: "Null",
          Legislative: "Null",
          Judicial: "Null",
          Defense: "Null",
          Administration: "Null",
          Treasury: "Null"
        }
      },
      BodyPartV3: {
        _enum: {
          Voice: "Null",
          Members: {
            count: "Compact<u32>"
          },
          Fraction: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          },
          AtLeastProportion: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          },
          MoreThanProportion: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          }
        }
      },
      AssetInstanceV3: {
        _enum: {
          Undefined: "Null",
          Index: "Compact<u128>",
          Array4: "[u8;4]",
          Array8: "[u8;8]",
          Array16: "[u8;16]",
          Array32: "[u8;32]"
        }
      },
      FungibilityV3: {
        _enum: {
          Fungible: "Compact<u128>",
          NonFungible: "AssetInstanceV3"
        }
      },
      InteriorMultiLocationV3: "JunctionsV3",
      JunctionV3: {
        _enum: {
          Parachain: "Compact<u32>",
          AccountId32: {
            network: "Option<NetworkIdV3>",
            id: "[u8;32]"
          },
          AccountIndex64: {
            network: "Option<NetworkIdV3>",
            index: "Compact<u64>"
          },
          AccountKey20: {
            network: "Option<NetworkIdV3>",
            key: "[u8;20]"
          },
          PalletInstance: "u8",
          GeneralIndex: "Compact<u128>",
          GeneralKey: {
            length: "u8",
            data: "[u8;32]"
          },
          OnlyChild: "Null",
          Plurality: {
            id: "BodyIdV3",
            part: "BodyPartV3"
          },
          GlobalConsensus: "NetworkIdV3"
        }
      },
      JunctionsV3: {
        _enum: {
          Here: "Null",
          X1: "JunctionV3",
          X2: "(JunctionV3, JunctionV3)",
          X3: "(JunctionV3, JunctionV3, JunctionV3)",
          X4: "(JunctionV3, JunctionV3, JunctionV3, JunctionV3)",
          X5: "(JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3)",
          X6: "(JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3)",
          X7: "(JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3)",
          X8: "(JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3, JunctionV3)"
        }
      },
      MaybeErrorCodeV3: {
        _enum: {
          Success: "Null",
          Error: "Bytes",
          TruncatedError: "Bytes"
        }
      },
      MaxPalletsInfo: "u32",
      MultiAssetV3: {
        id: "AssetIdV3",
        fun: "FungibilityV3"
      },
      MultiAssetsV3: "Vec<MultiAssetV3>",
      MultiAssetFilterV3: {
        _enum: {
          Definite: "MultiAssetsV3",
          Wild: "WildMultiAssetV3"
        }
      },
      MultiLocationV3: {
        parents: "u8",
        interior: "JunctionsV3"
      },
      MaxPalletNameLen: "u32",
      NetworkIdV3: {
        _enum: {
          ByGenesis: "[u8;32]",
          ByFork: {
            blockNumber: "u64",
            blockHash: "[u8;32]"
          },
          Polkadot: "Null",
          Kusama: "Null",
          Westend: "Null",
          Rococo: "Null",
          Wococo: "Null",
          Ethereum: {
            chainId: "Compact<u64>"
          },
          BitcoinCore: "Null",
          BitcoinCash: "Null",
          PolkadotBulletin: "Null"
        }
      },
      OriginKindV3: "OriginKindV2",
      PalletInfoV3: {
        index: "Compact<u32>",
        name: "Bytes",
        moduleName: "Bytes",
        major: "Compact<u32>",
        minor: "Compact<u32>",
        patch: "Compact<u32>"
      },
      WildFungibilityV3: "WildFungibilityV2",
      QueryResponseInfoV3: {
        destination: "MultiLocationV3",
        queryId: "Compact<u64>",
        maxWeight: "WeightV2"
      },
      ResponseV3: {
        _enum: {
          Null: "Null",
          Assets: "MultiAssetsV3",
          ExecutionResult: "Option<(u32,XcmErrorV3)>",
          Version: "u32",
          PalletsInfo: "Vec<PalletInfoV3>",
          DispatchResult: "MaybeErrorCodeV3"
        }
      },
      XcmErrorV3: {
        _enum: {
          Overflow: "Null",
          Unimplemented: "Null",
          UntrustedReserveLocation: "Null",
          UntrustedTeleportLocation: "Null",
          LocationFull: "Null",
          LocationNotInvertible: "Null",
          BadOrigin: "Null",
          InvalidLocation: "Null",
          AssetNotFound: "Null",
          FailedToTransactAsset: "Null",
          NotWithdrawable: "Null",
          LocationCannotHold: "Null",
          ExceedsMaxMessageSize: "Null",
          DestinationUnsupported: "Null",
          Transport: "Null",
          Unroutable: "Null",
          UnknownClaim: "Null",
          FailedToDecode: "Null",
          MaxWeightInvalid: "Null",
          NotHoldingFees: "Null",
          TooExpensive: "Null",
          Trap: "u64",
          ExpectationFalse: "Null",
          PalletNotFound: "Null",
          NameMismatch: "Null",
          VersionIncompatible: "Null",
          HoldingWouldOverflow: "Null",
          ExportError: "Null",
          ReanchorFailed: "Null",
          NoDeal: "Null",
          FeesNotMet: "Null",
          LockError: "Null",
          NoPermission: "Null",
          Unanchored: "Null",
          NotDepositable: "Null",
          UnhandledXcmVersion: "Null",
          WeightLimitReached: "WeightV2",
          Barrier: "Null",
          ExceedsStackLimit: "Null"
        }
      },
      ResponseV3Error: "(u32, XcmErrorV3)",
      ResponseV3Result: "Option<(u32, ResponseV3Error)>",
      WeightLimitV3: {
        _enum: {
          Unlimited: "Null",
          Limited: "WeightV2"
        }
      },
      InstructionV3: {
        _enum: {
          WithdrawAsset: "MultiAssetsV3",
          ReserveAssetDeposited: "MultiAssetsV3",
          ReceiveTeleportedAsset: "MultiAssetsV3",
          QueryResponse: {
            queryId: "Compact<u64>",
            response: "ResponseV3",
            maxWeight: "WeightV2",
            querier: "Option<MultiLocationV3>"
          },
          TransferAsset: {
            assets: "MultiAssetsV3",
            beneficiary: "MultiLocationV3"
          },
          TransferReserveAsset: {
            assets: "MultiAssetsV3",
            dest: "MultiLocationV3",
            xcm: "XcmV3"
          },
          Transact: {
            originKind: "XcmOriginKind",
            requireWeightAtMost: "WeightV2",
            call: "DoubleEncodedCall"
          },
          HrmpNewChannelOpenRequest: {
            sender: "Compact<u32>",
            maxMessageSize: "Compact<u32>",
            maxCapacity: "Compact<u32>"
          },
          HrmpChannelAccepted: {
            recipient: "Compact<u32>"
          },
          HrmpChannelClosing: {
            initiator: "Compact<u32>",
            sender: "Compact<u32>",
            recipient: "Compact<u32>"
          },
          ClearOrigin: "Null",
          DescendOrigin: "JunctionsV3",
          ReportError: "QueryResponseInfoV3",
          DepositAsset: {
            assets: "MultiAssetFilterV3",
            beneficiary: "MultiLocationV3"
          },
          DepositReserveAsset: {
            assets: "MultiAssetFilterV3",
            dest: "MultiLocationV3",
            xcm: "XcmV3"
          },
          ExchangeAsset: {
            give: "MultiAssetFilterV3",
            want: "MultiAssetsV3",
            maximal: "bool"
          },
          InitiateReserveWithdraw: {
            assets: "MultiAssetFilterV3",
            reserve: "MultiLocationV3",
            xcm: "XcmV3"
          },
          InitiateTeleport: {
            assets: "MultiAssetFilterV3",
            dest: "MultiLocationV3",
            xcm: "XcmV3"
          },
          ReportHolding: {
            responseInfo: "QueryResponseInfoV3",
            assets: "MultiAssetFilterV3"
          },
          BuyExecution: {
            fees: "MultiAssetV3",
            weightLimit: "WeightLimitV3"
          },
          RefundSurplus: "Null",
          SetErrorHandler: "XcmV3<RuntimeCall>",
          SetAppendix: "XcmV3<RuntimeCall>",
          ClearError: "Null",
          ClaimAsset: {
            assets: "MultiAssetsV3",
            ticket: "MultiLocationV3"
          },
          Trap: "Compact<u64>",
          SubscribeVersion: {
            queryId: "Compact<u64>",
            maxResponseWeight: "WeightV2"
          },
          UnsubscribeVersion: "Null",
          BurnAsset: "MultiAssetsV3",
          ExpectAsset: "MultiAssetsV3",
          ExpectOrigin: "Option<MultiLocationV3>",
          ExpectError: "Option<(u32, XcmErrorV3)>",
          ExpectTransactStatus: "MaybeErrorCodeV3",
          QueryPallet: {
            moduleName: "Vec<u8>",
            responseInfo: "QueryResponseInfoV3"
          },
          ExpectPallet: {
            index: "Compact<u32>",
            name: "Vec<u8>",
            moduleName: "Vec<u8>",
            crateMajor: "Compact<u32>",
            minCrateMinor: "Compact<u32>"
          },
          ReportTransactStatus: "QueryResponseInfoV3",
          ClearTransactStatus: "Null",
          UniversalOrigin: "JunctionV3",
          ExportMessage: {
            network: "NetworkIdV3",
            destination: "JunctionsV3",
            xcm: "XcmV3"
          },
          LockAsset: {
            asset: "MultiAssetV3",
            unlocker: "MultiLocationV3"
          },
          UnlockAsset: {
            asset: "MultiAssetV3",
            target: "MultiLocationV3"
          },
          NoteUnlockable: {
            asset: "MultiAssetV3",
            owner: "MultiLocationV3"
          },
          RequestUnlock: {
            asset: "MultiAssetV3",
            locker: "MultiLocationV3"
          },
          SetFeesMode: {
            jitWithdraw: "bool"
          },
          SetTopic: "[u8; 32]",
          ClearTopic: "Null",
          AliasOrigin: "MultiLocationV3",
          UnpaidExecution: {
            weightLimit: "WeightLimitV3",
            checkOrigin: "Option<MultiLocationV3>"
          }
        }
      },
      WildMultiAssetV3: {
        _enum: {
          All: "Null",
          AllOf: {
            id: "AssetIdV3",
            fun: "WildFungibilityV2"
          },
          AllCounted: "Compact<u32>",
          AllOfCounted: {
            id: "AssetIdV3",
            fun: "WildFungibilityV2",
            count: "Compact<u32>"
          }
        }
      },
      VersionV3: "u32",
      XcmV3: "Vec<InstructionV3>"
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcm/v4.js
var v4;
var init_v4 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcm/v4.js"() {
    v4 = {
      AssetIdV4: "MultiLocationV4",
      AssetInstanceV4: {
        _enum: {
          Undefined: "Null",
          Index: "Compact<u128>",
          Array4: "[u8;4]",
          Array8: "[u8;8]",
          Array16: "[u8;16]",
          Array32: "[u8;32]"
        }
      },
      FungibilityV4: {
        _enum: {
          Fungible: "Compact<u128>",
          NonFungible: "AssetInstanceV4"
        }
      },
      UncheckedFungibilityV4: {
        _enum: {
          Fungible: "Compact<u128>",
          NonFungible: "AssetInstanceV4"
        }
      },
      JunctionV4: {
        _enum: {
          Parachain: "Compact<u32>",
          AccountId32: {
            network: "Option<NetworkIdV4>",
            id: "[u8;32]"
          },
          AccountIndex64: {
            network: "Option<NetworkIdV4>",
            index: "Compact<u64>"
          },
          AccountKey20: {
            network: "Option<NetworkIdV4>",
            key: "[u8;20]"
          },
          PalletInstance: "u8",
          GeneralIndex: "Compact<u128>",
          GeneralKey: {
            length: "u8",
            data: "[u8;32]"
          },
          OnlyChild: "Null",
          Plurality: {
            id: "BodyIdV3",
            part: "BodyPartV3"
          },
          GlobalConsensus: "NetworkIdV4"
        }
      },
      JunctionsV4: {
        _enum: {
          Here: "Null",
          X1: "[JunctionV4;1]",
          X2: "[JunctionV4;2]",
          X3: "[JunctionV4;3]",
          X4: "[JunctionV4;4]",
          X5: "[JunctionV4;5]",
          X6: "[JunctionV4;6]",
          X7: "[JunctionV4;7]",
          X8: "[JunctionV4;8]"
        }
      },
      MaxPalletsInfo: "u32",
      NetworkIdV4: "NetworkIdV3",
      MultiAssetV4: {
        id: "AssetIdV4",
        fun: "FungibilityV4"
      },
      MultiAssetsV4: "Vec<MultiAssetV4>",
      MultiAssetFilterV4: {
        _enum: {
          Definite: "MultiAssetsV4",
          Wild: "WildMultiAssetV4"
        }
      },
      MultiLocationV4: {
        parents: "u8",
        interior: "JunctionsV4"
      },
      OriginKindV4: "XcmOriginKind",
      PalletInfoV4: "PalletInfoV3",
      WildFungibilityV4: "WildFungibilityV2",
      QueryResponseInfoV4: {
        destination: "MultiLocationV4",
        queryId: "Compact<u64>",
        maxWeight: "WeightV2"
      },
      ResponseV4: {
        _enum: {
          Null: "Null",
          Assets: "MultiAssetsV4",
          ExecutionResult: "Option<(u32, XcmErrorV3)>",
          Version: "u32",
          PalletsInfo: "Vec<PalletInfoV4>",
          DispatchResult: "MaybeErrorCodeV3"
        }
      },
      InstructionV4: {
        _enum: {
          WithdrawAsset: "MultiAssetsV4",
          ReserveAssetDeposited: "MultiAssetsV4",
          ReceiveTeleportedAsset: "MultiAssetsV4",
          QueryResponse: {
            queryId: "Compact<u64>",
            response: "ResponseV4",
            maxWeight: "WeightV2",
            querier: "Option<MultiLocationV4>"
          },
          TransferAsset: {
            assets: "MultiAssetsV4",
            beneficiary: "MultiLocationV4"
          },
          TransferReserveAsset: {
            assets: "MultiAssetsV4",
            dest: "MultiLocationV4",
            xcm: "XcmV4"
          },
          Transact: {
            originKind: "OriginKindV4",
            requireWeightAtMost: "WeightV2",
            call: "DoubleEncodedCall"
          },
          HrmpNewChannelOpenRequest: {
            sender: "Compact<u32>",
            maxMessageSize: "Compact<u32>",
            maxCapacity: "Compact<u32>"
          },
          HrmpChannelAccepted: {
            recipient: "Compact<u32>"
          },
          HrmpChannelClosing: {
            initiator: "Compact<u32>",
            sender: "Compact<u32>",
            recipient: "Compact<u32>"
          },
          ClearOrigin: "Null",
          DescendOrigin: "JunctionsV4",
          ReportError: "QueryResponseInfoV4",
          DepositAsset: {
            assets: "MultiAssetFilterV4",
            beneficiary: "MultiLocationV4"
          },
          DepositReserveAsset: {
            assets: "MultiAssetFilterV4",
            dest: "MultiLocationV4",
            xcm: "XcmV4"
          },
          ExchangeAsset: {
            give: "MultiAssetFilterV4",
            want: "MultiAssetsV4",
            maximal: "bool"
          },
          InitiateReserveWithdraw: {
            assets: "MultiAssetFilterV4",
            reserve: "MultiLocationV4",
            xcm: "XcmV4"
          },
          InitiateTeleport: {
            assets: "MultiAssetFilterV4",
            dest: "MultiLocationV4",
            xcm: "XcmV4"
          },
          ReportHolding: {
            responseInfo: "QueryResponseInfoV4",
            assets: "MultiAssetFilterV4"
          },
          BuyExecution: {
            fees: "MultiAssetV4",
            weightLimit: "WeightLimitV3"
          },
          RefundSurplus: "Null",
          SetErrorHandler: "XcmV4",
          SetAppendix: "XcmV4",
          ClearError: "Null",
          ClaimAsset: {
            assets: "MultiAssetsV4",
            ticket: "MultiLocationV4"
          },
          Trap: "Compact<u64>",
          SubscribeVersion: {
            queryId: "Compact<u64>",
            maxResponseWeight: "WeightV2"
          },
          UnsubscribeVersion: "Null",
          BurnAsset: "MultiAssetsV4",
          ExpectAsset: "MultiAssetsV4",
          ExpectOrigin: "Option<MultiLocationV4>",
          ExpectError: "Option<(u32, XcmErrorV3)>",
          ExpectTransactStatus: "MaybeErrorCodeV3",
          QueryPallet: {
            moduleName: "Vec<u8>",
            responseInfo: "QueryResponseInfoV4"
          },
          ExpectPallet: {
            index: "Compact<u32>",
            name: "Vec<u8>",
            moduleName: "Vec<u8>",
            crateMajor: "Compact<u32>",
            minCrateMinor: "Compact<u32>"
          },
          ReportTransactStatus: "QueryResponseInfoV4",
          ClearTransactStatus: "Null",
          UniversalOrigin: "JunctionV4",
          ExportMessage: {
            network: "NetworkIdV4",
            destination: "JunctionsV4",
            xcm: "XcmV4"
          },
          LockAsset: {
            asset: "MultiAssetV4",
            unlocker: "MultiLocationV4"
          },
          UnlockAsset: {
            asset: "MultiAssetV4",
            target: "MultiLocationV4"
          },
          NoteUnlockable: {
            asset: "MultiAssetV4",
            owner: "MultiLocationV4"
          },
          RequestUnlock: {
            asset: "MultiAssetV4",
            locker: "MultiLocationV4"
          },
          SetFeesMode: {
            jitWithdraw: "bool"
          },
          SetTopic: "[u8;32]",
          ClearTopic: "Null",
          AliasOrigin: "MultiLocationV4",
          UnpaidExecution: {
            weightLimit: "WeightLimitV3",
            checkOrigin: "Option<MultiLocationV4>"
          }
        }
      },
      OutcomeV4: {
        _enum: {
          Complete: {
            used: "WeightV2"
          },
          Incomplete: {
            used: "WeightV2",
            error: "XcmErrorV3"
          },
          Error: {
            error: "XcmErrorV3"
          }
        }
      },
      WildMultiAssetV4: {
        _enum: {
          All: "Null",
          AllOf: {
            id: "AssetIdV4",
            fun: "WildFungibilityV4"
          },
          AllCounted: "Compact<u32>",
          AllOfCounted: {
            id: "AssetIdV4",
            fun: "WildFungibilityV4",
            count: "Compact<u32>"
          }
        }
      },
      VersionV4: "u32",
      XcmV4: "Vec<InstructionV4>",
      XcmErrorV4: "XcmErrorV3"
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcm/definitions.js
var XCM_LATEST, xcm, location, definitions_default63;
var init_definitions63 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcm/definitions.js"() {
    init_types_create();
    init_v02();
    init_v16();
    init_v2();
    init_v3();
    init_v4();
    XCM_LATEST = "V4";
    xcm = {
      XcmOrigin: {
        _enum: {
          Xcm: "MultiLocation"
        }
      },
      XcmpMessageFormat: {
        _enum: ["ConcatenatedVersionedXcm", "ConcatenatedEncodedBlob", "Signals"]
      },
      XcmAssetId: {
        _enum: {
          Concrete: "MultiLocation",
          Abstract: "Bytes"
        }
      },
      InboundStatus: {
        _enum: ["Ok", "Suspended"]
      },
      OutboundStatus: {
        _enum: ["Ok", "Suspended"]
      },
      MultiAssets: "Vec<MultiAsset>"
    };
    location = {
      BodyId: {
        _enum: {
          Unit: "Null",
          Named: "Vec<u8>",
          Index: "Compact<u32>",
          Executive: "Null",
          Technical: "Null",
          Legislative: "Null",
          Judicial: "Null"
        }
      },
      BodyPart: {
        _enum: {
          Voice: "Null",
          Members: "Compact<u32>",
          Fraction: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          },
          AtLeastProportion: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          },
          MoreThanProportion: {
            nom: "Compact<u32>",
            denom: "Compact<u32>"
          }
        }
      },
      InteriorMultiLocation: "Junctions",
      NetworkId: {
        _enum: {
          Any: "Null",
          Named: "Vec<u8>",
          Polkadot: "Null",
          Kusama: "Null"
        }
      }
    };
    definitions_default63 = {
      rpc: {},
      types: {
        ...location,
        ...xcm,
        ...v02,
        ...v16,
        ...v2,
        ...v3,
        ...v4,
        ...mapXcmTypes(XCM_LATEST),
        DoubleEncodedCall: {
          encoded: "Bytes"
        },
        XcmOriginKind: {
          _enum: ["Native", "SovereignAccount", "Superuser", "Xcm"]
        },
        Outcome: {
          _enum: {
            Complete: "Weight",
            Incomplete: "(Weight, XcmErrorV0)",
            Error: "XcmErrorV0"
          }
        },
        QueryId: "u64",
        QueryStatus: {
          _enum: {
            Pending: {
              responder: "VersionedMultiLocation",
              maybeNotify: "Option<(u8, u8)>",
              timeout: "BlockNumber"
            },
            Ready: {
              response: "VersionedResponse",
              at: "BlockNumber"
            }
          }
        },
        QueueConfigData: {
          suspendThreshold: "u32",
          dropThreshold: "u32",
          resumeThreshold: "u32",
          thresholdWeight: "Weight",
          weightRestrictDecay: "Weight"
        },
        VersionMigrationStage: {
          _enum: {
            MigrateSupportedVersion: "Null",
            MigrateVersionNotifiers: "Null",
            NotifyCurrentTargets: "Option<Bytes>",
            MigrateAndNotifyOldTargets: "Null"
          }
        },
        VersionedMultiAsset: {
          _enum: {
            V0: "MultiAssetV0",
            V1: "MultiAssetV1",
            V2: "MultiAssetV2",
            V3: "MultiAssetV3",
            V4: "MultiAssetV4"
          }
        },
        VersionedMultiAssets: {
          _enum: {
            V0: "Vec<MultiAssetV0>",
            V1: "MultiAssetsV1",
            V2: "MultiAssetsV2",
            V3: "MultiAssetsV3",
            V4: "MultiAssetsV4"
          }
        },
        VersionedMultiLocation: {
          _enum: {
            V0: "MultiLocationV0",
            V1: "MultiLocationV1",
            V2: "MultiLocationV2",
            V3: "MultiLocationV3",
            V4: "MultiLocationV4"
          }
        },
        VersionedResponse: {
          V0: "ResponseV0",
          V1: "ResponseV1",
          V2: "ResponseV2",
          V3: "ResponseV3",
          V4: "ResponseV4"
        },
        VersionedXcm: {
          _enum: {
            V0: "XcmV0",
            V1: "XcmV1",
            V2: "XcmV2",
            V3: "XcmV3",
            V4: "XcmV4"
          }
        },
        XcmVersion: "u32"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcmPaymentApi/runtime.js
var runtime29;
var init_runtime29 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcmPaymentApi/runtime.js"() {
    runtime29 = {
      XcmPaymentApi: [
        {
          methods: {
            query_acceptable_payment_assets: {
              description: "The API to query acceptable payment assets",
              params: [
                {
                  name: "version",
                  type: "u32"
                }
              ],
              type: "Result<Vec<XcmVersionedAssetId>, XcmPaymentApiError>"
            },
            query_weight_to_asset_fee: {
              description: "",
              params: [
                {
                  name: "weight",
                  type: "WeightV2"
                },
                {
                  name: "asset",
                  type: "XcmVersionedAssetId"
                }
              ],
              type: "Result<u128, XcmPaymentApiError>"
            },
            query_xcm_weight: {
              description: "",
              params: [
                {
                  name: "message",
                  type: "XcmVersionedXcm"
                }
              ],
              type: "Result<WeightV2, XcmPaymentApiError>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcmPaymentApi/definitions.js
var definitions_default64;
var init_definitions64 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcmPaymentApi/definitions.js"() {
    init_runtime29();
    definitions_default64 = {
      rpc: {},
      runtime: runtime29,
      types: {
        XcmPaymentApiError: {
          _enum: [
            "Unimplemented",
            "VersionedConversionFailed",
            "WeightNotComputable",
            "UnhandledXcmVersion",
            "AssetNotFound"
          ]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcmRuntimeApi/runtime.js
var runtime30;
var init_runtime30 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcmRuntimeApi/runtime.js"() {
    runtime30 = {
      LocationToAccountApi: [
        {
          methods: {
            convert_location: {
              description: "Converts `Location` to `AccountId`",
              params: [
                {
                  name: "location",
                  type: "XcmVersionedLocation"
                }
              ],
              type: "Result<AccountId, Error>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/xcmRuntimeApi/definitions.js
var definitions_default65;
var init_definitions65 = __esm({
  "../../node_modules/@polkadot/types/interfaces/xcmRuntimeApi/definitions.js"() {
    init_runtime30();
    definitions_default65 = {
      rpc: {},
      runtime: runtime30,
      types: {
        Error: {
          _enum: ["Unsupported", "VersionedConversionFailed"]
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/contractsAbi/definitions.js
var layout, spec, latest, definitions_default66;
var init_definitions66 = __esm({
  "../../node_modules/@polkadot/types/interfaces/contractsAbi/definitions.js"() {
    layout = {
      ContractCryptoHasher: {
        _enum: ["Blake2x256", "Sha2x256", "Keccak256"]
      },
      ContractDiscriminant: "u32",
      ContractLayoutArray: {
        offset: "ContractLayoutKey",
        len: "u32",
        cellsPerElem: "u64",
        layout: "ContractStorageLayout"
      },
      ContractLayoutCell: {
        key: "ContractLayoutKey",
        ty: "SiLookupTypeId"
      },
      ContractLayoutEnum: {
        dispatchKey: "ContractLayoutKey",
        variants: "BTreeMap<ContractDiscriminant, ContractLayoutStruct>"
      },
      ContractLayoutHash: {
        offset: "ContractLayoutKey",
        strategy: "ContractLayoutHashingStrategy",
        layout: "ContractStorageLayout"
      },
      ContractLayoutHashingStrategy: {
        hasher: "ContractCryptoHasher",
        postfix: "Vec<u8>",
        prefix: "Vec<u8>"
      },
      ContractLayoutKey: "[u8; 32]",
      ContractLayoutStruct: {
        fields: "Vec<ContractLayoutStructField>"
      },
      ContractLayoutStructField: {
        layout: "ContractStorageLayout",
        name: "Text"
      },
      ContractStorageLayout: {
        _enum: {
          Cell: "ContractLayoutCell",
          Hash: "ContractLayoutHash",
          Array: "ContractLayoutArray",
          Struct: "ContractLayoutStruct",
          Enum: "ContractLayoutEnum"
        }
      }
    };
    spec = {
      ContractConstructorSpecV0: {
        name: "Text",
        selector: "ContractSelector",
        args: "Vec<ContractMessageParamSpecV0>",
        docs: "Vec<Text>"
      },
      ContractConstructorSpecV1: {
        name: "Vec<Text>",
        selector: "ContractSelector",
        args: "Vec<ContractMessageParamSpecV0>",
        docs: "Vec<Text>"
      },
      ContractConstructorSpecV2: {
        label: "Text",
        selector: "ContractSelector",
        args: "Vec<ContractMessageParamSpecV2>",
        docs: "Vec<Text>"
      },
      ContractConstructorSpecV3: {
        label: "Text",
        selector: "ContractSelector",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV2>",
        docs: "Vec<Text>"
      },
      ContractConstructorSpecV4: {
        label: "Text",
        selector: "ContractSelector",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV2>",
        docs: "Vec<Text>",
        default: "bool",
        returnType: "Option<ContractTypeSpec>"
      },
      ContractContractSpecV0: {
        constructors: "Vec<ContractConstructorSpecV0>",
        messages: "Vec<ContractMessageSpecV0>",
        events: "Vec<ContractEventSpecV0>",
        docs: "Vec<Text>"
      },
      ContractContractSpecV1: {
        constructors: "Vec<ContractConstructorSpecV1>",
        messages: "Vec<ContractMessageSpecV1>",
        events: "Vec<ContractEventSpecV1>",
        docs: "Vec<Text>"
      },
      ContractContractSpecV2: {
        constructors: "Vec<ContractConstructorSpecV2>",
        messages: "Vec<ContractMessageSpecV2>",
        events: "Vec<ContractEventSpecV2>",
        docs: "Vec<Text>"
      },
      ContractContractSpecV3: {
        constructors: "Vec<ContractConstructorSpecV3>",
        messages: "Vec<ContractMessageSpecV2>",
        events: "Vec<ContractEventSpecV2>",
        docs: "Vec<Text>"
      },
      ContractContractSpecV4: {
        constructors: "Vec<ContractConstructorSpecV4>",
        messages: "Vec<ContractMessageSpecV3>",
        events: "Vec<ContractEventSpecV2>",
        docs: "Vec<Text>",
        environment: "ContractEnvironmentV4"
      },
      ContractContractSpecV5: {
        constructors: "Vec<ContractConstructorSpecV4>",
        messages: "Vec<ContractMessageSpecV3>",
        events: "Vec<ContractEventSpecV3>",
        docs: "Vec<Text>",
        environment: "ContractEnvironmentV4"
      },
      ContractDisplayName: "SiPath",
      ContractEventParamSpecV0: {
        name: "Text",
        indexed: "bool",
        type: "ContractTypeSpec",
        docs: "Vec<Text>"
      },
      ContractEventParamSpecV2: {
        label: "Text",
        indexed: "bool",
        type: "ContractTypeSpec",
        docs: "Vec<Text>"
      },
      ContractEventSpecV0: {
        name: "Text",
        args: "Vec<ContractEventParamSpecV0>",
        docs: "Vec<Text>"
      },
      ContractEventSpecV1: {
        name: "Text",
        args: "Vec<ContractEventParamSpecV0>",
        docs: "Vec<Text>"
      },
      ContractEventSpecV2: {
        label: "Text",
        args: "Vec<ContractEventParamSpecV2>",
        docs: "Vec<Text>"
      },
      ContractEventSpecV3: {
        label: "Text",
        args: "Vec<ContractEventParamSpecV2>",
        docs: "Vec<Text>",
        module_path: "Text",
        signature_topic: "Option<[u8; 32]>"
      },
      ContractMessageParamSpecV0: {
        name: "Text",
        type: "ContractTypeSpec"
      },
      ContractMessageParamSpecV2: {
        label: "Text",
        type: "ContractTypeSpec"
      },
      ContractMessageSpecV0: {
        name: "Text",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV0>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>"
      },
      ContractMessageSpecV1: {
        name: "Vec<Text>",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV0>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>"
      },
      ContractMessageSpecV2: {
        label: "Text",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV2>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>"
      },
      ContractMessageSpecV3: {
        label: "Text",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV2>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>",
        default: "bool"
      },
      ContractSelector: "[u8; 4]",
      ContractTypeSpec: {
        type: "SiLookupTypeId",
        displayName: "ContractDisplayName"
      }
    };
    latest = {
      ContractConstructorSpecLatest: "ContractConstructorSpecV4",
      ContractEventSpecLatest: "ContractEventSpecV3",
      ContractEventParamSpecLatest: "ContractEventParamSpecV2",
      ContractMessageParamSpecLatest: "ContractMessageParamSpecV2",
      ContractMessageSpecLatest: "ContractMessageSpecV3",
      ContractMetadataLatest: "ContractMetadataV5"
    };
    definitions_default66 = {
      rpc: {},
      types: {
        ...layout,
        ...spec,
        ...latest,
        ContractProjectInfo: {
          source: "ContractProjectSource",
          contract: "ContractProjectContract"
        },
        ContractMetadataV0: {
          metadataVersion: "Text",
          types: "Vec<Si0Type>",
          spec: "ContractContractSpecV0"
        },
        ContractMetadataV1: {
          types: "Vec<PortableType>",
          spec: "ContractContractSpecV1"
        },
        ContractMetadataV2: {
          types: "Vec<PortableType>",
          spec: "ContractContractSpecV2"
        },
        ContractMetadataV3: {
          types: "Vec<PortableType>",
          spec: "ContractContractSpecV3"
        },
        ContractMetadataV4: {
          types: "Vec<PortableType>",
          spec: "ContractContractSpecV4",
          version: "Text"
        },
        ContractMetadataV5: {
          types: "Vec<PortableType>",
          spec: "ContractContractSpecV5",
          version: "u64"
        },
        ContractMetadata: {
          _enum: {
            V0: "ContractMetadataV0",
            V1: "ContractMetadataV1",
            V2: "ContractMetadataV2",
            V3: "ContractMetadataV3",
            V4: "ContractMetadataV4",
            V5: "ContractMetadataV5"
          }
        },
        ContractProjectV0: {
          metadataVersion: "Text",
          source: "ContractProjectSource",
          contract: "ContractProjectContract",
          types: "Vec<Si0Type>",
          spec: "ContractContractSpecV0"
        },
        ContractProject: "(ContractProjectInfo, ContractMetadata)",
        ContractProjectContract: {
          _alias: {
            docs: "documentation"
          },
          name: "Text",
          version: "Text",
          authors: "Vec<Text>",
          description: "Option<Text>",
          docs: "Option<Text>",
          repository: "Option<Text>",
          homepage: "Option<Text>",
          license: "Option<Text>"
        },
        ContractProjectSource: {
          _alias: {
            wasmHash: "hash"
          },
          wasmHash: "[u8; 32]",
          language: "Text",
          compiler: "Text",
          wasm: "Raw"
        },
        ContractEnvironmentV4: {
          _alias: {
            hashType: "hash"
          },
          // NOTE These are not marked optional in the Rust code, however since we
          // convert from older versions to newer, we may not have these fields.
          // The Option<...> works since our inputs are always JSON, so it will
          // be None when not specified.
          //
          // Additionally we don't mark the full structure as Option, rather we
          // do it on a per-field basis since fields may be added as the versions
          // progress.
          accountId: "Option<ContractTypeSpec>",
          balance: "Option<ContractTypeSpec>",
          blockNumber: "Option<ContractTypeSpec>",
          hashType: "Option<ContractTypeSpec>",
          timestamp: "Option<ContractTypeSpec>",
          maxEventTopics: "Option<u32>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/eth/rpc.js
var netRpc, web3Rpc, rpc10;
var init_rpc10 = __esm({
  "../../node_modules/@polkadot/types/interfaces/eth/rpc.js"() {
    netRpc = {
      listening: {
        aliasSection: "net",
        description: "Returns true if client is actively listening for network connections. Otherwise false.",
        params: [],
        type: "bool"
      },
      peerCount: {
        aliasSection: "net",
        description: "Returns number of peers connected to node.",
        params: [],
        type: "Text"
      },
      version: {
        aliasSection: "net",
        description: "Returns protocol version.",
        params: [],
        type: "Text"
      }
    };
    web3Rpc = {
      clientVersion: {
        aliasSection: "web3",
        description: "Returns current client version.",
        params: [],
        type: "Text"
      },
      sha3: {
        aliasSection: "web3",
        description: "Returns sha3 of the given data",
        params: [{ name: "data", type: "Bytes" }],
        type: "H256"
      }
    };
    rpc10 = {
      ...netRpc,
      ...web3Rpc,
      accounts: {
        description: "Returns accounts list.",
        params: [],
        type: "Vec<H160>"
      },
      blockNumber: {
        description: "Returns the blockNumber",
        params: [],
        type: "U256"
      },
      call: {
        description: "Call contract, returning the output data.",
        params: [
          {
            name: "request",
            type: "EthCallRequest"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "Bytes"
      },
      chainId: {
        description: "Returns the chain ID used for transaction signing at the current best block. None is returned if not available.",
        params: [],
        type: "U64"
      },
      coinbase: {
        description: "Returns block author.",
        params: [],
        type: "H160"
      },
      estimateGas: {
        description: "Estimate gas needed for execution of given contract.",
        params: [
          {
            name: "request",
            type: "EthCallRequest"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "U256"
      },
      feeHistory: {
        description: "Returns fee history for given block count & reward percentiles",
        params: [
          {
            name: "blockCount",
            type: "U256"
          },
          {
            name: "newestBlock",
            type: "BlockNumber"
          },
          {
            name: "rewardPercentiles",
            type: "Option<Vec<f64>>"
          }
        ],
        type: "EthFeeHistory"
      },
      gasPrice: {
        description: "Returns current gas price.",
        params: [],
        type: "U256"
      },
      getBalance: {
        description: "Returns balance of the given account.",
        params: [
          {
            name: "address",
            type: "H160"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "U256"
      },
      getBlockByHash: {
        description: "Returns block with given hash.",
        params: [
          {
            name: "hash",
            type: "H256"
          },
          {
            name: "full",
            type: "bool"
          }
        ],
        type: "Option<EthRichBlock>"
      },
      getBlockByNumber: {
        description: "Returns block with given number.",
        params: [
          {
            name: "block",
            type: "BlockNumber"
          },
          { name: "full", type: "bool" }
        ],
        type: "Option<EthRichBlock>"
      },
      getBlockTransactionCountByHash: {
        description: "Returns the number of transactions in a block with given hash.",
        params: [
          {
            name: "hash",
            type: "H256"
          }
        ],
        type: "U256"
      },
      getBlockTransactionCountByNumber: {
        description: "Returns the number of transactions in a block with given block number.",
        params: [
          {
            name: "block",
            type: "BlockNumber"
          }
        ],
        type: "U256"
      },
      getCode: {
        description: "Returns the code at given address at given time (block number).",
        params: [
          {
            name: "address",
            type: "H160"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "Bytes"
      },
      getFilterChanges: {
        description: "Returns filter changes since last poll.",
        params: [
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "EthFilterChanges"
      },
      getFilterLogs: {
        description: "Returns all logs matching given filter (in a range 'from' - 'to').",
        params: [
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "Vec<EthLog>"
      },
      getLogs: {
        description: "Returns logs matching given filter object.",
        params: [
          {
            name: "filter",
            type: "EthFilter"
          }
        ],
        type: "Vec<EthLog>"
      },
      getProof: {
        description: "Returns proof for account and storage.",
        params: [
          {
            name: "address",
            type: "H160"
          },
          {
            name: "storageKeys",
            type: "Vec<H256>"
          },
          {
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "EthAccount"
      },
      getStorageAt: {
        description: "Returns content of the storage at given address.",
        params: [
          {
            name: "address",
            type: "H160"
          },
          {
            name: "index",
            type: "U256"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "H256"
      },
      getTransactionByBlockHashAndIndex: {
        description: "Returns transaction at given block hash and index.",
        params: [
          {
            name: "hash",
            type: "H256"
          },
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "EthTransaction"
      },
      getTransactionByBlockNumberAndIndex: {
        description: "Returns transaction by given block number and index.",
        params: [
          {
            name: "number",
            type: "BlockNumber"
          },
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "EthTransaction"
      },
      getTransactionByHash: {
        description: "Get transaction by its hash.",
        params: [
          {
            name: "hash",
            type: "H256"
          }
        ],
        type: "EthTransaction"
      },
      getTransactionCount: {
        description: "Returns the number of transactions sent from given address at given time (block number).",
        params: [
          {
            name: "address",
            type: "H160"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "U256"
      },
      getTransactionReceipt: {
        description: "Returns transaction receipt by transaction hash.",
        params: [
          {
            name: "hash",
            type: "H256"
          }
        ],
        type: "EthReceipt"
      },
      getUncleByBlockHashAndIndex: {
        description: "Returns an uncles at given block and index.",
        params: [
          {
            name: "hash",
            type: "H256"
          },
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "EthRichBlock"
      },
      getUncleByBlockNumberAndIndex: {
        description: "Returns an uncles at given block and index.",
        params: [
          {
            name: "number",
            type: "BlockNumber"
          },
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "EthRichBlock"
      },
      getUncleCountByBlockHash: {
        description: "Returns the number of uncles in a block with given hash.",
        params: [
          {
            name: "hash",
            type: "H256"
          }
        ],
        type: "U256"
      },
      getUncleCountByBlockNumber: {
        description: "Returns the number of uncles in a block with given block number.",
        params: [
          {
            name: "number",
            type: "BlockNumber"
          }
        ],
        type: "U256"
      },
      getWork: {
        description: "Returns the hash of the current block, the seedHash, and the boundary condition to be met.",
        params: [],
        type: "EthWork"
      },
      hashrate: {
        description: "Returns the number of hashes per second that the node is mining with.",
        params: [],
        type: "U256"
      },
      maxPriorityFeePerGas: {
        description: "Returns max priority fee per gas",
        params: [],
        type: "U256"
      },
      mining: {
        description: "Returns true if client is actively mining new blocks.",
        params: [],
        type: "bool"
      },
      newBlockFilter: {
        description: "Returns id of new block filter.",
        params: [],
        type: "U256"
      },
      newFilter: {
        description: "Returns id of new filter.",
        params: [
          {
            name: "filter",
            type: "EthFilter"
          }
        ],
        type: "U256"
      },
      newPendingTransactionFilter: {
        description: "Returns id of new block filter.",
        params: [],
        type: "U256"
      },
      protocolVersion: {
        description: "Returns protocol version encoded as a string (quotes are necessary).",
        params: [],
        type: "u64"
      },
      sendRawTransaction: {
        description: "Sends signed transaction, returning its hash.",
        params: [
          {
            name: "bytes",
            type: "Bytes"
          }
        ],
        type: "H256"
      },
      sendTransaction: {
        description: "Sends transaction; will block waiting for signer to return the transaction hash",
        params: [
          {
            name: "tx",
            type: "EthTransactionRequest"
          }
        ],
        type: "H256"
      },
      submitHashrate: {
        description: "Used for submitting mining hashrate.",
        params: [
          {
            name: "index",
            type: "U256"
          },
          {
            name: "hash",
            type: "H256"
          }
        ],
        type: "bool"
      },
      submitWork: {
        description: "Used for submitting a proof-of-work solution.",
        params: [
          {
            name: "nonce",
            type: "H64"
          },
          {
            name: "headerHash",
            type: "H256"
          },
          {
            name: "mixDigest",
            type: "H256"
          }
        ],
        type: "bool"
      },
      subscribe: {
        description: "Subscribe to Eth subscription.",
        params: [
          { name: "kind", type: "EthSubKind" },
          {
            isOptional: true,
            name: "params",
            type: "EthSubParams"
          }
        ],
        pubsub: [
          "subscription",
          "subscribe",
          "unsubscribe"
        ],
        type: "Null"
      },
      syncing: {
        description: "Returns an object with data about the sync status or false.",
        params: [],
        type: "EthSyncStatus"
      },
      uninstallFilter: {
        description: "Uninstalls filter.",
        params: [
          {
            name: "index",
            type: "U256"
          }
        ],
        type: "bool"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/eth/runtime.js
var ethMethodsV4, ethMethodsV5, runtime31;
var init_runtime31 = __esm({
  "../../node_modules/@polkadot/types/interfaces/eth/runtime.js"() {
    ethMethodsV4 = {
      account_basic: {
        description: "Returns pallet_evm::Accounts by address.",
        params: [
          {
            name: "address",
            type: "H160"
          }
        ],
        type: "EvmAccount"
      },
      account_code_at: {
        description: "For a given account address, returns pallet_evm::AccountCodes.",
        params: [
          {
            name: "address",
            type: "H160"
          }
        ],
        type: "Bytes"
      },
      author: {
        description: "Returns the converted FindAuthor::find_author authority id.",
        params: [],
        type: "H160"
      },
      call: {
        description: "Returns a frame_ethereum::call response. If `estimate` is true,",
        params: [
          {
            name: "from",
            type: "H160"
          },
          {
            name: "to",
            type: "H160"
          },
          {
            name: "data",
            type: "Vec<u8>"
          },
          {
            name: "value",
            type: "U256"
          },
          {
            name: "gasLimit",
            type: "U256"
          },
          {
            name: "maxFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "nonce",
            type: "Option<U256>"
          },
          {
            name: "estimate",
            type: "bool"
          },
          {
            name: "accessList",
            type: "Option<Vec<(H160, Vec<H256>)>>"
          }
        ],
        type: "Result<EvmCallInfo, DispatchError>"
      },
      chain_id: {
        description: "Returns runtime defined pallet_evm::ChainId.",
        params: [],
        type: "u64"
      },
      create: {
        description: "Returns a frame_ethereum::call response. If `estimate` is true,",
        params: [
          {
            name: "from",
            type: "H160"
          },
          {
            name: "data",
            type: "Vec<u8>"
          },
          {
            name: "value",
            type: "U256"
          },
          {
            name: "gasLimit",
            type: "U256"
          },
          {
            name: "maxFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "nonce",
            type: "Option<U256>"
          },
          {
            name: "estimate",
            type: "bool"
          },
          {
            name: "accessList",
            type: "Option<Vec<(H160, Vec<H256>)>>"
          }
        ],
        type: "Result<EvmCreateInfo, DispatchError>"
      },
      current_all: {
        description: "Return all the current data for a block in a single runtime call.",
        params: [],
        type: "(Option<BlockV2>, Option<Vec<EthReceiptV3>>, Option<Vec<EthTransactionStatus>>)"
      },
      current_block: {
        description: "Return the current block.",
        params: [],
        type: "BlockV2"
      },
      current_receipts: {
        description: "Return the current receipt.",
        params: [],
        type: "Option<Vec<EthReceiptV3>>"
      },
      current_transaction_statuses: {
        description: "Return the current transaction status.",
        params: [],
        type: "Option<Vec<EthTransactionStatus>>"
      },
      elasticity: {
        description: "Return the elasticity multiplier.",
        params: [],
        type: "Option<Permill>"
      },
      extrinsic_filter: {
        description: "Receives a `Vec<OpaqueExtrinsic>` and filters all the ethereum transactions.",
        params: [
          {
            name: "xts",
            type: "Vec<Extrinsic>"
          }
        ],
        type: "Vec<TransactionV2>"
      },
      gas_price: {
        description: "Returns FixedGasPrice::min_gas_price",
        params: [],
        type: "u256"
      },
      storage_at: {
        description: "For a given account address and index, returns pallet_evm::AccountStorages.",
        params: [
          {
            name: "address",
            type: "H160"
          },
          {
            name: "index",
            type: "u256"
          }
        ],
        type: "H256"
      }
    };
    ethMethodsV5 = {
      call: {
        description: "Returns a frame_ethereum::call response. If `estimate` is true,",
        params: [
          {
            name: "from",
            type: "H160"
          },
          {
            name: "to",
            type: "H160"
          },
          {
            name: "data",
            type: "Vec<u8>"
          },
          {
            name: "value",
            type: "U256"
          },
          {
            name: "gasLimit",
            type: "U256"
          },
          {
            name: "maxFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "nonce",
            type: "Option<U256>"
          },
          {
            name: "estimate",
            type: "bool"
          },
          {
            name: "accessList",
            type: "Option<Vec<(H160, Vec<H256>)>>"
          }
        ],
        type: "Result<EvmCallInfoV2, DispatchError>"
      },
      create: {
        description: "Returns a frame_ethereum::call response. If `estimate` is true,",
        params: [
          {
            name: "from",
            type: "H160"
          },
          {
            name: "data",
            type: "Vec<u8>"
          },
          {
            name: "value",
            type: "U256"
          },
          {
            name: "gasLimit",
            type: "U256"
          },
          {
            name: "maxFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "maxPriorityFeePerGas",
            type: "Option<U256>"
          },
          {
            name: "nonce",
            type: "Option<U256>"
          },
          {
            name: "estimate",
            type: "bool"
          },
          {
            name: "accessList",
            type: "Option<Vec<(H160, Vec<H256>)>>"
          }
        ],
        type: "Result<EvmCreateInfoV2, DispatchError>"
      }
    };
    runtime31 = {
      ConvertTransactionRuntimeApi: [
        {
          methods: {
            convert_transaction: {
              description: "Converts an Ethereum-style transaction to Extrinsic",
              params: [
                {
                  name: "transaction",
                  type: "TransactionV2"
                }
              ],
              type: "Extrinsic"
            }
          },
          version: 2
        }
      ],
      DebugRuntimeApi: [
        {
          methods: {
            trace_block: {
              description: "Trace all block extrinsics",
              params: [
                {
                  name: "extrinsics",
                  type: "Vec<Extrinsic>"
                },
                {
                  name: "knownTransactions",
                  type: "Vec<H256>"
                }
              ],
              type: "Result<(), DispatchError>"
            },
            trace_transaction: {
              description: "Trace transaction extrinsics",
              params: [
                {
                  name: "extrinsics",
                  type: "Vec<Extrinsic>"
                },
                {
                  name: "transaction",
                  type: "EthTransaction"
                }
              ],
              type: "Result<(), DispatchError>"
            }
          },
          version: 4
        }
      ],
      EthereumRuntimeRPCApi: [
        {
          methods: {
            ...ethMethodsV4
          },
          version: 4
        },
        {
          methods: {
            ...ethMethodsV4,
            ...ethMethodsV5
          },
          version: 5
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/eth/definitions.js
var V0, V1, V2, types3, definitions_default67;
var init_definitions67 = __esm({
  "../../node_modules/@polkadot/types/interfaces/eth/definitions.js"() {
    init_rpc10();
    init_runtime31();
    V0 = {
      BlockV0: {
        header: "EthHeader",
        transactions: "Vec<TransactionV0>",
        ommers: "Vec<EthHeader>"
      },
      LegacyTransaction: {
        nonce: "U256",
        gasPrice: "U256",
        gasLimit: "U256",
        action: "EthTransactionAction",
        value: "U256",
        input: "Bytes",
        signature: "EthTransactionSignature"
      },
      TransactionV0: "LegacyTransaction"
    };
    V1 = {
      BlockV1: {
        header: "EthHeader",
        transactions: "Vec<TransactionV1>",
        ommers: "Vec<EthHeader>"
      },
      EIP2930Transaction: {
        chainId: "u64",
        nonce: "U256",
        gasPrice: "U256",
        gasLimit: "U256",
        action: "EthTransactionAction",
        value: "U256",
        input: "Bytes",
        accessList: "EthAccessList",
        oddYParity: "bool",
        r: "H256",
        s: "H256"
      },
      TransactionV1: {
        _enum: {
          Legacy: "LegacyTransaction",
          EIP2930: "EIP2930Transaction"
        }
      }
    };
    V2 = {
      BlockV2: {
        header: "EthHeader",
        transactions: "Vec<TransactionV2>",
        ommers: "Vec<EthHeader>"
      },
      EIP1559Transaction: {
        chainId: "u64",
        nonce: "U256",
        maxPriorityFeePerGas: "U256",
        maxFeePerGas: "U256",
        gasLimit: "U256",
        action: "EthTransactionAction",
        value: "U256",
        input: "Bytes",
        accessList: "EthAccessList",
        oddYParity: "bool",
        r: "H256",
        s: "H256"
      },
      TransactionV2: {
        _enum: {
          Legacy: "LegacyTransaction",
          EIP2930: "EIP2930Transaction",
          EIP1559: "EIP1559Transaction"
        }
      }
    };
    types3 = {
      ...V0,
      ...V1,
      ...V2,
      EthereumAccountId: "GenericEthereumAccountId",
      EthereumAddress: "GenericEthereumAccountId",
      EthereumLookupSource: "GenericEthereumLookupSource",
      EthereumSignature: "[u8; 65]",
      EthAccessListItem: {
        address: "EthAddress",
        slots: "Vec<H256>"
      },
      EthAccessList: "Vec<EthAccessListItem>",
      EthAccount: {
        address: "EthAddress",
        balance: "U256",
        nonce: "U256",
        codeHash: "H256",
        storageHash: "H256",
        accountProof: "Vec<Bytes>",
        storageProof: "Vec<EthStorageProof>"
      },
      EthAddress: "H160",
      EthBlock: {
        header: "EthHeader",
        transactions: "Vec<EthTransaction>",
        ommers: "Vec<EthHeader>"
      },
      EthHeader: {
        parentHash: "H256",
        ommersHash: "H256",
        beneficiary: "EthAddress",
        stateRoot: "H256",
        transactionsRoot: "H256",
        receiptsRoot: "H256",
        logsBloom: "EthBloom",
        difficulty: "U256",
        number: "U256",
        gasLimit: "U256",
        gasUsed: "U256",
        timestamp: "u64",
        extraData: "Bytes",
        mixMash: "H256",
        nonce: "H64"
      },
      EthRichBlock: {
        _alias: {
          blockHash: "hash",
          blockSize: "size"
        },
        blockHash: "Option<H256>",
        parentHash: "H256",
        sha3Uncles: "H256",
        author: "EthAddress",
        miner: "EthAddress",
        stateRoot: "H256",
        transactionsRoot: "H256",
        receiptsRoot: "H256",
        number: "Option<U256>",
        gasUsed: "U256",
        gasLimit: "U256",
        extraData: "Bytes",
        logsBloom: "EthBloom",
        timestamp: "U256",
        difficulty: "U256",
        totalDifficulty: "Option<U256>",
        sealFields: "Vec<Bytes>",
        uncles: "Vec<H256>",
        transactions: "Vec<EthTransaction>",
        blockSize: "Option<U256>"
      },
      EthBloom: "H2048",
      EthCallRequest: {
        from: "Option<EthAddress>",
        to: "Option<EthAddress>",
        gasPrice: "Option<U256>",
        gas: "Option<U256>",
        value: "Option<U256>",
        data: "Option<Bytes>",
        nonce: "Option<U256>"
      },
      EthFeeHistory: {
        oldestBlock: "U256",
        baseFeePerGas: "Vec<U256>",
        gasUsedRatio: "Vec<f64>",
        reward: "Option<Vec<Vec<U256>>>"
      },
      EthFilter: {
        fromBlock: "Option<BlockNumber>",
        toBlock: "Option<BlockNumber>",
        blockHash: "Option<H256>",
        address: "Option<EthFilterAddress>",
        topics: "Option<EthFilterTopic>"
      },
      EthFilterAddress: {
        _enum: {
          Single: "EthAddress",
          Multiple: "Vec<EthAddress>",
          Null: "Null"
        }
      },
      EthFilterChanges: {
        _enum: {
          Logs: "Vec<EthLog>",
          Hashes: "Vec<H256>",
          Empty: "Null"
        }
      },
      EthFilterTopic: {
        _enum: {
          Single: "EthFilterTopicInner",
          Multiple: "Vec<EthFilterTopicInner>",
          Null: "Null"
        }
      },
      EthFilterTopicEntry: "Option<H256>",
      EthFilterTopicInner: {
        _enum: {
          Single: "EthFilterTopicEntry",
          Multiple: "Vec<EthFilterTopicEntry>",
          Null: "Null"
        }
      },
      EthRichHeader: {
        _alias: {
          blockHash: "hash",
          blockSize: "size"
        },
        blockHash: "Option<H256>",
        parentHash: "H256",
        sha3Uncles: "H256",
        author: "EthAddress",
        miner: "EthAddress",
        stateRoot: "H256",
        transactionsRoot: "H256",
        receiptsRoot: "H256",
        number: "Option<U256>",
        gasUsed: "U256",
        gasLimit: "U256",
        extraData: "Bytes",
        logsBloom: "EthBloom",
        timestamp: "U256",
        difficulty: "U256",
        sealFields: "Vec<Bytes>",
        blockSize: "Option<U256>"
      },
      EthLog: {
        address: "EthAddress",
        topics: "Vec<H256>",
        data: "Bytes",
        blockHash: "Option<H256>",
        blockNumber: "Option<U256>",
        transactionHash: "Option<H256>",
        transactionIndex: "Option<U256>",
        logIndex: "Option<U256>",
        transactionLogIndex: "Option<U256>",
        removed: "bool"
      },
      EthReceipt: {
        transactionHash: "Option<H256>",
        transactionIndex: "Option<U256>",
        blockHash: "Option<H256>",
        from: "Option<EthAddress>",
        to: "Option<EthAddress>",
        blockNumber: "Option<U256>",
        cumulativeGasUsed: "U256",
        gasUsed: "Option<U256>",
        contractAddress: "Option<EthAddress>",
        logs: "Vec<EthLog>",
        root: "Option<H256>",
        logsBloom: "EthBloom",
        statusCode: "Option<U64>"
      },
      // not convinced, however the original commit matches, so... (maybe V3 is incorrect?)
      EthReceiptV0: "EthReceipt",
      EthReceiptV3: "EthReceipt",
      EthStorageProof: {
        key: "U256",
        value: "U256",
        proof: "Vec<Bytes>"
      },
      EthSubKind: {
        _enum: ["newHeads", "logs", "newPendingTransactions", "syncing"]
      },
      EthSubParams: {
        _enum: {
          None: "Null",
          Logs: "EthFilter"
        }
      },
      EthSubResult: {
        _enum: {
          Header: "EthRichHeader",
          Log: "EthLog",
          TransactionHash: "H256",
          SyncState: "EthSyncStatus"
        }
      },
      EthSyncInfo: {
        startingBlock: "U256",
        currentBlock: "U256",
        highestBlock: "U256",
        warpChunksAmount: "Option<U256>",
        warpChunksProcessed: "Option<U256>"
      },
      EthSyncStatus: {
        _enum: {
          Info: "EthSyncInfo",
          None: "Null"
        }
      },
      EthTransaction: {
        hash: "H256",
        nonce: "U256",
        blockHash: "Option<H256>",
        blockNumber: "Option<U256>",
        transactionIndex: "Option<U256>",
        from: "H160",
        to: "Option<H160>",
        value: "U256",
        gasPrice: "Option<U256>",
        maxFeePerGas: "Option<U256>",
        maxPriorityFeePerGas: "Option<U256>",
        gas: "U256",
        input: "Bytes",
        creates: "Option<H160>",
        raw: "Bytes",
        publicKey: "Option<H512>",
        chainId: "Option<U64>",
        standardV: "U256",
        v: "U256",
        r: "U256",
        s: "U256",
        accessList: "Option<Vec<EthAccessListItem>>",
        transactionType: "Option<U256>"
      },
      EthTransactionSignature: {
        v: "u64",
        r: "H256",
        s: "H256"
      },
      EthTransactionAction: {
        _enum: {
          Call: "H160",
          Create: "Null"
        }
      },
      EthTransactionCondition: {
        _enum: {
          block: "u64",
          time: "u64"
        }
      },
      EthTransactionRequest: {
        from: "Option<EthAddress>",
        to: "Option<EthAddress>",
        gasPrice: "Option<U256>",
        gas: "Option<U256>",
        value: "Option<U256>",
        data: "Option<Bytes>",
        nonce: "Option<U256>"
      },
      EthTransactionStatus: {
        transactionHash: "H256",
        transactionIndex: "u32",
        from: "EthAddress",
        to: "Option<EthAddress>",
        contractAddress: "Option<EthAddress>",
        logs: "Vec<EthLog>",
        logsBloom: "EthBloom"
      },
      EthWork: {
        powHash: "H256",
        seedHash: "H256",
        target: "H256",
        number: "Option<u64>"
      }
    };
    definitions_default67 = { rpc: rpc10, runtime: runtime31, types: types3 };
  }
});

// ../../node_modules/@polkadot/types/interfaces/nimbus/runtime.js
var runtime32;
var init_runtime32 = __esm({
  "../../node_modules/@polkadot/types/interfaces/nimbus/runtime.js"() {
    runtime32 = {
      // deprecated, the NimbusApi is current - this is for backwards compat
      AuthorFilterAPI: [
        {
          methods: {
            can_author: {
              description: "The runtime api used to predict whether an author will be eligible in the given slot",
              params: [
                {
                  name: "author",
                  type: "AccountId"
                },
                {
                  name: "relayParent",
                  type: "u32"
                },
                {
                  name: "parentHeader",
                  type: "Header"
                }
              ],
              type: "bool"
            }
          },
          version: 2
        },
        {
          methods: {
            can_author: {
              description: "The runtime api used to predict whether an author will be eligible in the given slot",
              params: [
                {
                  name: "author",
                  type: "AccountId"
                },
                {
                  name: "relayParent",
                  type: "u32"
                }
              ],
              type: "bool"
            }
          },
          version: 1
        }
      ],
      NimbusApi: [
        {
          methods: {
            can_author: {
              description: "The runtime api used to predict whether a Nimbus author will be eligible in the given slot",
              params: [
                {
                  name: "author",
                  type: "AccountId"
                },
                {
                  name: "relayParent",
                  type: "u32"
                },
                {
                  name: "parentHeader",
                  type: "Header"
                }
              ],
              type: "bool"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/nimbus/definitions.js
var definitions_default68;
var init_definitions68 = __esm({
  "../../node_modules/@polkadot/types/interfaces/nimbus/definitions.js"() {
    init_runtime32();
    definitions_default68 = {
      rpc: {},
      runtime: runtime32,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/ormlOracle/runtime.js
var runtime33;
var init_runtime33 = __esm({
  "../../node_modules/@polkadot/types/interfaces/ormlOracle/runtime.js"() {
    runtime33 = {
      // https://github.com/open-web3-stack/open-runtime-module-library/blob/b57f88b39cd547e2fb51727d8bb9bcc64fddf8b5/oracle/rpc/runtime-api/src/lib.rs#L12-L21
      OracleApi: [
        {
          methods: {
            get_all_values: {
              description: "Retrieves all values",
              params: [
                {
                  name: "providerId",
                  // This is a Codec type
                  type: "Raw"
                }
              ],
              // This won't actually work as expected - since we have
              // no information about the actual Raw sizes, we cannot
              // handle it in this format (it would need an override
              // for the specific Codec). So return the Raw value.
              // type: 'Vec<(Raw, Option<Raw>)>'
              type: "Raw"
            },
            get_value: {
              description: "Retrieves a single value",
              params: [
                {
                  name: "providerId",
                  // This is a Codec type
                  type: "Raw"
                },
                {
                  name: "key",
                  // This is a Codec type
                  type: "Raw"
                }
              ],
              // This is an Option<Codec> type
              type: "Option<Raw>"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/ormlOracle/definitions.js
var definitions_default69;
var init_definitions69 = __esm({
  "../../node_modules/@polkadot/types/interfaces/ormlOracle/definitions.js"() {
    init_runtime33();
    definitions_default69 = {
      rpc: {},
      runtime: runtime33,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/ormlTokens/runtime.js
var runtime34;
var init_runtime34 = __esm({
  "../../node_modules/@polkadot/types/interfaces/ormlTokens/runtime.js"() {
    runtime34 = {
      // https://github.com/open-web3-stack/open-runtime-module-library/blob/b57f88b39cd547e2fb51727d8bb9bcc64fddf8b5/tokens/rpc/runtime-api/src/lib.rs#L11-L18
      TokensApi: [
        {
          methods: {
            query_existential_deposit: {
              description: "Query the existential amount for a specific currency",
              params: [
                {
                  name: "currencyId",
                  // This is CurrencyId, as per the return value, we are unsure
                  // if this is specialized and/or global to the chain or not
                  type: "Raw"
                }
              ],
              // This is Balance - since we don't understand enough about the way
              // in which this is used, we default to u128 here (it certainly could
              // be a specialized type that doesn't map to the on-chain Balance)
              type: "u128"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/ormlTokens/definitions.js
var definitions_default70;
var init_definitions70 = __esm({
  "../../node_modules/@polkadot/types/interfaces/ormlTokens/definitions.js"() {
    init_runtime34();
    definitions_default70 = {
      rpc: {},
      runtime: runtime34,
      types: {}
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/rpc/rpc.js
var rpc11;
var init_rpc11 = __esm({
  "../../node_modules/@polkadot/types/interfaces/rpc/rpc.js"() {
    rpc11 = {
      methods: {
        description: "Retrieves the list of RPC methods that are exposed by the node",
        params: [],
        type: "RpcMethods"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/rpc/definitions.js
var definitions_default71;
var init_definitions71 = __esm({
  "../../node_modules/@polkadot/types/interfaces/rpc/definitions.js"() {
    init_rpc11();
    definitions_default71 = {
      rpc: rpc11,
      types: {
        RpcMethods: {
          version: "u32",
          methods: "Vec<Text>"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/author/rpc.js
var rpc12;
var init_rpc12 = __esm({
  "../../node_modules/@polkadot/types/interfaces/author/rpc.js"() {
    rpc12 = {
      hasKey: {
        description: "Returns true if the keystore has private keys for the given public key and key type.",
        isUnsafe: true,
        params: [
          {
            name: "publicKey",
            type: "Bytes"
          },
          {
            name: "keyType",
            type: "Text"
          }
        ],
        type: "bool"
      },
      hasSessionKeys: {
        description: "Returns true if the keystore has private keys for the given session public keys.",
        isUnsafe: true,
        params: [
          {
            name: "sessionKeys",
            type: "Bytes"
          }
        ],
        type: "bool"
      },
      insertKey: {
        description: "Insert a key into the keystore.",
        isUnsafe: true,
        params: [
          {
            name: "keyType",
            type: "Text"
          },
          {
            name: "suri",
            type: "Text"
          },
          {
            name: "publicKey",
            type: "Bytes"
          }
        ],
        type: "Bytes"
      },
      pendingExtrinsics: {
        description: "Returns all pending extrinsics, potentially grouped by sender",
        params: [],
        type: "Vec<Extrinsic>"
      },
      removeExtrinsic: {
        description: "Remove given extrinsic from the pool and temporarily ban it to prevent reimporting",
        isUnsafe: true,
        params: [
          {
            name: "bytesOrHash",
            type: "Vec<ExtrinsicOrHash>"
          }
        ],
        type: "Vec<Hash>"
      },
      rotateKeys: {
        description: "Generate new session keys and returns the corresponding public keys",
        isUnsafe: true,
        params: [],
        type: "Bytes"
      },
      submitAndWatchExtrinsic: {
        description: "Submit and subscribe to watch an extrinsic until unsubscribed",
        isSigned: true,
        params: [
          {
            name: "extrinsic",
            type: "Extrinsic"
          }
        ],
        pubsub: [
          "extrinsicUpdate",
          "submitAndWatchExtrinsic",
          "unwatchExtrinsic"
        ],
        type: "ExtrinsicStatus"
      },
      submitExtrinsic: {
        description: "Submit a fully formatted extrinsic for block inclusion",
        isSigned: true,
        params: [
          {
            name: "extrinsic",
            type: "Extrinsic"
          }
        ],
        type: "Hash"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/author/definitions.js
var definitions_default72;
var init_definitions72 = __esm({
  "../../node_modules/@polkadot/types/interfaces/author/definitions.js"() {
    init_rpc12();
    definitions_default72 = {
      rpc: rpc12,
      types: {
        ExtrinsicOrHash: {
          _enum: {
            Hash: "Hash",
            Extrinsic: "Bytes"
          }
        },
        ExtrinsicStatus: {
          _enum: {
            Future: "Null",
            Ready: "Null",
            Broadcast: "Vec<Text>",
            InBlock: "Hash",
            Retracted: "Hash",
            FinalityTimeout: "Hash",
            Finalized: "Hash",
            Usurped: "Hash",
            Dropped: "Null",
            Invalid: "Null"
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/chain/rpc.js
var rpc13;
var init_rpc13 = __esm({
  "../../node_modules/@polkadot/types/interfaces/chain/rpc.js"() {
    rpc13 = {
      getBlock: {
        description: "Get header and body of a relay chain block",
        params: [
          {
            isHistoric: true,
            isOptional: true,
            name: "hash",
            type: "BlockHash"
          }
        ],
        type: "SignedBlock"
      },
      getBlockHash: {
        description: "Get the block hash for a specific block",
        params: [
          {
            isOptional: true,
            name: "blockNumber",
            type: "BlockNumber"
          }
        ],
        type: "BlockHash"
      },
      getFinalizedHead: {
        alias: ["chain_getFinalisedHead"],
        description: "Get hash of the last finalized block in the canon chain",
        params: [],
        type: "BlockHash"
      },
      getHeader: {
        alias: ["chain_getHead"],
        description: "Retrieves the header for a specific block",
        params: [
          {
            isHistoric: true,
            isOptional: true,
            name: "hash",
            type: "BlockHash"
          }
        ],
        type: "Header"
      },
      subscribeAllHeads: {
        description: "Retrieves the newest header via subscription",
        params: [],
        pubsub: [
          "allHead",
          "subscribeAllHeads",
          "unsubscribeAllHeads"
        ],
        type: "Header"
      },
      subscribeFinalizedHeads: {
        alias: ["chain_subscribeFinalisedHeads", "chain_unsubscribeFinalisedHeads"],
        description: "Retrieves the best finalized header via subscription",
        params: [],
        pubsub: [
          "finalizedHead",
          "subscribeFinalizedHeads",
          "unsubscribeFinalizedHeads"
        ],
        type: "Header"
      },
      subscribeNewHeads: {
        alias: ["chain_unsubscribeNewHeads", "subscribe_newHead", "unsubscribe_newHead"],
        description: "Retrieves the best header via subscription",
        params: [],
        // NOTE These still has the aliassed version, compatible with 1.x
        pubsub: [
          "newHead",
          "subscribeNewHead",
          "unsubscribeNewHead"
        ],
        type: "Header"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/chain/definitions.js
var definitions_default73;
var init_definitions73 = __esm({
  "../../node_modules/@polkadot/types/interfaces/chain/definitions.js"() {
    init_rpc13();
    definitions_default73 = {
      rpc: rpc13,
      types: {
        BlockHash: "Hash"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/childstate/rpc.js
var rpc14;
var init_rpc14 = __esm({
  "../../node_modules/@polkadot/types/interfaces/childstate/rpc.js"() {
    rpc14 = {
      getKeys: {
        description: "Returns the keys with prefix from a child storage, leave empty to get all the keys",
        params: [
          {
            name: "childKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "prefix",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Vec<StorageKey>"
      },
      getKeysPaged: {
        alias: ["childstate_getKeysPagedAt"],
        description: "Returns the keys with prefix from a child storage with pagination support",
        params: [
          {
            name: "childKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "prefix",
            type: "StorageKey"
          },
          {
            name: "count",
            type: "u32"
          },
          {
            isOptional: true,
            name: "startKey",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Vec<StorageKey>"
      },
      getStorage: {
        description: "Returns a child storage entry at a specific block state",
        params: [
          {
            name: "childKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Option<StorageData>"
      },
      getStorageEntries: {
        description: "Returns child storage entries for multiple keys at a specific block state",
        params: [
          {
            name: "childKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "keys",
            type: "Vec<StorageKey>"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Vec<Option<StorageData>>"
      },
      getStorageHash: {
        description: "Returns the hash of a child storage entry at a block state",
        params: [
          {
            name: "childKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Option<Hash>"
      },
      getStorageSize: {
        description: "Returns the size of a child storage entry at a block state",
        params: [
          {
            name: "childKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "Hash"
          }
        ],
        type: "Option<u64>"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/childstate/definitions.js
var definitions_default74;
var init_definitions74 = __esm({
  "../../node_modules/@polkadot/types/interfaces/childstate/definitions.js"() {
    init_rpc14();
    definitions_default74 = {
      rpc: rpc14,
      types: {
        // StorageKey extends Bytes
        PrefixedStorageKey: "StorageKey"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/offchain/rpc.js
var rpc15;
var init_rpc15 = __esm({
  "../../node_modules/@polkadot/types/interfaces/offchain/rpc.js"() {
    rpc15 = {
      localStorageGet: {
        description: "Get offchain local storage under given key and prefix",
        isUnsafe: true,
        params: [
          {
            name: "kind",
            type: "StorageKind"
          },
          {
            name: "key",
            type: "Bytes"
          }
        ],
        type: "Option<Bytes>"
      },
      localStorageSet: {
        description: "Set offchain local storage under given key and prefix",
        isUnsafe: true,
        params: [
          {
            name: "kind",
            type: "StorageKind"
          },
          {
            name: "key",
            type: "Bytes"
          },
          {
            name: "value",
            type: "Bytes"
          }
        ],
        type: "Null"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/offchain/runtime.js
var runtime35;
var init_runtime35 = __esm({
  "../../node_modules/@polkadot/types/interfaces/offchain/runtime.js"() {
    runtime35 = {
      OffchainWorkerApi: [
        {
          methods: {
            offchain_worker: {
              description: "Starts the off-chain task for given block header.",
              params: [
                {
                  name: "header",
                  type: "Header"
                }
              ],
              type: "Null"
            }
          },
          version: 2
        },
        {
          methods: {
            offchain_worker: {
              description: "Starts the off-chain task for given block header.",
              params: [
                {
                  name: "number",
                  type: "BlockNumber"
                }
              ],
              type: "Null"
            }
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/offchain/definitions.js
var definitions_default75;
var init_definitions75 = __esm({
  "../../node_modules/@polkadot/types/interfaces/offchain/definitions.js"() {
    init_rpc15();
    init_runtime35();
    definitions_default75 = {
      rpc: rpc15,
      runtime: runtime35,
      types: {
        StorageKind: {
          _enum: {
            PERSISTENT: 1,
            LOCAL: 2
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/payment/rpc.js
var rpc16;
var init_rpc16 = __esm({
  "../../node_modules/@polkadot/types/interfaces/payment/rpc.js"() {
    rpc16 = {
      queryFeeDetails: {
        // NOTE: Not deprecated (yet) in Substrate, but it is the intent to do so
        deprecated: "Use `api.call.transactionPaymentApi.queryFeeDetails` instead",
        description: "Query the detailed fee of a given encoded extrinsic",
        params: [
          {
            name: "extrinsic",
            type: "Bytes"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "FeeDetails"
      },
      queryInfo: {
        // NOTE: Not deprecated (yet) in Substrate, but it is the intent to do so
        deprecated: "Use `api.call.transactionPaymentApi.queryInfo` instead",
        description: "Retrieves the fee information for an encoded extrinsic",
        params: [
          {
            name: "extrinsic",
            type: "Bytes"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        // NOTE: Stuck on V1 forever (at least for the time being)
        type: "RuntimeDispatchInfoV1"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/payment/runtime.js
var V1_TO_V4_SHARED_PAY, V1_TO_V3_SHARED_CALL, V2_TO_V4_SHARED_PAY, V2_V3_SHARED_CALL, V3_SHARED_PAY_CALL, runtime36;
var init_runtime36 = __esm({
  "../../node_modules/@polkadot/types/interfaces/payment/runtime.js"() {
    V1_TO_V4_SHARED_PAY = {
      query_fee_details: {
        description: "The transaction fee details",
        params: [
          {
            name: "uxt",
            type: "Extrinsic"
          },
          {
            name: "len",
            type: "u32"
          }
        ],
        type: "FeeDetails"
      }
    };
    V1_TO_V3_SHARED_CALL = {
      query_call_fee_details: {
        description: "The call fee details",
        params: [
          {
            name: "call",
            type: "Call"
          },
          {
            name: "len",
            type: "u32"
          }
        ],
        type: "FeeDetails"
      }
    };
    V2_TO_V4_SHARED_PAY = {
      query_info: {
        description: "The transaction info",
        params: [
          {
            name: "uxt",
            type: "Extrinsic"
          },
          {
            name: "len",
            type: "u32"
          }
        ],
        type: "RuntimeDispatchInfo"
      }
    };
    V2_V3_SHARED_CALL = {
      query_call_info: {
        description: "The call info",
        params: [
          {
            name: "call",
            type: "Call"
          },
          {
            name: "len",
            type: "u32"
          }
        ],
        type: "RuntimeDispatchInfo"
      }
    };
    V3_SHARED_PAY_CALL = {
      query_length_to_fee: {
        description: "Query the output of the current LengthToFee given some input",
        params: [
          {
            name: "length",
            type: "u32"
          }
        ],
        type: "Balance"
      },
      query_weight_to_fee: {
        description: "Query the output of the current WeightToFee given some input",
        params: [
          {
            name: "weight",
            type: "Weight"
          }
        ],
        type: "Balance"
      }
    };
    runtime36 = {
      TransactionPaymentApi: [
        {
          // V4 is equivalent to V3 (V4 just dropped all V1 references)
          methods: {
            ...V3_SHARED_PAY_CALL,
            ...V2_TO_V4_SHARED_PAY,
            ...V1_TO_V4_SHARED_PAY
          },
          version: 4
        },
        {
          methods: {
            ...V3_SHARED_PAY_CALL,
            ...V2_TO_V4_SHARED_PAY,
            ...V1_TO_V4_SHARED_PAY
          },
          version: 3
        },
        {
          methods: {
            ...V2_TO_V4_SHARED_PAY,
            ...V1_TO_V4_SHARED_PAY
          },
          version: 2
        },
        {
          methods: {
            query_info: {
              description: "The transaction info",
              params: [
                {
                  name: "uxt",
                  type: "Extrinsic"
                },
                {
                  name: "len",
                  type: "u32"
                }
              ],
              // NOTE: _Should_ be V1 (as per current Substrate), however the interface was
              // changed mid-flight between versions. So we have some of each depending on
              // runtime. (We do detect the weight type, so correct)
              type: "RuntimeDispatchInfo"
            },
            ...V1_TO_V4_SHARED_PAY
          },
          version: 1
        }
      ],
      TransactionPaymentCallApi: [
        {
          methods: {
            ...V3_SHARED_PAY_CALL,
            ...V2_V3_SHARED_CALL,
            ...V1_TO_V3_SHARED_CALL
          },
          version: 3
        },
        {
          methods: {
            ...V2_V3_SHARED_CALL,
            ...V1_TO_V3_SHARED_CALL
          },
          version: 2
        },
        {
          methods: {
            CALL: {
              description: "The call info",
              params: [
                {
                  name: "call",
                  type: "Call"
                },
                {
                  name: "len",
                  type: "u32"
                }
              ],
              // NOTE: As per the above comment, the below is correct according to Substrate, but
              // _may_ yield fallback decoding on some versions of the runtime
              type: "RuntimeDispatchInfo"
            },
            ...V1_TO_V3_SHARED_CALL
          },
          version: 1
        }
      ]
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/payment/definitions.js
var definitions_default76;
var init_definitions76 = __esm({
  "../../node_modules/@polkadot/types/interfaces/payment/definitions.js"() {
    init_rpc16();
    init_runtime36();
    definitions_default76 = {
      rpc: rpc16,
      runtime: runtime36,
      types: {
        FeeDetails: {
          inclusionFee: "Option<InclusionFee>"
          // skipped in serde
          // tip: 'Balance'
        },
        InclusionFee: {
          baseFee: "Balance",
          lenFee: "Balance",
          adjustedWeightFee: "Balance"
        },
        RuntimeDispatchInfo: {
          weight: "Weight",
          class: "DispatchClass",
          partialFee: "Balance"
        },
        RuntimeDispatchInfoV1: {
          weight: "WeightV1",
          class: "DispatchClass",
          partialFee: "Balance"
        },
        RuntimeDispatchInfoV2: {
          weight: "WeightV2",
          class: "DispatchClass",
          partialFee: "Balance"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/state/rpc.js
var rpc17;
var init_rpc17 = __esm({
  "../../node_modules/@polkadot/types/interfaces/state/rpc.js"() {
    rpc17 = {
      call: {
        alias: ["state_callAt"],
        description: "Perform a call to a builtin on the chain",
        params: [
          {
            name: "method",
            type: "Text"
          },
          {
            name: "data",
            type: "Bytes"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Bytes"
      },
      getChildKeys: {
        description: "Retrieves the keys with prefix of a specific child storage",
        params: [
          {
            name: "childStorageKey",
            type: "StorageKey"
          },
          {
            name: "childDefinition",
            type: "StorageKey"
          },
          {
            name: "childType",
            type: "u32"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Vec<StorageKey>"
      },
      getChildReadProof: {
        description: "Returns proof of storage for child key entries at a specific block state.",
        params: [
          {
            name: "childStorageKey",
            type: "PrefixedStorageKey"
          },
          {
            name: "keys",
            type: "Vec<StorageKey>"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "ReadProof"
      },
      getChildStorage: {
        description: "Retrieves the child storage for a key",
        params: [
          {
            name: "childStorageKey",
            type: "StorageKey"
          },
          {
            name: "childDefinition",
            type: "StorageKey"
          },
          {
            name: "childType",
            type: "u32"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "StorageData"
      },
      getChildStorageHash: {
        description: "Retrieves the child storage hash",
        params: [
          {
            name: "childStorageKey",
            type: "StorageKey"
          },
          {
            name: "childDefinition",
            type: "StorageKey"
          },
          {
            name: "childType",
            type: "u32"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Hash"
      },
      getChildStorageSize: {
        description: "Retrieves the child storage size",
        params: [
          {
            name: "childStorageKey",
            type: "StorageKey"
          },
          {
            name: "childDefinition",
            type: "StorageKey"
          },
          {
            name: "childType",
            type: "u32"
          },
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "u64"
      },
      getKeys: {
        deprecated: "Use `api.rpc.state.getKeysPaged` to retrieve keys",
        description: "Retrieves the keys with a certain prefix",
        params: [
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Vec<StorageKey>"
      },
      getKeysPaged: {
        alias: ["state_getKeysPagedAt"],
        description: "Returns the keys with prefix with pagination support.",
        params: [
          {
            name: "key",
            type: "StorageKey"
          },
          {
            name: "count",
            type: "u32"
          },
          {
            isOptional: true,
            name: "startKey",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Vec<StorageKey>"
      },
      getMetadata: {
        description: "Returns the runtime metadata",
        params: [
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Metadata"
      },
      getPairs: {
        deprecated: "Use `api.rpc.state.getKeysPaged` to retrieve keys",
        description: "Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)",
        isUnsafe: true,
        params: [
          {
            name: "prefix",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Vec<KeyValue>"
      },
      getReadProof: {
        description: "Returns proof of storage entries at a specific block state",
        params: [
          {
            name: "keys",
            type: "Vec<StorageKey>"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "ReadProof"
      },
      getRuntimeVersion: {
        alias: ["chain_getRuntimeVersion"],
        description: "Get the runtime version",
        params: [
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "RuntimeVersion"
      },
      getStorage: {
        alias: ["state_getStorageAt"],
        description: "Retrieves the storage for a key",
        params: [
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "StorageData"
      },
      getStorageHash: {
        alias: ["state_getStorageHashAt"],
        description: "Retrieves the storage hash",
        params: [
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Hash"
      },
      getStorageSize: {
        alias: ["state_getStorageSizeAt"],
        description: "Retrieves the storage size",
        params: [
          {
            name: "key",
            type: "StorageKey"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "u64"
      },
      queryStorage: {
        description: "Query historical storage entries (by key) starting from a start block",
        isUnsafe: true,
        params: [
          {
            name: "keys",
            type: "Vec<StorageKey>"
          },
          {
            name: "fromBlock",
            type: "Hash"
          },
          {
            isOptional: true,
            name: "toBlock",
            type: "BlockHash"
          }
        ],
        type: "Vec<StorageChangeSet>"
      },
      queryStorageAt: {
        description: "Query storage entries (by key) starting at block hash given as the second parameter",
        params: [
          {
            name: "keys",
            type: "Vec<StorageKey>"
          },
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "Vec<StorageChangeSet>"
      },
      subscribeRuntimeVersion: {
        alias: ["chain_subscribeRuntimeVersion", "chain_unsubscribeRuntimeVersion"],
        description: "Retrieves the runtime version via subscription",
        params: [],
        pubsub: [
          "runtimeVersion",
          "subscribeRuntimeVersion",
          "unsubscribeRuntimeVersion"
        ],
        type: "RuntimeVersion"
      },
      subscribeStorage: {
        description: "Subscribes to storage changes for the provided keys",
        // NOTE Just marking it here to follow the logic - this is unsafe when no
        // keys are provided (i.e. subscribing to all), generally this is used
        // extensively with normal subscriptions
        // isUnsafe: true,
        params: [
          {
            isOptional: true,
            name: "keys",
            type: "Vec<StorageKey>"
          }
        ],
        pubsub: [
          "storage",
          "subscribeStorage",
          "unsubscribeStorage"
        ],
        type: "StorageChangeSet"
      },
      traceBlock: {
        description: "Provides a way to trace the re-execution of a single block",
        isUnsafe: true,
        params: [
          {
            name: "block",
            type: "Hash"
          },
          {
            name: "targets",
            type: "Option<Text>"
          },
          {
            name: "storageKeys",
            type: "Option<Text>"
          },
          {
            name: "methods",
            type: "Option<Text>"
          }
        ],
        type: "TraceBlockResponse"
      },
      trieMigrationStatus: {
        description: "Check current migration state",
        isUnsafe: true,
        params: [
          {
            isHistoric: true,
            isOptional: true,
            name: "at",
            type: "BlockHash"
          }
        ],
        type: "MigrationStatusResult"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/state/definitions.js
var definitions_default77;
var init_definitions77 = __esm({
  "../../node_modules/@polkadot/types/interfaces/state/definitions.js"() {
    init_rpc17();
    definitions_default77 = {
      rpc: rpc17,
      types: {
        ApiId: "[u8; 8]",
        BlockTrace: {
          blockHash: "Text",
          parentHash: "Text",
          tracingTargets: "Text",
          storageKeys: "Text",
          spans: "Vec<BlockTraceSpan>",
          events: "Vec<BlockTraceEvent>"
        },
        BlockTraceEvent: {
          target: "Text",
          data: "BlockTraceEventData",
          parentId: "Option<u64>"
        },
        BlockTraceEventData: {
          stringValues: "HashMap<Text, Text>"
        },
        BlockTraceSpan: {
          id: "u64",
          parentId: "Option<u64>",
          name: "Text",
          target: "Text",
          wasm: "bool"
        },
        KeyValueOption: "(StorageKey, Option<StorageData>)",
        MigrationStatusResult: {
          topRemainingToMigrate: "u64",
          childRemainingToMigrate: "u64"
        },
        ReadProof: {
          at: "Hash",
          proof: "Vec<Bytes>"
        },
        RuntimeVersionApi: "(ApiId, u32)",
        RuntimeVersion: {
          specName: "Text",
          implName: "Text",
          authoringVersion: "u32",
          specVersion: "u32",
          implVersion: "u32",
          apis: "Vec<RuntimeVersionApi>",
          transactionVersion: "u32",
          stateVersion: "u8"
        },
        RuntimeVersionPre4: {
          specName: "Text",
          implName: "Text",
          authoringVersion: "u32",
          specVersion: "u32",
          implVersion: "u32",
          apis: "Vec<RuntimeVersionApi>",
          transactionVersion: "u32"
        },
        RuntimeVersionPre3: {
          specName: "Text",
          implName: "Text",
          authoringVersion: "u32",
          specVersion: "u32",
          implVersion: "u32",
          apis: "Vec<RuntimeVersionApi>"
        },
        RuntimeVersionPartial: {
          specName: "Text",
          specVersion: "u32",
          apis: "Vec<RuntimeVersionApi>"
        },
        SpecVersion: "u32",
        StorageChangeSet: {
          block: "Hash",
          changes: "Vec<KeyValueOption>"
        },
        TraceBlockResponse: {
          _enum: {
            TraceError: "TraceError",
            BlockTrace: "BlockTrace"
          }
        },
        TraceError: {
          error: "Text"
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/interfaces/definitions.js
var definitions_exports = {};
__export(definitions_exports, {
  assetConversion: () => definitions_default4,
  assets: () => definitions_default5,
  attestations: () => definitions_default53,
  aura: () => definitions_default6,
  author: () => definitions_default72,
  authorship: () => definitions_default7,
  babe: () => definitions_default8,
  balances: () => definitions_default9,
  beefy: () => definitions_default10,
  benchmark: () => definitions_default11,
  blockbuilder: () => definitions_default12,
  bridges: () => definitions_default54,
  chain: () => definitions_default73,
  childstate: () => definitions_default74,
  claims: () => definitions_default55,
  collective: () => definitions_default13,
  consensus: () => definitions_default14,
  contracts: () => definitions_default15,
  contractsAbi: () => definitions_default66,
  crowdloan: () => definitions_default56,
  cumulus: () => definitions_default57,
  democracy: () => definitions_default16,
  dev: () => definitions_default17,
  discovery: () => definitions_default18,
  dryRunApi: () => definitions_default62,
  elections: () => definitions_default19,
  engine: () => definitions_default20,
  eth: () => definitions_default67,
  evm: () => definitions_default21,
  extrinsics: () => definitions_default22,
  finality: () => definitions_default58,
  fungibles: () => definitions_default23,
  genericAsset: () => definitions_default24,
  genesisBuilder: () => definitions_default25,
  gilt: () => definitions_default26,
  grandpa: () => definitions_default27,
  identity: () => definitions_default28,
  imOnline: () => definitions_default29,
  lottery: () => definitions_default30,
  metadata: () => definitions_default,
  mixnet: () => definitions_default31,
  mmr: () => definitions_default32,
  nfts: () => definitions_default33,
  nimbus: () => definitions_default68,
  nompools: () => definitions_default34,
  offchain: () => definitions_default75,
  offences: () => definitions_default35,
  ormlOracle: () => definitions_default69,
  ormlTokens: () => definitions_default70,
  parachains: () => definitions_default59,
  payment: () => definitions_default76,
  poll: () => definitions_default60,
  pow: () => definitions_default36,
  proxy: () => definitions_default37,
  purchase: () => definitions_default61,
  recovery: () => definitions_default38,
  rpc: () => definitions_default71,
  runtime: () => definitions_default2,
  scaleInfo: () => definitions_default3,
  scheduler: () => definitions_default39,
  session: () => definitions_default40,
  society: () => definitions_default41,
  staking: () => definitions_default42,
  state: () => definitions_default77,
  statement: () => definitions_default43,
  support: () => definitions_default44,
  syncstate: () => definitions_default45,
  system: () => definitions_default46,
  treasury: () => definitions_default47,
  txpayment: () => definitions_default48,
  txqueue: () => definitions_default49,
  uniques: () => definitions_default50,
  utility: () => definitions_default51,
  vesting: () => definitions_default52,
  xcm: () => definitions_default63,
  xcmPaymentApi: () => definitions_default64,
  xcmRuntimeApi: () => definitions_default65
});
var init_definitions78 = __esm({
  "../../node_modules/@polkadot/types/interfaces/definitions.js"() {
    init_essentials();
    init_definitions4();
    init_definitions5();
    init_definitions6();
    init_definitions7();
    init_definitions8();
    init_definitions9();
    init_definitions10();
    init_definitions11();
    init_definitions12();
    init_definitions13();
    init_definitions14();
    init_definitions15();
    init_definitions16();
    init_definitions17();
    init_definitions18();
    init_definitions19();
    init_definitions20();
    init_definitions21();
    init_definitions22();
    init_definitions23();
    init_definitions24();
    init_definitions25();
    init_definitions26();
    init_definitions27();
    init_definitions28();
    init_definitions29();
    init_definitions30();
    init_definitions31();
    init_definitions32();
    init_definitions33();
    init_definitions34();
    init_definitions35();
    init_definitions36();
    init_definitions37();
    init_definitions38();
    init_definitions39();
    init_definitions40();
    init_definitions41();
    init_definitions42();
    init_definitions43();
    init_definitions44();
    init_definitions45();
    init_definitions46();
    init_definitions47();
    init_definitions48();
    init_definitions49();
    init_definitions50();
    init_definitions51();
    init_definitions52();
    init_definitions53();
    init_definitions54();
    init_definitions55();
    init_definitions56();
    init_definitions57();
    init_definitions58();
    init_definitions59();
    init_definitions60();
    init_definitions61();
    init_definitions62();
    init_definitions63();
    init_definitions64();
    init_definitions65();
    init_definitions66();
    init_definitions67();
    init_definitions68();
    init_definitions69();
    init_definitions70();
    init_definitions71();
    init_definitions72();
    init_definitions73();
    init_definitions74();
    init_definitions75();
    init_definitions76();
    init_definitions77();
  }
});

// ../../node_modules/@polkadot/types/interfaces/jsonrpc.js
var jsonrpc, jsonrpc_default;
var init_jsonrpc = __esm({
  "../../node_modules/@polkadot/types/interfaces/jsonrpc.js"() {
    init_util();
    init_definitions78();
    jsonrpc = {};
    Object.keys(definitions_exports).forEach((s2) => Object.entries(definitions_exports[s2].rpc || {}).forEach(([method, def]) => {
      const section2 = def.aliasSection || s2;
      if (!jsonrpc[section2]) {
        jsonrpc[section2] = {};
      }
      jsonrpc[section2][method] = objectSpread({}, def, {
        isSubscription: !!def.pubsub,
        jsonrpc: `${section2}_${method}`,
        method,
        section: section2
      });
    }));
    jsonrpc_default = jsonrpc;
  }
});

// ../../node_modules/@polkadot/types/metadata/PortableRegistry/PortableRegistry.js
function sanitizeDocs(docs) {
  const count = docs.length;
  const result = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    result[i2] = docs[i2].toString();
  }
  return result;
}
function splitNamespace(values) {
  const count = values.length;
  const result = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    result[i2] = values[i2].split("::");
  }
  return result;
}
function matchParts(first2, second) {
  return first2.length === second.length && first2.every((a, index) => {
    const b = second[index].toString();
    if (a === "*" || a === b) {
      return true;
    }
    if (a.includes("*") && a.includes("_") && b.includes("_")) {
      let suba = a.split("_");
      let subb = b.split("_");
      if (suba[0] === "*") {
        const indexOf = subb.indexOf(suba[1]);
        if (indexOf !== -1) {
          suba = suba.slice(1);
          subb = subb.slice(indexOf);
        }
      }
      if (suba.length === 2 && suba[1] === "*" && suba[0] === subb[0]) {
        return true;
      }
      return matchParts(suba, subb);
    }
    return false;
  });
}
function getAliasPath({ def, path }) {
  if (["frame_support::weights::weight_v2::Weight", "sp_weights::weight_v2::Weight"].includes(path.join("::"))) {
    return !def.isComposite || def.asComposite.fields.length === 1 ? "WeightV1" : null;
  }
  return path.length && PATHS_ALIAS.some((a) => matchParts(a, path)) ? path[path.length - 1].toString() : null;
}
function extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {
  const count = path.length;
  if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {
    return null;
  }
  const camels = new Array(count);
  const lowers = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const c = stringPascalCase(isInternal ? path[i2].replace("pallet_", "") : path[i2]);
    const l15 = c.toLowerCase();
    camels[i2] = c;
    lowers[i2] = l15;
  }
  let name = "";
  for (let i2 = 0; i2 < count; i2++) {
    const l15 = lowers[i2];
    if (i2 !== 1 || !PATH_RM_INDEX_1.includes(l15)) {
      if (l15 !== lowers[i2 + 1]) {
        name += camels[i2];
      }
    }
  }
  if (camels[1] === "RawOrigin" && count === 2 && params.length === 2 && params[1].type.isSome) {
    const instanceType = portable[params[1].type.unwrap().toNumber()];
    if (instanceType.type.path.length === 2) {
      name = `${name}${instanceType.type.path[1].toString()}`;
    }
  }
  return { lookupIndex, name, params };
}
function extractName(portable, lookupIndex, { type: { params, path } }) {
  return extractNameFlat(portable, lookupIndex, params, path);
}
function nextDupeMatches(name, startAt, names) {
  const result = [names[startAt]];
  for (let i2 = startAt + 1, count = names.length; i2 < count; i2++) {
    const v = names[i2];
    if (v.name === name) {
      result.push(v);
    }
  }
  return result;
}
function rewriteDupes(input, rewrite) {
  const count = input.length;
  for (let i2 = 0; i2 < count; i2++) {
    const a = input[i2];
    for (let j = i2 + 1; j < count; j++) {
      const b = input[j];
      if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {
        return false;
      }
    }
  }
  for (let i2 = 0; i2 < count; i2++) {
    const p = input[i2];
    rewrite[p.lookupIndex] = p.name;
  }
  return true;
}
function removeDupeNames(lookup, portable, names) {
  const rewrite = {};
  return names.map((original, startAt) => {
    const { lookupIndex, name, params } = original;
    if (!name) {
      return null;
    } else if (rewrite[lookupIndex]) {
      return original;
    }
    const allSame = nextDupeMatches(name, startAt, names);
    if (allSame.length === 1) {
      return original;
    }
    const anyDiff = allSame.some((o) => params.length !== o.params.length || params.some((p, index) => !p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));
    if (!anyDiff) {
      return original;
    }
    const paramIdx = params.findIndex(({ type }, index) => allSame.every(({ params: params2 }, aIndex) => params2[index].type.isSome && (aIndex === 0 || !params2[index].type.eq(type))));
    if (paramIdx === -1) {
      return original;
    }
    const sameCount = allSame.length;
    const adjusted = new Array(sameCount);
    for (let i2 = 0; i2 < sameCount; i2++) {
      const { lookupIndex: lookupIndex2, name: name2, params: params2 } = allSame[i2];
      const { def, path } = lookup.getSiType(params2[paramIdx].type.unwrap());
      if (!def.isPrimitive && !path.length) {
        return null;
      }
      adjusted[i2] = {
        lookupIndex: lookupIndex2,
        name: def.isPrimitive ? `${name2}${def.asPrimitive.toString()}` : `${name2}${path[path.length - 1].toString()}`
      };
    }
    if (rewriteDupes(adjusted, rewrite)) {
      return original;
    }
    for (let i2 = 0; i2 < sameCount; i2++) {
      const { lookupIndex: lookupIndex2, name: name2, params: params2 } = allSame[i2];
      const { def, path } = lookup.getSiType(params2[paramIdx].type.unwrap());
      const flat = extractNameFlat(portable, lookupIndex2, params2, path, true);
      if (def.isPrimitive || !flat) {
        return null;
      }
      adjusted[i2] = {
        lookupIndex: lookupIndex2,
        name: `${name2}${flat.name}`
      };
    }
    if (rewriteDupes(adjusted, rewrite)) {
      return original;
    }
    return null;
  }).filter((n) => !!n).map(({ lookupIndex, name, params }) => ({
    lookupIndex,
    name: rewrite[lookupIndex] || name,
    params
  }));
}
function registerTypes(lookup, lookups, names, params) {
  lookup.registry.register(lookups);
  if (params.SpRuntimeUncheckedExtrinsic) {
    const [addrParam, , sigParam] = params.SpRuntimeUncheckedExtrinsic;
    const siAddress = lookup.getSiType(addrParam.type.unwrap());
    const siSignature = lookup.getSiType(sigParam.type.unwrap());
    const nsSignature = siSignature.path.join("::");
    let nsAccountId = siAddress.path.join("::");
    const isMultiAddress = nsAccountId === "sp_runtime::multiaddress::MultiAddress";
    if (isMultiAddress) {
      const [idParam] = siAddress.params;
      nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join("::");
    }
    lookup.registry.register({
      // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160
      AccountId: nsAccountId.endsWith("::AccountId20") || nsAccountId.endsWith("::H160") ? "AccountId20" : "AccountId32",
      Address: isMultiAddress ? "MultiAddress" : "AccountId",
      ExtrinsicSignature: ["sp_runtime::MultiSignature"].includes(nsSignature) ? "MultiSignature" : names[sigParam.type.unwrap().toNumber()] || "MultiSignature"
    });
  }
}
function extractAliases(params, isContract) {
  const hasParams = Object.keys(params).some((k) => !k.startsWith("Pallet"));
  const alias2 = {};
  if (params.SpRuntimeUncheckedExtrinsic) {
    const [, { type }] = params.SpRuntimeUncheckedExtrinsic;
    alias2[type.unwrap().toNumber()] = "Call";
  } else if (hasParams && !isContract) {
    l8.warn("Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic");
  }
  if (params.FrameSystemEventRecord) {
    const [{ type }] = params.FrameSystemEventRecord;
    alias2[type.unwrap().toNumber()] = "Event";
  } else if (hasParams && !isContract) {
    l8.warn("Unable to determine runtime Event type, cannot inspect frame_system::EventRecord");
  }
  return alias2;
}
function extractTypeInfo(lookup, portable) {
  const nameInfo = [];
  const types4 = {};
  for (let i2 = 0, count = portable.length; i2 < count; i2++) {
    const type = portable[i2];
    const lookupIndex = type.id.toNumber();
    const extracted = extractName(portable, lookupIndex, portable[i2]);
    if (extracted) {
      nameInfo.push(extracted);
    }
    types4[lookupIndex] = type;
  }
  const lookups = {};
  const names = {};
  const params = {};
  const dedup = removeDupeNames(lookup, portable, nameInfo);
  for (let i2 = 0, count = dedup.length; i2 < count; i2++) {
    const { lookupIndex, name, params: p } = dedup[i2];
    names[lookupIndex] = name;
    lookups[name] = lookup.registry.createLookupType(lookupIndex);
    params[name] = p;
  }
  return { lookups, names, params, types: types4 };
}
var l8, TYPE_UNWRAP, PRIMITIVE_ALIAS, PATHS_ALIAS, PATHS_SET, BITVEC_NS_LSB, BITVEC_NS_MSB, BITVEC_NS, WRAPPERS, RESERVED, PATH_RM_INDEX_1, PortableRegistry;
var init_PortableRegistry = __esm({
  "../../node_modules/@polkadot/types/metadata/PortableRegistry/PortableRegistry.js"() {
    init_types_codec();
    init_types_create();
    init_util();
    l8 = logger("PortableRegistry");
    TYPE_UNWRAP = { toNumber: () => -1 };
    PRIMITIVE_ALIAS = {
      Char: "u32",
      // Rust char is 4-bytes
      Str: "Text"
    };
    PATHS_ALIAS = splitNamespace([
      // full matching on exact names...
      // these are well-known types with additional encoding
      "sp_core::crypto::AccountId32",
      "sp_runtime::generic::era::Era",
      "sp_runtime::multiaddress::MultiAddress",
      // ethereum overrides (Frontier, Moonbeam, Polkadot claims)
      "fp_account::AccountId20",
      "account::AccountId20",
      "polkadot_runtime_common::claims::EthereumAddress",
      // weights 2 is a structure, however for 1.5. with a single field it
      // should be flatenned (can appear in Compact<Weight> extrinsics)
      "frame_support::weights::weight_v2::Weight",
      "sp_weights::weight_v2::Weight",
      // wildcard matching in place...
      // these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy
      "*_democracy::vote::Vote",
      "*_conviction_voting::vote::Vote",
      "*_identity::types::Data",
      // these are opaque Vec<u8> wrappers
      "sp_core::OpaqueMetadata",
      "sp_core::OpaquePeerId",
      "sp_core::offchain::OpaqueMultiaddr",
      // shorten some well-known types
      "primitive_types::*",
      "sp_arithmetic::per_things::*",
      // runtime
      "*_runtime::RuntimeCall",
      "*_runtime::RuntimeEvent",
      // ink!
      "ink::env::types::*",
      "ink::primitives::types::*",
      "ink_env::types::*",
      "ink_primitives::types::*"
    ]);
    PATHS_SET = splitNamespace([
      "pallet_identity::types::BitFlags"
    ]);
    BITVEC_NS_LSB = ["bitvec::order::Lsb0", "BitOrderLsb0"];
    BITVEC_NS_MSB = ["bitvec::order::Msb0", "BitOrderMsb0"];
    BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];
    WRAPPERS = ["BoundedBTreeMap", "BoundedBTreeSet", "BoundedVec", "Box", "BTreeMap", "BTreeSet", "Cow", "Option", "Range", "RangeInclusive", "Result", "WeakBoundedVec", "WrapperKeepOpaque", "WrapperOpaque"];
    RESERVED = [
      // JS reserved words
      "entries",
      "keys",
      "new",
      "size",
      // exposed by all Codec objects
      "hash",
      "registry"
    ];
    PATH_RM_INDEX_1 = ["generic", "misc", "pallet", "traits", "types"];
    PortableRegistry = class extends Struct {
      __internal__alias;
      __internal__lookups;
      __internal__names;
      __internal__params;
      __internal__typeDefs = {};
      __internal__types;
      constructor(registry, value, isContract) {
        super(registry, {
          types: "Vec<PortableType>"
        }, value);
        const { lookups, names, params, types: types4 } = extractTypeInfo(this, this.types);
        this.__internal__alias = extractAliases(params, isContract);
        this.__internal__lookups = lookups;
        this.__internal__names = names;
        this.__internal__params = params;
        this.__internal__types = types4;
      }
      /**
       * @description Returns all the available type names for this chain
       **/
      get names() {
        return Object.values(this.__internal__names).sort();
      }
      /**
       * @description Returns all the available parameterized types for this chain
       **/
      get paramTypes() {
        return this.__internal__params;
      }
      /**
       * @description The types of the registry
       */
      get types() {
        return this.getT("types");
      }
      /**
       * @description Register all available types into the registry (generally for internal usage)
       */
      register() {
        registerTypes(this, this.__internal__lookups, this.__internal__names, this.__internal__params);
      }
      /**
       * @description Returns the name for a specific lookup
       */
      getName(lookupId) {
        return this.__internal__names[this.__internal__getLookupId(lookupId)];
      }
      /**
       * @description Finds a specific type in the registry
       */
      getSiType(lookupId) {
        const found = (this.__internal__types || this.types)[this.__internal__getLookupId(lookupId)];
        if (!found) {
          throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
        }
        return found.type;
      }
      /**
       * @description Lookup the type definition for the index
       */
      getTypeDef(lookupId) {
        const lookupIndex = this.__internal__getLookupId(lookupId);
        if (!this.__internal__typeDefs[lookupIndex]) {
          const lookupName = this.__internal__names[lookupIndex];
          const empty2 = {
            info: TypeDefInfo.DoNotConstruct,
            lookupIndex,
            lookupName,
            type: this.registry.createLookupType(lookupIndex)
          };
          if (lookupName) {
            this.__internal__typeDefs[lookupIndex] = empty2;
          }
          const extracted = this.__internal__extract(this.getSiType(lookupId), lookupIndex);
          if (!lookupName) {
            this.__internal__typeDefs[lookupIndex] = empty2;
          }
          Object.keys(extracted).forEach((k) => {
            if (k !== "lookupName" || extracted[k]) {
              this.__internal__typeDefs[lookupIndex][k] = extracted[k];
            }
          });
          if (extracted.info === TypeDefInfo.Plain) {
            this.__internal__typeDefs[lookupIndex].lookupNameRoot = this.__internal__typeDefs[lookupIndex].lookupName;
            delete this.__internal__typeDefs[lookupIndex].lookupName;
          }
        }
        return this.__internal__typeDefs[lookupIndex];
      }
      /**
       * @description For a specific field, perform adjustments to not have built-in conflicts
       */
      sanitizeField(name) {
        let nameField = null;
        let nameOrig = null;
        if (name.isSome) {
          nameField = stringCamelCase(name.unwrap());
          if (nameField.includes("#")) {
            nameOrig = nameField;
            nameField = nameOrig.replace(/#/g, "_");
          } else if (RESERVED.includes(nameField)) {
            nameOrig = nameField;
            nameField = `${nameField}_`;
          }
        }
        return [nameField, nameOrig];
      }
      /** @internal Creates a TypeDef based on an internal lookupId */
      __internal__createSiDef(lookupId) {
        const typeDef = this.getTypeDef(lookupId);
        const lookupIndex = lookupId.toNumber();
        return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {
          docs: typeDef.docs,
          info: TypeDefInfo.Si,
          lookupIndex,
          lookupName: this.__internal__names[lookupIndex],
          type: this.registry.createLookupType(lookupId)
        } : typeDef;
      }
      /** @internal Converts a lookupId input to the actual lookup index */
      __internal__getLookupId(lookupId) {
        if (isString(lookupId)) {
          if (!this.registry.isLookupType(lookupId)) {
            throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);
          }
          return parseInt(lookupId.replace("Lookup", ""), 10);
        } else if (isNumber(lookupId)) {
          return lookupId;
        }
        return lookupId.toNumber();
      }
      /** @internal Converts a type into a TypeDef for Codec usage */
      __internal__extract(type, lookupIndex) {
        const namespace = type.path.join("::");
        let typeDef;
        const aliasType = this.__internal__alias[lookupIndex] || getAliasPath(type);
        try {
          if (aliasType) {
            typeDef = this.__internal__extractAliasPath(lookupIndex, aliasType);
          } else {
            switch (type.def.type) {
              case "Array":
                typeDef = this.__internal__extractArray(lookupIndex, type.def.asArray);
                break;
              case "BitSequence":
                typeDef = this.__internal__extractBitSequence(lookupIndex, type.def.asBitSequence);
                break;
              case "Compact":
                typeDef = this.__internal__extractCompact(lookupIndex, type.def.asCompact);
                break;
              case "Composite":
                typeDef = this.__internal__extractComposite(lookupIndex, type, type.def.asComposite);
                break;
              case "HistoricMetaCompat":
                typeDef = this.__internal__extractHistoric(lookupIndex, type.def.asHistoricMetaCompat);
                break;
              case "Primitive":
                typeDef = this.__internal__extractPrimitive(lookupIndex, type);
                break;
              case "Sequence":
                typeDef = this.__internal__extractSequence(lookupIndex, type.def.asSequence);
                break;
              case "Tuple":
                typeDef = this.__internal__extractTuple(lookupIndex, type.def.asTuple);
                break;
              case "Variant":
                typeDef = this.__internal__extractVariant(lookupIndex, type, type.def.asVariant);
                break;
              default:
                assertUnreachable(type.def.type);
            }
          }
        } catch (error) {
          throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ""}: Error extracting ${stringify(type)}: ${error.message}`);
        }
        return objectSpread({
          docs: sanitizeDocs(type.docs),
          namespace
        }, typeDef);
      }
      /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */
      __internal__extractArray(_, { len, type }) {
        const length = len.toNumber();
        if (length > 2048) {
          throw new Error("Only support for [Type; <length>], where length <= 2048");
        }
        return withTypeString(this.registry, {
          info: TypeDefInfo.VecFixed,
          length,
          sub: this.__internal__createSiDef(type)
        });
      }
      /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */
      __internal__extractBitSequence(_, { bitOrderType, bitStoreType }) {
        const a = this.__internal__createSiDef(bitOrderType);
        const b = this.__internal__createSiDef(bitStoreType);
        const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || "") ? [a, b] : [b, a];
        if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {
          throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || "<unknown>"}`);
        } else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== "u8") {
          throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);
        }
        const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);
        if (!isLsb) {
        }
        return {
          info: TypeDefInfo.Plain,
          type: "BitVec"
        };
      }
      /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */
      __internal__extractCompact(_, { type }) {
        return withTypeString(this.registry, {
          info: TypeDefInfo.Compact,
          sub: this.__internal__createSiDef(type)
        });
      }
      /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */
      __internal__extractComposite(lookupIndex, { params, path }, { fields }) {
        if (path.length) {
          const pathFirst = path[0].toString();
          const pathLast = path[path.length - 1].toString();
          if (path.length === 1 && pathFirst === "BTreeMap") {
            if (params.length !== 2) {
              throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);
            }
            return withTypeString(this.registry, {
              info: TypeDefInfo.BTreeMap,
              sub: params.map(({ type }) => this.__internal__createSiDef(type.unwrap()))
            });
          } else if (path.length === 1 && pathFirst === "BTreeSet") {
            if (params.length !== 1) {
              throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);
            }
            return withTypeString(this.registry, {
              info: TypeDefInfo.BTreeSet,
              sub: this.__internal__createSiDef(params[0].type.unwrap())
            });
          } else if (["Range", "RangeInclusive"].includes(pathFirst)) {
            if (params.length !== 1) {
              throw new Error(`Range requires 1 parameter, found ${params.length}`);
            }
            return withTypeString(this.registry, {
              info: pathFirst === "Range" ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,
              sub: this.__internal__createSiDef(params[0].type.unwrap()),
              type: pathFirst
            });
          } else if (["WrapperKeepOpaque", "WrapperOpaque"].includes(pathLast)) {
            if (params.length !== 1) {
              throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);
            }
            return withTypeString(this.registry, {
              info: pathLast === "WrapperKeepOpaque" ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,
              sub: this.__internal__createSiDef(params[0].type.unwrap()),
              type: pathLast
            });
          }
        }
        return PATHS_SET.some((p) => matchParts(p, path)) ? this.__internal__extractCompositeSet(lookupIndex, params, fields) : this.__internal__extractFields(lookupIndex, fields);
      }
      /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */
      __internal__extractCompositeSet(_, params, fields) {
        if (params.length !== 1 || fields.length !== 1) {
          throw new Error("Set handling expects param/field as single entries");
        }
        return withTypeString(this.registry, {
          info: TypeDefInfo.Set,
          length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),
          sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({ index, name }) => ({
            // This will be an issue > 2^53 - 1 ... don't have those (yet)
            index: index.toNumber(),
            info: TypeDefInfo.Plain,
            name: name.toString(),
            type: "Null"
          }))
        });
      }
      /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */
      __internal__extractFields(lookupIndex, fields) {
        let isStruct = true;
        let isTuple = true;
        const count = fields.length;
        for (let f3 = 0; f3 < count; f3++) {
          const { name } = fields[f3];
          isStruct = isStruct && name.isSome;
          isTuple = isTuple && name.isNone;
        }
        if (!isTuple && !isStruct) {
          throw new Error("Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)");
        }
        if (count === 0) {
          return {
            info: TypeDefInfo.Null,
            type: "Null"
          };
        } else if (isTuple && count === 1) {
          const typeDef = this.__internal__createSiDef(fields[0].type);
          return objectSpread({}, typeDef, lookupIndex === -1 ? null : {
            lookupIndex,
            lookupName: this.__internal__names[lookupIndex],
            lookupNameRoot: typeDef.lookupName
          }, fields[0].typeName.isSome ? { typeName: sanitize(fields[0].typeName.unwrap()) } : null);
        }
        const [sub, alias2] = this.__internal__extractFieldsAlias(fields);
        return withTypeString(this.registry, objectSpread({
          info: isTuple ? TypeDefInfo.Tuple : TypeDefInfo.Struct,
          sub
        }, alias2.size ? { alias: alias2 } : null, lookupIndex === -1 ? null : {
          lookupIndex,
          lookupName: this.__internal__names[lookupIndex]
        }));
      }
      /** @internal Apply field aliassed (with no JS conflicts) */
      __internal__extractFieldsAlias(fields) {
        const alias2 = /* @__PURE__ */ new Map();
        const count = fields.length;
        const sub = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          const { docs, name, type, typeName } = fields[i2];
          const typeDef = this.__internal__createSiDef(type);
          if (name.isNone) {
            sub[i2] = typeDef;
          } else {
            const [nameField, nameOrig] = this.sanitizeField(name);
            if (nameField && nameOrig) {
              alias2.set(nameField, nameOrig);
            }
            sub[i2] = objectSpread({
              docs: sanitizeDocs(docs),
              name: nameField
            }, typeDef, typeName.isSome ? { typeName: sanitize(typeName.unwrap()) } : null);
          }
        }
        return [sub, alias2];
      }
      /** @internal Extracts an internal Historic (pre V14) type  */
      __internal__extractHistoric(_, type) {
        return objectSpread({
          displayName: type.toString(),
          isFromSi: true
        }, getTypeDef(type));
      }
      /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */
      __internal__extractPrimitive(_, type) {
        const typeStr = type.def.asPrimitive.type.toString();
        return {
          info: TypeDefInfo.Plain,
          type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
        };
      }
      /** @internal Applies an alias path onto the TypeDef */
      __internal__extractAliasPath(_, type) {
        return {
          info: TypeDefInfo.Plain,
          type
        };
      }
      /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */
      __internal__extractSequence(lookupIndex, { type }) {
        const sub = this.__internal__createSiDef(type);
        if (sub.type === "u8") {
          return {
            info: TypeDefInfo.Plain,
            type: "Bytes"
          };
        }
        return withTypeString(this.registry, {
          info: TypeDefInfo.Vec,
          lookupIndex,
          lookupName: this.__internal__names[lookupIndex],
          sub
        });
      }
      /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */
      __internal__extractTuple(lookupIndex, ids) {
        if (ids.length === 0) {
          return {
            info: TypeDefInfo.Null,
            type: "Null"
          };
        } else if (ids.length === 1) {
          return this.getTypeDef(ids[0]);
        }
        const sub = ids.map((t2) => this.__internal__createSiDef(t2));
        return withTypeString(this.registry, {
          info: TypeDefInfo.Tuple,
          lookupIndex,
          lookupName: this.__internal__names[lookupIndex],
          sub
        });
      }
      /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */
      __internal__extractVariant(lookupIndex, { params, path }, { variants }) {
        if (path.length) {
          const specialVariant = path[0].toString();
          if (specialVariant === "Option") {
            if (params.length !== 1) {
              throw new Error(`Option requires 1 parameter, found ${params.length}`);
            }
            return withTypeString(this.registry, {
              info: TypeDefInfo.Option,
              sub: this.__internal__createSiDef(params[0].type.unwrap())
            });
          } else if (specialVariant === "Result") {
            if (params.length !== 2) {
              throw new Error(`Result requires 2 parameters, found ${params.length}`);
            }
            return withTypeString(this.registry, {
              info: TypeDefInfo.Result,
              sub: params.map(({ type }, index) => objectSpread({
                name: ["Ok", "Error"][index]
              }, this.__internal__createSiDef(type.unwrap())))
            });
          }
        }
        if (variants.length === 0) {
          return {
            info: TypeDefInfo.Null,
            type: "Null"
          };
        }
        return this.__internal__extractVariantEnum(lookupIndex, variants);
      }
      /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */
      __internal__extractVariantEnum(lookupIndex, variants) {
        const sub = [];
        variants.slice().sort((a, b) => a.index.cmp(b.index)).forEach(({ fields, index: bnIndex, name }) => {
          const index = bnIndex.toNumber();
          while (sub.length !== index) {
            sub.push({
              index: sub.length,
              info: TypeDefInfo.Null,
              name: `__Unused${sub.length}`,
              type: "Null"
            });
          }
          sub.push(objectSpread(this.__internal__extractFields(-1, fields), {
            index,
            name: name.toString()
          }));
        });
        return withTypeString(this.registry, {
          info: TypeDefInfo.Enum,
          lookupIndex,
          lookupName: this.__internal__names[lookupIndex],
          sub
        });
      }
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/PortableRegistry/index.js
var init_PortableRegistry2 = __esm({
  "../../node_modules/@polkadot/types/metadata/PortableRegistry/index.js"() {
    init_PortableRegistry();
  }
});

// ../../node_modules/@polkadot/types/metadata/util/flattenUniq.js
function flattenUniq(list, result = []) {
  for (let i2 = 0, count = list.length; i2 < count; i2++) {
    const entry = list[i2];
    if (Array.isArray(entry)) {
      flattenUniq(entry, result);
    } else {
      result.push(entry);
    }
  }
  return [...new Set(result)];
}
var init_flattenUniq = __esm({
  "../../node_modules/@polkadot/types/metadata/util/flattenUniq.js"() {
  }
});

// ../../node_modules/@polkadot/types/metadata/util/getSiName.js
function getSiName(lookup, type) {
  const typeDef = lookup.getTypeDef(type);
  return typeDef.lookupName || typeDef.type;
}
var init_getSiName = __esm({
  "../../node_modules/@polkadot/types/metadata/util/getSiName.js"() {
  }
});

// ../../node_modules/@polkadot/types/metadata/util/extractTypes.js
function extractSubSingle(_, { sub }) {
  const { lookupName, type } = sub;
  return extractTypes([lookupName || type]);
}
function extractSubArray(_, { sub }) {
  return extractTypes(sub.map(({ lookupName, type }) => lookupName || type));
}
function unhandled(type, { info: info6 }) {
  throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${TypeDefInfo[info6]})`);
}
function extractTypes(types4) {
  const count = types4.length;
  const result = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const type = types4[i2];
    const typeDef = getTypeDef(type);
    result[i2] = mapping[typeDef.info](type, typeDef);
  }
  return result;
}
var mapping;
var init_extractTypes = __esm({
  "../../node_modules/@polkadot/types/metadata/util/extractTypes.js"() {
    init_types_create();
    mapping = {
      [TypeDefInfo.BTreeMap]: extractSubArray,
      [TypeDefInfo.BTreeSet]: extractSubSingle,
      [TypeDefInfo.Compact]: extractSubSingle,
      [TypeDefInfo.DoNotConstruct]: unhandled,
      [TypeDefInfo.Enum]: extractSubArray,
      [TypeDefInfo.HashMap]: extractSubArray,
      [TypeDefInfo.Int]: unhandled,
      [TypeDefInfo.Linkage]: extractSubSingle,
      [TypeDefInfo.Null]: unhandled,
      [TypeDefInfo.Option]: extractSubSingle,
      [TypeDefInfo.Plain]: (_, typeDef) => typeDef.lookupName || typeDef.type,
      [TypeDefInfo.Range]: extractSubSingle,
      [TypeDefInfo.RangeInclusive]: extractSubSingle,
      [TypeDefInfo.Result]: extractSubArray,
      [TypeDefInfo.Set]: extractSubArray,
      [TypeDefInfo.Si]: unhandled,
      [TypeDefInfo.Struct]: extractSubArray,
      [TypeDefInfo.Tuple]: extractSubArray,
      [TypeDefInfo.UInt]: unhandled,
      [TypeDefInfo.Vec]: extractSubSingle,
      [TypeDefInfo.VecFixed]: extractSubSingle,
      [TypeDefInfo.WrapperKeepOpaque]: extractSubSingle,
      [TypeDefInfo.WrapperOpaque]: extractSubSingle
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/util/validateTypes.js
function validateTypes(registry, throwError, types4) {
  const missing = flattenUniq(extractTypes(types4)).filter((type) => !registry.hasType(type) && !registry.isLookupType(type)).sort();
  if (missing.length !== 0) {
    const message = `Unknown types found, no types for ${missing.join(", ")}`;
    if (throwError) {
      throw new Error(message);
    } else {
      l9.warn(message);
    }
  }
  return types4;
}
var l9;
var init_validateTypes = __esm({
  "../../node_modules/@polkadot/types/metadata/util/validateTypes.js"() {
    init_util();
    init_extractTypes();
    init_flattenUniq();
    l9 = logger("metadata");
  }
});

// ../../node_modules/@polkadot/types/metadata/util/getUniqTypes.js
function extractTypes2(lookup, types4) {
  return types4.map(({ type }) => lookup.getTypeDef(type).type);
}
function extractFieldTypes(lookup, type) {
  return lookup.getSiType(type).def.asVariant.variants.map(({ fields }) => extractTypes2(lookup, fields));
}
function getPalletNames({ lookup, pallets }) {
  return pallets.reduce((all3, { calls, constants, events: events2, storage }) => {
    all3.push([extractTypes2(lookup, constants)]);
    if (calls.isSome) {
      all3.push(extractFieldTypes(lookup, calls.unwrap().type));
    }
    if (events2.isSome) {
      all3.push(extractFieldTypes(lookup, events2.unwrap().type));
    }
    if (storage.isSome) {
      all3.push(storage.unwrap().items.map(({ type }) => {
        if (type.isPlain) {
          return [lookup.getTypeDef(type.asPlain).type];
        }
        const { hashers, key, value } = type.asMap;
        return hashers.length === 1 ? [
          lookup.getTypeDef(value).type,
          lookup.getTypeDef(key).type
        ] : [
          lookup.getTypeDef(value).type,
          ...lookup.getSiType(key).def.asTuple.map((t2) => lookup.getTypeDef(t2).type)
        ];
      }));
    }
    return all3;
  }, []);
}
function getUniqTypes(registry, meta, throwError) {
  return validateTypes(registry, throwError, flattenUniq(getPalletNames(meta)));
}
var init_getUniqTypes = __esm({
  "../../node_modules/@polkadot/types/metadata/util/getUniqTypes.js"() {
    init_flattenUniq();
    init_validateTypes();
  }
});

// ../../node_modules/@polkadot/types/metadata/util/toCallsOnly.js
function trimDocs(docs) {
  const strings = docs.map((d) => d.toString().trim());
  const firstEmpty = strings.findIndex((d) => !d.length);
  return firstEmpty === -1 ? strings : strings.slice(0, firstEmpty);
}
function toCallsOnly(registry, { extrinsic, lookup, pallets }) {
  return registry.createTypeUnsafe("MetadataLatest", [{
    extrinsic,
    lookup: {
      types: lookup.types.map(({ id, type }) => registry.createTypeUnsafe("PortableType", [{
        id,
        type: objectSpread({}, type, { docs: trimDocs(type.docs) })
      }]))
    },
    pallets: pallets.map(({ calls, index, name }) => ({
      calls: registry.createTypeUnsafe("Option<PalletCallMetadataLatest>", [calls.unwrapOr(null)]),
      index,
      name
    }))
  }]).toJSON();
}
var init_toCallsOnly = __esm({
  "../../node_modules/@polkadot/types/metadata/util/toCallsOnly.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types/metadata/util/index.js
var init_util4 = __esm({
  "../../node_modules/@polkadot/types/metadata/util/index.js"() {
    init_getSiName();
    init_getUniqTypes();
    init_toCallsOnly();
  }
});

// ../../node_modules/@polkadot/types/util/storage.js
function unwrapStorageSi(type) {
  return type.isPlain ? type.asPlain : type.asMap.value;
}
function unwrapStorageType(registry, type, isOptional) {
  const outputType = getSiName(registry.lookup, unwrapStorageSi(type));
  return isOptional ? `Option<${outputType}>` : outputType;
}
var init_storage = __esm({
  "../../node_modules/@polkadot/types/util/storage.js"() {
    init_util4();
  }
});

// ../../node_modules/@polkadot/types/util/index.js
var init_util5 = __esm({
  "../../node_modules/@polkadot/types/util/index.js"() {
    init_storage();
  }
});

// ../../node_modules/@polkadot/types/codec/index.js
var init_codec2 = __esm({
  "../../node_modules/@polkadot/types/codec/index.js"() {
    init_types_codec();
  }
});

// ../../node_modules/@polkadot/types/create/createClass.js
var init_createClass = __esm({
  "../../node_modules/@polkadot/types/create/createClass.js"() {
  }
});

// ../../node_modules/@polkadot/types/create/createType.js
var init_createType = __esm({
  "../../node_modules/@polkadot/types/create/createType.js"() {
  }
});

// ../../node_modules/@polkadot/types/create/lazy.js
function lazyVariants(lookup, { type }, getName, creator) {
  const result = {};
  const variants = lookup.getSiType(type).def.asVariant.variants;
  for (let i2 = 0, count = variants.length; i2 < count; i2++) {
    lazyMethod(result, variants[i2], creator, getName, i2);
  }
  return result;
}
var init_lazy2 = __esm({
  "../../node_modules/@polkadot/types/create/lazy.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js
var emptyCheck;
var init_emptyCheck = __esm({
  "../../node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js"() {
    emptyCheck = {
      extrinsic: {},
      payload: {}
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/signedExtensions/polkadot.js
var polkadot;
var init_polkadot = __esm({
  "../../node_modules/@polkadot/types/extrinsic/signedExtensions/polkadot.js"() {
    init_emptyCheck();
    polkadot = {
      LimitParathreadCommits: emptyCheck,
      OnlyStakingAndClaims: emptyCheck,
      PrevalidateAttests: emptyCheck,
      RestrictFunctionality: emptyCheck,
      TransactionCallFilter: emptyCheck,
      ValidateDoubleVoteReports: emptyCheck
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/signedExtensions/shell.js
var shell;
var init_shell = __esm({
  "../../node_modules/@polkadot/types/extrinsic/signedExtensions/shell.js"() {
    init_emptyCheck();
    shell = {
      DisallowSigned: emptyCheck
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/signedExtensions/statemint.js
var statemint;
var init_statemint = __esm({
  "../../node_modules/@polkadot/types/extrinsic/signedExtensions/statemint.js"() {
    statemint = {
      ChargeAssetTxPayment: {
        extrinsic: {
          tip: "Compact<Balance>",
          // eslint-disable-next-line sort-keys
          assetId: "TAssetConversion"
        },
        payload: {}
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/signedExtensions/substrate.js
var CheckMetadataHash, CheckMortality, ChargeTransactionPayment, substrate;
var init_substrate = __esm({
  "../../node_modules/@polkadot/types/extrinsic/signedExtensions/substrate.js"() {
    init_emptyCheck();
    CheckMetadataHash = {
      extrinsic: {
        mode: "u8"
      },
      payload: {
        metadataHash: "Option<[u8;32]>"
      }
    };
    CheckMortality = {
      extrinsic: {
        era: "ExtrinsicEra"
      },
      payload: {
        blockHash: "Hash"
      }
    };
    ChargeTransactionPayment = {
      extrinsic: {
        tip: "Compact<Balance>"
      },
      payload: {}
    };
    substrate = {
      ChargeTransactionPayment,
      CheckBlockGasLimit: emptyCheck,
      CheckEra: CheckMortality,
      CheckGenesis: {
        extrinsic: {},
        payload: {
          genesisHash: "Hash"
        }
      },
      CheckMetadataHash,
      CheckMortality,
      CheckNonZeroSender: emptyCheck,
      CheckNonce: {
        extrinsic: {
          nonce: "Compact<Index>"
        },
        payload: {}
      },
      CheckSpecVersion: {
        extrinsic: {},
        payload: {
          specVersion: "u32"
        }
      },
      CheckTxVersion: {
        extrinsic: {},
        payload: {
          transactionVersion: "u32"
        }
      },
      CheckVersion: {
        extrinsic: {},
        payload: {
          specVersion: "u32"
        }
      },
      CheckWeight: emptyCheck,
      LockStakingStatus: emptyCheck,
      SkipCheckIfFeeless: ChargeTransactionPayment,
      ValidateEquivocationReport: emptyCheck
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/signedExtensions/index.js
function findUnknownExtensions(extensions, userExtensions = {}) {
  const names = [...Object.keys(allExtensions), ...Object.keys(userExtensions)];
  return extensions.filter((k) => !names.includes(k));
}
function expandExtensionTypes(extensions, type, userExtensions = {}) {
  return extensions.map((k) => userExtensions[k] || allExtensions[k]).filter((info6) => !!info6).reduce((result, info6) => objectSpread(result, info6[type]), {});
}
var allExtensions, fallbackExtensions;
var init_signedExtensions = __esm({
  "../../node_modules/@polkadot/types/extrinsic/signedExtensions/index.js"() {
    init_util();
    init_polkadot();
    init_shell();
    init_statemint();
    init_substrate();
    allExtensions = objectSpread({}, substrate, polkadot, shell, statemint);
    fallbackExtensions = [
      "CheckVersion",
      "CheckGenesis",
      "CheckEra",
      "CheckNonce",
      "CheckWeight",
      "ChargeTransactionPayment",
      "CheckBlockGasLimit"
    ];
  }
});

// ../../node_modules/@polkadot/types/generic/Event.js
function decodeEvent(registry, value) {
  if (!value?.length) {
    return { DataType: Null };
  }
  const index = value.subarray(0, 2);
  return {
    DataType: registry.findMetaEvent(index),
    value: {
      data: value.subarray(2),
      index
    }
  };
}
var GenericEventData, GenericEvent;
var init_Event = __esm({
  "../../node_modules/@polkadot/types/generic/Event.js"() {
    init_types_codec();
    init_util();
    GenericEventData = class extends Tuple {
      __internal__meta;
      __internal__method;
      __internal__names = null;
      __internal__section;
      __internal__typeDef;
      constructor(registry, value, meta, section2 = "<unknown>", method = "<unknown>") {
        const fields = meta?.fields || [];
        super(registry, fields.map(({ type }) => registry.createLookupType(type)), value);
        this.__internal__meta = meta;
        this.__internal__method = method;
        this.__internal__section = section2;
        this.__internal__typeDef = fields.map(({ type }) => registry.lookup.getTypeDef(type));
        const names = fields.map(({ name }) => registry.lookup.sanitizeField(name)[0]).filter((n) => !!n);
        if (names.length === fields.length) {
          this.__internal__names = names;
          objectProperties(this, names, (_, i2) => this[i2]);
        }
      }
      /**
       * @description The wrapped [[EventMetadata]]
       */
      get meta() {
        return this.__internal__meta;
      }
      /**
       * @description The method as a string
       */
      get method() {
        return this.__internal__method;
      }
      /**
       * @description The field names (as available)
       */
      get names() {
        return this.__internal__names;
      }
      /**
       * @description The section as a string
       */
      get section() {
        return this.__internal__section;
      }
      /**
       * @description The [[TypeDef]] for this event
       */
      get typeDef() {
        return this.__internal__typeDef;
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        if (this.__internal__names !== null) {
          const json = {};
          for (let i2 = 0, count = this.__internal__names.length; i2 < count; i2++) {
            json[this.__internal__names[i2]] = this[i2].toHuman(isExtended, disableAscii);
          }
          return json;
        }
        return super.toHuman(isExtended);
      }
    };
    GenericEvent = class extends Struct {
      // Currently we _only_ decode from Uint8Array, since we expect it to
      // be used via EventRecord
      constructor(registry, _value) {
        const { DataType, value } = decodeEvent(registry, _value);
        super(registry, {
          index: "EventId",
          // eslint-disable-next-line sort-keys
          data: DataType
        }, value);
      }
      /**
       * @description The wrapped [[EventData]]
       */
      get data() {
        return this.getT("data");
      }
      /**
       * @description The [[EventId]], identifying the raw event
       */
      get index() {
        return this.getT("index");
      }
      /**
       * @description The [[EventMetadata]] with the documentation
       */
      get meta() {
        return this.data.meta;
      }
      /**
       * @description The method string identifying the event
       */
      get method() {
        return this.data.method;
      }
      /**
       * @description The section string identifying the event
       */
      get section() {
        return this.data.section;
      }
      /**
       * @description The [[TypeDef]] for the event
       */
      get typeDef() {
        return this.data.typeDef;
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExpanded, disableAscii) {
        return objectSpread({
          method: this.method,
          section: this.section
        }, isExpanded ? { docs: this.meta.docs.map((d) => d.toString()) } : null, super.toHuman(isExpanded, disableAscii));
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/constants.js
var BIT_SIGNED, BIT_UNSIGNED, EMPTY_U8A3, IMMORTAL_ERA, UNMASK_VERSION, DEFAULT_PREAMBLE, LATEST_EXTRINSIC_VERSION, VERSION_MASK, TYPE_MASK, BARE_EXTRINSIC, GENERAL_EXTRINSIC, LOWEST_SUPPORTED_EXTRINSIC_FORMAT_VERSION;
var init_constants2 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/constants.js"() {
    BIT_SIGNED = 128;
    BIT_UNSIGNED = 0;
    EMPTY_U8A3 = new Uint8Array();
    IMMORTAL_ERA = new Uint8Array([0]);
    UNMASK_VERSION = 127;
    DEFAULT_PREAMBLE = "bare";
    LATEST_EXTRINSIC_VERSION = 5;
    VERSION_MASK = 63;
    TYPE_MASK = 192;
    BARE_EXTRINSIC = 0;
    GENERAL_EXTRINSIC = 64;
    LOWEST_SUPPORTED_EXTRINSIC_FORMAT_VERSION = 4;
  }
});

// ../../node_modules/@polkadot/types/extrinsic/Extrinsic.js
function newFromValue(registry, value, version, preamble) {
  if (value instanceof GenericExtrinsic) {
    return value.unwrap();
  }
  const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;
  const type = (version & VERSION_MASK) === 5 ? PREAMBLE[preamble] : VERSIONS[version & VERSION_MASK] || VERSIONS[0];
  return registry.createTypeUnsafe(type, [value, { isSigned, version }]);
}
function decodeExtrinsic(registry, value, version = LOWEST_SUPPORTED_EXTRINSIC_FORMAT_VERSION, preamble = DEFAULT_PREAMBLE) {
  if (isU8a(value) || Array.isArray(value) || isHex(value)) {
    return decodeU8a3(registry, u8aToU8a(value), version, preamble);
  } else if (value instanceof registry.createClassUnsafe("Call")) {
    return newFromValue(registry, { method: value }, version, preamble);
  }
  return newFromValue(registry, value, version, preamble);
}
function decodeU8a3(registry, value, version, preamble) {
  if (!value.length) {
    return newFromValue(registry, new Uint8Array(), version, preamble);
  }
  const [offset, length] = compactFromU8a(value);
  const total = offset + length.toNumber();
  if (total > value.length) {
    throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);
  }
  const data = value.subarray(offset, total);
  const unmaskedPreamble = data[0] & TYPE_MASK;
  if (preambleUnMask[`${unmaskedPreamble}`] === "general") {
    return newFromValue(registry, value, data[0], preambleUnMask[`${unmaskedPreamble}`] || preamble);
  } else {
    return newFromValue(registry, data.subarray(1), data[0], preambleUnMask[`${unmaskedPreamble}`] || preamble);
  }
}
var VERSIONS, PREAMBLE, PreambleMask, preambleUnMask, ExtrinsicBase, GenericExtrinsic;
var init_Extrinsic = __esm({
  "../../node_modules/@polkadot/types/extrinsic/Extrinsic.js"() {
    init_types_codec();
    init_util();
    init_constants2();
    VERSIONS = [
      "ExtrinsicUnknown",
      // v0 is unknown
      "ExtrinsicUnknown",
      "ExtrinsicUnknown",
      "ExtrinsicUnknown",
      "ExtrinsicV4",
      "ExtrinsicV5"
    ];
    PREAMBLE = {
      bare: "ExtrinsicV5",
      general: "GeneralExtrinsic"
    };
    PreambleMask = {
      bare: BARE_EXTRINSIC,
      general: GENERAL_EXTRINSIC
    };
    preambleUnMask = {
      0: "bare",
      // eslint-disable-next-line sort-keys
      64: "general"
    };
    ExtrinsicBase = class extends AbstractBase {
      __internal__preamble;
      constructor(registry, value, initialU8aLength, preamble) {
        super(registry, value, initialU8aLength);
        const signKeys = Object.keys(registry.getSignedExtensionTypes());
        if (this.version === 5 && preamble !== "general") {
          const getter = (key) => this.inner.signature[key];
          for (let i2 = 0, count = signKeys.length; i2 < count; i2++) {
            objectProperty(this, signKeys[i2], getter);
          }
        }
        const unmaskedPreamble = this.type & TYPE_MASK;
        this.__internal__preamble = preamble || preambleUnMask[`${unmaskedPreamble}`];
      }
      isGeneral() {
        return this.__internal__preamble === "general";
      }
      /**
       * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]
       */
      get args() {
        return this.method.args;
      }
      /**
       * @description The argument definitions, compatible with [[Call]]
       */
      get argsDef() {
        return this.method.argsDef;
      }
      /**
       * @description The actual `[sectionIndex, methodIndex]` as used in the Call
       */
      get callIndex() {
        return this.method.callIndex;
      }
      /**
       * @description The actual data for the Call
       */
      get data() {
        return this.method.data;
      }
      /**
       * @description The era for this extrinsic
       */
      get era() {
        return this.isGeneral() ? this.inner.era : this.inner.signature.era;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description `true` id the extrinsic is signed
       */
      get isSigned() {
        return this.isGeneral() ? false : this.inner.signature.isSigned;
      }
      /**
       * @description The length of the actual data, excluding prefix
       */
      get length() {
        return this.toU8a(true).length;
      }
      /**
       * @description The [[FunctionMetadataLatest]] that describes the extrinsic
       */
      get meta() {
        return this.method.meta;
      }
      /**
       * @description The [[Call]] this extrinsic wraps
       */
      get method() {
        return this.inner.method;
      }
      /**
       * @description The nonce for this extrinsic
       */
      get nonce() {
        return this.isGeneral() ? this.inner.nonce : this.inner.signature.nonce;
      }
      /**
       * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
       */
      get signature() {
        if (this.isGeneral()) {
          throw new Error("Extrinsic: GeneralExtrinsic does not have signature implemented");
        }
        return this.inner.signature.signature;
      }
      /**
       * @description The [[Address]] that signed
       */
      get signer() {
        if (this.isGeneral()) {
          throw new Error("Extrinsic: GeneralExtrinsic does not have signer implemented");
        }
        return this.inner.signature.signer;
      }
      /**
       * @description Forwards compat
       */
      get tip() {
        return this.isGeneral() ? this.inner.tip : this.inner.signature.tip;
      }
      /**
       * @description Forward compat
       */
      get assetId() {
        return this.isGeneral() ? this.inner.assetId : this.inner.signature.assetId;
      }
      /**
       * @description Forward compat
       */
      get metadataHash() {
        return this.isGeneral() ? this.inner.metadataHash : this.inner.signature.metadataHash;
      }
      /**
       * @description Forward compat
       */
      get mode() {
        return this.isGeneral() ? this.inner.mode : this.inner.signature.mode;
      }
      /**
       * @description Returns the raw transaction version (not flagged with signing information)
      */
      get type() {
        return this.inner.version;
      }
      get inner() {
        return this.unwrap();
      }
      /**
       * @description Returns the encoded version flag
      */
      get version() {
        if (this.type <= LOWEST_SUPPORTED_EXTRINSIC_FORMAT_VERSION) {
          return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);
        } else {
          if (this.isSigned) {
            throw new Error("Signed Extrinsics are currently only available for ExtrinsicV4");
          }
          return this.type | (this.isGeneral() ? PreambleMask.general : PreambleMask.bare);
        }
      }
      /**
       * @description Checks if the source matches this in type
       */
      is(other) {
        return this.method.is(other);
      }
      unwrap() {
        return super.unwrap();
      }
    };
    GenericExtrinsic = class extends ExtrinsicBase {
      __internal__hashCache;
      static LATEST_EXTRINSIC_VERSION = LATEST_EXTRINSIC_VERSION;
      constructor(registry, value, { preamble, version } = {}) {
        super(registry, decodeExtrinsic(registry, value, version || registry.metadata.extrinsic.version?.toNumber(), preamble), void 0, preamble);
      }
      /**
       * @description returns a hash of the contents
       */
      get hash() {
        if (!this.__internal__hashCache) {
          this.__internal__hashCache = super.hash;
        }
        return this.__internal__hashCache;
      }
      /**
       * @description Injects an already-generated signature into the extrinsic
       */
      addSignature(signer, signature, payload) {
        this.inner.addSignature(signer, signature, payload);
        this.__internal__hashCache = void 0;
        return this;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        const encoded = u8aConcat(...this.toU8aInner());
        return {
          inner: this.isSigned ? this.inner.inspect().inner : this.inner.method.inspect().inner,
          outer: [compactToU8a(encoded.length), new Uint8Array([this.version])]
        };
      }
      /**
       * @description Sign the extrinsic with a specific keypair
       */
      sign(account3, options) {
        this.inner.sign(account3, options);
        this.__internal__hashCache = void 0;
        return this;
      }
      /**
       * @describe Adds a fake signature to the extrinsic
       */
      signFake(signer, options) {
        this.inner.signFake(signer, options);
        this.__internal__hashCache = void 0;
        return this;
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex(isBare) {
        return u8aToHex(this.toU8a(isBare));
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExpanded, disableAscii) {
        return objectSpread({}, {
          isSigned: this.isSigned,
          method: this.method.toHuman(isExpanded, disableAscii)
        }, this.isSigned ? {
          assetId: this.assetId ? this.assetId.toHuman(isExpanded, disableAscii) : null,
          era: this.era.toHuman(isExpanded, disableAscii),
          metadataHash: this.metadataHash ? this.metadataHash.toHex() : null,
          mode: this.mode ? this.mode.toHuman() : null,
          nonce: this.nonce.toHuman(isExpanded, disableAscii),
          signature: this.signature.toHex(),
          signer: this.signer.toHuman(isExpanded, disableAscii),
          tip: this.tip.toHuman(isExpanded, disableAscii)
        } : null);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toHex();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Extrinsic";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value is not length-prefixed
       */
      toU8a(isBare) {
        const encoded = u8aConcat(...this.toU8aInner());
        return isBare ? encoded : compactAddLength(encoded);
      }
      toU8aInner() {
        return [
          new Uint8Array([this.version]),
          this.inner.toU8a()
        ];
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js
function getTrailingZeros(period) {
  const binary = period.toString(2);
  let index = 0;
  while (binary[binary.length - 1 - index] === "0") {
    index++;
  }
  return index;
}
function decodeMortalEra(registry, value) {
  if (isU8a(value) || isHex(value) || Array.isArray(value)) {
    return decodeMortalU8a(registry, u8aToU8a(value));
  } else if (!value) {
    return [new u643(registry), new u643(registry)];
  } else if (isObject(value)) {
    return decodeMortalObject(registry, value);
  }
  throw new Error("Invalid data passed to Mortal era");
}
function decodeMortalObject(registry, value) {
  const { current, period } = value;
  let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));
  calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);
  const phase = current % calPeriod;
  const quantizeFactor = Math.max(calPeriod >> 12, 1);
  const quantizedPhase = phase / quantizeFactor * quantizeFactor;
  return [new u643(registry, calPeriod), new u643(registry, quantizedPhase)];
}
function decodeMortalU8a(registry, value) {
  if (value.length === 0) {
    return [new u643(registry), new u643(registry)];
  }
  const first2 = u8aToBn(value.subarray(0, 1)).toNumber();
  const second = u8aToBn(value.subarray(1, 2)).toNumber();
  const encoded = first2 + (second << 8);
  const period = 2 << encoded % (1 << 4);
  const quantizeFactor = Math.max(period >> 12, 1);
  const phase = (encoded >> 4) * quantizeFactor;
  if (period < 4 || phase >= period) {
    throw new Error("Invalid data passed to Mortal era");
  }
  return [new u643(registry, period), new u643(registry, phase)];
}
function decodeExtrinsicEra(value = new Uint8Array()) {
  if (isU8a(value)) {
    return !value.length || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);
  } else if (!value) {
    return new Uint8Array([0]);
  } else if (value instanceof GenericExtrinsicEra) {
    return decodeExtrinsicEra(value.toU8a());
  } else if (isHex(value)) {
    return decodeExtrinsicEra(hexToU8a(value));
  } else if (isObject(value)) {
    const entries = Object.entries(value).map(([k, v]) => [k.toLowerCase(), v]);
    const mortal = entries.find(([k]) => k.toLowerCase() === "mortalera");
    const immortal = entries.find(([k]) => k.toLowerCase() === "immortalera");
    return mortal ? { MortalEra: mortal[1] } : immortal ? { ImmortalEra: immortal[1] } : { MortalEra: value };
  }
  throw new Error("Invalid data passed to Era");
}
var ImmortalEra, MortalEra, GenericExtrinsicEra;
var init_ExtrinsicEra = __esm({
  "../../node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js"() {
    init_types_codec();
    init_util();
    init_constants2();
    ImmortalEra = class extends Raw {
      constructor(registry, _value) {
        super(registry, IMMORTAL_ERA);
      }
    };
    MortalEra = class extends Tuple {
      constructor(registry, value) {
        super(registry, {
          period: u643,
          phase: u643
        }, decodeMortalEra(registry, value));
      }
      /**
       * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`
       */
      get encodedLength() {
        return 2 | 0;
      }
      /**
       * @description The period of this Mortal wraps as a [[U64]]
       */
      get period() {
        return this[0];
      }
      /**
       * @description The phase of this Mortal wraps as a [[U64]]
       */
      get phase() {
        return this[1];
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return {
          period: formatNumber(this.period),
          phase: formatNumber(this.phase)
        };
      }
      /**
       * @description Returns a JSON representation of the actual value
       */
      toJSON() {
        return this.toHex();
      }
      /**
       * @description Encodes the value as a Uint8Array as per the parity-codec specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       * Period and phase are encoded:
       *   - The period of validity from the block hash found in the signing material.
       *   - The phase in the period that this transaction's lifetime begins (and, importantly,
       *     implies which block hash is included in the signature material). If the `period` is
       *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that
       *     `period` is.
       */
      toU8a(_isBare) {
        const period = this.period.toNumber();
        const encoded = Math.min(15, Math.max(1, getTrailingZeros(period) - 1)) + (this.phase.toNumber() / Math.max(period >> 12, 1) << 4);
        return new Uint8Array([
          encoded & 255,
          encoded >> 8
        ]);
      }
      /**
       * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.
       */
      birth(current) {
        const phase = this.phase.toNumber();
        const period = this.period.toNumber();
        return ~~((Math.max(bnToBn(current).toNumber(), phase) - phase) / period) * period + phase;
      }
      /**
       * @description Get the block number of the first block at which the era has ended.
       */
      death(current) {
        return this.birth(current) + this.period.toNumber();
      }
    };
    GenericExtrinsicEra = class extends Enum {
      constructor(registry, value) {
        super(registry, {
          ImmortalEra,
          MortalEra
        }, decodeExtrinsicEra(value));
      }
      /**
       * @description Override the encoded length method
       */
      get encodedLength() {
        return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;
      }
      /**
       * @description Returns the item as a [[ImmortalEra]]
       */
      get asImmortalEra() {
        if (!this.isImmortalEra) {
          throw new Error(`Cannot convert '${this.type}' via asImmortalEra`);
        }
        return this.inner;
      }
      /**
       * @description Returns the item as a [[MortalEra]]
       */
      get asMortalEra() {
        if (!this.isMortalEra) {
          throw new Error(`Cannot convert '${this.type}' via asMortalEra`);
        }
        return this.inner;
      }
      /**
       * @description `true` if Immortal
       */
      get isImmortalEra() {
        return this.index === 0;
      }
      /**
       * @description `true` if Mortal
       */
      get isMortalEra() {
        return this.index > 0;
      }
      /**
       * @description Encodes the value as a Uint8Array as per the parity-codec specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js
function decodeExtrinsicPayload(registry, value, version = LATEST_EXTRINSIC_VERSION, preamble = DEFAULT_PREAMBLE) {
  if (value instanceof GenericExtrinsicPayload) {
    return value.unwrap();
  }
  const extVersion = version === 5 ? PREAMBLES[preamble] : VERSIONS2[version] || VERSIONS2[0];
  if (value && value.assetId && isHex(value.assetId)) {
    const assetId = registry.createType("TAssetConversion", hexToU8a(value.assetId));
    if (value.assetId === "0x00" || value.assetId === "0x01" + assetId.toHex().slice(2)) {
      const adjustedPayload = {
        ...value,
        assetId: assetId.toJSON()
      };
      return registry.createTypeUnsafe(extVersion, [adjustedPayload, { version }]);
    }
  }
  return registry.createTypeUnsafe(extVersion, [value, { version }]);
}
var VERSIONS2, PREAMBLES, GenericExtrinsicPayload;
var init_ExtrinsicPayload = __esm({
  "../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js"() {
    init_types_codec();
    init_util();
    init_constants2();
    VERSIONS2 = [
      "ExtrinsicPayloadUnknown",
      // v0 is unknown
      "ExtrinsicPayloadUnknown",
      "ExtrinsicPayloadUnknown",
      "ExtrinsicPayloadUnknown",
      "ExtrinsicPayloadV4",
      "ExtrinsicPayloadV5"
    ];
    PREAMBLES = {
      bare: "ExtrinsicPayloadV5",
      // Not supported yet
      general: "ExtrinsicPayloadV5"
    };
    GenericExtrinsicPayload = class extends AbstractBase {
      constructor(registry, value, { preamble, version } = {}) {
        super(registry, decodeExtrinsicPayload(registry, value, version, preamble));
      }
      /**
       * @description The block [[BlockHash]] the signature applies to (mortal/immortal)
       */
      get blockHash() {
        return this.inner.blockHash;
      }
      /**
       * @description The [[ExtrinsicEra]]
       */
      get era() {
        return this.inner.era;
      }
      /**
       * @description The genesis block [[BlockHash]] the signature applies to
       */
      get genesisHash() {
        return this.inner.genesisHash || this.registry.createTypeUnsafe("Hash", []);
      }
      /**
       * @description The [[Bytes]] contained in the payload
       */
      get method() {
        return this.inner.method;
      }
      /**
       * @description The [[Index]]
       */
      get nonce() {
        return this.inner.nonce;
      }
      /**
       * @description The specVersion as a [[u32]] for this payload
       */
      get specVersion() {
        return this.inner.specVersion || this.registry.createTypeUnsafe("u32", []);
      }
      /**
       * @description The [[Balance]]
       */
      get tip() {
        return this.inner.tip || this.registry.createTypeUnsafe("Compact<Balance>", []);
      }
      /**
       * @description The transaction version as a [[u32]] for this payload
       */
      get transactionVersion() {
        return this.inner.transactionVersion || this.registry.createTypeUnsafe("u32", []);
      }
      /**
       * @description The (optional) asset id as a [[u32]] or [[MultiLocation]] for this payload
       */
      get assetId() {
        return this.inner.assetId;
      }
      /**
       * @description The (optional) [[Hash]] of the genesis metadata for this payload
       */
      get metadataHash() {
        return this.inner.metadataHash;
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return this.inner.eq(other);
      }
      /**
       * @description Sign the payload with the keypair
       */
      sign(signerPair) {
        const signature = this.inner.sign(signerPair);
        return {
          signature: u8aToHex(signature)
        };
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExtended, disableAscii) {
        return this.inner.toHuman(isExtended, disableAscii);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toHex();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "ExtrinsicPayload";
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.toHex();
      }
      /**
       * @description Returns a serialized u8a form
       */
      toU8a(isBare) {
        return super.toU8a(isBare ? { method: true } : false);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayloadUnknown.js
var GenericExtrinsicPayloadUnknown;
var init_ExtrinsicPayloadUnknown = __esm({
  "../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayloadUnknown.js"() {
    init_types_codec();
    GenericExtrinsicPayloadUnknown = class extends Struct {
      constructor(registry, _value, { version = 0 } = {}) {
        super(registry, {});
        throw new Error(`Unsupported extrinsic payload version ${version}`);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/ExtrinsicUnknown.js
var GenericExtrinsicUnknown;
var init_ExtrinsicUnknown = __esm({
  "../../node_modules/@polkadot/types/extrinsic/ExtrinsicUnknown.js"() {
    init_types_codec();
    init_constants2();
    GenericExtrinsicUnknown = class extends Struct {
      constructor(registry, _value, { isSigned = false, version = 0 } = {}) {
        super(registry, {});
        throw new Error(`Unsupported ${isSigned ? "" : "un"}signed extrinsic version ${version & UNMASK_VERSION}`);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/SignerPayload.js
var knownTypes, GenericSignerPayload;
var init_SignerPayload = __esm({
  "../../node_modules/@polkadot/types/extrinsic/SignerPayload.js"() {
    init_types_codec();
    init_util();
    knownTypes = {
      address: "Address",
      assetId: "Option<TAssetConversion>",
      blockHash: "Hash",
      blockNumber: "BlockNumber",
      era: "ExtrinsicEra",
      genesisHash: "Hash",
      metadataHash: "Option<[u8;32]>",
      method: "Call",
      mode: "u8",
      nonce: "Compact<Index>",
      runtimeVersion: "RuntimeVersion",
      signedExtensions: "Vec<Text>",
      tip: "Compact<Balance>",
      version: "u8"
    };
    GenericSignerPayload = class extends Struct {
      __internal__extraTypes;
      constructor(registry, value) {
        const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());
        super(registry, objectSpread({}, extensionTypes, knownTypes, { withSignedTransaction: "bool" }), value);
        this.__internal__extraTypes = {};
        const getter = (key) => this.get(key);
        for (const [key, type] of Object.entries(extensionTypes)) {
          if (!knownTypes[key]) {
            this.__internal__extraTypes[key] = type;
          }
          objectProperty(this, key, getter);
        }
      }
      get address() {
        return this.getT("address");
      }
      get blockHash() {
        return this.getT("blockHash");
      }
      get blockNumber() {
        return this.getT("blockNumber");
      }
      get era() {
        return this.getT("era");
      }
      get genesisHash() {
        return this.getT("genesisHash");
      }
      get method() {
        return this.getT("method");
      }
      get nonce() {
        return this.getT("nonce");
      }
      get runtimeVersion() {
        return this.getT("runtimeVersion");
      }
      get signedExtensions() {
        return this.getT("signedExtensions");
      }
      get tip() {
        return this.getT("tip");
      }
      get assetId() {
        return this.getT("assetId");
      }
      get version() {
        return this.getT("version");
      }
      get mode() {
        return this.getT("mode");
      }
      get metadataHash() {
        return this.getT("metadataHash");
      }
      get withSignedTransaction() {
        const val = this.getT("withSignedTransaction");
        return val.isTrue;
      }
      /**
       * @description Creates an representation of the structure as an ISignerPayload JSON
       */
      toPayload() {
        const result = {};
        const keys2 = Object.keys(this.__internal__extraTypes);
        for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
          const key = keys2[i2];
          const value = this.getT(key);
          if (!(value instanceof Option) || value.isSome) {
            result[key] = value.toJSON();
          }
        }
        return objectSpread(result, {
          // the known defaults as managed explicitly and has different
          // formatting in cases, e.g. we mostly expose a hex format here
          address: this.address.toString(),
          assetId: this.assetId && this.assetId.isSome ? this.assetId.toHex() : null,
          blockHash: this.blockHash.toHex(),
          blockNumber: this.blockNumber.toHex(),
          era: this.era.toHex(),
          genesisHash: this.genesisHash.toHex(),
          metadataHash: this.metadataHash.isSome ? this.metadataHash.toHex() : null,
          method: this.method.toHex(),
          mode: this.mode.toNumber(),
          nonce: this.nonce.toHex(),
          signedExtensions: this.signedExtensions.map((e2) => e2.toString()),
          specVersion: this.runtimeVersion.specVersion.toHex(),
          tip: this.tip.toHex(),
          transactionVersion: this.runtimeVersion.transactionVersion.toHex(),
          version: this.version.toNumber(),
          withSignedTransaction: this.withSignedTransaction
        });
      }
      /**
       * @description Creates a representation of the payload in raw Exrinsic form
       */
      toRaw() {
        const payload = this.toPayload();
        const data = u8aToHex(this.registry.createTypeUnsafe("ExtrinsicPayload", [payload, { version: payload.version }]).toU8a({ method: true }));
        return {
          address: payload.address,
          data,
          type: "payload"
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js
var EXTRINSIC_VERSION, GenericExtrinsicV4;
var init_Extrinsic2 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js"() {
    init_types_codec();
    init_util();
    EXTRINSIC_VERSION = 4;
    GenericExtrinsicV4 = class _GenericExtrinsicV4 extends Struct {
      constructor(registry, value, { isSigned } = {}) {
        super(registry, {
          signature: "ExtrinsicSignatureV4",
          // eslint-disable-next-line sort-keys
          method: "Call"
        }, _GenericExtrinsicV4.decodeExtrinsic(registry, value, isSigned));
      }
      /** @internal */
      static decodeExtrinsic(registry, value, isSigned = false) {
        if (value instanceof _GenericExtrinsicV4) {
          return value;
        } else if (value instanceof registry.createClassUnsafe("Call")) {
          return { method: value };
        } else if (isU8a(value)) {
          const signature = registry.createTypeUnsafe("ExtrinsicSignatureV4", [value, { isSigned }]);
          const method = registry.createTypeUnsafe("Call", [value.subarray(signature.encodedLength)]);
          return {
            method,
            signature
          };
        }
        return value || {};
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description The [[Call]] this extrinsic wraps
       */
      get method() {
        return this.getT("method");
      }
      /**
       * @description The [[ExtrinsicSignatureV4]]
       */
      get signature() {
        return this.getT("signature");
      }
      /**
       * @description The version for the signature
       */
      get version() {
        return EXTRINSIC_VERSION;
      }
      /**
       * @description Add an [[ExtrinsicSignatureV4]] to the extrinsic (already generated)
       */
      addSignature(signer, signature, payload) {
        this.signature.addSignature(signer, signature, payload);
        return this;
      }
      /**
       * @description Sign the extrinsic with a specific keypair
       */
      sign(account3, options) {
        this.signature.sign(this.method, account3, options);
        return this;
      }
      /**
       * @describe Adds a fake signature to the extrinsic
       */
      signFake(signer, options) {
        this.signature.signFake(this.method, signer, options);
        return this;
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/util.js
function sign(registry, signerPair, u8a, options) {
  const encoded = u8a.length > 256 ? registry.hash(u8a) : u8a;
  return signerPair.sign(encoded, options);
}
var init_util6 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/util.js"() {
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js
var GenericExtrinsicPayloadV4;
var init_ExtrinsicPayload2 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js"() {
    init_types_codec();
    init_util();
    init_util6();
    GenericExtrinsicPayloadV4 = class extends Struct {
      __internal__signOptions;
      constructor(registry, value) {
        super(registry, objectSpread({ method: "Bytes" }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);
        this.__internal__signOptions = {
          withType: registry.createTypeUnsafe("ExtrinsicSignature", []) instanceof Enum
        };
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return super.inspect({ method: true });
      }
      /**
       * @description The block [[BlockHash]] the signature applies to (mortal/immortal)
       */
      get blockHash() {
        return this.getT("blockHash");
      }
      /**
       * @description The [[ExtrinsicEra]]
       */
      get era() {
        return this.getT("era");
      }
      /**
       * @description The genesis [[BlockHash]] the signature applies to (mortal/immortal)
       */
      get genesisHash() {
        return this.getT("genesisHash");
      }
      /**
       * @description The [[Bytes]] contained in the payload
       */
      get method() {
        return this.getT("method");
      }
      /**
       * @description The [[Index]]
       */
      get nonce() {
        return this.getT("nonce");
      }
      /**
       * @description The specVersion for this signature
       */
      get specVersion() {
        return this.getT("specVersion");
      }
      /**
       * @description The tip [[Balance]]
       */
      get tip() {
        return this.getT("tip");
      }
      /**
       * @description The transactionVersion for this signature
       */
      get transactionVersion() {
        return this.getT("transactionVersion");
      }
      /**
       * @description The (optional) asset id for this signature for chains that support transaction fees in assets
       */
      get assetId() {
        return this.getT("assetId");
      }
      /**
       * @description The (optional) asset id for this signature for chains that support transaction fees in assets
       */
      get metadataHash() {
        return this.getT("metadataHash");
      }
      /**
       * @description Sign the payload with the keypair
       */
      sign(signerPair) {
        return sign(this.registry, signerPair, this.toU8a({ method: true }), this.__internal__signOptions);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js
function toAddress(registry, address) {
  return registry.createTypeUnsafe("Address", [isU8a(address) ? u8aToHex(address) : address]);
}
var FAKE_SIGNATURE, GenericExtrinsicSignatureV4;
var init_ExtrinsicSignature = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js"() {
    init_types_codec();
    init_util();
    init_constants2();
    init_ExtrinsicPayload2();
    FAKE_SIGNATURE = new Uint8Array(256).fill(1);
    GenericExtrinsicSignatureV4 = class _GenericExtrinsicSignatureV4 extends Struct {
      __internal__signKeys;
      constructor(registry, value, { isSigned } = {}) {
        const signTypes = registry.getSignedExtensionTypes();
        super(registry, objectSpread(
          // eslint-disable-next-line sort-keys
          { signer: "Address", signature: "ExtrinsicSignature" },
          signTypes
        ), _GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));
        this.__internal__signKeys = Object.keys(signTypes);
        objectProperties(this, this.__internal__signKeys, (k) => this.get(k));
      }
      /** @internal */
      static decodeExtrinsicSignature(value, isSigned = false) {
        if (!value) {
          return EMPTY_U8A3;
        } else if (value instanceof _GenericExtrinsicSignatureV4) {
          return value;
        }
        return isSigned ? value : EMPTY_U8A3;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.isSigned ? super.encodedLength : 0;
      }
      /**
       * @description `true` if the signature is valid
       */
      get isSigned() {
        return !this.signature.isEmpty;
      }
      /**
       * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
       */
      get era() {
        return this.getT("era");
      }
      /**
       * @description The [[Index]] for the signature
       */
      get nonce() {
        return this.getT("nonce");
      }
      /**
       * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
       */
      get signature() {
        return this.multiSignature.value || this.multiSignature;
      }
      /**
       * @description The raw [[ExtrinsicSignature]]
       */
      get multiSignature() {
        return this.getT("signature");
      }
      /**
       * @description The [[Address]] that signed
       */
      get signer() {
        return this.getT("signer");
      }
      /**
       * @description The [[Balance]] tip
       */
      get tip() {
        return this.getT("tip");
      }
      /**
       * @description The [[u32]] or [[MultiLocation]] assetId
       */
      get assetId() {
        return this.getT("assetId");
      }
      /**
       * @description the [[u32]] mode
       */
      get mode() {
        return this.getT("mode");
      }
      /**
       * @description The [[Hash]] for the metadata
       */
      get metadataHash() {
        return this.getT("metadataHash");
      }
      _injectSignature(signer, signature, payload) {
        for (let i2 = 0, count = this.__internal__signKeys.length; i2 < count; i2++) {
          const k = this.__internal__signKeys[i2];
          const v = payload.get(k);
          if (!isUndefined(v)) {
            this.set(k, v);
          }
        }
        this.set("signer", signer);
        this.set("signature", signature);
        return this;
      }
      /**
       * @description Adds a raw signature
       */
      addSignature(signer, signature, payload) {
        return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe("ExtrinsicSignature", [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));
      }
      /**
       * @description Creates a payload from the supplied options
       */
      createPayload(method, options) {
        const { era, runtimeVersion: { specVersion, transactionVersion } } = options;
        return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {
          era: era || IMMORTAL_ERA,
          method: method.toHex(),
          specVersion,
          transactionVersion
        }));
      }
      /**
       * @description Generate a payload and applies the signature from a keypair
       */
      sign(method, account3, options) {
        if (!account3?.addressRaw) {
          throw new Error(`Expected a valid keypair for signing, found ${stringify(account3)}`);
        }
        const payload = this.createPayload(method, options);
        return this._injectSignature(toAddress(this.registry, account3.addressRaw), this.registry.createTypeUnsafe("ExtrinsicSignature", [payload.sign(account3)]), payload);
      }
      /**
       * @description Generate a payload and applies a fake signature
       */
      signFake(method, address, options) {
        if (!address) {
          throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);
        }
        const payload = this.createPayload(method, options);
        return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe("ExtrinsicSignature", [FAKE_SIGNATURE]), payload);
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A3;
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v4/index.js
var init_v42 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v4/index.js"() {
    init_Extrinsic2();
    init_ExtrinsicPayload2();
    init_ExtrinsicSignature();
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v5/Extrinsic.js
var EXTRINSIC_VERSION2, GenericExtrinsicV5;
var init_Extrinsic3 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v5/Extrinsic.js"() {
    init_types_codec();
    init_util();
    EXTRINSIC_VERSION2 = 5;
    GenericExtrinsicV5 = class _GenericExtrinsicV5 extends Struct {
      constructor(registry, value, { isSigned } = {}) {
        super(registry, {
          signature: "ExtrinsicSignatureV5",
          // eslint-disable-next-line sort-keys
          method: "Call"
        }, _GenericExtrinsicV5.decodeExtrinsic(registry, value, isSigned));
      }
      /** @internal */
      static decodeExtrinsic(registry, value, isSigned = false) {
        if (value instanceof _GenericExtrinsicV5) {
          return value;
        } else if (value instanceof registry.createClassUnsafe("Call")) {
          return { method: value };
        } else if (isU8a(value)) {
          const signature = registry.createTypeUnsafe("ExtrinsicSignatureV5", [value, { isSigned }]);
          const method = registry.createTypeUnsafe("Call", [value.subarray(signature.encodedLength)]);
          return {
            method,
            signature
          };
        }
        return value || {};
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description The [[Call]] this extrinsic wraps
       */
      get method() {
        return this.getT("method");
      }
      /**
       * @description The [[ExtrinsicSignatureV5]]
       */
      get signature() {
        return this.getT("signature");
      }
      /**
       * @description The version for the signature
       */
      get version() {
        return EXTRINSIC_VERSION2;
      }
      /**
       * @description The [[Preamble]] for the extrinsic
       */
      get preamble() {
        return this.getT("preamble");
      }
      /**
       * @description Add an [[ExtrinsicSignatureV5]] to the extrinsic (already generated)
       *
       * [Disabled for ExtrinsicV5]
       */
      addSignature(_signer, _signature, _payload) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
      /**
       * @description Sign the extrinsic with a specific keypair
       *
       * [Disabled for ExtrinsicV5]
       */
      sign(_account, _options) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
      /**
       * @describe Adds a fake signature to the extrinsic
       *
       * [Disabled for ExtrinsicV5]
       */
      signFake(_signer, _options) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v5/ExtrinsicPayload.js
var GenericExtrinsicPayloadV5;
var init_ExtrinsicPayload3 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v5/ExtrinsicPayload.js"() {
    init_types_codec();
    init_util();
    GenericExtrinsicPayloadV5 = class extends Struct {
      constructor(registry, value) {
        super(registry, objectSpread({ method: "Bytes" }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        return super.inspect({ method: true });
      }
      /**
       * @description The block [[BlockHash]] the signature applies to (mortal/immortal)
       */
      get blockHash() {
        return this.getT("blockHash");
      }
      /**
       * @description The [[ExtrinsicEra]]
       */
      get era() {
        return this.getT("era");
      }
      /**
       * @description The genesis [[BlockHash]] the signature applies to (mortal/immortal)
       */
      get genesisHash() {
        return this.getT("genesisHash");
      }
      /**
       * @description The [[Bytes]] contained in the payload
       */
      get method() {
        return this.getT("method");
      }
      /**
       * @description The [[Index]]
       */
      get nonce() {
        return this.getT("nonce");
      }
      /**
       * @description The specVersion for this signature
       */
      get specVersion() {
        return this.getT("specVersion");
      }
      /**
       * @description The tip [[Balance]]
       */
      get tip() {
        return this.getT("tip");
      }
      /**
       * @description The transactionVersion for this signature
       */
      get transactionVersion() {
        return this.getT("transactionVersion");
      }
      /**
       * @description The (optional) asset id for this signature for chains that support transaction fees in assets
       */
      get assetId() {
        return this.getT("assetId");
      }
      /**
       * @description The (optional) metadataHash proof for the CheckMetadataHash TransactionExtension
       */
      get metadataHash() {
        return this.getT("metadataHash");
      }
      /**
       * @description Sign the payload with the keypair
       *
       * [Disabled for ExtrinsicV5]
       */
      sign(_signerPair) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v5/ExtrinsicSignature.js
var GenericExtrinsicSignatureV5;
var init_ExtrinsicSignature2 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v5/ExtrinsicSignature.js"() {
    init_types_codec();
    init_util();
    init_constants2();
    init_ExtrinsicPayload3();
    GenericExtrinsicSignatureV5 = class _GenericExtrinsicSignatureV5 extends Struct {
      __internal__signKeys;
      constructor(registry, value, { isSigned } = {}) {
        const signTypes = registry.getSignedExtensionTypes();
        super(registry, objectSpread(
          // eslint-disable-next-line sort-keys
          { signer: "Address", signature: "ExtrinsicSignature", transactionExtensionVersion: "u8" },
          signTypes
        ), _GenericExtrinsicSignatureV5.decodeExtrinsicSignature(value, isSigned));
        this.__internal__signKeys = Object.keys(signTypes);
        objectProperties(this, this.__internal__signKeys, (k) => this.get(k));
      }
      /** @internal */
      static decodeExtrinsicSignature(value, isSigned = false) {
        if (!value) {
          return EMPTY_U8A3;
        } else if (value instanceof _GenericExtrinsicSignatureV5) {
          return value;
        }
        return isSigned ? value : EMPTY_U8A3;
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return this.isSigned ? super.encodedLength : 0;
      }
      /**
       * @description `true` if the signature is valid
       */
      get isSigned() {
        return !this.signature.isEmpty;
      }
      /**
       * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
       */
      get era() {
        return this.getT("era");
      }
      /**
       * @description The [[Index]] for the signature
       */
      get nonce() {
        return this.getT("nonce");
      }
      /**
       * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
       */
      get signature() {
        return this.multiSignature.value || this.multiSignature;
      }
      /**
       * @description The raw [[ExtrinsicSignature]]
       */
      get multiSignature() {
        return this.getT("signature");
      }
      /**
       * @description The [[Address]] that signed
       */
      get signer() {
        return this.getT("signer");
      }
      /**
       * @description The [[Balance]] tip
       */
      get tip() {
        return this.getT("tip");
      }
      /**
       * @description The [[u32]] or [[MultiLocation]] assetId
       */
      get assetId() {
        return this.getT("assetId");
      }
      /**
       * @description the [[u32]] mode
       */
      get mode() {
        return this.getT("mode");
      }
      /**
       * @description The (optional)  [[Hash]] for the metadata proof
       */
      get metadataHash() {
        return this.getT("metadataHash");
      }
      /**
       * @description The [[u8]] for the TransactionExtension version
       */
      get transactionExtensionVersion() {
        return this.getT("transactionExtensionVersion");
      }
      /**
       * [Disabled for ExtrinsicV5]
       */
      _injectSignature(_signer, _signature, _payload) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
      /**
       * @description Adds a raw signature
       *
       * [Disabled for ExtrinsicV5]
       */
      addSignature(_signer, _signature, _payload) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
      /**
       * @description Creates a payload from the supplied options
       */
      createPayload(method, options) {
        const { era, runtimeVersion: { specVersion, transactionVersion } } = options;
        return new GenericExtrinsicPayloadV5(this.registry, objectSpread({}, options, {
          era: era || IMMORTAL_ERA,
          method: method.toHex(),
          specVersion,
          transactionVersion
        }));
      }
      /**
       * @description Generate a payload and applies the signature from a keypair
       *
       * [Disabled for ExtrinsicV5]
       */
      sign(_method, _account, _options) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
      /**
       * @description Generate a payload and applies a fake signature
       *
       * [Disabled for ExtrinsicV5]
       */
      signFake(_method, _address, _options) {
        throw new Error("Extrinsic: ExtrinsicV5 does not include signing support");
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A3;
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v5/GeneralExtrinsic.js
function decodeU8a4(u8a) {
  if (!u8a.length) {
    return new Uint8Array();
  }
  const [offset, length] = compactFromU8a(u8a);
  const total = offset + length.toNumber();
  if (total > u8a.length) {
    throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${u8a.length}`);
  }
  const data = u8a.subarray(offset, total);
  if (data[0] !== 69) {
    throw new Error(`Extrinsic: incorrect version for General Transactions, expected 5, found ${data[0] & UNMASK_VERSION}`);
  }
  return data.subarray(1);
}
var GeneralExtrinsic;
var init_GeneralExtrinsic = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v5/GeneralExtrinsic.js"() {
    init_types_codec();
    init_util();
    init_constants2();
    GeneralExtrinsic = class _GeneralExtrinsic extends Struct {
      __internal__version;
      __internal__preamble;
      constructor(registry, value, opt) {
        const extTypes = registry.getSignedExtensionTypes();
        super(registry, objectSpread({
          transactionExtensionVersion: "u8"
        }, extTypes, {
          method: "Call"
        }), _GeneralExtrinsic.decodeExtrinsic(registry, value));
        this.__internal__version = opt?.version || 5;
        this.__internal__preamble = 64;
      }
      static decodeExtrinsic(registry, value) {
        if (!value) {
          return EMPTY_U8A3;
        } else if (value instanceof _GeneralExtrinsic) {
          return value;
        } else if (isU8a(value) || Array.isArray(value) || isHex(value)) {
          return decodeU8a4(u8aToU8a(value));
        } else if (isObject(value)) {
          const { payload, transactionExtensionVersion } = value;
          return objectSpread(payload || {}, {
            transactionExtensionVersion: transactionExtensionVersion || registry.getTransactionExtensionVersion()
          });
        }
        return {};
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        return super.encodedLength;
      }
      /**
       * @description The [[ExtrinsicEra]]
       */
      get era() {
        return this.getT("era");
      }
      /**
       * @description The [[Index]]
       */
      get nonce() {
        return this.getT("nonce");
      }
      /**
       * @description The tip [[Balance]]
       */
      get tip() {
        return this.getT("tip");
      }
      /**
       * @description The (optional) asset id for this signature for chains that support transaction fees in assets
       */
      get assetId() {
        return this.getT("assetId");
      }
      /**
       * @description The mode used for the CheckMetadataHash TransactionExtension
       */
      get mode() {
        return this.getT("mode");
      }
      /**
       * @description The (optional) [[Hash]] for the metadata proof
       */
      get metadataHash() {
        return this.getT("metadataHash");
      }
      /**
       * @description The version of the TransactionExtensions used in this extrinsic
       */
      get transactionExtensionVersion() {
        return this.getT("transactionExtensionVersion");
      }
      /**
       * @description The [[Call]] this extrinsic wraps
       */
      get method() {
        return this.getT("method");
      }
      /**
       * @description The extrinsic's version
       */
      get version() {
        return this.__internal__version;
      }
      /**
       * @description The [[Preamble]] for the extrinsic
       */
      get preamble() {
        return this.__internal__preamble;
      }
      toHex(isBare) {
        return u8aToHex(this.toU8a(isBare));
      }
      toU8a(isBare) {
        return isBare ? this.encode() : compactAddLength(this.encode());
      }
      toRawType() {
        return "GeneralExt";
      }
      /**
       *
       * @description Returns an encoded GeneralExtrinsic
       */
      encode() {
        return u8aConcat(new Uint8Array([this.version | this.preamble]), super.toU8a());
      }
      signFake() {
        throw new Error("Extrinsic: Type GeneralExtrinsic does not have signFake implemented");
      }
      addSignature() {
        throw new Error("Extrinsic: Type GeneralExtrinsic does not have addSignature implemented");
      }
      sign() {
        throw new Error("Extrinsic: Type GeneralExtrinsic does not have sign implemented");
      }
      signature() {
        throw new Error("Extrinsic: Type GeneralExtrinsic does not have the signature getter");
      }
    };
  }
});

// ../../node_modules/@polkadot/types/extrinsic/v5/index.js
var init_v5 = __esm({
  "../../node_modules/@polkadot/types/extrinsic/v5/index.js"() {
    init_Extrinsic3();
    init_ExtrinsicPayload3();
    init_ExtrinsicSignature2();
    init_GeneralExtrinsic();
  }
});

// ../../node_modules/@polkadot/types/extrinsic/index.js
var init_extrinsic = __esm({
  "../../node_modules/@polkadot/types/extrinsic/index.js"() {
    init_Extrinsic();
    init_ExtrinsicEra();
    init_ExtrinsicPayload();
    init_ExtrinsicPayloadUnknown();
    init_ExtrinsicUnknown();
    init_SignerPayload();
    init_v42();
    init_v5();
  }
});

// ../../node_modules/@polkadot/types/generic/AccountId.js
function decodeAccountId(value) {
  if (isU8a(value) || Array.isArray(value)) {
    return u8aToU8a(value);
  } else if (!value) {
    return new Uint8Array();
  } else if (isHex(value)) {
    return hexToU8a(value);
  } else if (isString(value)) {
    return decodeAddress(value.toString());
  }
  throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof value}`);
}
var BaseAccountId, GenericAccountId, GenericAccountId33;
var init_AccountId = __esm({
  "../../node_modules/@polkadot/types/generic/AccountId.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    BaseAccountId = class extends U8aFixed {
      constructor(registry, allowedBits = 256 | 264, value) {
        const decoded = decodeAccountId(value);
        const decodedBits = decoded.length * 8;
        if (decodedBits < allowedBits && decoded.some((b) => b)) {
          throw new Error(`Invalid AccountId provided, expected ${allowedBits >> 3} bytes, found ${decoded.length}`);
        }
        super(registry, decoded, allowedBits);
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return super.eq(decodeAccountId(other));
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toString();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toJSON();
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return encodeAddress(this, this.registry.chainSS58);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "AccountId";
      }
    };
    GenericAccountId = class extends BaseAccountId {
      constructor(registry, value) {
        super(registry, 256, value);
      }
    };
    GenericAccountId33 = class extends BaseAccountId {
      constructor(registry, value) {
        super(registry, 264, value);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/AccountIndex.js
function decodeAccountIndex(value) {
  if (value instanceof GenericAccountIndex) {
    return value.toBn();
  } else if (isBn(value) || isNumber(value) || isHex(value) || isU8a(value) || isBigInt(value)) {
    return value;
  }
  return decodeAccountIndex(decodeAddress(value));
}
var PREFIX_1BYTE, PREFIX_2BYTE, PREFIX_4BYTE, PREFIX_8BYTE, MAX_1BYTE, MAX_2BYTE, MAX_4BYTE, GenericAccountIndex;
var init_AccountIndex = __esm({
  "../../node_modules/@polkadot/types/generic/AccountIndex.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    PREFIX_1BYTE = 239;
    PREFIX_2BYTE = 252;
    PREFIX_4BYTE = 253;
    PREFIX_8BYTE = 254;
    MAX_1BYTE = new import_bn.default(PREFIX_1BYTE);
    MAX_2BYTE = new import_bn.default(1).shln(16);
    MAX_4BYTE = new import_bn.default(1).shln(32);
    GenericAccountIndex = class _GenericAccountIndex extends u323 {
      constructor(registry, value = new import_bn.default(0)) {
        super(registry, decodeAccountIndex(value));
      }
      static calcLength(_value) {
        const value = bnToBn(_value);
        if (value.lte(MAX_1BYTE)) {
          return 1;
        } else if (value.lt(MAX_2BYTE)) {
          return 2;
        } else if (value.lt(MAX_4BYTE)) {
          return 4;
        }
        return 8;
      }
      static readLength(input) {
        const first2 = input[0];
        if (first2 === PREFIX_2BYTE) {
          return [1, 2];
        } else if (first2 === PREFIX_4BYTE) {
          return [1, 4];
        } else if (first2 === PREFIX_8BYTE) {
          return [1, 8];
        }
        return [0, 1];
      }
      static writeLength(input) {
        switch (input.length) {
          case 2:
            return new Uint8Array([PREFIX_2BYTE]);
          case 4:
            return new Uint8Array([PREFIX_4BYTE]);
          case 8:
            return new Uint8Array([PREFIX_8BYTE]);
          default:
            return new Uint8Array([]);
        }
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        if (isBn(other) || isNumber(other)) {
          return super.eq(other);
        }
        return super.eq(this.registry.createTypeUnsafe("AccountIndex", [other]));
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toString();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toJSON();
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        const length = _GenericAccountIndex.calcLength(this);
        return encodeAddress(this.toU8a().subarray(0, length), this.registry.chainSS58);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "AccountIndex";
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/Block.js
var GenericBlock;
var init_Block = __esm({
  "../../node_modules/@polkadot/types/generic/Block.js"() {
    init_types_codec();
    GenericBlock = class extends Struct {
      constructor(registry, value) {
        super(registry, {
          header: "Header",
          // eslint-disable-next-line sort-keys
          extrinsics: "Vec<Extrinsic>"
        }, value);
      }
      /**
       * @description Encodes a content [[Hash]] for the block
       */
      get contentHash() {
        return this.registry.hash(this.toU8a());
      }
      /**
       * @description The [[Extrinsic]] contained in the block
       */
      get extrinsics() {
        return this.getT("extrinsics");
      }
      /**
       * @description Block/header [[Hash]]
       */
      get hash() {
        return this.header.hash;
      }
      /**
       * @description The [[Header]] of the block
       */
      get header() {
        return this.getT("header");
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/Call.js
function getArgsDef(registry, meta) {
  return meta.fields.reduce((result, { name, type }, index) => {
    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);
    return result;
  }, {});
}
function decodeCallViaObject(registry, value, _meta) {
  const { args, callIndex } = value;
  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;
  const meta = _meta || registry.findMetaCall(lookupIndex).meta;
  return {
    args,
    argsDef: getArgsDef(registry, meta),
    callIndex,
    meta
  };
}
function decodeCallViaU8a(registry, value, _meta) {
  const callIndex = registry.firstCallIndex.slice();
  callIndex.set(value.subarray(0, 2), 0);
  const meta = _meta || registry.findMetaCall(callIndex).meta;
  return {
    args: value.subarray(2),
    argsDef: getArgsDef(registry, meta),
    callIndex,
    meta
  };
}
function decodeCall(registry, value = new Uint8Array(), _meta) {
  if (isU8a(value) || isHex(value)) {
    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);
  } else if (isObject(value) && value.callIndex && value.args) {
    return decodeCallViaObject(registry, value, _meta);
  }
  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);
}
var GenericCallIndex, GenericCall;
var init_Call = __esm({
  "../../node_modules/@polkadot/types/generic/Call.js"() {
    init_types_codec();
    init_util();
    GenericCallIndex = class extends U8aFixed {
      constructor(registry, value) {
        super(registry, value, 16);
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toHex();
      }
    };
    GenericCall = class extends Struct {
      _meta;
      constructor(registry, value, meta) {
        const decoded = decodeCall(registry, value, meta);
        try {
          super(registry, {
            callIndex: GenericCallIndex,
            // eslint-disable-next-line sort-keys
            args: Struct.with(decoded.argsDef)
          }, decoded);
        } catch (error) {
          let method = "unknown.unknown";
          try {
            const c = registry.findMetaCall(decoded.callIndex);
            method = `${c.section}.${c.method}`;
          } catch {
          }
          throw new Error(`Call: failed decoding ${method}:: ${error.message}`);
        }
        this._meta = decoded.meta;
      }
      /**
       * @description The arguments for the function call
       */
      get args() {
        return [...this.getT("args").values()];
      }
      /**
       * @description The argument definitions
       */
      get argsDef() {
        return getArgsDef(this.registry, this.meta);
      }
      /**
       * @description The argument entries
       */
      get argsEntries() {
        return [...this.getT("args").entries()];
      }
      /**
       * @description The encoded `[sectionIndex, methodIndex]` identifier
       */
      get callIndex() {
        return this.getT("callIndex").toU8a();
      }
      /**
       * @description The encoded data
       */
      get data() {
        return this.getT("args").toU8a();
      }
      /**
       * @description The [[FunctionMetadata]]
       */
      get meta() {
        return this._meta;
      }
      /**
       * @description Returns the name of the method
       */
      get method() {
        return this.registry.findMetaCall(this.callIndex).method;
      }
      /**
       * @description Returns the module containing the method
       */
      get section() {
        return this.registry.findMetaCall(this.callIndex).section;
      }
      /**
       * @description Checks if the source matches this in type
       */
      is(other) {
        return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExpanded, disableAscii) {
        let call;
        try {
          call = this.registry.findMetaCall(this.callIndex);
        } catch {
        }
        return objectSpread({
          args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, { [n]: a.toHuman(isExpanded, disableAscii) }), {}),
          method: call?.method,
          section: call?.section
        }, isExpanded && call ? { docs: call.meta.docs.map((d) => d.toString()) } : null);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Call";
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/ChainProperties.js
function createValue(registry, type, value, asArray = true) {
  if (value && isFunction(value.unwrapOrDefault)) {
    return value;
  }
  return registry.createTypeUnsafe(type, [
    asArray ? isNull(value) || isUndefined(value) ? null : Array.isArray(value) ? value : [value] : value
  ]);
}
function decodeValue(registry, key, value) {
  return key === "ss58Format" ? createValue(registry, "Option<u32>", value, false) : key === "tokenDecimals" ? createValue(registry, "Option<Vec<u32>>", value) : key === "tokenSymbol" ? createValue(registry, "Option<Vec<Text>>", value) : key === "isEthereum" ? createValue(registry, "Bool", value, false) : value;
}
function decode(registry, value) {
  return (
    // allow decoding from a map as well (ourselves)
    (value && isFunction(value.entries) ? [...value.entries()] : Object.entries(value || {})).reduce((all3, [key, value2]) => {
      all3[key] = decodeValue(registry, key, value2);
      return all3;
    }, {
      isEthereum: registry.createTypeUnsafe("Bool", []),
      ss58Format: registry.createTypeUnsafe("Option<u32>", []),
      tokenDecimals: registry.createTypeUnsafe("Option<Vec<u32>>", []),
      tokenSymbol: registry.createTypeUnsafe("Option<Vec<Text>>", [])
    })
  );
}
var GenericChainProperties;
var init_ChainProperties = __esm({
  "../../node_modules/@polkadot/types/generic/ChainProperties.js"() {
    init_types_codec();
    init_util();
    GenericChainProperties = class extends Json {
      constructor(registry, value) {
        super(registry, decode(registry, value));
      }
      /**
       * @description The chain uses Ethereum addresses
       */
      get isEthereum() {
        return this.getT("isEthereum");
      }
      /**
       * @description The chain ss58Format
       */
      get ss58Format() {
        return this.getT("ss58Format");
      }
      /**
       * @description The decimals for each of the tokens
       */
      get tokenDecimals() {
        return this.getT("tokenDecimals");
      }
      /**
       * @description The symbols for the tokens
       */
      get tokenSymbol() {
        return this.getT("tokenSymbol");
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/ConsensusEngineId.js
function getAuraAuthor(registry, bytes2, sessionValidators) {
  return sessionValidators[registry.createTypeUnsafe("RawAuraPreDigest", [bytes2.toU8a(true)]).slotNumber.mod(new import_bn.default(sessionValidators.length)).toNumber()];
}
function getBabeAuthor(registry, bytes2, sessionValidators) {
  const digest = registry.createTypeUnsafe("RawBabePreDigestCompat", [bytes2.toU8a(true)]);
  return sessionValidators[digest.value.toNumber()];
}
function getBytesAsAuthor(registry, bytes2) {
  return registry.createTypeUnsafe("AccountId", [bytes2]);
}
var CID_AURA, CID_BABE, CID_GRPA, CID_POW, CID_NMBS, GenericConsensusEngineId;
var init_ConsensusEngineId = __esm({
  "../../node_modules/@polkadot/types/generic/ConsensusEngineId.js"() {
    init_types_codec();
    init_util();
    CID_AURA = /* @__PURE__ */ stringToU8a("aura");
    CID_BABE = /* @__PURE__ */ stringToU8a("BABE");
    CID_GRPA = /* @__PURE__ */ stringToU8a("FRNK");
    CID_POW = /* @__PURE__ */ stringToU8a("pow_");
    CID_NMBS = /* @__PURE__ */ stringToU8a("nmbs");
    GenericConsensusEngineId = class extends U8aFixed {
      constructor(registry, value) {
        super(registry, isNumber(value) ? bnToU8a(value, { isLe: false }) : value, 32);
      }
      /**
       * @description `true` if the engine matches aura
       */
      get isAura() {
        return this.eq(CID_AURA);
      }
      /**
       * @description `true` is the engine matches babe
       */
      get isBabe() {
        return this.eq(CID_BABE);
      }
      /**
       * @description `true` is the engine matches grandpa
       */
      get isGrandpa() {
        return this.eq(CID_GRPA);
      }
      /**
       * @description `true` is the engine matches pow
       */
      get isPow() {
        return this.eq(CID_POW);
      }
      /**
       * @description `true` is the engine matches nimbus
       */
      get isNimbus() {
        return this.eq(CID_NMBS);
      }
      /**
       * @description From the input bytes, decode into an author
       */
      extractAuthor(bytes2, sessionValidators) {
        if (sessionValidators?.length) {
          if (this.isAura) {
            return getAuraAuthor(this.registry, bytes2, sessionValidators);
          } else if (this.isBabe) {
            return getBabeAuthor(this.registry, bytes2, sessionValidators);
          }
        }
        if (this.isPow || this.isNimbus) {
          return getBytesAsAuthor(this.registry, bytes2);
        }
        return void 0;
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toString();
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "ConsensusEngineId";
      }
      /**
       * @description Override the default toString to return a 4-byte string
       */
      toString() {
        return this.isAscii ? u8aToString(this) : u8aToHex(this);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/LookupSource.js
function decodeString(registry, value) {
  const decoded = decodeAddress(value);
  return decoded.length === 32 ? registry.createTypeUnsafe("AccountId", [decoded]) : registry.createTypeUnsafe("AccountIndex", [u8aToBn(decoded)]);
}
function decodeU8a5(registry, value) {
  if (value.length === 32) {
    return registry.createTypeUnsafe("AccountId", [value]);
  } else if (value[0] === 255) {
    return registry.createTypeUnsafe("AccountId", [value.subarray(1)]);
  }
  const [offset, length] = GenericAccountIndex.readLength(value);
  return registry.createTypeUnsafe("AccountIndex", [u8aToBn(value.subarray(offset, offset + length))]);
}
function decodeAddressOrIndex(registry, value) {
  return value instanceof GenericLookupSource ? value.inner : value instanceof GenericAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createTypeUnsafe("AccountIndex", [value]) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a5(registry, u8aToU8a(value)) : decodeString(registry, value);
}
var ACCOUNT_ID_PREFIX, GenericLookupSource;
var init_LookupSource = __esm({
  "../../node_modules/@polkadot/types/generic/LookupSource.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    init_AccountId();
    init_AccountIndex();
    ACCOUNT_ID_PREFIX = new Uint8Array([255]);
    GenericLookupSource = class extends AbstractBase {
      constructor(registry, value = new Uint8Array()) {
        super(registry, decodeAddressOrIndex(registry, value));
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        const rawLength = this._rawLength;
        return rawLength + // for 1 byte AccountIndexes, we are not adding a specific prefix
        (rawLength > 1 ? 1 : 0);
      }
      /**
       * @description The length of the raw value, either AccountIndex or AccountId
       */
      get _rawLength() {
        return this.inner instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this.inner) : this.inner.encodedLength;
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        const value = this.inner.toU8a().subarray(0, this._rawLength);
        return {
          outer: [
            new Uint8Array(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(value) : ACCOUNT_ID_PREFIX),
            value
          ]
        };
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Address";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = this.inner.toU8a().subarray(0, this._rawLength);
        return isBare ? encoded : u8aConcat(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/MultiAddress.js
function decodeU8a6(registry, u8a) {
  if ([0, 32].includes(u8a.length)) {
    return { Id: u8a };
  } else if (u8a.length === 20) {
    return { Address20: u8a };
  } else if (u8a.length <= 8) {
    return { Index: registry.createTypeUnsafe("AccountIndex", [u8a]).toNumber() };
  }
  return u8a;
}
function decodeMultiAny(registry, value) {
  if (value instanceof GenericAccountId) {
    return { Id: value };
  } else if (isU8a(value)) {
    return decodeU8a6(registry, value);
  } else if (value instanceof GenericMultiAddress) {
    return value;
  } else if (value instanceof GenericAccountIndex || isBn(value) || isNumber(value)) {
    return { Index: isNumber(value) ? value : value.toNumber() };
  } else if (isString(value)) {
    return decodeU8a6(registry, decodeAddress(value.toString()));
  }
  return value;
}
var GenericMultiAddress;
var init_MultiAddress = __esm({
  "../../node_modules/@polkadot/types/generic/MultiAddress.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    init_AccountId();
    init_AccountIndex();
    GenericMultiAddress = class extends Enum {
      constructor(registry, value) {
        super(registry, {
          Id: "AccountId",
          Index: "Compact<AccountIndex>",
          Raw: "Bytes",
          // eslint-disable-next-line sort-keys
          Address32: "H256",
          // eslint-disable-next-line sort-keys
          Address20: "H160"
        }, decodeMultiAny(registry, value));
      }
      /**
       * @description Returns a breakdown of the hex encoding for this Codec
       */
      inspect() {
        const { inner, outer = [] } = this.inner.inspect();
        return {
          inner,
          outer: [new Uint8Array([this.index]), ...outer]
        };
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return this.value.toString();
      }
    };
  }
});

// ../../node_modules/@polkadot/types/generic/Vote.js
function decodeVoteBool(value) {
  return value ? new Uint8Array([AYE_BITS | DEF_CONV]) : new Uint8Array([NAY_BITS]);
}
function decodeVoteU8a(value) {
  return value.length ? value.subarray(0, 1) : new Uint8Array([NAY_BITS]);
}
function decodeVoteType(registry, value) {
  return new Uint8Array([
    (new bool(registry, value.aye).isTrue ? AYE_BITS : NAY_BITS) | registry.createTypeUnsafe("Conviction", [value.conviction || DEF_CONV]).index
  ]);
}
function decodeVote(registry, value) {
  if (isU8a(value)) {
    return decodeVoteU8a(value);
  } else if (isUndefined(value) || value instanceof Boolean || isBoolean(value)) {
    return decodeVoteBool(new bool(registry, value).isTrue);
  } else if (isNumber(value)) {
    return decodeVoteBool(value < 0);
  }
  return decodeVoteType(registry, value);
}
var AYE_BITS, NAY_BITS, CON_MASK, DEF_CONV, GenericVote;
var init_Vote = __esm({
  "../../node_modules/@polkadot/types/generic/Vote.js"() {
    init_types_codec();
    init_util();
    AYE_BITS = 128;
    NAY_BITS = 0;
    CON_MASK = 127;
    DEF_CONV = 0;
    GenericVote = class extends U8aFixed {
      __internal__aye;
      __internal__conviction;
      constructor(registry, value) {
        const decoded = decodeVote(registry, value);
        super(registry, decoded, 8);
        this.__internal__aye = (decoded[0] & AYE_BITS) === AYE_BITS;
        this.__internal__conviction = this.registry.createTypeUnsafe("Conviction", [decoded[0] & CON_MASK]);
      }
      /**
       * @description returns a V2 conviction
       */
      get conviction() {
        return this.__internal__conviction;
      }
      /**
       * @description true if the wrapped value is a positive vote
       */
      get isAye() {
        return this.__internal__aye;
      }
      /**
       * @description true if the wrapped value is a negative vote
       */
      get isNay() {
        return !this.isAye;
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman(isExpanded) {
        return {
          conviction: this.conviction.toHuman(isExpanded),
          vote: this.isAye ? "Aye" : "Nay"
        };
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return {
          aye: this.isAye,
          conviction: this.conviction.toPrimitive()
        };
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Vote";
      }
    };
  }
});

// ../../node_modules/@polkadot/types/ethereum/AccountId.js
function decodeAccountId2(value) {
  if (isU8a(value) || Array.isArray(value)) {
    return u8aToU8a(value);
  } else if (isHex(value) || isEthereumAddress(value.toString())) {
    return hexToU8a(value.toString());
  } else if (isString(value)) {
    return u8aToU8a(value);
  }
  return value;
}
var GenericEthereumAccountId;
var init_AccountId2 = __esm({
  "../../node_modules/@polkadot/types/ethereum/AccountId.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    GenericEthereumAccountId = class extends U8aFixed {
      constructor(registry, value = new Uint8Array()) {
        super(registry, decodeAccountId2(value), 160);
      }
      /**
       * @description Compares the value of the input to see if there is a match
       */
      eq(other) {
        return !!other && super.eq(decodeAccountId2(other));
      }
      /**
       * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
       */
      toHuman() {
        return this.toJSON();
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        return this.toString();
      }
      /**
       * @description Converts the value in a best-fit primitive form
       */
      toPrimitive() {
        return this.toJSON();
      }
      /**
       * @description Returns the string representation of the value
       */
      toString() {
        return ethereumEncode(this);
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "AccountId";
      }
    };
  }
});

// ../../node_modules/@polkadot/types/ethereum/LookupSource.js
function decodeString2(registry, value) {
  const decoded = decodeAddress(value);
  return decoded.length === 20 ? registry.createTypeUnsafe("EthereumAccountId", [decoded]) : registry.createTypeUnsafe("AccountIndex", [u8aToBn(decoded)]);
}
function decodeU8a7(registry, value) {
  if (value.length === 20) {
    return registry.createTypeUnsafe("EthereumAccountId", [value]);
  } else if (value[0] === 255) {
    return registry.createTypeUnsafe("EthereumAccountId", [value.subarray(1)]);
  }
  const [offset, length] = GenericAccountIndex.readLength(value);
  return registry.createTypeUnsafe("AccountIndex", [u8aToBn(value.subarray(offset, offset + length))]);
}
function decodeAddressOrIndex2(registry, value) {
  return value instanceof GenericEthereumLookupSource ? value.inner : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isU8a(value) || Array.isArray(value) || isHex(value) ? decodeU8a7(registry, u8aToU8a(value)) : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createTypeUnsafe("AccountIndex", [value]) : decodeString2(registry, value);
}
var ACCOUNT_ID_PREFIX2, GenericEthereumLookupSource;
var init_LookupSource2 = __esm({
  "../../node_modules/@polkadot/types/ethereum/LookupSource.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    init_AccountIndex();
    init_AccountId2();
    ACCOUNT_ID_PREFIX2 = new Uint8Array([255]);
    GenericEthereumLookupSource = class extends AbstractBase {
      constructor(registry, value = new Uint8Array()) {
        super(registry, decodeAddressOrIndex2(registry, value));
      }
      /**
       * @description The length of the value when encoded as a Uint8Array
       */
      get encodedLength() {
        const rawLength = this._rawLength;
        return rawLength + // for 1 byte AccountIndexes, we are not adding a specific prefix
        (rawLength > 1 ? 1 : 0);
      }
      /**
       * @description The length of the raw value, either AccountIndex or AccountId
       */
      get _rawLength() {
        return this.inner instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this.inner) : this.inner.encodedLength;
      }
      /**
       * @description Returns a hex string representation of the value
       */
      toHex() {
        return u8aToHex(this.toU8a());
      }
      /**
       * @description Returns the base runtime type name for this instance
       */
      toRawType() {
        return "Address";
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       * @param isBare true when the value has none of the type-specific prefixes (internal)
       */
      toU8a(isBare) {
        const encoded = this.inner.toU8a().subarray(0, this._rawLength);
        return isBare ? encoded : u8aConcat(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX2, encoded);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/ethereum/index.js
var init_ethereum3 = __esm({
  "../../node_modules/@polkadot/types/ethereum/index.js"() {
    init_AccountId2();
    init_LookupSource2();
  }
});

// ../../node_modules/@polkadot/types/generic/index.js
var init_generic = __esm({
  "../../node_modules/@polkadot/types/generic/index.js"() {
    init_AccountId();
    init_AccountIndex();
    init_Block();
    init_Call();
    init_ChainProperties();
    init_ConsensusEngineId();
    init_Event();
    init_LookupSource();
    init_MultiAddress();
    init_Vote();
    init_ethereum3();
  }
});

// ../../node_modules/@polkadot/types/primitive/Data.js
function decodeDataU8a(registry, value) {
  const indicator = value[0];
  if (!indicator) {
    return [void 0, void 0];
  } else if (indicator >= 1 && indicator <= 33) {
    const length = indicator - 1;
    const data = value.subarray(1, length + 1);
    return [registry.createTypeUnsafe("Raw", [data]), 1];
  } else if (indicator >= 34 && indicator <= 37) {
    return [value.subarray(1, 32 + 1), indicator - 32];
  }
  throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);
}
function decodeData(registry, value) {
  if (isU8a(value) || isString(value)) {
    return decodeDataU8a(registry, u8aToU8a(value));
  } else if (!value) {
    return [void 0, void 0];
  }
  return [value, void 0];
}
var Data;
var init_Data = __esm({
  "../../node_modules/@polkadot/types/primitive/Data.js"() {
    init_types_codec();
    init_util();
    Data = class extends Enum {
      constructor(registry, value) {
        super(registry, {
          None: "Null",
          // 0
          Raw: "Bytes",
          // 1
          // eslint-disable-next-line sort-keys
          BlakeTwo256: "H256",
          // 2
          Sha256: "H256",
          // 3
          // eslint-disable-next-line sort-keys
          Keccak256: "H256",
          // 4
          ShaThree256: "H256"
          // 5
        }, ...decodeData(registry, value));
        if (this.isRaw && this.asRaw.length > 32) {
          throw new Error("Data.Raw values are limited to a maximum length of 32 bytes");
        }
      }
      get asBlakeTwo256() {
        return this.value;
      }
      get asKeccak256() {
        return this.value;
      }
      get asRaw() {
        return this.value;
      }
      get asSha256() {
        return this.value;
      }
      get asShaThree256() {
        return this.value;
      }
      get isBlakeTwo256() {
        return this.index === 2;
      }
      get isKeccak256() {
        return this.index === 4;
      }
      get isNone() {
        return this.index === 0;
      }
      get isRaw() {
        return this.index === 1;
      }
      get isSha256() {
        return this.index === 3;
      }
      get isShaThree256() {
        return this.index === 5;
      }
      /**
       * @description The encoded length
       */
      get encodedLength() {
        return this.toU8a().length;
      }
      /**
       * @description Encodes the value as a Uint8Array as per the SCALE specifications
       */
      toU8a() {
        if (this.index === 0) {
          return new Uint8Array(1);
        } else if (this.index === 1) {
          const data = this.value.toU8a(true);
          const length = Math.min(data.length, 32);
          const u8a2 = new Uint8Array(length + 1);
          u8a2.set([length + 1], 0);
          u8a2.set(data.subarray(0, length), 1);
          return u8a2;
        }
        const u8a = new Uint8Array(33);
        u8a.set([this.index + 32], 0);
        u8a.set(this.value.toU8a(), 1);
        return u8a;
      }
    };
  }
});

// ../../node_modules/@polkadot/types/primitive/StorageKey.js
function decodeStorageKey(value) {
  if (isU8a(value) || !value || isString(value)) {
    return { key: value };
  } else if (value instanceof StorageKey) {
    return {
      key: value,
      method: value.method,
      section: value.section
    };
  } else if (isFunction(value)) {
    return {
      key: value(),
      method: value.method,
      section: value.section
    };
  } else if (Array.isArray(value)) {
    const [fn, args = []] = value;
    if (!isFunction(fn)) {
      throw new Error("Expected function input for key construction");
    }
    if (fn.meta && fn.meta.type.isMap) {
      const map79 = fn.meta.type.asMap;
      if (!Array.isArray(args) || args.length !== map79.hashers.length) {
        throw new Error(`Expected an array of ${map79.hashers.length} values as params to a Map query`);
      }
    }
    return {
      key: fn(...args),
      method: fn.method,
      section: fn.section
    };
  }
  throw new Error(`Unable to convert input ${value} to StorageKey`);
}
function decodeHashers(registry, value, hashers) {
  let offset = 32;
  const count = hashers.length;
  const result = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const [hasher2, type] = hashers[i2];
    const [hashLen, canDecode] = HASHER_MAP[hasher2.type];
    const decoded = canDecode ? registry.createTypeUnsafe(getSiName(registry.lookup, type), [value.subarray(offset + hashLen)]) : registry.createTypeUnsafe("Raw", [value.subarray(offset, offset + hashLen)]);
    offset += hashLen + (canDecode ? decoded.encodedLength : 0);
    result[i2] = decoded;
  }
  return result;
}
function decodeArgsFromMeta(registry, value, meta) {
  if (!meta || !meta.type.isMap) {
    return [];
  }
  const { hashers, key } = meta.type.asMap;
  const keys2 = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;
  return decodeHashers(registry, value, hashers.map((h2, i2) => [h2, keys2[i2]]));
}
function getMeta(value) {
  if (value instanceof StorageKey) {
    return value.meta;
  } else if (isFunction(value)) {
    return value.meta;
  } else if (Array.isArray(value)) {
    const [fn] = value;
    return fn.meta;
  }
  return void 0;
}
function getType(registry, value) {
  if (value instanceof StorageKey) {
    return value.outputType;
  } else if (isFunction(value)) {
    return unwrapStorageType(registry, value.meta.type);
  } else if (Array.isArray(value)) {
    const [fn] = value;
    if (fn.meta) {
      return unwrapStorageType(registry, fn.meta.type);
    }
  }
  return "Raw";
}
var HASHER_MAP, StorageKey;
var init_StorageKey = __esm({
  "../../node_modules/@polkadot/types/primitive/StorageKey.js"() {
    init_types_codec();
    init_util();
    init_util4();
    init_util5();
    HASHER_MAP = {
      // opaque
      Blake2_128: [16, false],
      // eslint-disable-line camelcase
      Blake2_128Concat: [16, true],
      // eslint-disable-line camelcase
      Blake2_256: [32, false],
      // eslint-disable-line camelcase
      Identity: [0, true],
      Twox128: [16, false],
      Twox256: [32, false],
      Twox64Concat: [8, true]
    };
    StorageKey = class extends Bytes {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore This is assigned via this.decodeArgsFromMeta()
      __internal__args;
      __internal__meta;
      __internal__outputType;
      __internal__method;
      __internal__section;
      constructor(registry, value, override = {}) {
        const { key, method, section: section2 } = decodeStorageKey(value);
        super(registry, key);
        this.__internal__outputType = getType(registry, value);
        this.setMeta(getMeta(value), override.section || section2, override.method || method);
      }
      /**
       * @description Return the decoded arguments (applicable to map with decodable values)
       */
      get args() {
        return this.__internal__args;
      }
      /**
       * @description The metadata or `undefined` when not available
       */
      get meta() {
        return this.__internal__meta;
      }
      /**
       * @description The key method or `undefined` when not specified
       */
      get method() {
        return this.__internal__method;
      }
      /**
       * @description The output type
       */
      get outputType() {
        return this.__internal__outputType;
      }
      /**
       * @description The key section or `undefined` when not specified
       */
      get section() {
        return this.__internal__section;
      }
      is(key) {
        return key.section === this.section && key.method === this.method;
      }
      /**
       * @description Sets the meta for this key
       */
      setMeta(meta, section2, method) {
        this.__internal__meta = meta;
        this.__internal__method = method || this.__internal__method;
        this.__internal__section = section2 || this.__internal__section;
        if (meta) {
          this.__internal__outputType = unwrapStorageType(this.registry, meta.type);
        }
        try {
          this.__internal__args = decodeArgsFromMeta(this.registry, this.toU8a(true), meta);
        } catch {
        }
        return this;
      }
      /**
       * @description Returns the Human representation for this type
       */
      toHuman(_isExtended, disableAscii) {
        return this.__internal__args.length ? this.__internal__args.map((a) => a.toHuman(void 0, disableAscii)) : super.toHuman(void 0, disableAscii);
      }
      /**
       * @description Returns the raw type for this
       */
      toRawType() {
        return "StorageKey";
      }
    };
  }
});

// ../../node_modules/@polkadot/types/primitive/index.js
var init_primitive2 = __esm({
  "../../node_modules/@polkadot/types/primitive/index.js"() {
    init_types_codec();
    init_Data();
    init_StorageKey();
  }
});

// ../../node_modules/@polkadot/types/index.types.js
var index_types_exports = {};
__export(index_types_exports, {
  BitVec: () => BitVec,
  Bool: () => bool,
  Bytes: () => Bytes,
  Data: () => Data,
  F32: () => f32,
  F64: () => f64,
  GeneralExtrinsic: () => GeneralExtrinsic,
  GenericAccountId: () => GenericAccountId,
  GenericAccountId32: () => GenericAccountId,
  GenericAccountId33: () => GenericAccountId33,
  GenericAccountIndex: () => GenericAccountIndex,
  GenericAddress: () => GenericMultiAddress,
  GenericBlock: () => GenericBlock,
  GenericCall: () => GenericCall,
  GenericChainProperties: () => GenericChainProperties,
  GenericConsensusEngineId: () => GenericConsensusEngineId,
  GenericEthereumAccountId: () => GenericEthereumAccountId,
  GenericEthereumLookupSource: () => GenericEthereumLookupSource,
  GenericEvent: () => GenericEvent,
  GenericEventData: () => GenericEventData,
  GenericExtrinsic: () => GenericExtrinsic,
  GenericExtrinsicEra: () => GenericExtrinsicEra,
  GenericExtrinsicPayload: () => GenericExtrinsicPayload,
  GenericExtrinsicPayloadUnknown: () => GenericExtrinsicPayloadUnknown,
  GenericExtrinsicPayloadV4: () => GenericExtrinsicPayloadV4,
  GenericExtrinsicPayloadV5: () => GenericExtrinsicPayloadV5,
  GenericExtrinsicSignatureV4: () => GenericExtrinsicSignatureV4,
  GenericExtrinsicSignatureV5: () => GenericExtrinsicSignatureV5,
  GenericExtrinsicUnknown: () => GenericExtrinsicUnknown,
  GenericExtrinsicV4: () => GenericExtrinsicV4,
  GenericExtrinsicV5: () => GenericExtrinsicV5,
  GenericImmortalEra: () => ImmortalEra,
  GenericLookupSource: () => GenericLookupSource,
  GenericMortalEra: () => MortalEra,
  GenericMultiAddress: () => GenericMultiAddress,
  GenericSignerPayload: () => GenericSignerPayload,
  GenericVote: () => GenericVote,
  I128: () => i128,
  I16: () => i16,
  I256: () => i256,
  I32: () => i32,
  I64: () => i64,
  I8: () => i8,
  ISize: () => isize,
  Null: () => Null,
  OptionBool: () => OptionBool,
  StorageKey: () => StorageKey,
  Text: () => Text,
  Type: () => Type,
  U128: () => u128,
  U16: () => u162,
  U256: () => u256,
  U32: () => u323,
  U64: () => u643,
  U8: () => u82,
  USize: () => usize,
  bool: () => bool,
  f32: () => f32,
  f64: () => f64,
  i128: () => i128,
  i16: () => i16,
  i256: () => i256,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  isize: () => isize,
  u128: () => u128,
  u16: () => u162,
  u256: () => u256,
  u32: () => u323,
  u64: () => u643,
  u8: () => u82,
  usize: () => usize
});
var init_index_types = __esm({
  "../../node_modules/@polkadot/types/index.types.js"() {
    init_extrinsic();
    init_generic();
    init_primitive2();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/util.js
function convert(fn) {
  return ({ name }) => fn(name);
}
var objectNameToCamel, objectNameToString;
var init_util7 = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/util.js"() {
    init_util();
    objectNameToCamel = /* @__PURE__ */ convert(stringCamelCase);
    objectNameToString = /* @__PURE__ */ convert((n) => n.toString());
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/extrinsics/createUnchecked.js
function isTx(tx, callIndex) {
  return tx.callIndex[0] === callIndex[0] && tx.callIndex[1] === callIndex[1];
}
function createUnchecked(registry, section2, callIndex, callMetadata) {
  const expectedArgs = callMetadata.fields;
  const funcName = stringCamelCase(callMetadata.name);
  const extrinsicFn = (...args) => {
    if (expectedArgs.length !== args.length) {
      throw new Error(`Extrinsic ${section2}.${funcName} expects ${expectedArgs.length} arguments, got ${args.length}.`);
    }
    return registry.createTypeUnsafe("Call", [{ args, callIndex }, callMetadata]);
  };
  extrinsicFn.is = (tx) => isTx(tx, callIndex);
  extrinsicFn.callIndex = callIndex;
  extrinsicFn.meta = callMetadata;
  extrinsicFn.method = funcName;
  extrinsicFn.section = section2;
  extrinsicFn.toJSON = () => callMetadata.toJSON();
  return extrinsicFn;
}
var init_createUnchecked = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/extrinsics/createUnchecked.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/extrinsics/index.js
function filterCallsSome({ calls }) {
  return calls.isSome;
}
function createCallFunction(registry, lookup, variant, sectionName, sectionIndex) {
  const { fields, index } = variant;
  const count = fields.length;
  const args = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const { name, type, typeName } = fields[i2];
    args[i2] = objectSpread({
      name: stringCamelCase(name.unwrapOr(`param${i2}`)),
      type: getSiName(lookup, type)
    }, typeName.isSome ? { typeName: typeName.unwrap() } : null);
  }
  return createUnchecked(registry, sectionName, new Uint8Array([sectionIndex, index.toNumber()]), registry.createTypeUnsafe("FunctionMetadataLatest", [objectSpread({ args }, variant)]));
}
function decorateExtrinsics(registry, { lookup, pallets }, version) {
  const result = {};
  const filtered = pallets.filter(filterCallsSome);
  for (let i2 = 0, count = filtered.length; i2 < count; i2++) {
    const { calls, index, name } = filtered[i2];
    const sectionName = stringCamelCase(name);
    const sectionIndex = version >= 12 ? index.toNumber() : i2;
    lazyMethod(result, sectionName, () => lazyVariants(lookup, calls.unwrap(), objectNameToCamel, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
  }
  return result;
}
var init_extrinsics = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/extrinsics/index.js"() {
    init_util();
    init_lazy2();
    init_util4();
    init_util7();
    init_createUnchecked();
  }
});

// ../../node_modules/@polkadot/types/metadata/v9/toV10.js
function createStorageHasher(registry, hasher2) {
  if (hasher2.toNumber() >= 2) {
    return registry.createTypeUnsafe("StorageHasherV10", [hasher2.toNumber() + 1]);
  }
  return registry.createTypeUnsafe("StorageHasherV10", [hasher2]);
}
function createStorageType(registry, entryType) {
  if (entryType.isMap) {
    return [objectSpread({}, entryType.asMap, {
      hasher: createStorageHasher(registry, entryType.asMap.hasher)
    }), 1];
  }
  if (entryType.isDoubleMap) {
    return [objectSpread({}, entryType.asDoubleMap, {
      hasher: createStorageHasher(registry, entryType.asDoubleMap.hasher),
      key2Hasher: createStorageHasher(registry, entryType.asDoubleMap.key2Hasher)
    }), 2];
  }
  return [entryType.asPlain, 0];
}
function convertModule(registry, mod2) {
  const storage = mod2.storage.unwrapOr(null);
  return registry.createTypeUnsafe("ModuleMetadataV10", [objectSpread({}, mod2, {
    storage: storage ? objectSpread({}, storage, {
      items: storage.items.map((item) => objectSpread({}, item, {
        type: registry.createTypeUnsafe("StorageEntryTypeV10", createStorageType(registry, item.type))
      }))
    }) : null
  })]);
}
function toV10(registry, { modules }) {
  return registry.createTypeUnsafe("MetadataV10", [{
    modules: modules.map((mod2) => convertModule(registry, mod2))
  }]);
}
var init_toV10 = __esm({
  "../../node_modules/@polkadot/types/metadata/v9/toV10.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types/metadata/v10/toV11.js
function toV11(registry, { modules }) {
  return registry.createTypeUnsafe("MetadataV11", [{
    // This is new in V11, pass V0 here - something non-existing, telling the API to use
    // the fallback for this information (on-chain detection)
    extrinsic: {
      signedExtensions: [],
      version: 0
    },
    modules
  }]);
}
var init_toV11 = __esm({
  "../../node_modules/@polkadot/types/metadata/v10/toV11.js"() {
  }
});

// ../../node_modules/@polkadot/types/metadata/v11/toV12.js
function toV12(registry, { extrinsic, modules }) {
  return registry.createTypeUnsafe("MetadataV12", [{
    extrinsic,
    modules: modules.map((mod2) => registry.createTypeUnsafe("ModuleMetadataV12", [objectSpread({}, mod2, { index: 255 })]))
  }]);
}
var init_toV12 = __esm({
  "../../node_modules/@polkadot/types/metadata/v11/toV12.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types/metadata/v12/toV13.js
function toV13(registry, v122) {
  return registry.createTypeUnsafe("MetadataV13", [v122]);
}
var init_toV13 = __esm({
  "../../node_modules/@polkadot/types/metadata/v12/toV13.js"() {
  }
});

// ../../node_modules/@polkadot/types/interfaces/alias.js
function getAliasTypes({ knownTypes: knownTypes2 }, section2) {
  return {
    ...typesAlias[section2] ?? {},
    ...knownTypes2.typesAlias?.[section2] ?? {}
  };
}
var typesAlias;
var init_alias = __esm({
  "../../node_modules/@polkadot/types/interfaces/alias.js"() {
    typesAlias = {
      assets: {
        Approval: "AssetApproval",
        ApprovalKey: "AssetApprovalKey",
        Balance: "TAssetBalance",
        DestroyWitness: "AssetDestroyWitness"
      },
      babe: {
        EquivocationProof: "BabeEquivocationProof"
      },
      balances: {
        Status: "BalanceStatus"
      },
      beefy: {
        AuthorityId: "BeefyId"
      },
      contracts: {
        StorageKey: "ContractStorageKey"
      },
      electionProviderMultiPhase: {
        Phase: "ElectionPhase"
      },
      ethereum: {
        Block: "EthBlock",
        Header: "EthHeader",
        Receipt: "EthReceipt",
        Transaction: "EthTransaction",
        TransactionStatus: "EthTransactionStatus"
      },
      evm: {
        Account: "EvmAccount",
        Log: "EvmLog",
        Vicinity: "EvmVicinity"
      },
      grandpa: {
        Equivocation: "GrandpaEquivocation",
        EquivocationProof: "GrandpaEquivocationProof"
      },
      identity: {
        Judgement: "IdentityJudgement"
      },
      inclusion: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      paraDisputes: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      paraInclusion: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      paraScheduler: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      paraShared: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      parachains: {
        Id: "ParaId"
      },
      parasDisputes: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      parasInclusion: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      parasScheduler: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      parasShared: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      proposeParachain: {
        Proposal: "ParachainProposal"
      },
      proxy: {
        Announcement: "ProxyAnnouncement"
      },
      scheduler: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      shared: {
        ValidatorIndex: "ParaValidatorIndex"
      },
      society: {
        Judgement: "SocietyJudgement",
        Vote: "SocietyVote"
      },
      staking: {
        Compact: "CompactAssignments"
      },
      treasury: {
        Proposal: "TreasuryProposal"
      },
      xcm: {
        AssetId: "XcmAssetId"
      },
      xcmPallet: {
        AssetId: "XcmAssetId"
      }
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/v13/toV14.js
function compatType(specs, _type) {
  const type = _type.toString();
  const index = specs.findIndex(({ def }) => def.HistoricMetaCompat === type);
  if (index !== -1) {
    return index;
  }
  return specs.push({
    def: {
      HistoricMetaCompat: type
    }
  }) - 1;
}
function compatTypes(specs, ...types4) {
  for (let i2 = 0, count = types4.length; i2 < count; i2++) {
    compatType(specs, types4[i2]);
  }
}
function makeTupleType(specs, entries) {
  return specs.push({
    def: {
      Tuple: entries
    }
  }) - 1;
}
function makeVariantType(modName, variantType, specs, variants) {
  return specs.push({
    def: {
      Variant: { variants }
    },
    path: [`pallet_${modName.toString()}`, "pallet", variantType]
  }) - 1;
}
function registerOriginCaller(registry, modules, metaVersion) {
  registry.register({
    OriginCaller: {
      _enum: modules.map((mod2, index) => [
        mod2.name.toString(),
        metaVersion >= 12 ? mod2.index.toNumber() : index
      ]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {
        for (let i2 = Object.keys(result).length; i2 < index; i2++) {
          result[`Empty${i2}`] = "Null";
        }
        result[name] = knownOrigins[name] || "Null";
        return result;
      }, {})
    }
  });
}
function setTypeOverride(sectionTypes, types4) {
  types4.forEach((type) => {
    const override = Object.keys(sectionTypes).find((aliased) => type.eq(aliased));
    if (override) {
      type.setOverride(sectionTypes[override]);
    } else {
      const orig = type.toString();
      const alias2 = Object.entries(sectionTypes).reduce((result, [src, dst]) => BOXES.reduce((result2, [a, z]) => result2.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);
      if (orig !== alias2) {
        type.setOverride(alias2);
      }
    }
  });
}
function convertCalls(specs, registry, modName, calls, sectionTypes) {
  const variants = calls.map(({ args, docs, name }, index) => {
    setTypeOverride(sectionTypes, args.map(({ type }) => type));
    return registry.createTypeUnsafe("SiVariant", [{
      docs,
      fields: args.map(({ name: name2, type }) => registry.createTypeUnsafe("SiField", [{ name: name2, type: compatType(specs, type) }])),
      index,
      name
    }]);
  });
  return registry.createTypeUnsafe("PalletCallMetadataV14", [{
    type: makeVariantType(modName, "Call", specs, variants)
  }]);
}
function convertConstants(specs, registry, constants, sectionTypes) {
  return constants.map(({ docs, name, type, value }) => {
    setTypeOverride(sectionTypes, [type]);
    return registry.createTypeUnsafe("PalletConstantMetadataV14", [{
      docs,
      name,
      type: compatType(specs, type),
      value
    }]);
  });
}
function convertErrors(specs, registry, modName, errors, _sectionTypes) {
  const variants = errors.map(({ docs, name }, index) => registry.createTypeUnsafe("SiVariant", [{
    docs,
    fields: [],
    index,
    name
  }]));
  return registry.createTypeUnsafe("PalletErrorMetadataV14", [{
    type: makeVariantType(modName, "Error", specs, variants)
  }]);
}
function convertEvents(specs, registry, modName, events2, sectionTypes) {
  const variants = events2.map(({ args, docs, name }, index) => {
    setTypeOverride(sectionTypes, args);
    return registry.createTypeUnsafe("SiVariant", [{
      docs,
      fields: args.map((t2) => registry.createTypeUnsafe("SiField", [{ type: compatType(specs, t2) }])),
      index,
      name
    }]);
  });
  return registry.createTypeUnsafe("PalletEventMetadataV14", [{
    type: makeVariantType(modName, "Event", specs, variants)
  }]);
}
function createMapEntry(specs, registry, sectionTypes, { hashers, isLinked, isOptional, keys: keys2, value }) {
  setTypeOverride(sectionTypes, [value, ...Array.isArray(keys2) ? keys2 : [keys2]]);
  return registry.createTypeUnsafe("StorageEntryTypeV14", [{
    Map: {
      hashers,
      key: hashers.length === 1 ? compatType(specs, keys2[0]) : makeTupleType(specs, keys2.map((t2) => compatType(specs, t2))),
      value: isLinked ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys2[0].toString()}>)`) : compatType(specs, value)
    }
  }]);
}
function convertStorage(specs, registry, { items, prefix: prefix2 }, sectionTypes) {
  return registry.createTypeUnsafe("PalletStorageMetadataV14", [{
    items: items.map(({ docs, fallback, modifier, name, type }) => {
      let entryType;
      if (type.isPlain) {
        const plain = type.asPlain;
        setTypeOverride(sectionTypes, [plain]);
        entryType = registry.createTypeUnsafe("StorageEntryTypeV14", [{
          Plain: compatType(specs, plain)
        }]);
      } else if (type.isMap) {
        const map79 = type.asMap;
        entryType = createMapEntry(specs, registry, sectionTypes, {
          hashers: [map79.hasher],
          isLinked: map79.linked.isTrue,
          isOptional: modifier.isOptional,
          keys: [map79.key],
          value: map79.value
        });
      } else if (type.isDoubleMap) {
        const dm = type.asDoubleMap;
        entryType = createMapEntry(specs, registry, sectionTypes, {
          hashers: [dm.hasher, dm.key2Hasher],
          isLinked: false,
          isOptional: modifier.isOptional,
          keys: [dm.key1, dm.key2],
          value: dm.value
        });
      } else {
        const nm = type.asNMap;
        entryType = createMapEntry(specs, registry, sectionTypes, {
          hashers: nm.hashers,
          isLinked: false,
          isOptional: modifier.isOptional,
          keys: nm.keyVec,
          value: nm.value
        });
      }
      return registry.createTypeUnsafe("StorageEntryMetadataV14", [{
        docs,
        fallback,
        modifier,
        name,
        type: entryType
      }]);
    }),
    prefix: prefix2
  }]);
}
function convertExtrinsic(registry, { signedExtensions, version }) {
  return registry.createTypeUnsafe("ExtrinsicMetadataV14", [{
    signedExtensions: signedExtensions.map((identifier) => ({
      identifier,
      type: 0
      // we don't map the fields at all
    })),
    type: 0,
    // Map to extrinsic like in v14?
    version
  }]);
}
function createPallet(specs, registry, mod2, { calls, constants, errors, events: events2, storage }) {
  const sectionTypes = getAliasTypes(registry, stringCamelCase(mod2.name));
  return registry.createTypeUnsafe("PalletMetadataV14", [{
    calls: calls && convertCalls(specs, registry, mod2.name, calls, sectionTypes),
    constants: convertConstants(specs, registry, constants, sectionTypes),
    errors: errors && convertErrors(specs, registry, mod2.name, errors, sectionTypes),
    events: events2 && convertEvents(specs, registry, mod2.name, events2, sectionTypes),
    index: mod2.index,
    name: mod2.name,
    storage: storage && convertStorage(specs, registry, storage, sectionTypes)
  }]);
}
function toV14(registry, v132, metaVersion) {
  const specs = [];
  compatTypes(specs, "Null", "u8", "u16", "u32", "u64");
  registerOriginCaller(registry, v132.modules, metaVersion);
  const extrinsic = convertExtrinsic(registry, v132.extrinsic);
  const pallets = v132.modules.map((mod2) => createPallet(specs, registry, mod2, {
    calls: mod2.calls.unwrapOr(null),
    constants: mod2.constants,
    errors: mod2.errors.length ? mod2.errors : null,
    events: mod2.events.unwrapOr(null),
    storage: mod2.storage.unwrapOr(null)
  }));
  return registry.createTypeUnsafe("MetadataV14", [{
    extrinsic,
    lookup: {
      types: specs.map((type, id) => registry.createTypeUnsafe("PortableType", [{ id, type }]))
    },
    pallets
  }]);
}
var BOXES;
var init_toV14 = __esm({
  "../../node_modules/@polkadot/types/metadata/v13/toV14.js"() {
    init_util();
    init_alias();
    init_definitions2();
    BOXES = [["<", ">"], ["<", ","], [",", ">"], ["(", ")"], ["(", ","], [",", ","], [",", ")"]];
  }
});

// ../../node_modules/@polkadot/types/metadata/v14/toV15.js
function toV15(registry, v142, _) {
  const unchecked = v142.lookup.paramTypes.SpRuntimeUncheckedExtrinsic;
  return registry.createTypeUnsafe("MetadataV15", [
    objectSpread({}, v142, {
      extrinsic: registry.createTypeUnsafe("ExtrinsicMetadataV15", [
        objectSpread({}, v142.extrinsic, {
          addressType: unchecked?.[0].type.unwrapOr(0),
          callType: unchecked?.[1].type.unwrapOr(0),
          extraType: unchecked?.[3].type.unwrapOr(0),
          signatureType: unchecked?.[2].type.unwrapOr(0)
        })
      ]),
      outerEnums: registry.createTypeUnsafe("OuterEnums15", [{
        // FIXME We need to extract & add the errorType in here
        // (these doesn't seem to be an esay way to detect & extract it)
        callType: unchecked?.[1].type.unwrapOr(0),
        eventType: v142.lookup.paramTypes.FrameSystemEventRecord?.[0].type.unwrapOr(0)
      }])
    })
  ]);
}
var init_toV15 = __esm({
  "../../node_modules/@polkadot/types/metadata/v14/toV15.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types/metadata/v15/toLatest.js
function toLatest(_registry, v152, _metaVersion) {
  return v152;
}
var init_toLatest = __esm({
  "../../node_modules/@polkadot/types/metadata/v15/toLatest.js"() {
  }
});

// ../../node_modules/@polkadot/types/metadata/MagicNumber.js
var MAGIC_NUMBER, MagicNumber;
var init_MagicNumber = __esm({
  "../../node_modules/@polkadot/types/metadata/MagicNumber.js"() {
    init_types_codec();
    MAGIC_NUMBER = 1635018093;
    MagicNumber = class extends u323 {
      constructor(registry, value) {
        super(registry, value);
        if (!this.isEmpty && !this.eq(MAGIC_NUMBER)) {
          throw new Error(`MagicNumber mismatch: expected ${registry.createTypeUnsafe("u32", [MAGIC_NUMBER]).toHex()}, found ${this.toHex()}`);
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/versions.js
var KNOWN_VERSIONS, LATEST_VERSION, TO_CALLS_VERSION;
var init_versions = __esm({
  "../../node_modules/@polkadot/types/metadata/versions.js"() {
    KNOWN_VERSIONS = [15, 14, 13, 12, 11, 10, 9];
    LATEST_VERSION = KNOWN_VERSIONS[0];
    TO_CALLS_VERSION = 14;
  }
});

// ../../node_modules/@polkadot/types/metadata/MetadataVersioned.js
var MetadataVersioned;
var init_MetadataVersioned = __esm({
  "../../node_modules/@polkadot/types/metadata/MetadataVersioned.js"() {
    init_types_codec();
    init_util4();
    init_toV10();
    init_toV11();
    init_toV12();
    init_toV13();
    init_toV14();
    init_toV15();
    init_toLatest();
    init_MagicNumber();
    init_versions();
    MetadataVersioned = class _MetadataVersioned extends Struct {
      __internal__converted = /* @__PURE__ */ new Map();
      constructor(registry, value) {
        super(registry, {
          magicNumber: MagicNumber,
          metadata: "MetadataAll"
        }, value);
      }
      __internal__assertVersion = (version) => {
        if (this.version > version) {
          throw new Error(`Cannot convert metadata from version ${this.version} to ${version}`);
        }
        return this.version === version;
      };
      __internal__getVersion = (version, fromPrev) => {
        if (version !== "latest" && this.__internal__assertVersion(version)) {
          const asCurr = `asV${version}`;
          return this.__internal__metadata()[asCurr];
        }
        if (!this.__internal__converted.has(version)) {
          const asPrev = version === "latest" ? `asV${LATEST_VERSION}` : `asV${version - 1}`;
          this.__internal__converted.set(version, fromPrev(this.registry, this[asPrev], this.version));
        }
        return this.__internal__converted.get(version);
      };
      /**
       * @description the metadata wrapped
       */
      __internal__metadata = () => {
        return this.getT("metadata");
      };
      /**
       * @description Returns the wrapped metadata as a limited calls-only (latest) version
       */
      get asCallsOnly() {
        return new _MetadataVersioned(this.registry, {
          magicNumber: this.magicNumber,
          metadata: this.registry.createTypeUnsafe("MetadataAll", [toCallsOnly(this.registry, this.asLatest), TO_CALLS_VERSION])
        });
      }
      /**
       * @description Returns the wrapped metadata as a V9 object
       */
      get asV9() {
        this.__internal__assertVersion(9);
        return this.__internal__metadata().asV9;
      }
      /**
       * @description Returns the wrapped values as a V10 object
       */
      get asV10() {
        return this.__internal__getVersion(10, toV10);
      }
      /**
       * @description Returns the wrapped values as a V11 object
       */
      get asV11() {
        return this.__internal__getVersion(11, toV11);
      }
      /**
       * @description Returns the wrapped values as a V12 object
       */
      get asV12() {
        return this.__internal__getVersion(12, toV12);
      }
      /**
       * @description Returns the wrapped values as a V13 object
       */
      get asV13() {
        return this.__internal__getVersion(13, toV13);
      }
      /**
       * @description Returns the wrapped values as a V14 object
       */
      get asV14() {
        return this.__internal__getVersion(14, toV14);
      }
      /**
       * @description Returns the wrapped values as a V14 object
       */
      get asV15() {
        return this.__internal__getVersion(15, toV15);
      }
      /**
       * @description Returns the wrapped values as a latest version object
       */
      get asLatest() {
        return this.__internal__getVersion("latest", toLatest);
      }
      /**
       * @description The magicNumber for the Metadata (known constant)
       */
      get magicNumber() {
        return this.getT("magicNumber");
      }
      /**
       * @description the metadata version this structure represents
       */
      get version() {
        return this.__internal__metadata().index;
      }
      getUniqTypes(throwError) {
        return getUniqTypes(this.registry, this.asLatest, throwError);
      }
      /**
       * @description Converts the Object to JSON, typically used for RPC transfers
       */
      toJSON() {
        this.asLatest;
        return super.toJSON();
      }
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/Metadata.js
function decodeU8a8(registry, u8a) {
  if (u8a.length === 0) {
    return EMPTY_METADATA;
  } else if (u8a[VERSION_IDX] === 9) {
    try {
      return new MetadataVersioned(registry, u8a);
    } catch {
      u8a[VERSION_IDX] = 10;
    }
  }
  return u8a;
}
var EMPTY_METADATA, VERSION_IDX, Metadata;
var init_Metadata = __esm({
  "../../node_modules/@polkadot/types/metadata/Metadata.js"() {
    init_util();
    init_MetadataVersioned();
    EMPTY_METADATA = new Uint8Array([109, 101, 116, 97, 9]);
    VERSION_IDX = EMPTY_METADATA.length - 1;
    Metadata = class extends MetadataVersioned {
      constructor(registry, value) {
        super(registry, isU8a(value) || isString(value) ? decodeU8a8(registry, u8aToU8a(value)) : value);
      }
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/constants/index.js
function decorateConstants(registry, { pallets }, _version) {
  const result = {};
  for (let i2 = 0, count = pallets.length; i2 < count; i2++) {
    const { constants, name } = pallets[i2];
    if (!constants.isEmpty) {
      lazyMethod(result, stringCamelCase(name), () => lazyMethods({}, constants, (constant) => {
        const codec = registry.createTypeUnsafe(registry.createLookupType(constant.type), [hexToU8a(constant.value.toHex())]);
        codec.meta = constant;
        return codec;
      }, objectNameToCamel));
    }
  }
  return result;
}
var init_constants3 = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/constants/index.js"() {
    init_util();
    init_util7();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/errors/index.js
function variantToMeta(lookup, variant) {
  return objectSpread({ args: variant.fields.map(({ type }) => lookup.getTypeDef(type).type) }, variant);
}
function decorateErrors(registry, { lookup, pallets }, version) {
  const result = {};
  for (let i2 = 0, count = pallets.length; i2 < count; i2++) {
    const { errors, index, name } = pallets[i2];
    if (errors.isSome) {
      const sectionIndex = version >= 12 ? index.toNumber() : i2;
      lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, errors.unwrap(), objectNameToString, (variant) => ({
        // We sprinkle in isCodec & isU8a to ensure we are dealing with the correct objects
        is: (errorMod) => isCodec(errorMod) && isCodec(errorMod.index) && errorMod.index.eq(sectionIndex) && (isU8a(errorMod.error) ? errorMod.error[0] === variant.index.toNumber() : isCodec(errorMod.error) && errorMod.error.eq(variant.index)),
        meta: registry.createTypeUnsafe("ErrorMetadataLatest", [variantToMeta(lookup, variant)])
      })));
    }
  }
  return result;
}
var init_errors2 = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/errors/index.js"() {
    init_util();
    init_lazy2();
    init_util7();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/events/index.js
function filterEventsSome({ events: events2 }) {
  return events2.isSome;
}
function decorateEvents(registry, { lookup, pallets }, version) {
  const result = {};
  const filtered = pallets.filter(filterEventsSome);
  for (let i2 = 0, count = filtered.length; i2 < count; i2++) {
    const { events: events2, index, name } = filtered[i2];
    const sectionIndex = version >= 12 ? index.toNumber() : i2;
    lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, events2.unwrap(), objectNameToString, (variant) => ({
      // We sprinkle in isCodec & isU8a to ensure we are dealing with the correct objects
      is: (eventRecord) => isCodec(eventRecord) && isU8a(eventRecord.index) && sectionIndex === eventRecord.index[0] && variant.index.eq(eventRecord.index[1]),
      meta: registry.createTypeUnsafe("EventMetadataLatest", [variantToMeta(lookup, variant)])
    })));
  }
  return result;
}
var init_events = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/events/index.js"() {
    init_util();
    init_lazy2();
    init_errors2();
    init_util7();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/storage/getHasher.js
function getHasher(hasher2) {
  return HASHERS[hasher2.type] || DEFAULT_FN;
}
var DEFAULT_FN, HASHERS;
var init_getHasher = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/storage/getHasher.js"() {
    init_util();
    init_util_crypto();
    DEFAULT_FN = (data) => xxhashAsU8a(data, 128);
    HASHERS = {
      Blake2_128: (data) => (
        // eslint-disable-line camelcase
        blake2AsU8a(data, 128)
      ),
      Blake2_128Concat: (data) => (
        // eslint-disable-line camelcase
        u8aConcat(blake2AsU8a(data, 128), u8aToU8a(data))
      ),
      Blake2_256: (data) => (
        // eslint-disable-line camelcase
        blake2AsU8a(data, 256)
      ),
      Identity: (data) => u8aToU8a(data),
      Twox128: (data) => xxhashAsU8a(data, 128),
      Twox256: (data) => xxhashAsU8a(data, 256),
      Twox64Concat: (data) => u8aConcat(xxhashAsU8a(data, 64), u8aToU8a(data))
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js
function filterDefined(a) {
  return !isUndefined(a);
}
function assertArgs({ method, section: section2 }, { args, keys: keys2 }) {
  if (!Array.isArray(args)) {
    throw new Error(`Call to ${stringCamelCase(section2 || "unknown")}.${stringCamelCase(method || "unknown")} needs ${keys2.length} arguments`);
  } else if (args.filter(filterDefined).length !== keys2.length) {
    throw new Error(`Call to ${stringCamelCase(section2 || "unknown")}.${stringCamelCase(method || "unknown")} needs ${keys2.length} arguments, found [${args.join(", ")}]`);
  }
}
function createKeyRawParts(registry, itemFn, { args, hashers, keys: keys2 }) {
  const count = keys2.length;
  const extra = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    extra[i2] = getHasher(hashers[i2])(registry.createTypeUnsafe(registry.createLookupType(keys2[i2]), [args[i2]]).toU8a());
  }
  return [
    [
      xxhashAsU8a(itemFn.prefix, 128),
      xxhashAsU8a(itemFn.method, 128)
    ],
    extra
  ];
}
function createKeyInspect(registry, itemFn, args) {
  assertArgs(itemFn, args);
  const { meta } = itemFn;
  const [prefix2, extra] = createKeyRawParts(registry, itemFn, args);
  let types4 = [];
  if (meta.type.isMap) {
    const { hashers, key } = meta.type.asMap;
    types4 = hashers.length === 1 ? [`${hashers[0].type}(${getSiName(registry.lookup, key)})`] : registry.lookup.getSiType(key).def.asTuple.map((k, i2) => `${hashers[i2].type}(${getSiName(registry.lookup, k)})`);
  }
  const names = ["module", "method"].concat(...args.args.map((_, i2) => types4[i2]));
  return {
    inner: prefix2.concat(...extra).map((v, i2) => ({ name: names[i2], outer: [v] }))
  };
}
function createKeyRaw(registry, itemFn, args) {
  const [prefix2, extra] = createKeyRawParts(registry, itemFn, args);
  return u8aConcat(...prefix2, ...extra);
}
function createKey(registry, itemFn, args) {
  assertArgs(itemFn, args);
  return compactAddLength(createKeyRaw(registry, itemFn, args));
}
function createStorageInspect(registry, itemFn, options) {
  const { meta: { type } } = itemFn;
  return (...args) => {
    if (type.isPlain) {
      return options.skipHashing ? { inner: [], name: "wellKnown", outer: [u8aToU8a(options.key)] } : createKeyInspect(registry, itemFn, NO_RAW_ARGS);
    }
    const { hashers, key } = type.asMap;
    return hashers.length === 1 ? createKeyInspect(registry, itemFn, { args, hashers, keys: [key] }) : createKeyInspect(registry, itemFn, { args, hashers, keys: registry.lookup.getSiType(key).def.asTuple });
  };
}
function createStorageFn(registry, itemFn, options) {
  const { meta: { type } } = itemFn;
  let cacheKey = null;
  return (...args) => {
    if (type.isPlain) {
      if (!cacheKey) {
        cacheKey = options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, NO_RAW_ARGS);
      }
      return cacheKey;
    }
    const { hashers, key } = type.asMap;
    return hashers.length === 1 ? createKey(registry, itemFn, { args, hashers, keys: [key] }) : createKey(registry, itemFn, { args, hashers, keys: registry.lookup.getSiType(key).def.asTuple });
  };
}
function createWithMeta(registry, itemFn, options) {
  const { meta, method, prefix: prefix2, section: section2 } = itemFn;
  const storageFn = createStorageFn(registry, itemFn, options);
  storageFn.inspect = createStorageInspect(registry, itemFn, options);
  storageFn.meta = meta;
  storageFn.method = stringCamelCase(method);
  storageFn.prefix = prefix2;
  storageFn.section = section2;
  storageFn.toJSON = () => objectSpread({ storage: { method, prefix: prefix2, section: section2 } }, meta.toJSON());
  return storageFn;
}
function extendHeadMeta(registry, { meta: { docs, name, type }, section: section2 }, { method }, iterFn) {
  const meta = registry.createTypeUnsafe("StorageEntryMetadataLatest", [{
    docs,
    fallback: registry.createTypeUnsafe("Bytes", []),
    modifier: registry.createTypeUnsafe("StorageEntryModifierLatest", [1]),
    // required
    name,
    type: registry.createTypeUnsafe("StorageEntryTypeLatest", [type.asMap.key, 0])
  }]);
  iterFn.meta = meta;
  const fn = (...args) => registry.createTypeUnsafe("StorageKey", [iterFn(...args), { method, section: section2 }]);
  fn.meta = meta;
  return fn;
}
function extendPrefixedMap(registry, itemFn, storageFn) {
  const { meta: { type }, method, section: section2 } = itemFn;
  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {
    if (args.length && (type.isPlain || args.length >= type.asMap.hashers.length)) {
      throw new Error(`Iteration of ${stringCamelCase(section2 || "unknown")}.${stringCamelCase(method || "unknown")} needs arguments to be at least one less than the full arguments, found [${args.join(", ")}]`);
    }
    if (args.length) {
      if (type.isMap) {
        const { hashers, key } = type.asMap;
        const keysVec = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;
        return new Raw(registry, createKeyRaw(registry, itemFn, { args, hashers: hashers.slice(0, args.length), keys: keysVec.slice(0, args.length) }));
      }
    }
    return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));
  });
  return storageFn;
}
function createFunction(registry, itemFn, options) {
  const { meta: { type } } = itemFn;
  const storageFn = createWithMeta(registry, itemFn, options);
  if (type.isMap) {
    extendPrefixedMap(registry, itemFn, storageFn);
  }
  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];
  return storageFn;
}
var NO_RAW_ARGS;
var init_createFunction = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js"() {
    init_types_codec();
    init_util();
    init_util_crypto();
    init_util4();
    init_getHasher();
    NO_RAW_ARGS = {
      args: [],
      hashers: [],
      keys: []
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/storage/util.js
function findSiPrimitive(registry, type) {
  const prim = type.toLowerCase();
  return registry.lookup.types.find((t2) => t2.type.def.isPrimitive && t2.type.def.asPrimitive.toString().toLowerCase() === prim || t2.type.def.isHistoricMetaCompat && t2.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);
}
function findSiType(registry, type) {
  let portable = findSiPrimitive(registry, type);
  if (!portable && (type === "Bytes" || type.startsWith("[u8;"))) {
    const u83 = findSiPrimitive(registry, "u8");
    if (u83) {
      if (type === "Bytes") {
        portable = registry.lookup.types.find((t2) => t2.type.def.isSequence && t2.type.def.asSequence.type.eq(u83.id) || t2.type.def.isHistoricMetaCompat && t2.type.def.asHistoricMetaCompat.eq(type));
      } else {
        const td = getTypeDef(type);
        portable = registry.lookup.types.find((t2) => t2.type.def.isArray && t2.type.def.asArray.eq({
          len: td.length,
          type: u83.id
        }) || t2.type.def.isHistoricMetaCompat && t2.type.def.asHistoricMetaCompat.eq(type));
      }
    }
  }
  if (!portable) {
    console.warn(`Unable to map ${type} to a lookup index`);
  }
  return portable;
}
function createRuntimeFunction({ method, prefix: prefix2, section: section2 }, key, { docs, type }) {
  return (registry) => createFunction(registry, {
    meta: registry.createTypeUnsafe("StorageEntryMetadataLatest", [{
      docs: registry.createTypeUnsafe("Vec<Text>", [[docs]]),
      modifier: registry.createTypeUnsafe("StorageEntryModifierLatest", ["Required"]),
      name: registry.createTypeUnsafe("Text", [method]),
      toJSON: () => key,
      type: registry.createTypeUnsafe("StorageEntryTypeLatest", [{ Plain: findSiType(registry, type)?.id || 0 }])
    }]),
    method,
    prefix: prefix2,
    section: section2
  }, { key, skipHashing: true });
}
var init_util8 = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/storage/util.js"() {
    init_types_create();
    init_createFunction();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/storage/substrate.js
function createSubstrateFn(method, key, meta) {
  return createRuntimeFunction({ method, prefix, section }, key, meta);
}
var prefix, section, substrate2;
var init_substrate2 = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/storage/substrate.js"() {
    init_util8();
    prefix = "Substrate";
    section = "substrate";
    substrate2 = {
      changesTrieConfig: createSubstrateFn("changesTrieConfig", ":changes_trie", {
        docs: "Changes trie configuration is stored under this key.",
        type: "u32"
      }),
      childStorageKeyPrefix: createSubstrateFn("childStorageKeyPrefix", ":child_storage:", {
        docs: "Prefix of child storage keys.",
        type: "u32"
      }),
      code: createSubstrateFn("code", ":code", {
        docs: "Wasm code of the runtime.",
        type: "Bytes"
      }),
      extrinsicIndex: createSubstrateFn("extrinsicIndex", ":extrinsic_index", {
        docs: "Current extrinsic index (u32) is stored under this key.",
        type: "u32"
      }),
      heapPages: createSubstrateFn("heapPages", ":heappages", {
        docs: "Number of wasm linear memory pages required for execution of the runtime.",
        type: "u64"
      }),
      intrablockEntropy: createSubstrateFn("intrablockEntropy", ":intrablock_entropy", {
        docs: "Current intra-block entropy (a universally unique `[u8; 32]` value) is stored here.",
        type: "[u8; 32]"
      })
    };
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/storage/getStorage.js
function getStorage(registry) {
  const storage = {};
  const entries = Object.entries(substrate2);
  for (let e2 = 0, count = entries.length; e2 < count; e2++) {
    storage[entries[e2][0]] = entries[e2][1](registry);
  }
  return { substrate: storage };
}
var init_getStorage = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/storage/getStorage.js"() {
    init_substrate2();
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/storage/index.js
function decorateStorage(registry, { pallets }, _metaVersion) {
  const result = getStorage(registry);
  for (let i2 = 0, count = pallets.length; i2 < count; i2++) {
    const { name, storage } = pallets[i2];
    if (storage.isSome) {
      const section2 = stringCamelCase(name);
      const { items, prefix: _prefix } = storage.unwrap();
      const prefix2 = _prefix.toString();
      lazyMethod(result, section2, () => lazyMethods({
        palletVersion: createRuntimeFunction({ method: VERSION_NAME, prefix: prefix2, section: section2 }, createKeyRaw(registry, { method: VERSION_KEY, prefix: name.toString() }, NO_RAW_ARGS), VERSION_DOCS)(registry)
      }, items, (meta) => createFunction(registry, { meta, method: meta.name.toString(), prefix: prefix2, section: section2 }, {}), objectNameToCamel));
    }
  }
  return result;
}
var VERSION_NAME, VERSION_KEY, VERSION_DOCS;
var init_storage2 = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/storage/index.js"() {
    init_util();
    init_util7();
    init_createFunction();
    init_getStorage();
    init_util8();
    VERSION_NAME = "palletVersion";
    VERSION_KEY = ":__STORAGE_VERSION__:";
    VERSION_DOCS = { docs: "Returns the current pallet version from storage", type: "u16" };
  }
});

// ../../node_modules/@polkadot/types/metadata/decorate/index.js
function expandMetadata(registry, metadata) {
  if (!(metadata instanceof Metadata)) {
    throw new Error("You need to pass a valid Metadata instance to Decorated");
  }
  const latest2 = metadata.asLatest;
  const version = metadata.version;
  return {
    consts: decorateConstants(registry, latest2, version),
    errors: decorateErrors(registry, latest2, version),
    events: decorateEvents(registry, latest2, version),
    query: decorateStorage(registry, latest2, version),
    registry,
    tx: decorateExtrinsics(registry, latest2, version)
  };
}
var init_decorate = __esm({
  "../../node_modules/@polkadot/types/metadata/decorate/index.js"() {
    init_Metadata();
    init_constants3();
    init_errors2();
    init_events();
    init_extrinsics();
    init_storage2();
  }
});

// ../../node_modules/@polkadot/types/create/registry.js
function sortDecimalStrings(a, b) {
  return parseInt(a, 10) - parseInt(b, 10);
}
function valueToString(v) {
  return v.toString();
}
function getFieldArgs(lookup, fields) {
  const count = fields.length;
  const args = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    args[i2] = lookup.getTypeDef(fields[i2].type).type;
  }
  return args;
}
function clearRecord(record) {
  const keys2 = Object.keys(record);
  for (let i2 = 0, count = keys2.length; i2 < count; i2++) {
    delete record[keys2[i2]];
  }
}
function getVariantStringIdx({ index }) {
  return index.toString();
}
function injectErrors(_, { lookup, pallets }, version, result) {
  clearRecord(result);
  for (let i2 = 0, count = pallets.length; i2 < count; i2++) {
    const { errors, index, name } = pallets[i2];
    if (errors.isSome) {
      const sectionName = stringCamelCase(name);
      lazyMethod(result, version >= 12 ? index.toNumber() : i2, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({ docs, fields, index: index2, name: name2 }) => ({
        args: getFieldArgs(lookup, fields),
        docs: docs.map(valueToString),
        fields,
        index: index2.toNumber(),
        method: name2.toString(),
        name: name2.toString(),
        section: sectionName
      })));
    }
  }
}
function injectEvents(registry, { lookup, pallets }, version, result) {
  const filtered = pallets.filter(filterEventsSome);
  clearRecord(result);
  for (let i2 = 0, count = filtered.length; i2 < count; i2++) {
    const { events: events2, index, name } = filtered[i2];
    lazyMethod(result, version >= 12 ? index.toNumber() : i2, () => lazyVariants(lookup, events2.unwrap(), getVariantStringIdx, (variant) => {
      const meta = registry.createType("EventMetadataLatest", objectSpread({}, variant, { args: getFieldArgs(lookup, variant.fields) }));
      return class extends GenericEventData {
        constructor(registry2, value) {
          super(registry2, value, meta, stringCamelCase(name), variant.name.toString());
        }
      };
    }));
  }
}
function injectExtrinsics(registry, { lookup, pallets }, version, result, mapping2) {
  const filtered = pallets.filter(filterCallsSome);
  clearRecord(result);
  clearRecord(mapping2);
  for (let i2 = 0, count = filtered.length; i2 < count; i2++) {
    const { calls, index, name } = filtered[i2];
    const sectionIndex = version >= 12 ? index.toNumber() : i2;
    const sectionName = stringCamelCase(name);
    const allCalls = calls.unwrap();
    lazyMethod(result, sectionIndex, () => lazyVariants(lookup, allCalls, getVariantStringIdx, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
    const { path } = registry.lookup.getSiType(allCalls.type);
    const palletIdx = path.findIndex((v) => v.eq("pallet"));
    if (palletIdx !== -1) {
      const name2 = stringCamelCase(path.slice(0, palletIdx).map((p, i3) => i3 === 0 ? p.replace(/^(frame|pallet)_/, "") : p).join(" "));
      if (!mapping2[name2]) {
        mapping2[name2] = [sectionName];
      } else {
        mapping2[name2].push(sectionName);
      }
    }
  }
}
function extractProperties(registry, metadata) {
  const original = registry.getChainProperties();
  const constants = decorateConstants(registry, metadata.asLatest, metadata.version);
  const ss58Format = constants["system"] && (constants["system"]["sS58Prefix"] || constants["system"]["ss58Prefix"]);
  if (!ss58Format) {
    return original;
  }
  const { isEthereum, tokenDecimals, tokenSymbol } = original || {};
  return registry.createTypeUnsafe("ChainProperties", [{ isEthereum, ss58Format, tokenDecimals, tokenSymbol }]);
}
var DEFAULT_FIRST_CALL_IDX, l10, TypeRegistry;
var init_registry = __esm({
  "../../node_modules/@polkadot/types/create/registry.js"() {
    init_types_codec();
    init_types_create();
    init_util();
    init_util_crypto();
    init_signedExtensions();
    init_Event();
    init_index_types();
    init_definitions78();
    init_extrinsics();
    init_decorate();
    init_Metadata();
    init_PortableRegistry2();
    init_lazy2();
    DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);
    l10 = logger("registry");
    TypeRegistry = class {
      __internal__chainProperties;
      __internal__classes = /* @__PURE__ */ new Map();
      __internal__definitions = /* @__PURE__ */ new Map();
      __internal__firstCallIndex = null;
      __internal__hasher = blake2AsU8a;
      __internal__knownTypes = {};
      __internal__lookup;
      __internal__metadata;
      __internal__metadataVersion = 0;
      __internal__signedExtensions = fallbackExtensions;
      __internal__unknownTypes = /* @__PURE__ */ new Map();
      __internal__userExtensions;
      __internal__knownDefaults;
      __internal__knownDefaultsEntries;
      __internal__knownDefinitions;
      __internal__metadataCalls = {};
      __internal__metadataErrors = {};
      __internal__metadataEvents = {};
      __internal__moduleMap = {};
      createdAtHash;
      constructor(createdAtHash) {
        this.__internal__knownDefaults = objectSpread({ Json, Metadata, PortableRegistry, Raw }, index_types_exports);
        this.__internal__knownDefaultsEntries = Object.entries(this.__internal__knownDefaults);
        this.__internal__knownDefinitions = definitions_exports;
        const allKnown = Object.values(this.__internal__knownDefinitions);
        for (let i2 = 0, count = allKnown.length; i2 < count; i2++) {
          this.register(allKnown[i2].types);
        }
        if (createdAtHash) {
          this.createdAtHash = this.createType("BlockHash", createdAtHash);
        }
      }
      get chainDecimals() {
        if (this.__internal__chainProperties?.tokenDecimals.isSome) {
          const allDecimals = this.__internal__chainProperties.tokenDecimals.unwrap();
          if (allDecimals.length) {
            return allDecimals.map((b) => b.toNumber());
          }
        }
        return [12];
      }
      get chainIsEthereum() {
        return this.__internal__chainProperties?.isEthereum.isTrue || false;
      }
      get chainSS58() {
        return this.__internal__chainProperties?.ss58Format.isSome ? this.__internal__chainProperties.ss58Format.unwrap().toNumber() : void 0;
      }
      get chainTokens() {
        if (this.__internal__chainProperties?.tokenSymbol.isSome) {
          const allTokens = this.__internal__chainProperties.tokenSymbol.unwrap();
          if (allTokens.length) {
            return allTokens.map(valueToString);
          }
        }
        return [formatBalance.getDefaults().unit];
      }
      get firstCallIndex() {
        return this.__internal__firstCallIndex || DEFAULT_FIRST_CALL_IDX;
      }
      /**
       * @description Returns true if the type is in a Compat format
       */
      isLookupType(value) {
        return /Lookup\d+$/.test(value);
      }
      /**
       * @description Creates a lookup string from the supplied id
       */
      createLookupType(lookupId) {
        return `Lookup${typeof lookupId === "number" ? lookupId : lookupId.toNumber()}`;
      }
      get knownTypes() {
        return this.__internal__knownTypes;
      }
      get lookup() {
        return assertReturn(this.__internal__lookup, "PortableRegistry has not been set on this registry");
      }
      get metadata() {
        return assertReturn(this.__internal__metadata, "Metadata has not been set on this registry");
      }
      get unknownTypes() {
        return [...this.__internal__unknownTypes.keys()];
      }
      get signedExtensions() {
        return this.__internal__signedExtensions;
      }
      clearCache() {
        this.__internal__classes = /* @__PURE__ */ new Map();
      }
      /**
       * @describe Creates an instance of the class
       */
      createClass(type) {
        return createClassUnsafe(this, type);
      }
      /**
       * @describe Creates an instance of the class
       */
      createClassUnsafe(type) {
        return createClassUnsafe(this, type);
      }
      /**
       * @description Creates an instance of a type as registered
       */
      createType(type, ...params) {
        return createTypeUnsafe(this, type, params);
      }
      /**
       * @description Creates an instance of a type as registered
       */
      createTypeUnsafe(type, params, options) {
        return createTypeUnsafe(this, type, params, options);
      }
      // find a specific call
      findMetaCall(callIndex) {
        const [section2, method] = [callIndex[0], callIndex[1]];
        return assertReturn(this.__internal__metadataCalls[`${section2}`] && this.__internal__metadataCalls[`${section2}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section2}, ${method}]/[${callIndex.toString()}]`);
      }
      // finds an error
      findMetaError(errorIndex) {
        const [section2, method] = isU8a(errorIndex) ? [errorIndex[0], errorIndex[1]] : [
          errorIndex.index.toNumber(),
          isU8a(errorIndex.error) ? errorIndex.error[0] : errorIndex.error.toNumber()
        ];
        return assertReturn(this.__internal__metadataErrors[`${section2}`] && this.__internal__metadataErrors[`${section2}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section2}, ${method}]/[${errorIndex.toString()}]`);
      }
      findMetaEvent(eventIndex) {
        const [section2, method] = [eventIndex[0], eventIndex[1]];
        return assertReturn(this.__internal__metadataEvents[`${section2}`] && this.__internal__metadataEvents[`${section2}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section2}, ${method}]/[${eventIndex.toString()}]`);
      }
      get(name, withUnknown, knownTypeDef) {
        return this.getUnsafe(name, withUnknown, knownTypeDef);
      }
      getUnsafe(name, withUnknown, knownTypeDef) {
        let Type2 = this.__internal__classes.get(name) || this.__internal__knownDefaults[name];
        if (!Type2) {
          const definition = this.__internal__definitions.get(name);
          let BaseType;
          if (definition) {
            BaseType = createClassUnsafe(this, definition);
          } else if (knownTypeDef) {
            BaseType = constructTypeClass(this, knownTypeDef);
          } else if (withUnknown) {
            l10.warn(`Unable to resolve type ${name}, it will fail on construction`);
            this.__internal__unknownTypes.set(name, true);
            BaseType = DoNotConstruct.with(name);
          }
          if (BaseType) {
            Type2 = class extends BaseType {
            };
            this.__internal__classes.set(name, Type2);
            if (knownTypeDef && isNumber(knownTypeDef.lookupIndex)) {
              this.__internal__classes.set(this.createLookupType(knownTypeDef.lookupIndex), Type2);
            }
          }
        }
        return Type2;
      }
      getChainProperties() {
        return this.__internal__chainProperties;
      }
      getClassName(Type2) {
        const names = [];
        for (const [name, Clazz] of this.__internal__knownDefaultsEntries) {
          if (Type2 === Clazz) {
            names.push(name);
          }
        }
        for (const [name, Clazz] of this.__internal__classes.entries()) {
          if (Type2 === Clazz) {
            names.push(name);
          }
        }
        return names.length ? names.sort().reverse()[0] : void 0;
      }
      getDefinition(typeName) {
        return this.__internal__definitions.get(typeName);
      }
      getModuleInstances(specName, moduleName) {
        return this.__internal__knownTypes?.typesBundle?.spec?.[specName.toString()]?.instances?.[moduleName] || this.__internal__moduleMap[moduleName];
      }
      getOrThrow(name) {
        const Clazz = this.get(name);
        if (!Clazz) {
          throw new Error(`type ${name} not found`);
        }
        return Clazz;
      }
      getOrUnknown(name) {
        return this.get(name, true);
      }
      // Only used in extrinsic version 5
      getTransactionExtensionVersion() {
        return 0;
      }
      getSignedExtensionExtra() {
        return expandExtensionTypes(this.__internal__signedExtensions, "payload", this.__internal__userExtensions);
      }
      getSignedExtensionTypes() {
        return expandExtensionTypes(this.__internal__signedExtensions, "extrinsic", this.__internal__userExtensions);
      }
      hasClass(name) {
        return this.__internal__classes.has(name) || !!this.__internal__knownDefaults[name];
      }
      hasDef(name) {
        return this.__internal__definitions.has(name);
      }
      hasType(name) {
        return !this.__internal__unknownTypes.get(name) && (this.hasClass(name) || this.hasDef(name));
      }
      hash(data) {
        return this.createType("CodecHash", this.__internal__hasher(data));
      }
      // eslint-disable-next-line no-dupe-class-members
      register(arg1, arg2) {
        if (isFunction(arg1)) {
          this.__internal__classes.set(arg1.name, arg1);
        } else if (isString(arg1)) {
          if (!isFunction(arg2)) {
            throw new Error(`Expected class definition passed to '${arg1}' registration`);
          } else if (arg1 === arg2.toString()) {
            throw new Error(`Unable to register circular ${arg1} === ${arg1}`);
          }
          this.__internal__classes.set(arg1, arg2);
        } else {
          this.__internal__registerObject(arg1);
        }
      }
      __internal__registerObject = (obj) => {
        const entries = Object.entries(obj);
        for (let e2 = 0, count = entries.length; e2 < count; e2++) {
          const [name, type] = entries[e2];
          if (isFunction(type)) {
            this.__internal__classes.set(name, type);
          } else {
            const def = isString(type) ? type : stringify(type);
            if (name === def) {
              throw new Error(`Unable to register circular ${name} === ${def}`);
            }
            if (this.__internal__classes.has(name)) {
              this.__internal__classes.delete(name);
            }
            this.__internal__definitions.set(name, def);
          }
        }
      };
      // sets the chain properties
      setChainProperties(properties) {
        if (properties) {
          this.__internal__chainProperties = properties;
        }
      }
      setHasher(hasher2) {
        this.__internal__hasher = hasher2 || blake2AsU8a;
      }
      setKnownTypes(knownTypes2) {
        this.__internal__knownTypes = knownTypes2;
      }
      setLookup(lookup) {
        this.__internal__lookup = lookup;
        lookup.register();
      }
      // register alias types alongside the portable/lookup setup
      // (we don't combine this into setLookup since that would/could
      // affect stand-along lookups, such as ABIs which don't have
      // actual on-chain metadata)
      __internal__registerLookup = (lookup) => {
        this.setLookup(lookup);
        let Weight = null;
        if (this.hasType("SpWeightsWeightV2Weight")) {
          const weightv2 = this.createType("SpWeightsWeightV2Weight");
          Weight = weightv2.refTime && weightv2.proofSize ? "SpWeightsWeightV2Weight" : "WeightV1";
        } else if (!isBn(this.createType("Weight"))) {
          Weight = "WeightV1";
        }
        if (Weight) {
          this.register({ Weight });
        }
      };
      // sets the metadata
      setMetadata(metadata, signedExtensions, userExtensions, noInitWarn) {
        this.__internal__metadata = metadata.asLatest;
        this.__internal__metadataVersion = metadata.version;
        this.__internal__firstCallIndex = null;
        this.__internal__registerLookup(this.__internal__metadata.lookup);
        injectExtrinsics(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataCalls, this.__internal__moduleMap);
        injectErrors(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataErrors);
        injectEvents(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataEvents);
        const [defSection] = Object.keys(this.__internal__metadataCalls).sort(sortDecimalStrings);
        if (defSection) {
          const [defMethod] = Object.keys(this.__internal__metadataCalls[defSection]).sort(sortDecimalStrings);
          if (defMethod) {
            this.__internal__firstCallIndex = new Uint8Array([parseInt(defSection, 10), parseInt(defMethod, 10)]);
          }
        }
        this.setSignedExtensions(signedExtensions || (this.__internal__metadata.extrinsic.version.gt(BN_ZERO) ? this.__internal__metadata.extrinsic.signedExtensions.map(({ identifier }) => identifier.toString()) : fallbackExtensions), userExtensions, noInitWarn);
        this.setChainProperties(extractProperties(this, metadata));
      }
      // sets the available signed extensions
      setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions, noInitWarn) {
        this.__internal__signedExtensions = signedExtensions;
        this.__internal__userExtensions = userExtensions;
        if (!noInitWarn) {
          const unknown = findUnknownExtensions(this.__internal__signedExtensions, this.__internal__userExtensions);
          if (unknown.length) {
            l10.warn(`Unknown signed extensions ${unknown.join(", ")} found, treating them as no-effect`);
          }
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/types/create/index.js
var init_create2 = __esm({
  "../../node_modules/@polkadot/types/create/index.js"() {
    init_exports();
    init_createClass();
    init_createType();
    init_lazy2();
    init_registry();
  }
});

// ../../node_modules/@polkadot/types/metadata/index.js
var init_metadata = __esm({
  "../../node_modules/@polkadot/types/metadata/index.js"() {
    init_decorate();
    init_Metadata();
  }
});

// ../../node_modules/@polkadot/types/bundle.js
var init_bundle11 = __esm({
  "../../node_modules/@polkadot/types/bundle.js"() {
    init_definitions78();
    init_jsonrpc();
    init_codec2();
    init_create2();
    init_index_types();
    init_metadata();
  }
});

// ../../node_modules/@polkadot/types/index.js
var init_types3 = __esm({
  "../../node_modules/@polkadot/types/index.js"() {
    init_packageDetect12();
    init_bundle11();
  }
});

// ../../node_modules/@polkadot/rpc-core/util/refCountDelay.js
function refCountDelay(delay = 1750) {
  return (source) => {
    let [state, refCount3, connection, scheduler] = [0, 0, import_rxjs.Subscription.EMPTY, import_rxjs.Subscription.EMPTY];
    return new import_rxjs.Observable((ob) => {
      source.subscribe(ob);
      if (refCount3++ === 0) {
        if (state === 1) {
          scheduler.unsubscribe();
        } else {
          connection = source.connect();
        }
        state = 3;
      }
      return () => {
        if (--refCount3 === 0) {
          if (state === 2) {
            state = 0;
            scheduler.unsubscribe();
          } else {
            state = 1;
            scheduler = import_rxjs.asapScheduler.schedule(() => {
              state = 0;
              connection.unsubscribe();
            }, delay);
          }
        }
      };
    });
  };
}
var import_rxjs;
var init_refCountDelay = __esm({
  "../../node_modules/@polkadot/rpc-core/util/refCountDelay.js"() {
    import_rxjs = __toESM(require_cjs(), 1);
  }
});

// ../../node_modules/@polkadot/rpc-core/util/drr.js
function CMP(a, b) {
  return stringify({ t: a }) === stringify({ t: b });
}
function ERR(error) {
  throw error;
}
function NOOP() {
}
function drr({ delay, skipChange = false, skipTimeout = false } = {}) {
  return (source$) => source$.pipe(
    (0, import_rxjs2.catchError)(ERR),
    skipChange ? (0, import_rxjs2.tap)(NOOP) : (0, import_rxjs2.distinctUntilChanged)(CMP),
    // eslint-disable-next-line deprecation/deprecation
    (0, import_rxjs2.publishReplay)(1),
    skipTimeout ? (0, import_rxjs2.refCount)() : refCountDelay(delay)
  );
}
var import_rxjs2;
var init_drr = __esm({
  "../../node_modules/@polkadot/rpc-core/util/drr.js"() {
    import_rxjs2 = __toESM(require_cjs(), 1);
    init_util();
    init_refCountDelay();
  }
});

// ../../node_modules/@polkadot/rpc-core/util/memo.js
function memo(instanceId, inner) {
  const options = { getInstanceId: () => instanceId };
  const cached = memoize((...params) => new import_rxjs3.Observable((observer) => {
    const subscription = inner(...params).subscribe(observer);
    return () => {
      cached.unmemoize(...params);
      subscription.unsubscribe();
    };
  }).pipe(drr()), options);
  return cached;
}
var import_rxjs3;
var init_memo = __esm({
  "../../node_modules/@polkadot/rpc-core/util/memo.js"() {
    import_rxjs3 = __toESM(require_cjs(), 1);
    init_util();
    init_drr();
  }
});

// ../../node_modules/@polkadot/rpc-core/util/index.js
var init_util9 = __esm({
  "../../node_modules/@polkadot/rpc-core/util/index.js"() {
    init_drr();
    init_memo();
    init_refCountDelay();
  }
});

// ../../node_modules/@polkadot/rpc-core/bundle.js
function logErrorMessage(method, { noErrorLog, params, type }, error) {
  if (noErrorLog) {
    return;
  }
  l11.error(`${method}(${params.map(({ isOptional, name, type: type2 }) => `${name}${isOptional ? "?" : ""}: ${type2}`).join(", ")}): ${type}:: ${error.message}`);
}
function isTreatAsHex(key) {
  return ["0x3a636f6465"].includes(key.toHex());
}
var import_rxjs4, l11, EMPTY_META, RPC_CORE_DEFAULT_CAPACITY, RpcCore;
var init_bundle12 = __esm({
  "../../node_modules/@polkadot/rpc-core/bundle.js"() {
    import_rxjs4 = __toESM(require_cjs(), 1);
    init_rpc_provider();
    init_types3();
    init_util();
    init_util9();
    init_util9();
    l11 = logger("rpc-core");
    EMPTY_META = {
      fallback: void 0,
      modifier: { isOptional: true },
      type: {
        asMap: { linked: { isTrue: false } },
        isMap: false
      }
    };
    RPC_CORE_DEFAULT_CAPACITY = 1024 * 10 * 10;
    RpcCore = class {
      __internal__instanceId;
      __internal__isPedantic;
      __internal__registryDefault;
      __internal__storageCache;
      __internal__storageCacheHits = 0;
      __internal__getBlockRegistry;
      __internal__getBlockHash;
      mapping = /* @__PURE__ */ new Map();
      provider;
      sections = [];
      /**
       * @constructor
       * Default constructor for the core RPC handler
       * @param {Registry} registry Type Registry
       * @param {ProviderInterface} options.provider An API provider using any of the supported providers (HTTP, SC or WebSocket)
       * @param {number} [options.rpcCacheCapacity] Custom size of the rpc LRUCache capacity. Defaults to `RPC_CORE_DEFAULT_CAPACITY` (1024 * 10 * 10)
       */
      constructor(instanceId, registry, { isPedantic = true, provider, rpcCacheCapacity, userRpc = {} }) {
        if (!provider || !isFunction(provider.send)) {
          throw new Error("Expected Provider to API create");
        }
        this.__internal__instanceId = instanceId;
        this.__internal__isPedantic = isPedantic;
        this.__internal__registryDefault = registry;
        this.provider = provider;
        const sectionNames = Object.keys(jsonrpc_default);
        this.sections.push(...sectionNames);
        this.__internal__storageCache = new LRUCache(rpcCacheCapacity || RPC_CORE_DEFAULT_CAPACITY);
        this.addUserInterfaces(userRpc);
      }
      /**
       * @description Returns the connected status of a provider
       */
      get isConnected() {
        return this.provider.isConnected;
      }
      /**
       * @description Manually connect from the attached provider
       */
      connect() {
        return this.provider.connect();
      }
      /**
       * @description Manually disconnect from the attached provider
       */
      async disconnect() {
        return this.provider.disconnect();
      }
      /**
       * @description Returns the underlying core stats, including those from teh provider
       */
      get stats() {
        const stats = this.provider.stats;
        return stats ? {
          ...stats,
          core: {
            cacheHits: this.__internal__storageCacheHits,
            cacheSize: this.__internal__storageCache.length
          }
        } : void 0;
      }
      /**
       * @description Sets a registry swap (typically from Api)
       */
      setRegistrySwap(registrySwap) {
        this.__internal__getBlockRegistry = memoize(registrySwap, {
          getInstanceId: () => this.__internal__instanceId
        });
      }
      /**
       * @description Sets a function to resolve block hash from block number
       */
      setResolveBlockHash(resolveBlockHash) {
        this.__internal__getBlockHash = memoize(resolveBlockHash, {
          getInstanceId: () => this.__internal__instanceId
        });
      }
      addUserInterfaces(userRpc) {
        this.sections.push(...Object.keys(userRpc).filter((k) => !this.sections.includes(k)));
        for (let s2 = 0, scount = this.sections.length; s2 < scount; s2++) {
          const section2 = this.sections[s2];
          const defs = objectSpread({}, jsonrpc_default[section2], userRpc[section2]);
          const methods = Object.keys(defs);
          for (let m2 = 0, mcount = methods.length; m2 < mcount; m2++) {
            const method = methods[m2];
            const def = defs[method];
            const jsonrpc2 = def.endpoint || `${section2}_${method}`;
            if (!this.mapping.has(jsonrpc2)) {
              const isSubscription = !!def.pubsub;
              if (!this[section2]) {
                this[section2] = {};
              }
              this.mapping.set(jsonrpc2, objectSpread({}, def, { isSubscription, jsonrpc: jsonrpc2, method, section: section2 }));
              lazyMethod(this[section2], method, () => isSubscription ? this._createMethodSubscribe(section2, method, def) : this._createMethodSend(section2, method, def));
            }
          }
        }
      }
      _memomize(creator, def) {
        const memoOpts = { getInstanceId: () => this.__internal__instanceId };
        const memoized2 = memoize(creator(true), memoOpts);
        memoized2.raw = memoize(creator(false), memoOpts);
        memoized2.meta = def;
        return memoized2;
      }
      _formatResult(isScale, registry, blockHash, method, def, params, result) {
        return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;
      }
      _createMethodSend(section2, method, def) {
        const rpcName = def.endpoint || `${section2}_${method}`;
        const hashIndex = def.params.findIndex(({ isHistoric }) => isHistoric);
        let memoized2 = null;
        const callWithRegistry = async (isScale, values) => {
          const blockId = hashIndex === -1 ? null : values[hashIndex];
          const blockHash = blockId && def.params[hashIndex].type === "BlockNumber" ? await this.__internal__getBlockHash?.(blockId) : blockId;
          const { registry } = isScale && blockHash && this.__internal__getBlockRegistry ? await this.__internal__getBlockRegistry(u8aToU8a(blockHash)) : { registry: this.__internal__registryDefault };
          const params = this._formatParams(registry, null, def, values);
          const result = await this.provider.send(rpcName, params.map((p) => p.toJSON()), !!blockHash);
          return this._formatResult(isScale, registry, blockHash, method, def, params, result);
        };
        const creator = (isScale) => (...values) => {
          const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];
          return new import_rxjs4.Observable((observer) => {
            callWithRegistry(isScale, values).then((value) => {
              observer.next(value);
              observer.complete();
            }).catch((error) => {
              logErrorMessage(method, def, error);
              observer.error(error);
              observer.complete();
            });
            return () => {
              if (isScale) {
                memoized2?.unmemoize(...values);
              } else {
                memoized2?.raw.unmemoize(...values);
              }
            };
          }).pipe(
            // eslint-disable-next-line deprecation/deprecation
            (0, import_rxjs4.publishReplay)(1),
            // create a Replay(1)
            isDelayed ? refCountDelay() : (0, import_rxjs4.refCount)()
          );
        };
        memoized2 = this._memomize(creator, def);
        return memoized2;
      }
      // create a subscriptor, it subscribes once and resolves with the id as subscribe
      _createSubscriber({ paramsJson, subName, subType, update }, errorHandler) {
        return new Promise((resolve, reject) => {
          this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch((error) => {
            errorHandler(error);
            reject(error);
          });
        });
      }
      _createMethodSubscribe(section2, method, def) {
        const [updateType, subMethod, unsubMethod] = def.pubsub;
        const subName = `${section2}_${subMethod}`;
        const unsubName = `${section2}_${unsubMethod}`;
        const subType = `${section2}_${updateType}`;
        let memoized2 = null;
        const creator = (isScale) => (...values) => {
          return new import_rxjs4.Observable((observer) => {
            let subscriptionPromise = Promise.resolve(null);
            const registry = this.__internal__registryDefault;
            const errorHandler = (error) => {
              logErrorMessage(method, def, error);
              observer.error(error);
            };
            try {
              const params = this._formatParams(registry, null, def, values);
              const update = (error, result) => {
                if (error) {
                  logErrorMessage(method, def, error);
                  return;
                }
                try {
                  observer.next(this._formatResult(isScale, registry, null, method, def, params, result));
                } catch (error2) {
                  observer.error(error2);
                }
              };
              subscriptionPromise = this._createSubscriber({ paramsJson: params.map((p) => p.toJSON()), subName, subType, update }, errorHandler);
            } catch (error) {
              errorHandler(error);
            }
            return () => {
              if (isScale) {
                memoized2?.unmemoize(...values);
              } else {
                memoized2?.raw.unmemoize(...values);
              }
              subscriptionPromise.then((subscriptionId) => isNull(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch((error) => logErrorMessage(method, def, error));
            };
          }).pipe(drr());
        };
        memoized2 = this._memomize(creator, def);
        return memoized2;
      }
      _formatParams(registry, blockHash, def, inputs) {
        const count = inputs.length;
        const reqCount = def.params.filter(({ isOptional }) => !isOptional).length;
        if (count < reqCount || count > def.params.length) {
          throw new Error(`Expected ${def.params.length} parameters${reqCount === def.params.length ? "" : ` (${def.params.length - reqCount} optional)`}, ${count} found instead`);
        }
        const params = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          params[i2] = registry.createTypeUnsafe(def.params[i2].type, [inputs[i2]], { blockHash });
        }
        return params;
      }
      _formatOutput(registry, blockHash, method, rpc18, params, result) {
        if (rpc18.type === "StorageData") {
          const key = params[0];
          return this._formatStorageData(registry, blockHash, key, result);
        } else if (rpc18.type === "StorageChangeSet") {
          const keys2 = params[0];
          return keys2 ? this._formatStorageSet(registry, result.block, keys2, result.changes) : registry.createType("StorageChangeSet", result);
        } else if (rpc18.type === "Vec<StorageChangeSet>") {
          const jsonSet = result;
          const count = jsonSet.length;
          const mapped = new Array(count);
          for (let i2 = 0; i2 < count; i2++) {
            const { block, changes } = jsonSet[i2];
            mapped[i2] = [
              registry.createType("BlockHash", block),
              this._formatStorageSet(registry, block, params[0], changes)
            ];
          }
          return method === "queryStorageAt" ? mapped[0][1] : mapped;
        }
        return registry.createTypeUnsafe(rpc18.type, [result], { blockHash });
      }
      _formatStorageData(registry, blockHash, key, value) {
        const isEmpty = isNull(value);
        const input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);
        return this._newType(registry, blockHash, key, input, isEmpty);
      }
      _formatStorageSet(registry, blockHash, keys2, changes) {
        const count = keys2.length;
        const withCache = count !== 1;
        const values = new Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          values[i2] = this._formatStorageSetEntry(registry, blockHash, keys2[i2], changes, withCache, i2);
        }
        return values;
      }
      _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {
        const hexKey = key.toHex();
        const found = changes.find(([key2]) => key2 === hexKey);
        const isNotFound = isUndefined(found);
        if (isNotFound && withCache) {
          const cached = this.__internal__storageCache.get(hexKey);
          if (cached) {
            this.__internal__storageCacheHits++;
            return cached;
          }
        }
        const value = isNotFound ? null : found[1];
        const isEmpty = isNull(value);
        const input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value);
        const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);
        this._setToCache(hexKey, codec);
        return codec;
      }
      _setToCache(key, value) {
        this.__internal__storageCache.set(key, value);
      }
      _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {
        const type = key.outputType || "Raw";
        const meta = key.meta || EMPTY_META;
        const entryNum = entryIndex === -1 ? "" : ` entry ${entryIndex}:`;
        try {
          return registry.createTypeUnsafe(type, [
            isEmpty ? meta.fallback ? type.includes("Linkage<") ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2)) : hexToU8a(meta.fallback.toHex()) : void 0 : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], { blockHash, isPedantic: this.__internal__isPedantic }) : input
          ], { blockHash, isFallback: isEmpty && !!meta.fallback, isOptional: meta.modifier.isOptional, isPedantic: this.__internal__isPedantic && !meta.modifier.isOptional });
        } catch (error) {
          throw new Error(`Unable to decode storage ${key.section || "unknown"}.${key.method || "unknown"}:${entryNum}: ${error.message}`);
        }
      }
    };
  }
});

// ../../node_modules/@polkadot/rpc-core/index.js
var init_rpc_core = __esm({
  "../../node_modules/@polkadot/rpc-core/index.js"() {
    init_packageDetect11();
    init_bundle12();
  }
});

// ../../node_modules/@polkadot/api-derive/util/approvalFlagsToBools.js
var init_approvalFlagsToBools = __esm({
  "../../node_modules/@polkadot/api-derive/util/approvalFlagsToBools.js"() {
  }
});

// ../../node_modules/@polkadot/api-derive/util/blockNumber.js
function unwrapBlockNumber(hdr) {
  return isCompact(hdr.number) ? hdr.number.unwrap() : hdr.number;
}
var init_blockNumber = __esm({
  "../../node_modules/@polkadot/api-derive/util/blockNumber.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/api-derive/util/cacheImpl.js
var deriveNoopCache;
var init_cacheImpl = __esm({
  "../../node_modules/@polkadot/api-derive/util/cacheImpl.js"() {
    deriveNoopCache = {
      del: () => void 0,
      forEach: () => void 0,
      get: () => void 0,
      set: (_, value) => value
    };
  }
});

// ../../node_modules/@polkadot/api-derive/util/cache.js
function wrapCache(keyStart, cache) {
  return {
    del: (partial) => cache.del(`${keyStart}${partial}`),
    forEach: cache.forEach,
    get: (partial) => {
      const key = `${keyStart}${partial}`;
      const cached = cache.get(key);
      if (cached) {
        cached.x = Date.now();
        cache.set(key, cached);
        return cached.v;
      }
      return void 0;
    },
    set: (partial, v) => {
      cache.set(`${keyStart}${partial}`, { v, x: Date.now() });
    }
  };
}
function clearCache(cache) {
  const now = Date.now();
  const all3 = [];
  cache.forEach((key, { x: x2 }) => {
    now - x2 > CACHE_EXPIRY && all3.push(key);
  });
  all3.forEach((key) => cache.del(key));
}
function setDeriveCache(prefix2 = "", cache) {
  deriveCache = cache ? wrapCache(`derive:${prefix2}:`, cache) : deriveNoopCache;
  if (cache) {
    clearCache(cache);
  }
}
var CACHE_EXPIRY, deriveCache;
var init_cache = __esm({
  "../../node_modules/@polkadot/api-derive/util/cache.js"() {
    init_cacheImpl();
    CACHE_EXPIRY = 7 * (24 * 60) * (60 * 1e3);
    setDeriveCache();
  }
});

// ../../node_modules/@polkadot/api-derive/util/first.js
function firstObservable(obs) {
  return obs.pipe((0, import_rxjs5.map)(([a]) => a));
}
function firstMemo(fn) {
  return (instanceId, api) => memo(instanceId, (...args) => firstObservable(fn(api, ...args)));
}
var import_rxjs5;
var init_first = __esm({
  "../../node_modules/@polkadot/api-derive/util/first.js"() {
    import_rxjs5 = __toESM(require_cjs(), 1);
    init_rpc_core();
  }
});

// ../../node_modules/@polkadot/api-derive/util/lazy.js
function lazyDeriveSection(result, section2, getKeys, creator) {
  lazyMethod(result, section2, () => lazyMethods({}, getKeys(section2), (method) => creator(section2, method)));
}
var init_lazy3 = __esm({
  "../../node_modules/@polkadot/api-derive/util/lazy.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/api-derive/util/index.js
var init_util10 = __esm({
  "../../node_modules/@polkadot/api-derive/util/index.js"() {
    init_rpc_core();
    init_approvalFlagsToBools();
    init_blockNumber();
    init_cache();
    init_cacheImpl();
    init_first();
    init_lazy3();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/accountId.js
function accountId(instanceId, api) {
  return memo(instanceId, (address) => {
    const decoded = isU8a(address) ? address : decodeAddress((address || "").toString());
    if (decoded.length > 8) {
      return (0, import_rxjs6.of)(api.registry.createType(decoded.length === 20 ? "AccountId20" : "AccountId", decoded));
    }
    const accountIndex = api.registry.createType("AccountIndex", decoded);
    return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0, import_rxjs6.map)((a) => assertReturn(a, "Unable to retrieve accountId")));
  });
}
var import_rxjs6;
var init_accountId = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/accountId.js"() {
    import_rxjs6 = __toESM(require_cjs(), 1);
    init_util();
    init_util_crypto();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/flags.js
function parseFlags(address, [electionsMembers, councilMembers, technicalCommitteeMembers, societyMembers, sudoKey]) {
  const addrStr = address?.toString();
  const isIncluded = (id) => id.toString() === addrStr;
  return {
    isCouncil: (electionsMembers?.map((r2) => Array.isArray(r2) ? r2[0] : r2.who) || councilMembers || []).some(isIncluded),
    isSociety: (societyMembers || []).some(isIncluded),
    isSudo: sudoKey?.toString() === addrStr,
    isTechCommittee: (technicalCommitteeMembers || []).some(isIncluded)
  };
}
function _flags(instanceId, api) {
  return memo(instanceId, () => {
    const results = [void 0, [], [], [], void 0];
    const calls = [
      (api.query.elections || api.query["phragmenElection"] || api.query["electionsPhragmen"])?.members,
      api.query.council?.members,
      api.query.technicalCommittee?.members,
      api.query.society?.members,
      api.query.sudo?.key
    ];
    const filtered = calls.filter((c) => c);
    if (!filtered.length) {
      return (0, import_rxjs7.of)(results);
    }
    return api.queryMulti(filtered).pipe((0, import_rxjs7.map)((values) => {
      let resultIndex = -1;
      for (let i2 = 0, count = calls.length; i2 < count; i2++) {
        if (isFunction(calls[i2])) {
          results[i2] = values[++resultIndex];
        }
      }
      return results;
    }));
  });
}
function flags(instanceId, api) {
  return memo(instanceId, (address) => api.derive.accounts._flags().pipe((0, import_rxjs7.map)((r2) => parseFlags(address, r2))));
}
var import_rxjs7;
var init_flags = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/flags.js"() {
    import_rxjs7 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/idAndIndex.js
function idAndIndex(instanceId, api) {
  return memo(instanceId, (address) => {
    try {
      const decoded = isU8a(address) ? address : decodeAddress((address || "").toString());
      if (decoded.length > 8) {
        const accountId2 = api.registry.createType(decoded.length === 20 ? "AccountId20" : "AccountId", decoded);
        return api.derive.accounts.idToIndex(accountId2).pipe((0, import_rxjs8.map)((accountIndex2) => [accountId2, accountIndex2]));
      }
      const accountIndex = api.registry.createType("AccountIndex", decoded);
      return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0, import_rxjs8.map)((accountId2) => [accountId2, accountIndex]));
    } catch {
      return (0, import_rxjs8.of)([void 0, void 0]);
    }
  });
}
var import_rxjs8;
var init_idAndIndex = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/idAndIndex.js"() {
    import_rxjs8 = __toESM(require_cjs(), 1);
    init_util();
    init_util_crypto();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/identity.js
function dataAsString(data) {
  if (!data) {
    return data;
  }
  return data.isRaw ? u8aToString(data.asRaw.toU8a(true)) : data.isNone ? void 0 : data.toHex();
}
function extractOther(additional) {
  return additional.reduce((other, [_key, _value]) => {
    const key = dataAsString(_key);
    const value = dataAsString(_value);
    if (key && value) {
      other[key] = value;
    }
    return other;
  }, {});
}
function identityCompat(identityOfOpt) {
  const identity3 = identityOfOpt.unwrap();
  return Array.isArray(identity3) ? identity3[0] : identity3;
}
function extractIdentity(identityOfOpt, superOf) {
  if (!identityOfOpt?.isSome) {
    return { judgements: [] };
  }
  const { info: info6, judgements } = identityCompat(identityOfOpt);
  const topDisplay = dataAsString(info6.display);
  return {
    discord: dataAsString(info6.discord),
    display: superOf && dataAsString(superOf[1]) || topDisplay,
    displayParent: superOf && topDisplay,
    email: dataAsString(info6.email),
    github: dataAsString(info6.github),
    image: dataAsString(info6.image),
    judgements,
    legal: dataAsString(info6.legal),
    matrix: dataAsString(info6.matrix),
    other: info6.additional ? extractOther(info6.additional) : {},
    parent: superOf?.[0],
    pgp: info6.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),
    riot: dataAsString(info6.riot),
    twitter: dataAsString(info6.twitter),
    web: dataAsString(info6.web)
  };
}
function getParent(api, identityOfOpt, superOfOpt) {
  if (identityOfOpt?.isSome) {
    return (0, import_rxjs9.of)([identityOfOpt, void 0]);
  } else if (superOfOpt?.isSome) {
    const superOf = superOfOpt.unwrap();
    return (0, import_rxjs9.combineLatest)([
      api.derive.accounts._identity(superOf[0]).pipe((0, import_rxjs9.map)(([info6]) => info6)),
      (0, import_rxjs9.of)(superOf)
    ]);
  }
  return (0, import_rxjs9.of)([void 0, void 0]);
}
function _identity(instanceId, api) {
  return memo(instanceId, (accountId2) => accountId2 && api.query.identity?.identityOf ? (0, import_rxjs9.combineLatest)([
    api.query.identity.identityOf(accountId2),
    api.query.identity.superOf(accountId2)
  ]) : (0, import_rxjs9.of)([void 0, void 0]));
}
function identity2(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.accounts._identity(accountId2).pipe((0, import_rxjs9.switchMap)(([identityOfOpt, superOfOpt]) => getParent(api, identityOfOpt, superOfOpt)), (0, import_rxjs9.map)(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf))));
}
function hasIdentityMulti(instanceId, api) {
  return memo(instanceId, (accountIds) => api.query.identity?.identityOf ? (0, import_rxjs9.combineLatest)([
    api.query.identity.identityOf.multi(accountIds),
    api.query.identity.superOf.multi(accountIds)
  ]).pipe((0, import_rxjs9.map)(([identities, supers]) => identities.map((identityOfOpt, index) => {
    const superOfOpt = supers[index];
    const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : void 0;
    let display;
    if (identityOfOpt && identityOfOpt.isSome) {
      const value = dataAsString(identityCompat(identityOfOpt).info.display);
      if (value && !isHex(value)) {
        display = value;
      }
    }
    return { display, hasIdentity: !!(display || parentId), parentId };
  }))) : (0, import_rxjs9.of)(accountIds.map(() => ({ hasIdentity: false }))));
}
var import_rxjs9, UNDEF_HEX, hasIdentity;
var init_identity = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/identity.js"() {
    import_rxjs9 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    UNDEF_HEX = { toHex: () => void 0 };
    hasIdentity = /* @__PURE__ */ firstMemo((api, accountId2) => api.derive.accounts.hasIdentityMulti([accountId2]));
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/idToIndex.js
function idToIndex(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.accounts.indexes().pipe((0, import_rxjs10.map)((indexes3) => indexes3[accountId2.toString()])));
}
var import_rxjs10;
var init_idToIndex = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/idToIndex.js"() {
    import_rxjs10 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/indexes.js
function queryAccounts(api) {
  return api.query.indices.accounts.entries().pipe((0, import_rxjs11.map)((entries) => entries.reduce((indexes3, [key, idOpt]) => {
    if (idOpt.isSome) {
      indexes3[idOpt.unwrap()[0].toString()] = api.registry.createType("AccountIndex", key.args[0]);
    }
    return indexes3;
  }, {})));
}
function indexes(instanceId, api) {
  return memo(instanceId, () => indicesCache ? (0, import_rxjs11.of)(indicesCache) : (api.query.indices ? queryAccounts(api).pipe((0, import_rxjs11.startWith)({})) : (0, import_rxjs11.of)({})).pipe((0, import_rxjs11.map)((indices) => {
    indicesCache = indices;
    return indices;
  })));
}
var import_rxjs11, indicesCache;
var init_indexes = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/indexes.js"() {
    import_rxjs11 = __toESM(require_cjs(), 1);
    init_util10();
    indicesCache = null;
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/indexToId.js
function indexToId(instanceId, api) {
  return memo(instanceId, (accountIndex) => api.query.indices ? api.query.indices.accounts(accountIndex).pipe((0, import_rxjs12.map)((optResult) => optResult.unwrapOr([])[0])) : (0, import_rxjs12.of)(void 0));
}
var import_rxjs12;
var init_indexToId = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/indexToId.js"() {
    import_rxjs12 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/info.js
function retrieveNick(api, accountId2) {
  return (accountId2 && api.query["nicks"]?.["nameOf"] ? api.query["nicks"]["nameOf"](accountId2) : (0, import_rxjs13.of)(void 0)).pipe((0, import_rxjs13.map)((nameOf) => nameOf?.isSome ? u8aToString(nameOf.unwrap()[0]).substring(0, api.consts["nicks"]["maxLength"].toNumber()) : void 0));
}
function info(instanceId, api) {
  return memo(instanceId, (address) => api.derive.accounts.idAndIndex(address).pipe((0, import_rxjs13.switchMap)(([accountId2, accountIndex]) => (0, import_rxjs13.combineLatest)([
    (0, import_rxjs13.of)({ accountId: accountId2, accountIndex }),
    api.derive.accounts.identity(accountId2),
    retrieveNick(api, accountId2)
  ])), (0, import_rxjs13.map)(([{ accountId: accountId2, accountIndex }, identity3, nickname]) => ({
    accountId: accountId2,
    accountIndex,
    identity: identity3,
    nickname
  }))));
}
var import_rxjs13;
var init_info = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/info.js"() {
    import_rxjs13 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/accounts/index.js
var accounts_exports = {};
__export(accounts_exports, {
  _flags: () => _flags,
  _identity: () => _identity,
  accountId: () => accountId,
  flags: () => flags,
  hasIdentity: () => hasIdentity,
  hasIdentityMulti: () => hasIdentityMulti,
  idAndIndex: () => idAndIndex,
  idToIndex: () => idToIndex,
  identity: () => identity2,
  indexToId: () => indexToId,
  indexes: () => indexes,
  info: () => info
});
var init_accounts = __esm({
  "../../node_modules/@polkadot/api-derive/accounts/index.js"() {
    init_accountId();
    init_flags();
    init_idAndIndex();
    init_identity();
    init_idToIndex();
    init_indexes();
    init_indexToId();
    init_info();
  }
});

// ../../node_modules/@polkadot/api-derive/collective/helpers.js
function getInstance(api, section2) {
  const instances = api.registry.getModuleInstances(api.runtimeVersion.specName, section2);
  const name = instances?.length ? instances[0] : section2;
  return api.query[name];
}
function withSection(section2, fn) {
  return (instanceId, api) => memo(instanceId, fn(getInstance(api, section2), api, instanceId));
}
function callMethod(method, empty2) {
  return (section2) => withSection(section2, (query2) => () => isFunction(query2?.[method]) ? query2[method]() : (0, import_rxjs14.of)(empty2));
}
var import_rxjs14;
var init_helpers5 = __esm({
  "../../node_modules/@polkadot/api-derive/collective/helpers.js"() {
    import_rxjs14 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/collective/members.js
var members;
var init_members = __esm({
  "../../node_modules/@polkadot/api-derive/collective/members.js"() {
    init_helpers5();
    members = /* @__PURE__ */ callMethod("members", []);
  }
});

// ../../node_modules/@polkadot/api-derive/collective/prime.js
function prime(section2) {
  return withSection(section2, (query2) => () => isFunction(query2?.prime) ? query2.prime().pipe((0, import_rxjs15.map)((o) => o.unwrapOr(null))) : (0, import_rxjs15.of)(null));
}
var import_rxjs15;
var init_prime = __esm({
  "../../node_modules/@polkadot/api-derive/collective/prime.js"() {
    import_rxjs15 = __toESM(require_cjs(), 1);
    init_util();
    init_helpers5();
  }
});

// ../../node_modules/@polkadot/api-derive/collective/proposals.js
function parse(api, [hashes, proposals8, votes2]) {
  return proposals8.map((o, index) => ({
    hash: api.registry.createType("Hash", hashes[index]),
    proposal: o && o.isSome ? o.unwrap() : null,
    votes: votes2[index].unwrapOr(null)
  }));
}
function _proposalsFrom(api, query2, hashes) {
  return (isFunction(query2?.proposals) && hashes.length ? (0, import_rxjs16.combineLatest)([
    (0, import_rxjs16.of)(hashes),
    // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),
    // however we have had cases on Edgeware where the indices have moved around after an
    // upgrade, which results in invalid on-chain data
    query2.proposalOf.multi(hashes).pipe((0, import_rxjs16.catchError)(() => (0, import_rxjs16.of)(hashes.map(() => null)))),
    query2.voting.multi(hashes)
  ]) : (0, import_rxjs16.of)([[], [], []])).pipe((0, import_rxjs16.map)((r2) => parse(api, r2)));
}
function hasProposals(section2) {
  return withSection(section2, (query2) => () => (0, import_rxjs16.of)(isFunction(query2?.proposals)));
}
function proposals(section2) {
  return withSection(section2, (query2, api) => () => api.derive[section2].proposalHashes().pipe((0, import_rxjs16.switchMap)((all3) => _proposalsFrom(api, query2, all3))));
}
function proposal(section2) {
  return withSection(section2, (query2, api) => (hash) => isFunction(query2?.proposals) ? firstObservable(_proposalsFrom(api, query2, [hash])) : (0, import_rxjs16.of)(null));
}
var import_rxjs16, proposalCount, proposalHashes;
var init_proposals = __esm({
  "../../node_modules/@polkadot/api-derive/collective/proposals.js"() {
    import_rxjs16 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_helpers5();
    proposalCount = /* @__PURE__ */ callMethod("proposalCount", null);
    proposalHashes = /* @__PURE__ */ callMethod("proposals", []);
  }
});

// ../../node_modules/@polkadot/api-derive/collective/index.js
var init_collective = __esm({
  "../../node_modules/@polkadot/api-derive/collective/index.js"() {
    init_members();
    init_prime();
    init_proposals();
  }
});

// ../../node_modules/@polkadot/api-derive/alliance/index.js
var alliance_exports = {};
__export(alliance_exports, {
  hasProposals: () => hasProposals2,
  members: () => members2,
  prime: () => prime2,
  proposal: () => proposal2,
  proposalCount: () => proposalCount2,
  proposalHashes: () => proposalHashes2,
  proposals: () => proposals2
});
var members2, hasProposals2, proposal2, proposalCount2, proposalHashes2, proposals2, prime2;
var init_alliance = __esm({
  "../../node_modules/@polkadot/api-derive/alliance/index.js"() {
    init_collective();
    members2 = /* @__PURE__ */ members("allianceMotion");
    hasProposals2 = /* @__PURE__ */ hasProposals("allianceMotion");
    proposal2 = /* @__PURE__ */ proposal("allianceMotion");
    proposalCount2 = /* @__PURE__ */ proposalCount("allianceMotion");
    proposalHashes2 = /* @__PURE__ */ proposalHashes("allianceMotion");
    proposals2 = /* @__PURE__ */ proposals("allianceMotion");
    prime2 = /* @__PURE__ */ prime("allianceMotion");
  }
});

// ../../node_modules/@polkadot/api-derive/bagsList/util.js
function getQueryInterface(api) {
  return (
    // latest substrate & polkadot
    api.query.voterList || // previous substrate
    api.query["voterBagsList"] || api.query["bagsList"]
  );
}
var init_util11 = __esm({
  "../../node_modules/@polkadot/api-derive/bagsList/util.js"() {
  }
});

// ../../node_modules/@polkadot/api-derive/bagsList/get.js
function orderBags(ids, bags) {
  const sorted = ids.map((id, index) => ({
    bag: bags[index].unwrapOr(null),
    id,
    key: id.toString()
  })).sort((a, b) => b.id.cmp(a.id));
  const max2 = sorted.length - 1;
  return sorted.map((entry, index) => objectSpread(entry, {
    bagLower: index === max2 ? BN_ZERO : sorted[index + 1].id,
    bagUpper: entry.id,
    index
  }));
}
function _getIds(instanceId, api) {
  const query2 = getQueryInterface(api);
  return memo(instanceId, (_ids) => {
    const ids = _ids.map((id) => bnToBn(id));
    return ids.length ? query2.listBags.multi(ids).pipe((0, import_rxjs17.map)((bags) => orderBags(ids, bags))) : (0, import_rxjs17.of)([]);
  });
}
function all(instanceId, api) {
  const query2 = getQueryInterface(api);
  return memo(instanceId, () => query2.listBags.keys().pipe((0, import_rxjs17.switchMap)((keys2) => api.derive.bagsList._getIds(keys2.map(({ args: [id] }) => id))), (0, import_rxjs17.map)((list) => list.filter(({ bag }) => bag))));
}
function get(instanceId, api) {
  return memo(instanceId, (id) => api.derive.bagsList._getIds([bnToBn(id)]).pipe((0, import_rxjs17.map)((bags) => bags[0])));
}
var import_rxjs17;
var init_get = __esm({
  "../../node_modules/@polkadot/api-derive/bagsList/get.js"() {
    import_rxjs17 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util11();
  }
});

// ../../node_modules/@polkadot/api-derive/bagsList/getExpanded.js
function expand(instanceId, api) {
  return memo(instanceId, (bag) => api.derive.bagsList.listNodes(bag.bag).pipe((0, import_rxjs18.map)((nodes) => objectSpread({ nodes }, bag))));
}
function getExpanded(instanceId, api) {
  return memo(instanceId, (id) => api.derive.bagsList.get(id).pipe((0, import_rxjs18.switchMap)((bag) => api.derive.bagsList.expand(bag))));
}
var import_rxjs18;
var init_getExpanded = __esm({
  "../../node_modules/@polkadot/api-derive/bagsList/getExpanded.js"() {
    import_rxjs18 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/bagsList/listNodes.js
function traverseLinks(api, head) {
  const subject = new import_rxjs19.BehaviorSubject(head);
  const query2 = getQueryInterface(api);
  return subject.pipe(
    (0, import_rxjs19.switchMap)((account3) => query2.listNodes(account3)),
    (0, import_rxjs19.tap)((node) => {
      nextTick(() => {
        node.isSome && node.value.next.isSome ? subject.next(node.unwrap().next.unwrap()) : subject.complete();
      });
    }),
    (0, import_rxjs19.toArray)(),
    // toArray since we want to startSubject to be completed
    (0, import_rxjs19.map)((all3) => all3.map((o) => o.unwrap()))
  );
}
function listNodes(instanceId, api) {
  return memo(instanceId, (bag) => bag && bag.head.isSome ? traverseLinks(api, bag.head.unwrap()) : (0, import_rxjs19.of)([]));
}
var import_rxjs19;
var init_listNodes = __esm({
  "../../node_modules/@polkadot/api-derive/bagsList/listNodes.js"() {
    import_rxjs19 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util11();
  }
});

// ../../node_modules/@polkadot/api-derive/bagsList/index.js
var bagsList_exports = {};
__export(bagsList_exports, {
  _getIds: () => _getIds,
  all: () => all,
  expand: () => expand,
  get: () => get,
  getExpanded: () => getExpanded,
  listNodes: () => listNodes
});
var init_bagsList = __esm({
  "../../node_modules/@polkadot/api-derive/bagsList/index.js"() {
    init_get();
    init_getExpanded();
    init_listNodes();
  }
});

// ../../node_modules/@polkadot/api-derive/balances/all.js
function calcLocked(api, bestNumber2, locks2) {
  let lockedBalance = api.registry.createType("Balance");
  let lockedBreakdown = [];
  let vestingLocked = api.registry.createType("Balance");
  let allLocked = false;
  if (Array.isArray(locks2)) {
    lockedBreakdown = locks2.filter(({ until }) => !until || bestNumber2 && until.gt(bestNumber2));
    allLocked = lockedBreakdown.some(({ amount }) => amount && amount.isMax());
    vestingLocked = api.registry.createType("Balance", lockedBreakdown.filter(({ id }) => id.eq(VESTING_ID)).reduce((result, { amount }) => result.iadd(amount), new import_bn.default(0)));
    const notAll = lockedBreakdown.filter(({ amount }) => amount && !amount.isMax());
    if (notAll.length) {
      lockedBalance = api.registry.createType("Balance", bnMax(...notAll.map(({ amount }) => amount)));
    }
  }
  return { allLocked, lockedBalance, lockedBreakdown, vestingLocked };
}
function calcShared(api, bestNumber2, data, locks2) {
  const { allLocked, lockedBalance, lockedBreakdown, vestingLocked } = calcLocked(api, bestNumber2, locks2);
  let transferable = null;
  if (data?.frameSystemAccountInfo?.frozen) {
    const { frameSystemAccountInfo, freeBalance, reservedBalance } = data;
    const noFrozenReserved = frameSystemAccountInfo.frozen.isZero() && reservedBalance.isZero();
    const ED = api.consts.balances.existentialDeposit;
    const maybeED = noFrozenReserved ? new import_bn.default(0) : ED;
    const frozenReserveDif = frameSystemAccountInfo.frozen.sub(reservedBalance);
    transferable = api.registry.createType("Balance", allLocked ? 0 : freeBalance.sub(bnMax(maybeED, frozenReserveDif)));
  }
  return objectSpread({}, data, {
    availableBalance: api.registry.createType("Balance", allLocked ? 0 : bnMax(new import_bn.default(0), data?.freeBalance ? data.freeBalance.sub(lockedBalance) : new import_bn.default(0))),
    lockedBalance,
    lockedBreakdown,
    transferable,
    vestingLocked
  });
}
function calcVesting(bestNumber2, shared, _vesting) {
  const vesting = _vesting || [];
  const isVesting = !shared.vestingLocked.isZero();
  const vestedBalances = vesting.map(({ locked, perBlock, startingBlock }) => bestNumber2.gt(startingBlock) ? bnMin(locked, perBlock.mul(bestNumber2.sub(startingBlock))) : BN_ZERO);
  const vestedBalance = vestedBalances.reduce((all3, value) => all3.iadd(value), new import_bn.default(0));
  const vestingTotal = vesting.reduce((all3, { locked }) => all3.iadd(locked), new import_bn.default(0));
  return {
    isVesting,
    vestedBalance,
    vestedClaimable: isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : BN_ZERO,
    vesting: vesting.map(({ locked, perBlock, startingBlock }, index) => ({
      endBlock: locked.div(perBlock).iadd(startingBlock),
      locked,
      perBlock,
      startingBlock,
      vested: vestedBalances[index]
    })).filter(({ locked }) => !locked.isZero()),
    vestingTotal
  };
}
function calcBalances(api, result) {
  const [data, [vesting, allLocks, namedReserves], bestNumber2] = result;
  const shared = calcShared(api, bestNumber2, data, allLocks[0]);
  return objectSpread(shared, calcVesting(bestNumber2, shared, vesting), {
    accountId: data.accountId,
    accountNonce: data.accountNonce,
    additional: allLocks.slice(1).map((l15, index) => calcShared(api, bestNumber2, data.additional[index], l15)),
    namedReserves
  });
}
function queryOld(api, accountId2) {
  return (0, import_rxjs20.combineLatest)([
    api.query.balances.locks(accountId2),
    api.query.balances["vesting"](accountId2)
  ]).pipe((0, import_rxjs20.map)(([locks2, optVesting]) => {
    let vestingNew = null;
    if (optVesting.isSome) {
      const { offset: locked, perBlock, startingBlock } = optVesting.unwrap();
      vestingNew = api.registry.createType("VestingInfo", { locked, perBlock, startingBlock });
    }
    return [
      vestingNew ? [vestingNew] : null,
      [locks2],
      []
    ];
  }));
}
function createCalls(calls) {
  return [
    calls.map((c) => !c),
    calls.filter(isNonNullable)
  ];
}
function queryCurrent(api, accountId2, balanceInstances = ["balances"]) {
  const [lockEmpty, lockQueries] = createCalls(balanceInstances.map((m2) => api.derive[m2]?.customLocks || api.query[m2]?.locks));
  const [reserveEmpty, reserveQueries] = createCalls(balanceInstances.map((m2) => api.query[m2]?.reserves));
  return (0, import_rxjs20.combineLatest)([
    api.query.vesting?.vesting ? api.query.vesting.vesting(accountId2) : (0, import_rxjs20.of)(api.registry.createType("Option<VestingInfo>")),
    lockQueries.length ? (0, import_rxjs20.combineLatest)(lockQueries.map((c) => c(accountId2))) : (0, import_rxjs20.of)([]),
    reserveQueries.length ? (0, import_rxjs20.combineLatest)(reserveQueries.map((c) => c(accountId2))) : (0, import_rxjs20.of)([])
  ]).pipe((0, import_rxjs20.map)(([opt, locks2, reserves]) => {
    let offsetLock = -1;
    let offsetReserve = -1;
    const vesting = opt.unwrapOr(null);
    return [
      vesting ? Array.isArray(vesting) ? vesting : [vesting] : null,
      lockEmpty.map((e2) => e2 ? api.registry.createType("Vec<BalanceLock>") : locks2[++offsetLock]),
      reserveEmpty.map((e2) => e2 ? api.registry.createType("Vec<PalletBalancesReserveData>") : reserves[++offsetReserve])
    ];
  }));
}
function all2(instanceId, api) {
  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, "balances");
  return memo(instanceId, (address) => (0, import_rxjs20.combineLatest)([
    api.derive.balances.account(address),
    isFunction(api.query.system?.account) || isFunction(api.query.balances?.account) ? queryCurrent(api, address, balanceInstances) : queryOld(api, address)
  ]).pipe((0, import_rxjs20.switchMap)(([account3, locks2]) => (0, import_rxjs20.combineLatest)([
    (0, import_rxjs20.of)(account3),
    (0, import_rxjs20.of)(locks2),
    api.derive.chain.bestNumber()
  ])), (0, import_rxjs20.map)((result) => calcBalances(api, result))));
}
var import_rxjs20, VESTING_ID, isNonNullable;
var init_all = __esm({
  "../../node_modules/@polkadot/api-derive/balances/all.js"() {
    import_rxjs20 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    VESTING_ID = "0x76657374696e6720";
    isNonNullable = (nullable) => !!nullable;
  }
});

// ../../node_modules/@polkadot/api-derive/balances/account.js
function zeroBalance(api) {
  return api.registry.createType("Balance");
}
function getBalance(api, [freeBalance, reservedBalance, frozenFeeOrFrozen, frozenMiscOrFlags], accType) {
  const votingBalance2 = api.registry.createType("Balance", freeBalance.toBn());
  if (accType.isFrameAccountData) {
    return {
      frameSystemAccountInfo: {
        flags: frozenMiscOrFlags,
        frozen: frozenFeeOrFrozen
      },
      freeBalance,
      frozenFee: api.registry.createType("Balance", 0),
      frozenMisc: api.registry.createType("Balance", 0),
      reservedBalance,
      votingBalance: votingBalance2
    };
  }
  return {
    freeBalance,
    frozenFee: frozenFeeOrFrozen,
    frozenMisc: frozenMiscOrFlags,
    reservedBalance,
    votingBalance: votingBalance2
  };
}
function calcBalances2(api, [accountId2, [accountNonce, [primary, ...additional], accType]]) {
  return objectSpread({
    accountId: accountId2,
    accountNonce,
    additional: additional.map((b) => getBalance(api, b, accType))
  }, getBalance(api, primary, accType));
}
function queryBalancesFree(api, accountId2) {
  return (0, import_rxjs21.combineLatest)([
    api.query.balances["freeBalance"](accountId2),
    api.query.balances["reservedBalance"](accountId2),
    api.query.system["accountNonce"](accountId2)
  ]).pipe((0, import_rxjs21.map)(([freeBalance, reservedBalance, accountNonce]) => [
    accountNonce,
    [[freeBalance, reservedBalance, zeroBalance(api), zeroBalance(api)]],
    { isFrameAccountData: false }
  ]));
}
function queryNonceOnly(api, accountId2) {
  const fill = (nonce) => [
    nonce,
    [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]],
    { isFrameAccountData: false }
  ];
  return isFunction(api.query.system.account) ? api.query.system.account(accountId2).pipe((0, import_rxjs21.map)(({ nonce }) => fill(nonce))) : isFunction(api.query.system["accountNonce"]) ? api.query.system["accountNonce"](accountId2).pipe((0, import_rxjs21.map)((nonce) => fill(nonce))) : (0, import_rxjs21.of)(fill(api.registry.createType("Index")));
}
function queryBalancesAccount(api, accountId2, modules = ["balances"]) {
  const balances = modules.map((m2) => api.derive[m2]?.customAccount || api.query[m2]?.account).filter((q) => isFunction(q));
  const extract = (nonce, data) => [
    nonce,
    data.map(({ feeFrozen, free, miscFrozen, reserved }) => [free, reserved, feeFrozen, miscFrozen]),
    { isFrameAccountData: false }
  ];
  return balances.length ? isFunction(api.query.system.account) ? (0, import_rxjs21.combineLatest)([
    api.query.system.account(accountId2),
    ...balances.map((c) => c(accountId2))
  ]).pipe((0, import_rxjs21.map)(([{ nonce }, ...balances2]) => extract(nonce, balances2))) : (0, import_rxjs21.combineLatest)([
    api.query.system["accountNonce"](accountId2),
    ...balances.map((c) => c(accountId2))
  ]).pipe((0, import_rxjs21.map)(([nonce, ...balances2]) => extract(nonce, balances2))) : queryNonceOnly(api, accountId2);
}
function querySystemAccount(api, accountId2) {
  return api.query.system.account(accountId2).pipe((0, import_rxjs21.map)((infoOrTuple) => {
    const data = infoOrTuple.nonce ? infoOrTuple.data : infoOrTuple[1];
    const nonce = infoOrTuple.nonce || infoOrTuple[0];
    if (!data || data.isEmpty) {
      return [
        nonce,
        [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]],
        { isFrameAccountData: false }
      ];
    }
    const isFrameType = !!infoOrTuple.data.frozen;
    if (isFrameType) {
      const { flags: flags2, free, frozen, reserved } = data;
      return [
        nonce,
        [[free, reserved, frozen, flags2]],
        { isFrameAccountData: true }
      ];
    } else {
      const { feeFrozen, free, miscFrozen, reserved } = data;
      return [
        nonce,
        [[free, reserved, feeFrozen, miscFrozen]],
        { isFrameAccountData: false }
      ];
    }
  }));
}
function account(instanceId, api) {
  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, "balances");
  const nonDefaultBalances = balanceInstances && balanceInstances[0] !== "balances";
  return memo(instanceId, (address) => api.derive.accounts.accountId(address).pipe((0, import_rxjs21.switchMap)((accountId2) => accountId2 ? (0, import_rxjs21.combineLatest)([
    (0, import_rxjs21.of)(accountId2),
    nonDefaultBalances ? queryBalancesAccount(api, accountId2, balanceInstances) : isFunction(api.query.system?.account) ? querySystemAccount(api, accountId2) : isFunction(api.query.balances?.account) ? queryBalancesAccount(api, accountId2) : isFunction(api.query.balances?.["freeBalance"]) ? queryBalancesFree(api, accountId2) : queryNonceOnly(api, accountId2)
  ]) : (0, import_rxjs21.of)([api.registry.createType("AccountId"), [
    api.registry.createType("Index"),
    [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]],
    { isFrameAccountData: false }
  ]])), (0, import_rxjs21.map)((result) => calcBalances2(api, result))));
}
var import_rxjs21;
var init_account = __esm({
  "../../node_modules/@polkadot/api-derive/balances/account.js"() {
    import_rxjs21 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/balances/votingBalances.js
function votingBalances(instanceId, api) {
  return memo(instanceId, (addresses) => !addresses?.length ? (0, import_rxjs22.of)([]) : (0, import_rxjs22.combineLatest)(addresses.map((accountId2) => api.derive.balances.account(accountId2))));
}
var import_rxjs22;
var init_votingBalances = __esm({
  "../../node_modules/@polkadot/api-derive/balances/votingBalances.js"() {
    import_rxjs22 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/balances/index.js
var balances_exports = {};
__export(balances_exports, {
  account: () => account,
  all: () => all2,
  votingBalance: () => votingBalance,
  votingBalances: () => votingBalances
});
var votingBalance;
var init_balances = __esm({
  "../../node_modules/@polkadot/api-derive/balances/index.js"() {
    init_all();
    init_account();
    init_votingBalances();
    votingBalance = all2;
  }
});

// ../../node_modules/@polkadot/api-derive/bounties/helpers/filterBountyProposals.js
function filterBountiesProposals(api, allProposals) {
  const bountyTxBase = api.tx.bounties ? api.tx.bounties : api.tx.treasury;
  const bountyProposalCalls = [bountyTxBase.approveBounty, bountyTxBase.closeBounty, bountyTxBase.proposeCurator, bountyTxBase.unassignCurator];
  return allProposals.filter((proposal6) => bountyProposalCalls.find((bountyCall) => proposal6.proposal && bountyCall.is(proposal6.proposal)));
}
var init_filterBountyProposals = __esm({
  "../../node_modules/@polkadot/api-derive/bounties/helpers/filterBountyProposals.js"() {
  }
});

// ../../node_modules/@polkadot/api-derive/bounties/bounties.js
function parseResult([maybeBounties, maybeDescriptions, ids, bountyProposals]) {
  const bounties2 = [];
  maybeBounties.forEach((bounty, index) => {
    if (bounty.isSome) {
      bounties2.push({
        bounty: bounty.unwrap(),
        description: maybeDescriptions[index].unwrapOrDefault().toUtf8(),
        index: ids[index],
        proposals: bountyProposals.filter((bountyProposal) => bountyProposal.proposal && ids[index].eq(bountyProposal.proposal.args[0]))
      });
    }
  });
  return bounties2;
}
function bounties(instanceId, api) {
  const bountyBase = api.query.bounties || api.query.treasury;
  return memo(instanceId, () => bountyBase.bounties ? (0, import_rxjs23.combineLatest)([
    bountyBase.bountyCount(),
    api.query.council ? api.query.council.proposalCount() : (0, import_rxjs23.of)(0)
  ]).pipe((0, import_rxjs23.switchMap)(() => (0, import_rxjs23.combineLatest)([
    bountyBase.bounties.keys(),
    api.derive.council ? api.derive.council.proposals() : (0, import_rxjs23.of)([])
  ])), (0, import_rxjs23.switchMap)(([keys2, proposals8]) => {
    const ids = keys2.map(({ args: [id] }) => id);
    return (0, import_rxjs23.combineLatest)([
      bountyBase.bounties.multi(ids),
      bountyBase.bountyDescriptions.multi(ids),
      (0, import_rxjs23.of)(ids),
      (0, import_rxjs23.of)(filterBountiesProposals(api, proposals8))
    ]);
  }), (0, import_rxjs23.map)(parseResult)) : (0, import_rxjs23.of)(parseResult([[], [], [], []])));
}
var import_rxjs23;
var init_bounties = __esm({
  "../../node_modules/@polkadot/api-derive/bounties/bounties.js"() {
    import_rxjs23 = __toESM(require_cjs(), 1);
    init_util10();
    init_filterBountyProposals();
  }
});

// ../../node_modules/@polkadot/api-derive/bounties/index.js
var bounties_exports = {};
__export(bounties_exports, {
  bounties: () => bounties
});
var init_bounties2 = __esm({
  "../../node_modules/@polkadot/api-derive/bounties/index.js"() {
    init_bounties();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/util.js
function createBlockNumberDerive(fn) {
  return (instanceId, api) => memo(instanceId, () => fn(api).pipe((0, import_rxjs24.map)(unwrapBlockNumber)));
}
function getAuthorDetailsWithAt(header, queryAt) {
  const validators2 = queryAt.session?.validators ? queryAt.session.validators() : (0, import_rxjs24.of)(null);
  const { logs: [log] } = header.digest;
  const loggedAuthor = log && (log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1] || log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1]);
  if (loggedAuthor) {
    if (queryAt["authorMapping"]?.["mappingWithDeposit"]) {
      return (0, import_rxjs24.combineLatest)([
        (0, import_rxjs24.of)(header),
        validators2,
        queryAt["authorMapping"]["mappingWithDeposit"](loggedAuthor).pipe((0, import_rxjs24.map)((o) => o.unwrapOr({ account: null }).account))
      ]);
    }
    if (queryAt["parachainStaking"]?.["selectedCandidates"] && queryAt.session?.nextKeys) {
      const loggedHex = loggedAuthor.toHex();
      return (0, import_rxjs24.combineLatest)([
        (0, import_rxjs24.of)(header),
        validators2,
        queryAt["parachainStaking"]["selectedCandidates"]().pipe((0, import_rxjs24.mergeMap)((selectedCandidates) => (0, import_rxjs24.combineLatest)([
          (0, import_rxjs24.of)(selectedCandidates),
          queryAt.session.nextKeys.multi(selectedCandidates).pipe((0, import_rxjs24.map)((nextKeys) => nextKeys.findIndex((o) => o.unwrapOrDefault().nimbus.toHex() === loggedHex)))
        ])), (0, import_rxjs24.map)(([selectedCandidates, index]) => index === -1 ? null : selectedCandidates[index]))
      ]);
    }
  }
  return (0, import_rxjs24.combineLatest)([
    (0, import_rxjs24.of)(header),
    validators2,
    (0, import_rxjs24.of)(null)
  ]);
}
function getAuthorDetails(api, header, blockHash) {
  return api.queryAt(header.parentHash.isEmpty ? blockHash || header.hash : header.parentHash).pipe((0, import_rxjs24.switchMap)((queryAt) => getAuthorDetailsWithAt(header, queryAt)));
}
var import_rxjs24;
var init_util12 = __esm({
  "../../node_modules/@polkadot/api-derive/chain/util.js"() {
    import_rxjs24 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/bestNumber.js
var bestNumber;
var init_bestNumber = __esm({
  "../../node_modules/@polkadot/api-derive/chain/bestNumber.js"() {
    init_util12();
    bestNumber = /* @__PURE__ */ createBlockNumberDerive((api) => api.rpc.chain.subscribeNewHeads());
  }
});

// ../../node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js
var bestNumberFinalized;
var init_bestNumberFinalized = __esm({
  "../../node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js"() {
    init_util12();
    bestNumberFinalized = /* @__PURE__ */ createBlockNumberDerive((api) => api.rpc.chain.subscribeFinalizedHeads());
  }
});

// ../../node_modules/@polkadot/api-derive/chain/bestNumberLag.js
function bestNumberLag(instanceId, api) {
  return memo(instanceId, () => (0, import_rxjs25.combineLatest)([
    api.derive.chain.bestNumber(),
    api.derive.chain.bestNumberFinalized()
  ]).pipe((0, import_rxjs25.map)(([bestNumber2, bestNumberFinalized2]) => api.registry.createType("BlockNumber", bestNumber2.sub(bestNumberFinalized2)))));
}
var import_rxjs25;
var init_bestNumberLag = __esm({
  "../../node_modules/@polkadot/api-derive/chain/bestNumberLag.js"() {
    import_rxjs25 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/type/util.js
function extractAuthor(digest, sessionValidators) {
  const [citem] = digest.logs.filter((e2) => e2.isConsensus);
  const [pitem] = digest.logs.filter((e2) => e2.isPreRuntime);
  const [sitem] = digest.logs.filter((e2) => e2.isSeal);
  let accountId2;
  try {
    if (pitem) {
      const [engine, data] = pitem.asPreRuntime;
      accountId2 = engine.extractAuthor(data, sessionValidators);
    }
    if (!accountId2 && citem) {
      const [engine, data] = citem.asConsensus;
      accountId2 = engine.extractAuthor(data, sessionValidators);
    }
    if (!accountId2 && sitem) {
      const [engine, data] = sitem.asSeal;
      accountId2 = engine.extractAuthor(data, sessionValidators);
    }
  } catch {
  }
  return accountId2;
}
var init_util13 = __esm({
  "../../node_modules/@polkadot/api-derive/type/util.js"() {
  }
});

// ../../node_modules/@polkadot/api-derive/type/HeaderExtended.js
function createHeaderExtended(registry, header, validators2, author) {
  const HeaderBase = registry.createClass("Header");
  class Implementation extends HeaderBase {
    __internal__author;
    constructor(registry2, header2, validators3, author2) {
      super(registry2, header2);
      this.__internal__author = author2 || extractAuthor(this.digest, validators3 || []);
      this.createdAtHash = header2?.createdAtHash;
    }
    /**
     * @description Convenience method, returns the author for the block
     */
    get author() {
      return this.__internal__author;
    }
  }
  return new Implementation(registry, header, validators2, author);
}
var init_HeaderExtended = __esm({
  "../../node_modules/@polkadot/api-derive/type/HeaderExtended.js"() {
    init_util13();
  }
});

// ../../node_modules/@polkadot/api-derive/type/SignedBlockExtended.js
function mapExtrinsics(extrinsics, records) {
  return extrinsics.map((extrinsic, index) => {
    let dispatchError;
    let dispatchInfo;
    const events2 = records.filter(({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index)).map(({ event }) => {
      if (event.section === "system") {
        if (event.method === "ExtrinsicSuccess") {
          dispatchInfo = event.data[0];
        } else if (event.method === "ExtrinsicFailed") {
          dispatchError = event.data[0];
          dispatchInfo = event.data[1];
        }
      }
      return event;
    });
    return { dispatchError, dispatchInfo, events: events2, extrinsic };
  });
}
function createSignedBlockExtended(registry, block, events2, validators2, author) {
  const SignedBlockBase = registry.createClass("SignedBlock");
  class Implementation extends SignedBlockBase {
    __internal__author;
    __internal__events;
    __internal__extrinsics;
    constructor(registry2, block2, events3, validators3, author2) {
      super(registry2, block2);
      this.__internal__author = author2 || extractAuthor(this.block.header.digest, validators3 || []);
      this.__internal__events = events3 || [];
      this.__internal__extrinsics = mapExtrinsics(this.block.extrinsics, this.__internal__events);
      this.createdAtHash = block2?.createdAtHash;
    }
    /**
     * @description Convenience method, returns the author for the block
     */
    get author() {
      return this.__internal__author;
    }
    /**
     * @description Convenience method, returns the events associated with the block
     */
    get events() {
      return this.__internal__events;
    }
    /**
     * @description Returns the extrinsics and their events, mapped
     */
    get extrinsics() {
      return this.__internal__extrinsics;
    }
  }
  return new Implementation(registry, block, events2, validators2, author);
}
var init_SignedBlockExtended = __esm({
  "../../node_modules/@polkadot/api-derive/type/SignedBlockExtended.js"() {
    init_util13();
  }
});

// ../../node_modules/@polkadot/api-derive/type/index.js
var init_type2 = __esm({
  "../../node_modules/@polkadot/api-derive/type/index.js"() {
    init_HeaderExtended();
    init_SignedBlockExtended();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/getBlock.js
function getBlock(instanceId, api) {
  return memo(instanceId, (blockHash) => (0, import_rxjs26.combineLatest)([
    api.rpc.chain.getBlock(blockHash),
    api.queryAt(blockHash)
  ]).pipe((0, import_rxjs26.switchMap)(([signedBlock, queryAt]) => (0, import_rxjs26.combineLatest)([
    (0, import_rxjs26.of)(signedBlock),
    queryAt.system.events(),
    getAuthorDetails(api, signedBlock.block.header, blockHash)
  ])), (0, import_rxjs26.map)(([signedBlock, events2, [, validators2, author]]) => createSignedBlockExtended(events2.registry, signedBlock, events2, validators2, author))));
}
var import_rxjs26;
var init_getBlock = __esm({
  "../../node_modules/@polkadot/api-derive/chain/getBlock.js"() {
    import_rxjs26 = __toESM(require_cjs(), 1);
    init_type2();
    init_util10();
    init_util12();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/getBlockByNumber.js
function getBlockByNumber(instanceId, api) {
  return memo(instanceId, (blockNumber) => api.rpc.chain.getBlockHash(blockNumber).pipe((0, import_rxjs27.switchMap)((h2) => api.derive.chain.getBlock(h2))));
}
var import_rxjs27;
var init_getBlockByNumber = __esm({
  "../../node_modules/@polkadot/api-derive/chain/getBlockByNumber.js"() {
    import_rxjs27 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/getHeader.js
function getHeader(instanceId, api) {
  return memo(instanceId, (blockHash) => api.rpc.chain.getHeader(blockHash).pipe((0, import_rxjs28.switchMap)((header) => getAuthorDetails(api, header, blockHash)), (0, import_rxjs28.map)(([header, validators2, author]) => createHeaderExtended((validators2 || header).registry, header, validators2, author))));
}
var import_rxjs28;
var init_getHeader = __esm({
  "../../node_modules/@polkadot/api-derive/chain/getHeader.js"() {
    import_rxjs28 = __toESM(require_cjs(), 1);
    init_type2();
    init_util10();
    init_util12();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/subscribeFinalizedBlocks.js
function subscribeFinalizedBlocks(instanceId, api) {
  return memo(instanceId, () => api.derive.chain.subscribeFinalizedHeads().pipe((0, import_rxjs29.switchMap)((header) => api.derive.chain.getBlock(header.createdAtHash || header.hash))));
}
var import_rxjs29;
var init_subscribeFinalizedBlocks = __esm({
  "../../node_modules/@polkadot/api-derive/chain/subscribeFinalizedBlocks.js"() {
    import_rxjs29 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/subscribeFinalizedHeads.js
function _getHeaderRange(instanceId, api) {
  return memo(instanceId, (startHash, endHash, prev = []) => api.rpc.chain.getHeader(startHash).pipe((0, import_rxjs30.switchMap)((header) => header.parentHash.eq(endHash) ? (0, import_rxjs30.of)([header, ...prev]) : api.derive.chain._getHeaderRange(header.parentHash, endHash, [header, ...prev]))));
}
function subscribeFinalizedHeads(instanceId, api) {
  return memo(instanceId, () => {
    let prevHash = null;
    return api.rpc.chain.subscribeFinalizedHeads().pipe((0, import_rxjs30.switchMap)((header) => {
      const endHash = prevHash;
      const startHash = header.parentHash;
      prevHash = header.createdAtHash = header.hash;
      return endHash === null || startHash.eq(endHash) ? (0, import_rxjs30.of)(header) : api.derive.chain._getHeaderRange(startHash, endHash, [header]).pipe((0, import_rxjs30.switchMap)((headers) => (0, import_rxjs30.from)(headers)));
    }));
  });
}
var import_rxjs30;
var init_subscribeFinalizedHeads = __esm({
  "../../node_modules/@polkadot/api-derive/chain/subscribeFinalizedHeads.js"() {
    import_rxjs30 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/subscribeNewBlocks.js
function subscribeNewBlocks(instanceId, api) {
  return memo(instanceId, () => api.derive.chain.subscribeNewHeads().pipe((0, import_rxjs31.switchMap)((header) => api.derive.chain.getBlock(header.createdAtHash || header.hash))));
}
var import_rxjs31;
var init_subscribeNewBlocks = __esm({
  "../../node_modules/@polkadot/api-derive/chain/subscribeNewBlocks.js"() {
    import_rxjs31 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js
function subscribeNewHeads(instanceId, api) {
  return memo(instanceId, () => api.rpc.chain.subscribeNewHeads().pipe((0, import_rxjs32.switchMap)((header) => getAuthorDetails(api, header)), (0, import_rxjs32.map)(([header, validators2, author]) => {
    header.createdAtHash = header.hash;
    return createHeaderExtended(header.registry, header, validators2, author);
  })));
}
var import_rxjs32;
var init_subscribeNewHeads = __esm({
  "../../node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js"() {
    import_rxjs32 = __toESM(require_cjs(), 1);
    init_type2();
    init_util10();
    init_util12();
  }
});

// ../../node_modules/@polkadot/api-derive/chain/index.js
var chain_exports = {};
__export(chain_exports, {
  _getHeaderRange: () => _getHeaderRange,
  bestNumber: () => bestNumber,
  bestNumberFinalized: () => bestNumberFinalized,
  bestNumberLag: () => bestNumberLag,
  getBlock: () => getBlock,
  getBlockByNumber: () => getBlockByNumber,
  getHeader: () => getHeader,
  subscribeFinalizedBlocks: () => subscribeFinalizedBlocks,
  subscribeFinalizedHeads: () => subscribeFinalizedHeads,
  subscribeNewBlocks: () => subscribeNewBlocks,
  subscribeNewHeads: () => subscribeNewHeads
});
var init_chain = __esm({
  "../../node_modules/@polkadot/api-derive/chain/index.js"() {
    init_bestNumber();
    init_bestNumberFinalized();
    init_bestNumberLag();
    init_getBlock();
    init_getBlockByNumber();
    init_getHeader();
    init_subscribeFinalizedBlocks();
    init_subscribeFinalizedHeads();
    init_subscribeNewBlocks();
    init_subscribeNewHeads();
  }
});

// ../../node_modules/@polkadot/api-derive/contracts/fees.js
function queryConstants(api) {
  return (0, import_rxjs33.of)([
    // deprecated
    api.consts.contracts["callBaseFee"] || api.registry.createType("Balance"),
    api.consts.contracts["contractFee"] || api.registry.createType("Balance"),
    api.consts.contracts["creationFee"] || api.registry.createType("Balance"),
    api.consts.contracts["transactionBaseFee"] || api.registry.createType("Balance"),
    api.consts.contracts["transactionByteFee"] || api.registry.createType("Balance"),
    api.consts.contracts["transferFee"] || api.registry.createType("Balance"),
    // current
    api.consts.contracts["rentByteFee"] || api.registry.createType("Balance"),
    api.consts.contracts["rentDepositOffset"] || api.registry.createType("Balance"),
    api.consts.contracts["surchargeReward"] || api.registry.createType("Balance"),
    api.consts.contracts["tombstoneDeposit"] || api.registry.createType("Balance")
  ]);
}
function fees(instanceId, api) {
  return memo(instanceId, () => {
    return queryConstants(api).pipe((0, import_rxjs33.map)(([callBaseFee, contractFee, creationFee, transactionBaseFee, transactionByteFee, transferFee, rentByteFee, rentDepositOffset, surchargeReward, tombstoneDeposit]) => ({
      callBaseFee,
      contractFee,
      creationFee,
      rentByteFee,
      rentDepositOffset,
      surchargeReward,
      tombstoneDeposit,
      transactionBaseFee,
      transactionByteFee,
      transferFee
    })));
  });
}
var import_rxjs33;
var init_fees = __esm({
  "../../node_modules/@polkadot/api-derive/contracts/fees.js"() {
    import_rxjs33 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/contracts/index.js
var contracts_exports = {};
__export(contracts_exports, {
  fees: () => fees
});
var init_contracts = __esm({
  "../../node_modules/@polkadot/api-derive/contracts/index.js"() {
    init_fees();
  }
});

// ../../node_modules/@polkadot/api-derive/council/votes.js
function isVoter(value) {
  return !Array.isArray(value);
}
function retrieveStakeOf(elections) {
  return elections["stakeOf"].entries().pipe((0, import_rxjs34.map)((entries) => entries.map(([{ args: [accountId2] }, stake]) => [accountId2, stake])));
}
function retrieveVoteOf(elections) {
  return elections["votesOf"].entries().pipe((0, import_rxjs34.map)((entries) => entries.map(([{ args: [accountId2] }, votes2]) => [accountId2, votes2])));
}
function retrievePrev(api, elections) {
  return (0, import_rxjs34.combineLatest)([
    retrieveStakeOf(elections),
    retrieveVoteOf(elections)
  ]).pipe((0, import_rxjs34.map)(([stakes, votes2]) => {
    const result = [];
    votes2.forEach(([voter, votes3]) => {
      result.push([voter, { stake: api.registry.createType("Balance"), votes: votes3 }]);
    });
    stakes.forEach(([staker, stake]) => {
      const entry = result.find(([voter]) => voter.eq(staker));
      if (entry) {
        entry[1].stake = stake;
      } else {
        result.push([staker, { stake, votes: [] }]);
      }
    });
    return result;
  }));
}
function retrieveCurrent(elections) {
  return elections.voting.entries().pipe((0, import_rxjs34.map)((entries) => entries.map(([{ args: [accountId2] }, value]) => [
    accountId2,
    isVoter(value) ? { stake: value.stake, votes: value.votes } : { stake: value[0], votes: value[1] }
  ])));
}
function votes(instanceId, api) {
  const elections = api.query.elections || api.query["phragmenElection"] || api.query["electionsPhragmen"];
  return memo(instanceId, () => elections ? elections["stakeOf"] ? retrievePrev(api, elections) : retrieveCurrent(elections) : (0, import_rxjs34.of)([]));
}
var import_rxjs34;
var init_votes = __esm({
  "../../node_modules/@polkadot/api-derive/council/votes.js"() {
    import_rxjs34 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/council/votesOf.js
function votesOf(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.council.votes().pipe((0, import_rxjs35.map)((votes2) => (votes2.find(([from4]) => from4.eq(accountId2)) || [null, { stake: api.registry.createType("Balance"), votes: [] }])[1])));
}
var import_rxjs35;
var init_votesOf = __esm({
  "../../node_modules/@polkadot/api-derive/council/votesOf.js"() {
    import_rxjs35 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/council/index.js
var council_exports = {};
__export(council_exports, {
  hasProposals: () => hasProposals3,
  members: () => members3,
  prime: () => prime3,
  proposal: () => proposal3,
  proposalCount: () => proposalCount3,
  proposalHashes: () => proposalHashes3,
  proposals: () => proposals3,
  votes: () => votes,
  votesOf: () => votesOf
});
var members3, hasProposals3, proposal3, proposalCount3, proposalHashes3, proposals3, prime3;
var init_council = __esm({
  "../../node_modules/@polkadot/api-derive/council/index.js"() {
    init_collective();
    init_votes();
    init_votesOf();
    members3 = /* @__PURE__ */ members("council");
    hasProposals3 = /* @__PURE__ */ hasProposals("council");
    proposal3 = /* @__PURE__ */ proposal("council");
    proposalCount3 = /* @__PURE__ */ proposalCount("council");
    proposalHashes3 = /* @__PURE__ */ proposalHashes("council");
    proposals3 = /* @__PURE__ */ proposals("council");
    prime3 = /* @__PURE__ */ prime("council");
  }
});

// ../../node_modules/@polkadot/api-derive/crowdloan/childKey.js
function createChildKey(info6) {
  return u8aToHex(u8aConcat(":child_storage:default:", blake2AsU8a(u8aConcat("crowdloan", (info6.fundIndex || info6.trieIndex).toU8a()))));
}
function childKey(instanceId, api) {
  return memo(instanceId, (paraId) => api.query["crowdloan"]["funds"](paraId).pipe((0, import_rxjs36.map)((optInfo) => optInfo.isSome ? createChildKey(optInfo.unwrap()) : null)));
}
var import_rxjs36;
var init_childKey = __esm({
  "../../node_modules/@polkadot/api-derive/crowdloan/childKey.js"() {
    import_rxjs36 = __toESM(require_cjs(), 1);
    init_util();
    init_util_crypto();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/crowdloan/util.js
function extractContributed(paraId, events2) {
  const added = [];
  const removed = [];
  return events2.filter(({ event: { data: [, eventParaId], method, section: section2 } }) => section2 === "crowdloan" && ["Contributed", "Withdrew"].includes(method) && eventParaId.eq(paraId)).reduce((result, { event: { data: [accountId2], method } }) => {
    if (method === "Contributed") {
      result.added.push(accountId2.toHex());
    } else {
      result.removed.push(accountId2.toHex());
    }
    return result;
  }, { added, blockHash: events2.createdAtHash?.toHex() || "-", removed });
}
var init_util14 = __esm({
  "../../node_modules/@polkadot/api-derive/crowdloan/util.js"() {
  }
});

// ../../node_modules/@polkadot/api-derive/crowdloan/contributions.js
function _getUpdates(api, paraId) {
  let added = [];
  let removed = [];
  return api.query.system.events().pipe((0, import_rxjs37.switchMap)((events2) => {
    const changes = extractContributed(paraId, events2);
    if (changes.added.length || changes.removed.length) {
      added = added.concat(...changes.added);
      removed = removed.concat(...changes.removed);
      return (0, import_rxjs37.of)({ added, addedDelta: changes.added, blockHash: events2.createdAtHash?.toHex() || "-", removed, removedDelta: changes.removed });
    }
    return import_rxjs37.EMPTY;
  }), (0, import_rxjs37.startWith)({ added, addedDelta: [], blockHash: "-", removed, removedDelta: [] }));
}
function _eventTriggerAll(api, paraId) {
  return api.query.system.events().pipe((0, import_rxjs37.switchMap)((events2) => {
    const items = events2.filter(({ event: { data: [eventParaId], method, section: section2 } }) => section2 === "crowdloan" && ["AllRefunded", "Dissolved", "PartiallyRefunded"].includes(method) && eventParaId.eq(paraId));
    return items.length ? (0, import_rxjs37.of)(events2.createdAtHash?.toHex() || "-") : import_rxjs37.EMPTY;
  }), (0, import_rxjs37.startWith)("-"));
}
function _getKeysPaged(api, childKey2) {
  const subject = new import_rxjs37.BehaviorSubject(void 0);
  return subject.pipe(
    (0, import_rxjs37.switchMap)((startKey) => api.rpc.childstate.getKeysPaged(childKey2, "0x", PAGE_SIZE_K, startKey)),
    (0, import_rxjs37.tap)((keys2) => {
      nextTick(() => {
        keys2.length === PAGE_SIZE_K ? subject.next(keys2[PAGE_SIZE_K - 1].toHex()) : subject.complete();
      });
    }),
    (0, import_rxjs37.toArray)(),
    // toArray since we want to startSubject to be completed
    (0, import_rxjs37.map)((keyArr) => arrayFlatten(keyArr))
  );
}
function _getAll(api, paraId, childKey2) {
  return _eventTriggerAll(api, paraId).pipe((0, import_rxjs37.switchMap)(() => isFunction(api.rpc.childstate.getKeysPaged) ? _getKeysPaged(api, childKey2) : api.rpc.childstate.getKeys(childKey2, "0x")), (0, import_rxjs37.map)((keys2) => keys2.map((k) => k.toHex())));
}
function _contributions(api, paraId, childKey2) {
  return (0, import_rxjs37.combineLatest)([
    _getAll(api, paraId, childKey2),
    _getUpdates(api, paraId)
  ]).pipe((0, import_rxjs37.map)(([keys2, { added, blockHash, removed }]) => {
    const contributorsMap = {};
    keys2.forEach((k) => {
      contributorsMap[k] = true;
    });
    added.forEach((k) => {
      contributorsMap[k] = true;
    });
    removed.forEach((k) => {
      delete contributorsMap[k];
    });
    return {
      blockHash,
      contributorsHex: Object.keys(contributorsMap)
    };
  }));
}
function contributions(instanceId, api) {
  return memo(instanceId, (paraId) => api.derive.crowdloan.childKey(paraId).pipe((0, import_rxjs37.switchMap)((childKey2) => childKey2 ? _contributions(api, paraId, childKey2) : (0, import_rxjs37.of)({ blockHash: "-", contributorsHex: [] }))));
}
var import_rxjs37, PAGE_SIZE_K;
var init_contributions = __esm({
  "../../node_modules/@polkadot/api-derive/crowdloan/contributions.js"() {
    import_rxjs37 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util14();
    PAGE_SIZE_K = 1e3;
  }
});

// ../../node_modules/@polkadot/api-derive/crowdloan/ownContributions.js
function _getValues(api, childKey2, keys2) {
  return (0, import_rxjs38.combineLatest)(keys2.map((k) => api.rpc.childstate.getStorage(childKey2, k))).pipe((0, import_rxjs38.map)((values) => values.map((v) => api.registry.createType("Option<StorageData>", v)).map((o) => o.isSome ? api.registry.createType("Balance", o.unwrap()) : api.registry.createType("Balance")).reduce((all3, b, index) => objectSpread(all3, { [keys2[index]]: b }), {})));
}
function _watchOwnChanges(api, paraId, childkey, keys2) {
  return api.query.system.events().pipe((0, import_rxjs38.switchMap)((events2) => {
    const changes = extractContributed(paraId, events2);
    const filtered = keys2.filter((k) => changes.added.includes(k) || changes.removed.includes(k));
    return filtered.length ? _getValues(api, childkey, filtered) : import_rxjs38.EMPTY;
  }), (0, import_rxjs38.startWith)({}));
}
function _contributions2(api, paraId, childKey2, keys2) {
  return (0, import_rxjs38.combineLatest)([
    _getValues(api, childKey2, keys2),
    _watchOwnChanges(api, paraId, childKey2, keys2)
  ]).pipe((0, import_rxjs38.map)(([all3, latest2]) => objectSpread({}, all3, latest2)));
}
function ownContributions(instanceId, api) {
  return memo(instanceId, (paraId, keys2) => api.derive.crowdloan.childKey(paraId).pipe((0, import_rxjs38.switchMap)((childKey2) => childKey2 && keys2.length ? _contributions2(api, paraId, childKey2, keys2) : (0, import_rxjs38.of)({}))));
}
var import_rxjs38;
var init_ownContributions = __esm({
  "../../node_modules/@polkadot/api-derive/crowdloan/ownContributions.js"() {
    import_rxjs38 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util14();
  }
});

// ../../node_modules/@polkadot/api-derive/crowdloan/index.js
var crowdloan_exports = {};
__export(crowdloan_exports, {
  childKey: () => childKey,
  contributions: () => contributions,
  ownContributions: () => ownContributions
});
var init_crowdloan = __esm({
  "../../node_modules/@polkadot/api-derive/crowdloan/index.js"() {
    init_childKey();
    init_contributions();
    init_ownContributions();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/util.js
function isOldInfo(info6) {
  return !!info6.proposalHash;
}
function isCurrentStatus(status) {
  return !!status.tally;
}
function compareRationals(n1, d1, n2, d2) {
  while (true) {
    const q1 = n1.div(d1);
    const q2 = n2.div(d2);
    if (q1.lt(q2)) {
      return true;
    } else if (q2.lt(q1)) {
      return false;
    }
    const r1 = n1.mod(d1);
    const r2 = n2.mod(d2);
    if (r2.isZero()) {
      return false;
    } else if (r1.isZero()) {
      return true;
    }
    n1 = d2;
    n2 = d1;
    d1 = r2;
    d2 = r1;
  }
}
function calcPassingOther(threshold, sqrtElectorate2, { votedAye, votedNay, votedTotal }) {
  const sqrtVoters = bnSqrt(votedTotal);
  return sqrtVoters.isZero() ? false : threshold.isSuperMajorityApprove ? compareRationals(votedNay, sqrtVoters, votedAye, sqrtElectorate2) : compareRationals(votedNay, sqrtElectorate2, votedAye, sqrtVoters);
}
function calcPassing(threshold, sqrtElectorate2, state) {
  return threshold.isSimpleMajority ? state.votedAye.gt(state.votedNay) : calcPassingOther(threshold, sqrtElectorate2, state);
}
function calcVotesPrev(votesFor) {
  return votesFor.reduce((state, derived) => {
    const { balance, vote } = derived;
    const isDefault = vote.conviction.index === 0;
    const counted = balance.muln(isDefault ? 1 : vote.conviction.index).divn(isDefault ? 10 : 1);
    if (vote.isAye) {
      state.allAye.push(derived);
      state.voteCountAye++;
      state.votedAye.iadd(counted);
    } else {
      state.allNay.push(derived);
      state.voteCountNay++;
      state.votedNay.iadd(counted);
    }
    state.voteCount++;
    state.votedTotal.iadd(counted);
    return state;
  }, { allAye: [], allNay: [], voteCount: 0, voteCountAye: 0, voteCountNay: 0, votedAye: new import_bn.default(0), votedNay: new import_bn.default(0), votedTotal: new import_bn.default(0) });
}
function calcVotesCurrent(tally, votes2) {
  const allAye = [];
  const allNay = [];
  votes2.forEach((derived) => {
    if (derived.vote.isAye) {
      allAye.push(derived);
    } else {
      allNay.push(derived);
    }
  });
  return {
    allAye,
    allNay,
    voteCount: allAye.length + allNay.length,
    voteCountAye: allAye.length,
    voteCountNay: allNay.length,
    votedAye: tally.ayes,
    votedNay: tally.nays,
    votedTotal: tally.turnout
  };
}
function calcVotes(sqrtElectorate2, referendum, votes2) {
  const state = isCurrentStatus(referendum.status) ? calcVotesCurrent(referendum.status.tally, votes2) : calcVotesPrev(votes2);
  return objectSpread({}, state, {
    isPassing: calcPassing(referendum.status.threshold, sqrtElectorate2, state),
    votes: votes2
  });
}
function getStatus(info6) {
  if (info6.isNone) {
    return null;
  }
  const unwrapped = info6.unwrap();
  return isOldInfo(unwrapped) ? unwrapped : unwrapped.isOngoing ? unwrapped.asOngoing : null;
}
function getImageHashBounded(hash) {
  return hash.isLegacy ? hash.asLegacy.hash_.toHex() : hash.isLookup ? hash.asLookup.hash_.toHex() : hash.isInline ? hash.asInline.hash.toHex() : isString(hash) ? isHex(hash) ? hash : stringToHex(hash) : isU8a(hash) ? u8aToHex(hash) : hash.toHex();
}
function getImageHash(status) {
  return getImageHashBounded(status.proposal || status.proposalHash);
}
var init_util15 = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/util.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/dispatchQueue.js
function isMaybeHashedOrBounded(call) {
  return call instanceof Enum;
}
function isBounded(call) {
  return call.isInline || call.isLegacy || call.isLookup;
}
function queryQueue(api) {
  return api.query.democracy["dispatchQueue"]().pipe((0, import_rxjs39.switchMap)((dispatches) => (0, import_rxjs39.combineLatest)([
    (0, import_rxjs39.of)(dispatches),
    api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))
  ])), (0, import_rxjs39.map)(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({
    at,
    image: images[dispatchIndex],
    imageHash: getImageHashBounded(imageHash),
    index
  }))));
}
function schedulerEntries(api) {
  return api.derive.democracy.referendumsFinished().pipe((0, import_rxjs39.switchMap)(() => api.query.scheduler.agenda.keys()), (0, import_rxjs39.switchMap)((keys2) => {
    const blockNumbers = keys2.map(({ args: [blockNumber] }) => blockNumber);
    return blockNumbers.length ? (0, import_rxjs39.combineLatest)([
      (0, import_rxjs39.of)(blockNumbers),
      // this should simply be api.query.scheduler.agenda.multi,
      // however we have had cases on Darwinia where the indices have moved around after an
      // upgrade, which results in invalid on-chain data
      api.query.scheduler.agenda.multi(blockNumbers).pipe((0, import_rxjs39.catchError)(() => (0, import_rxjs39.of)(blockNumbers.map(() => []))))
    ]) : (0, import_rxjs39.of)([[], []]);
  }));
}
function queryScheduler(api) {
  return schedulerEntries(api).pipe((0, import_rxjs39.switchMap)(([blockNumbers, agendas]) => {
    const result = [];
    blockNumbers.forEach((at, index) => {
      (agendas[index] || []).filter((o) => o.isSome).forEach((o) => {
        const scheduled = o.unwrap();
        if (scheduled.maybeId.isSome) {
          const id = scheduled.maybeId.unwrap().toHex();
          if (id.startsWith(DEMOCRACY_ID)) {
            const imageHash = isMaybeHashedOrBounded(scheduled.call) ? isBounded(scheduled.call) ? getImageHashBounded(scheduled.call) : scheduled.call.isHash ? scheduled.call.asHash.toHex() : scheduled.call.asValue.args[0].toHex() : scheduled.call.args[0].toHex();
            result.push({ at, imageHash, index: api.registry.createType("(u64, ReferendumIndex)", id)[1] });
          }
        }
      });
    });
    return (0, import_rxjs39.combineLatest)([
      (0, import_rxjs39.of)(result),
      result.length ? api.derive.democracy.preimages(result.map(({ imageHash }) => imageHash)) : (0, import_rxjs39.of)([])
    ]);
  }), (0, import_rxjs39.map)(([infos, images]) => infos.map((info6, index) => objectSpread({ image: images[index] }, info6))));
}
function dispatchQueue(instanceId, api) {
  return memo(instanceId, () => isFunction(api.query.scheduler?.agenda) ? queryScheduler(api) : api.query.democracy["dispatchQueue"] ? queryQueue(api) : (0, import_rxjs39.of)([]));
}
var import_rxjs39, DEMOCRACY_ID;
var init_dispatchQueue = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/dispatchQueue.js"() {
    import_rxjs39 = __toESM(require_cjs(), 1);
    init_types3();
    init_util();
    init_util10();
    init_util15();
    DEMOCRACY_ID = stringToHex("democrac");
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/locks.js
function parseEnd(api, vote, { approved, end }) {
  return [
    end,
    approved.isTrue && vote.isAye || approved.isFalse && vote.isNay ? end.add((api.consts.democracy.voteLockingPeriod || api.consts.democracy.enactmentPeriod).muln(LOCKUPS[vote.conviction.index])) : BN_ZERO
  ];
}
function parseLock(api, [referendumId, accountVote], referendum) {
  const { balance, vote } = accountVote.asStandard;
  const [referendumEnd, unlockAt] = referendum.isFinished ? parseEnd(api, vote, referendum.asFinished) : [BN_ZERO, BN_ZERO];
  return { balance, isDelegated: false, isFinished: referendum.isFinished, referendumEnd, referendumId, unlockAt, vote };
}
function delegateLocks(api, { balance, conviction, target }) {
  return api.derive.democracy.locks(target).pipe((0, import_rxjs40.map)((available) => available.map(({ isFinished, referendumEnd, referendumId, unlockAt, vote }) => ({
    balance,
    isDelegated: true,
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt: unlockAt.isZero() ? unlockAt : referendumEnd.add((api.consts.democracy.voteLockingPeriod || api.consts.democracy.enactmentPeriod).muln(LOCKUPS[conviction.index])),
    vote: api.registry.createType("Vote", { aye: vote.isAye, conviction })
  }))));
}
function directLocks(api, { votes: votes2 }) {
  if (!votes2.length) {
    return (0, import_rxjs40.of)([]);
  }
  return api.query.democracy.referendumInfoOf.multi(votes2.map(([referendumId]) => referendumId)).pipe((0, import_rxjs40.map)((referendums2) => votes2.map((vote, index) => [vote, referendums2[index].unwrapOr(null)]).filter((item) => !!item[1] && isUndefined(item[1].end) && item[0][1].isStandard).map(([directVote, referendum]) => parseLock(api, directVote, referendum))));
}
function locks(instanceId, api) {
  return memo(instanceId, (accountId2) => api.query.democracy.votingOf ? api.query.democracy.votingOf(accountId2).pipe((0, import_rxjs40.switchMap)((voting) => voting.isDirect ? directLocks(api, voting.asDirect) : voting.isDelegating ? delegateLocks(api, voting.asDelegating) : (0, import_rxjs40.of)([]))) : (0, import_rxjs40.of)([]));
}
var import_rxjs40, LOCKUPS;
var init_locks = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/locks.js"() {
    import_rxjs40 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    LOCKUPS = [0, 1, 2, 4, 8, 16, 32];
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/nextExternal.js
function withImage(api, nextOpt) {
  if (nextOpt.isNone) {
    return (0, import_rxjs41.of)(null);
  }
  const [hash, threshold] = nextOpt.unwrap();
  return api.derive.democracy.preimage(hash).pipe((0, import_rxjs41.map)((image) => ({
    image,
    imageHash: getImageHashBounded(hash),
    threshold
  })));
}
function nextExternal(instanceId, api) {
  return memo(instanceId, () => api.query.democracy?.nextExternal ? api.query.democracy.nextExternal().pipe((0, import_rxjs41.switchMap)((nextOpt) => withImage(api, nextOpt))) : (0, import_rxjs41.of)(null));
}
var import_rxjs41;
var init_nextExternal = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/nextExternal.js"() {
    import_rxjs41 = __toESM(require_cjs(), 1);
    init_util10();
    init_util15();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/preimages.js
function getUnrequestedTicket(status) {
  return status.ticket || status.deposit;
}
function getRequestedTicket(status) {
  return (status.maybeTicket || status.deposit).unwrapOrDefault();
}
function isDemocracyPreimage(api, imageOpt) {
  return !!imageOpt && !api.query.democracy["dispatchQueue"];
}
function constructProposal(api, [bytes2, proposer, balance, at]) {
  let proposal6;
  try {
    proposal6 = api.registry.createType("Call", bytes2.toU8a(true));
  } catch (error) {
    console.error(error);
  }
  return { at, balance, proposal: proposal6, proposer };
}
function parseDemocracy(api, imageOpt) {
  if (imageOpt.isNone) {
    return;
  }
  if (isDemocracyPreimage(api, imageOpt)) {
    const status = imageOpt.unwrap();
    if (status.isMissing) {
      return;
    }
    const { data, deposit, provider, since } = status.asAvailable;
    return constructProposal(api, [data, provider, deposit, since]);
  }
  return constructProposal(api, imageOpt.unwrap());
}
function parseImage(api, [proposalHash, status, bytes2]) {
  if (!status) {
    return void 0;
  }
  const [proposer, balance] = status.isUnrequested ? getUnrequestedTicket(status.asUnrequested) : getRequestedTicket(status.asRequested);
  let proposal6;
  if (bytes2) {
    try {
      proposal6 = api.registry.createType("Call", bytes2.toU8a(true));
    } catch (error) {
      console.error(error);
    }
  }
  return { at: BN_ZERO, balance, proposal: proposal6, proposalHash, proposer };
}
function getDemocracyImages(api, bounded) {
  const hashes = bounded.map((b) => getImageHashBounded(b));
  return api.query.democracy["preimages"].multi(hashes).pipe((0, import_rxjs42.map)((images) => images.map((imageOpt) => parseDemocracy(api, imageOpt))));
}
function getImages(api, bounded) {
  const hashes = bounded.map((b) => getImageHashBounded(b));
  const bytesType = api.registry.lookup.getTypeDef(api.query.preimage.preimageFor.creator.meta.type.asMap.key).type;
  return api.query.preimage.statusFor.multi(hashes).pipe((0, import_rxjs42.switchMap)((optStatus) => {
    const statuses = optStatus.map((o) => o.unwrapOr(null));
    const keys2 = statuses.map((s2, i2) => s2 ? bytesType === "H256" ? hashes[i2] : s2.isRequested ? [hashes[i2], s2.asRequested.len.unwrapOr(0)] : [hashes[i2], s2.asUnrequested.len] : null).filter((p) => !!p);
    return api.query.preimage.preimageFor.multi(keys2).pipe((0, import_rxjs42.map)((optBytes) => {
      let ptr = -1;
      return statuses.map((s2, i2) => s2 ? [hashes[i2], s2, optBytes[++ptr].unwrapOr(null)] : [hashes[i2], null, null]).map((v) => parseImage(api, v));
    }));
  }));
}
function preimages(instanceId, api) {
  return memo(instanceId, (hashes) => hashes.length ? isFunction(api.query.democracy["preimages"]) ? getDemocracyImages(api, hashes) : isFunction(api.query.preimage.preimageFor) ? getImages(api, hashes) : (0, import_rxjs42.of)([]) : (0, import_rxjs42.of)([]));
}
var import_rxjs42, preimage;
var init_preimages = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/preimages.js"() {
    import_rxjs42 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util15();
    preimage = /* @__PURE__ */ firstMemo((api, hash) => api.derive.democracy.preimages([hash]));
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/proposals.js
function isNewDepositors(depositors) {
  return isFunction(depositors[1].mul);
}
function parse2([proposals8, images, optDepositors]) {
  return proposals8.filter(([, , proposer], index) => !!optDepositors[index]?.isSome && !proposer.isEmpty).map(([index, hash, proposer], proposalIndex) => {
    const depositors = optDepositors[proposalIndex].unwrap();
    return objectSpread({
      image: images[proposalIndex],
      imageHash: getImageHashBounded(hash),
      index,
      proposer
    }, isNewDepositors(depositors) ? { balance: depositors[1], seconds: depositors[0] } : { balance: depositors[0], seconds: depositors[1] });
  });
}
function proposals4(instanceId, api) {
  return memo(instanceId, () => isFunction(api.query.democracy?.publicProps) ? api.query.democracy.publicProps().pipe((0, import_rxjs43.switchMap)((proposals8) => proposals8.length ? (0, import_rxjs43.combineLatest)([
    (0, import_rxjs43.of)(proposals8),
    api.derive.democracy.preimages(proposals8.map(([, hash]) => hash)),
    api.query.democracy.depositOf.multi(proposals8.map(([index]) => index))
  ]) : (0, import_rxjs43.of)([[], [], []])), (0, import_rxjs43.map)(parse2)) : (0, import_rxjs43.of)([]));
}
var import_rxjs43;
var init_proposals2 = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/proposals.js"() {
    import_rxjs43 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util15();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/referendumIds.js
function referendumIds(instanceId, api) {
  return memo(instanceId, () => api.query.democracy?.lowestUnbaked ? api.queryMulti([
    api.query.democracy.lowestUnbaked,
    api.query.democracy.referendumCount
  ]).pipe((0, import_rxjs44.map)(([first2, total]) => total.gt(first2) ? [...Array(total.sub(first2).toNumber())].map((_, i2) => first2.addn(i2)) : [])) : (0, import_rxjs44.of)([]));
}
var import_rxjs44;
var init_referendumIds = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/referendumIds.js"() {
    import_rxjs44 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/referendums.js
function referendums(instanceId, api) {
  return memo(instanceId, () => api.derive.democracy.referendumsActive().pipe((0, import_rxjs45.switchMap)((referendums2) => referendums2.length ? (0, import_rxjs45.combineLatest)([
    (0, import_rxjs45.of)(referendums2),
    api.derive.democracy._referendumsVotes(referendums2)
  ]) : (0, import_rxjs45.of)([[], []])), (0, import_rxjs45.map)(([referendums2, votes2]) => referendums2.map((referendum, index) => objectSpread({}, referendum, votes2[index])))));
}
var import_rxjs45;
var init_referendums = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/referendums.js"() {
    import_rxjs45 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/referendumsActive.js
function referendumsActive(instanceId, api) {
  return memo(instanceId, () => api.derive.democracy.referendumIds().pipe((0, import_rxjs46.switchMap)((ids) => ids.length ? api.derive.democracy.referendumsInfo(ids) : (0, import_rxjs46.of)([]))));
}
var import_rxjs46;
var init_referendumsActive = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/referendumsActive.js"() {
    import_rxjs46 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/referendumsFinished.js
function referendumsFinished(instanceId, api) {
  return memo(instanceId, () => api.derive.democracy.referendumIds().pipe((0, import_rxjs47.switchMap)((ids) => api.query.democracy.referendumInfoOf.multi(ids)), (0, import_rxjs47.map)((infos) => infos.map((o) => o.unwrapOr(null)).filter((info6) => !!info6 && info6.isFinished).map((info6) => info6.asFinished))));
}
var import_rxjs47;
var init_referendumsFinished = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/referendumsFinished.js"() {
    import_rxjs47 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/referendumsInfo.js
function votesPrev(api, referendumId) {
  return api.query.democracy["votersFor"](referendumId).pipe((0, import_rxjs48.switchMap)((votersFor) => (0, import_rxjs48.combineLatest)([
    (0, import_rxjs48.of)(votersFor),
    votersFor.length ? api.query.democracy["voteOf"].multi(votersFor.map((accountId2) => [referendumId, accountId2])) : (0, import_rxjs48.of)([]),
    api.derive.balances.votingBalances(votersFor)
  ])), (0, import_rxjs48.map)(([votersFor, votes2, balances]) => votersFor.map((accountId2, index) => ({
    accountId: accountId2,
    balance: balances[index].votingBalance || api.registry.createType("Balance"),
    isDelegating: false,
    vote: votes2[index] || api.registry.createType("Vote")
  }))));
}
function extractVotes(mapped, referendumId) {
  return mapped.filter(([, voting]) => voting.isDirect).map(([accountId2, voting]) => [
    accountId2,
    voting.asDirect.votes.filter(([idx]) => idx.eq(referendumId))
  ]).filter(([, directVotes]) => !!directVotes.length).reduce((result, [accountId2, votes2]) => (
    // FIXME We are ignoring split votes
    votes2.reduce((result2, [, vote]) => {
      if (vote.isStandard) {
        result2.push(objectSpread({
          accountId: accountId2,
          isDelegating: false
        }, vote.asStandard));
      }
      return result2;
    }, result)
  ), []);
}
function votesCurr(api, referendumId) {
  return api.query.democracy.votingOf.entries().pipe((0, import_rxjs48.map)((allVoting) => {
    const mapped = allVoting.map(([{ args: [accountId2] }, voting]) => [accountId2, voting]);
    const votes2 = extractVotes(mapped, referendumId);
    const delegations = mapped.filter(([, voting]) => voting.isDelegating).map(([accountId2, voting]) => [accountId2, voting.asDelegating]);
    delegations.forEach(([accountId2, { balance, conviction, target }]) => {
      const toDelegator = delegations.find(([accountId3]) => accountId3.eq(target));
      const to = votes2.find(({ accountId: accountId3 }) => accountId3.eq(toDelegator ? toDelegator[0] : target));
      if (to) {
        votes2.push({
          accountId: accountId2,
          balance,
          isDelegating: true,
          vote: api.registry.createType("Vote", { aye: to.vote.isAye, conviction })
        });
      }
    });
    return votes2;
  }));
}
function _referendumVotes(instanceId, api) {
  return memo(instanceId, (referendum) => (0, import_rxjs48.combineLatest)([
    api.derive.democracy.sqrtElectorate(),
    isFunction(api.query.democracy.votingOf) ? votesCurr(api, referendum.index) : votesPrev(api, referendum.index)
  ]).pipe((0, import_rxjs48.map)(([sqrtElectorate2, votes2]) => calcVotes(sqrtElectorate2, referendum, votes2))));
}
function _referendumsVotes(instanceId, api) {
  return memo(instanceId, (referendums2) => referendums2.length ? (0, import_rxjs48.combineLatest)(referendums2.map((referendum) => api.derive.democracy._referendumVotes(referendum))) : (0, import_rxjs48.of)([]));
}
function _referendumInfo(instanceId, api) {
  return memo(instanceId, (index, info6) => {
    const status = getStatus(info6);
    return status ? api.derive.democracy.preimage(status.proposal || status.proposalHash).pipe((0, import_rxjs48.map)((image) => ({
      image,
      imageHash: getImageHash(status),
      index: api.registry.createType("ReferendumIndex", index),
      status
    }))) : (0, import_rxjs48.of)(null);
  });
}
function referendumsInfo(instanceId, api) {
  return memo(instanceId, (ids) => ids.length ? api.query.democracy.referendumInfoOf.multi(ids).pipe((0, import_rxjs48.switchMap)((infos) => (0, import_rxjs48.combineLatest)(ids.map((id, index) => api.derive.democracy._referendumInfo(id, infos[index])))), (0, import_rxjs48.map)((infos) => infos.filter((r2) => !!r2))) : (0, import_rxjs48.of)([]));
}
var import_rxjs48;
var init_referendumsInfo = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/referendumsInfo.js"() {
    import_rxjs48 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util15();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js
function sqrtElectorate(instanceId, api) {
  return memo(instanceId, () => api.query.balances.totalIssuance().pipe((0, import_rxjs49.map)(bnSqrt)));
}
var import_rxjs49;
var init_sqrtElectorate = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js"() {
    import_rxjs49 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/democracy/index.js
var democracy_exports = {};
__export(democracy_exports, {
  _referendumInfo: () => _referendumInfo,
  _referendumVotes: () => _referendumVotes,
  _referendumsVotes: () => _referendumsVotes,
  dispatchQueue: () => dispatchQueue,
  locks: () => locks,
  nextExternal: () => nextExternal,
  preimage: () => preimage,
  preimages: () => preimages,
  proposals: () => proposals4,
  referendumIds: () => referendumIds,
  referendums: () => referendums,
  referendumsActive: () => referendumsActive,
  referendumsFinished: () => referendumsFinished,
  referendumsInfo: () => referendumsInfo,
  sqrtElectorate: () => sqrtElectorate
});
var init_democracy = __esm({
  "../../node_modules/@polkadot/api-derive/democracy/index.js"() {
    init_dispatchQueue();
    init_locks();
    init_nextExternal();
    init_preimages();
    init_proposals2();
    init_referendumIds();
    init_referendums();
    init_referendumsActive();
    init_referendumsFinished();
    init_referendumsInfo();
    init_sqrtElectorate();
  }
});

// ../../node_modules/@polkadot/api-derive/elections/info.js
function isSeatHolder(value) {
  return !Array.isArray(value);
}
function isCandidateTuple(value) {
  return Array.isArray(value);
}
function getAccountTuple(value) {
  return isSeatHolder(value) ? [value.who, value.stake] : value;
}
function getCandidate(value) {
  return isCandidateTuple(value) ? value[0] : value;
}
function sortAccounts([, balanceA], [, balanceB]) {
  return balanceB.cmp(balanceA);
}
function getConstants(api, elections) {
  return elections ? {
    candidacyBond: api.consts[elections].candidacyBond,
    desiredRunnersUp: api.consts[elections].desiredRunnersUp,
    desiredSeats: api.consts[elections].desiredMembers,
    termDuration: api.consts[elections].termDuration,
    votingBond: api.consts[elections]["votingBond"],
    votingBondBase: api.consts[elections].votingBondBase,
    votingBondFactor: api.consts[elections].votingBondFactor
  } : {};
}
function getModules(api) {
  const [council] = api.registry.getModuleInstances(api.runtimeVersion.specName, "council") || ["council"];
  const elections = api.query["phragmenElection"] ? "phragmenElection" : api.query["electionsPhragmen"] ? "electionsPhragmen" : api.query.elections ? "elections" : null;
  const resolvedCouncil = api.query[council] ? council : "council";
  return [resolvedCouncil, elections];
}
function queryAll(api, council, elections) {
  return api.queryMulti([
    api.query[council].members,
    api.query[elections].candidates,
    api.query[elections].members,
    api.query[elections].runnersUp
  ]);
}
function queryCouncil(api, council) {
  return (0, import_rxjs50.combineLatest)([
    api.query[council].members(),
    (0, import_rxjs50.of)([]),
    (0, import_rxjs50.of)([]),
    (0, import_rxjs50.of)([])
  ]);
}
function info2(instanceId, api) {
  return memo(instanceId, () => {
    const [council, elections] = getModules(api);
    return (elections ? queryAll(api, council, elections) : queryCouncil(api, council)).pipe((0, import_rxjs50.map)(([councilMembers, candidates2, members7, runnersUp]) => objectSpread({}, getConstants(api, elections), {
      candidateCount: api.registry.createType("u32", candidates2.length),
      candidates: candidates2.map(getCandidate),
      members: members7.length ? members7.map(getAccountTuple).sort(sortAccounts) : councilMembers.map((a) => [a, api.registry.createType("Balance")]),
      runnersUp: runnersUp.map(getAccountTuple).sort(sortAccounts)
    })));
  });
}
var import_rxjs50;
var init_info2 = __esm({
  "../../node_modules/@polkadot/api-derive/elections/info.js"() {
    import_rxjs50 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/elections/index.js
var elections_exports = {};
__export(elections_exports, {
  info: () => info2
});
var init_elections = __esm({
  "../../node_modules/@polkadot/api-derive/elections/index.js"() {
    init_info2();
  }
});

// ../../node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js
function mapResult([result, validators2, heartbeats, numBlocks]) {
  validators2.forEach((validator, index) => {
    const validatorId = validator.toString();
    const blockCount = numBlocks[index];
    const hasMessage = !heartbeats[index].isEmpty;
    const prev = result[validatorId];
    if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) {
      result[validatorId] = {
        blockCount,
        hasMessage,
        isOnline: hasMessage || blockCount.gt(BN_ZERO)
      };
    }
  });
  return result;
}
function receivedHeartbeats(instanceId, api) {
  return memo(instanceId, () => api.query.imOnline?.receivedHeartbeats ? api.derive.staking.overview().pipe((0, import_rxjs51.switchMap)(({ currentIndex, validators: validators2 }) => (0, import_rxjs51.combineLatest)([
    (0, import_rxjs51.of)({}),
    (0, import_rxjs51.of)(validators2),
    api.query.imOnline.receivedHeartbeats.multi(validators2.map((_address, index) => [currentIndex, index])),
    api.query.imOnline.authoredBlocks.multi(validators2.map((address) => [currentIndex, address]))
  ])), (0, import_rxjs51.map)(mapResult)) : (0, import_rxjs51.of)({}));
}
var import_rxjs51;
var init_receivedHeartbeats = __esm({
  "../../node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js"() {
    import_rxjs51 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/imOnline/index.js
var imOnline_exports = {};
__export(imOnline_exports, {
  receivedHeartbeats: () => receivedHeartbeats
});
var init_imOnline = __esm({
  "../../node_modules/@polkadot/api-derive/imOnline/index.js"() {
    init_receivedHeartbeats();
  }
});

// ../../node_modules/@polkadot/api-derive/membership/index.js
var membership_exports = {};
__export(membership_exports, {
  hasProposals: () => hasProposals4,
  members: () => members4,
  prime: () => prime4,
  proposal: () => proposal4,
  proposalCount: () => proposalCount4,
  proposalHashes: () => proposalHashes4,
  proposals: () => proposals5
});
var members4, hasProposals4, proposal4, proposalCount4, proposalHashes4, proposals5, prime4;
var init_membership = __esm({
  "../../node_modules/@polkadot/api-derive/membership/index.js"() {
    init_collective();
    members4 = /* @__PURE__ */ members("membership");
    hasProposals4 = /* @__PURE__ */ hasProposals("membership");
    proposal4 = /* @__PURE__ */ proposal("membership");
    proposalCount4 = /* @__PURE__ */ proposalCount("membership");
    proposalHashes4 = /* @__PURE__ */ proposalHashes("membership");
    proposals5 = /* @__PURE__ */ proposals("membership");
    prime4 = /* @__PURE__ */ prime("membership");
  }
});

// ../../node_modules/@polkadot/api-derive/parachains/util.js
function didUpdateToBool(didUpdate, id) {
  return didUpdate.isSome ? didUpdate.unwrap().some((paraId) => paraId.eq(id)) : false;
}
var init_util16 = __esm({
  "../../node_modules/@polkadot/api-derive/parachains/util.js"() {
  }
});

// ../../node_modules/@polkadot/api-derive/parachains/info.js
function parseActive(id, active) {
  const found = active.find(([paraId]) => paraId === id);
  if (found && found[1].isSome) {
    const [collatorId, retriable] = found[1].unwrap();
    return objectSpread({ collatorId }, retriable.isWithRetries ? {
      isRetriable: true,
      retries: retriable.asWithRetries.toNumber()
    } : {
      isRetriable: false,
      retries: 0
    });
  }
  return null;
}
function parseCollators(id, collatorQueue) {
  return collatorQueue.map((queue) => {
    const found = queue.find(([paraId]) => paraId === id);
    return found ? found[1] : null;
  });
}
function parse3(id, [active, retryQueue, selectedThreads, didUpdate, info6, pendingSwap, heads, relayDispatchQueue]) {
  if (info6.isNone) {
    return null;
  }
  return {
    active: parseActive(id, active),
    didUpdate: didUpdateToBool(didUpdate, id),
    heads,
    id,
    info: objectSpread({ id }, info6.unwrap()),
    pendingSwapId: pendingSwap.unwrapOr(null),
    relayDispatchQueue,
    retryCollators: parseCollators(id, retryQueue),
    selectedCollators: parseCollators(id, selectedThreads)
  };
}
function info3(instanceId, api) {
  return memo(instanceId, (id) => api.query["registrar"] && api.query["parachains"] ? api.queryMulti([
    api.query["registrar"]["active"],
    api.query["registrar"]["retryQueue"],
    api.query["registrar"]["selectedThreads"],
    api.query["parachains"]["didUpdate"],
    [api.query["registrar"]["paras"], id],
    [api.query["registrar"]["pendingSwap"], id],
    [api.query["parachains"]["heads"], id],
    [api.query["parachains"]["relayDispatchQueue"], id]
  ]).pipe((0, import_rxjs52.map)((result) => parse3(api.registry.createType("ParaId", id), result))) : (0, import_rxjs52.of)(null));
}
var import_rxjs52;
var init_info3 = __esm({
  "../../node_modules/@polkadot/api-derive/parachains/info.js"() {
    import_rxjs52 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util16();
  }
});

// ../../node_modules/@polkadot/api-derive/parachains/overview.js
function parse4([ids, didUpdate, relayDispatchQueueSizes, infos, pendingSwaps]) {
  return ids.map((id, index) => ({
    didUpdate: didUpdateToBool(didUpdate, id),
    id,
    info: objectSpread({ id }, infos[index].unwrapOr(null)),
    pendingSwapId: pendingSwaps[index].unwrapOr(null),
    relayDispatchQueueSize: relayDispatchQueueSizes[index][0].toNumber()
  }));
}
function overview(instanceId, api) {
  return memo(instanceId, () => api.query["registrar"]?.["parachains"] && api.query["parachains"] ? api.query["registrar"]["parachains"]().pipe((0, import_rxjs53.switchMap)((paraIds) => (0, import_rxjs53.combineLatest)([
    (0, import_rxjs53.of)(paraIds),
    api.query["parachains"]["didUpdate"](),
    api.query["parachains"]["relayDispatchQueueSize"].multi(paraIds),
    api.query["registrar"]["paras"].multi(paraIds),
    api.query["registrar"]["pendingSwap"].multi(paraIds)
  ])), (0, import_rxjs53.map)(parse4)) : (0, import_rxjs53.of)([]));
}
var import_rxjs53;
var init_overview = __esm({
  "../../node_modules/@polkadot/api-derive/parachains/overview.js"() {
    import_rxjs53 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_util16();
  }
});

// ../../node_modules/@polkadot/api-derive/parachains/index.js
var parachains_exports = {};
__export(parachains_exports, {
  info: () => info3,
  overview: () => overview
});
var init_parachains = __esm({
  "../../node_modules/@polkadot/api-derive/parachains/index.js"() {
    init_info3();
    init_overview();
  }
});

// ../../node_modules/@polkadot/api-derive/session/indexes.js
function parse5([currentIndex, activeEra, activeEraStart, currentEra, validatorCount]) {
  return {
    activeEra,
    activeEraStart,
    currentEra,
    currentIndex,
    validatorCount
  };
}
function queryStaking(api) {
  return api.queryMulti([
    api.query.session.currentIndex,
    api.query.staking.activeEra,
    api.query.staking.currentEra,
    api.query.staking.validatorCount
  ]).pipe((0, import_rxjs54.map)(([currentIndex, activeOpt, currentEra, validatorCount]) => {
    const { index, start } = activeOpt.unwrapOrDefault();
    return parse5([
      currentIndex,
      index,
      start,
      currentEra.unwrapOrDefault(),
      validatorCount
    ]);
  }));
}
function querySession(api) {
  return api.query.session.currentIndex().pipe((0, import_rxjs54.map)((currentIndex) => parse5([
    currentIndex,
    api.registry.createType("EraIndex"),
    api.registry.createType("Option<Moment>"),
    api.registry.createType("EraIndex"),
    api.registry.createType("u32")
  ])));
}
function empty(api) {
  return (0, import_rxjs54.of)(parse5([
    api.registry.createType("SessionIndex", 1),
    api.registry.createType("EraIndex"),
    api.registry.createType("Option<Moment>"),
    api.registry.createType("EraIndex"),
    api.registry.createType("u32")
  ]));
}
function indexes2(instanceId, api) {
  return memo(instanceId, () => api.query.session ? api.query.staking ? queryStaking(api) : querySession(api) : empty(api));
}
var import_rxjs54;
var init_indexes2 = __esm({
  "../../node_modules/@polkadot/api-derive/session/indexes.js"() {
    import_rxjs54 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/session/info.js
function info4(instanceId, api) {
  return memo(instanceId, () => api.derive.session.indexes().pipe((0, import_rxjs55.map)((indexes3) => {
    const sessionLength = api.consts?.babe?.epochDuration || api.registry.createType("u64", 1);
    const sessionsPerEra = api.consts?.staking?.sessionsPerEra || api.registry.createType("SessionIndex", 1);
    return objectSpread({
      eraLength: api.registry.createType("BlockNumber", sessionsPerEra.mul(sessionLength)),
      isEpoch: !!api.query.babe,
      sessionLength,
      sessionsPerEra
    }, indexes3);
  })));
}
var import_rxjs55;
var init_info4 = __esm({
  "../../node_modules/@polkadot/api-derive/session/info.js"() {
    import_rxjs55 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/session/progress.js
function withProgressField(field) {
  return (instanceId, api) => memo(instanceId, () => api.derive.session.progress().pipe((0, import_rxjs56.map)((info6) => info6[field])));
}
function createDerive(api, info6, [currentSlot, epochIndex, epochOrGenesisStartSlot, activeEraStartSessionIndex]) {
  const epochStartSlot = epochIndex.mul(info6.sessionLength).iadd(epochOrGenesisStartSlot);
  const sessionProgress2 = currentSlot.sub(epochStartSlot);
  const eraProgress2 = info6.currentIndex.sub(activeEraStartSessionIndex).imul(info6.sessionLength).iadd(sessionProgress2);
  return objectSpread({
    eraProgress: api.registry.createType("BlockNumber", eraProgress2),
    sessionProgress: api.registry.createType("BlockNumber", sessionProgress2)
  }, info6);
}
function queryAura(api) {
  return api.derive.session.info().pipe((0, import_rxjs56.map)((info6) => objectSpread({
    eraProgress: api.registry.createType("BlockNumber"),
    sessionProgress: api.registry.createType("BlockNumber")
  }, info6)));
}
function queryBabe(api) {
  return api.derive.session.info().pipe((0, import_rxjs56.switchMap)((info6) => (0, import_rxjs56.combineLatest)([
    (0, import_rxjs56.of)(info6),
    // we may have no staking, but have babe (permissioned)
    api.query.staking?.erasStartSessionIndex ? api.queryMulti([
      api.query.babe.currentSlot,
      api.query.babe.epochIndex,
      api.query.babe.genesisSlot,
      [api.query.staking.erasStartSessionIndex, info6.activeEra]
    ]) : api.queryMulti([
      api.query.babe.currentSlot,
      api.query.babe.epochIndex,
      api.query.babe.genesisSlot
    ])
  ])), (0, import_rxjs56.map)(([info6, [currentSlot, epochIndex, genesisSlot, optStartIndex]]) => [
    info6,
    [currentSlot, epochIndex, genesisSlot, optStartIndex && optStartIndex.isSome ? optStartIndex.unwrap() : api.registry.createType("SessionIndex", 1)]
  ]));
}
function progress(instanceId, api) {
  return memo(instanceId, () => api.query.babe ? queryBabe(api).pipe((0, import_rxjs56.map)(([info6, slots]) => createDerive(api, info6, slots))) : queryAura(api));
}
var import_rxjs56, eraLength, eraProgress, sessionProgress;
var init_progress = __esm({
  "../../node_modules/@polkadot/api-derive/session/progress.js"() {
    import_rxjs56 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    eraLength = /* @__PURE__ */ withProgressField("eraLength");
    eraProgress = /* @__PURE__ */ withProgressField("eraProgress");
    sessionProgress = /* @__PURE__ */ withProgressField("sessionProgress");
  }
});

// ../../node_modules/@polkadot/api-derive/session/index.js
var session_exports = {};
__export(session_exports, {
  eraLength: () => eraLength,
  eraProgress: () => eraProgress,
  indexes: () => indexes2,
  info: () => info4,
  progress: () => progress,
  sessionProgress: () => sessionProgress
});
var init_session = __esm({
  "../../node_modules/@polkadot/api-derive/session/index.js"() {
    init_indexes2();
    init_info4();
    init_progress();
  }
});

// ../../node_modules/@polkadot/api-derive/society/candidates.js
function getPrev(api) {
  return api.query.society.candidates().pipe((0, import_rxjs57.switchMap)((candidates2) => (0, import_rxjs57.combineLatest)([
    (0, import_rxjs57.of)(candidates2),
    api.query.society["suspendedCandidates"].multi(candidates2.map(({ who }) => who))
  ])), (0, import_rxjs57.map)(([candidates2, suspended]) => candidates2.map(({ kind, value, who }, index) => ({
    accountId: who,
    isSuspended: suspended[index].isSome,
    kind,
    value
  }))));
}
function getCurr(api) {
  return api.query.society.candidates.entries().pipe((0, import_rxjs57.map)((entries) => entries.filter(([, opt]) => opt.isSome).map(([{ args: [accountId2] }, opt]) => [accountId2, opt.unwrap()]).map(([accountId2, { bid, kind }]) => ({
    accountId: accountId2,
    isSuspended: false,
    kind,
    value: bid
  }))));
}
function candidates(instanceId, api) {
  return memo(instanceId, () => api.query.society["suspendedCandidates"] && api.query.society.candidates.creator.meta.type.isPlain ? getPrev(api) : getCurr(api));
}
var import_rxjs57;
var init_candidates = __esm({
  "../../node_modules/@polkadot/api-derive/society/candidates.js"() {
    import_rxjs57 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/society/info.js
function info5(instanceId, api) {
  return memo(instanceId, () => (0, import_rxjs58.combineLatest)([
    api.query.society.bids(),
    api.query.society["defender"] ? api.query.society["defender"]() : (0, import_rxjs58.of)(void 0),
    api.query.society.founder(),
    api.query.society.head(),
    api.query.society["maxMembers"] ? api.query.society["maxMembers"]() : (0, import_rxjs58.of)(void 0),
    api.query.society.pot()
  ]).pipe((0, import_rxjs58.map)(([bids, defender, founder, head, maxMembers, pot]) => ({
    bids,
    defender: defender?.unwrapOr(void 0),
    founder: founder.unwrapOr(void 0),
    hasDefender: defender?.isSome && head.isSome && !head.eq(defender) || false,
    head: head.unwrapOr(void 0),
    maxMembers,
    pot
  }))));
}
var import_rxjs58;
var init_info5 = __esm({
  "../../node_modules/@polkadot/api-derive/society/info.js"() {
    import_rxjs58 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/society/member.js
function member(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.society._members([accountId2]).pipe((0, import_rxjs59.map)(([result]) => result)));
}
var import_rxjs59;
var init_member = __esm({
  "../../node_modules/@polkadot/api-derive/society/member.js"() {
    import_rxjs59 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/society/members.js
function _membersPrev(api, accountIds) {
  return (0, import_rxjs60.combineLatest)([
    (0, import_rxjs60.of)(accountIds),
    api.query.society.payouts.multi(accountIds),
    api.query.society["strikes"].multi(accountIds),
    api.query.society.defenderVotes.multi(accountIds),
    api.query.society.suspendedMembers.multi(accountIds),
    api.query.society["vouching"].multi(accountIds)
  ]).pipe((0, import_rxjs60.map)(([accountIds2, payouts, strikes, defenderVotes, suspended, vouching]) => accountIds2.map((accountId2, index) => ({
    accountId: accountId2,
    isDefenderVoter: defenderVotes[index].isSome,
    isSuspended: suspended[index].isTrue,
    payouts: payouts[index],
    strikes: strikes[index],
    vote: defenderVotes[index].unwrapOr(void 0),
    vouching: vouching[index].unwrapOr(void 0)
  }))));
}
function _membersCurr(api, accountIds) {
  return (0, import_rxjs60.combineLatest)([
    (0, import_rxjs60.of)(accountIds),
    api.query.society.members.multi(accountIds),
    api.query.society.payouts.multi(accountIds),
    api.query.society.challengeRoundCount().pipe((0, import_rxjs60.switchMap)((round) => api.query.society.defenderVotes.multi(accountIds.map((accountId2) => [round, accountId2])))),
    api.query.society.suspendedMembers.multi(accountIds)
  ]).pipe((0, import_rxjs60.map)(([accountIds2, members7, payouts, defenderVotes, suspendedMembers]) => accountIds2.map((accountId2, index) => members7[index].isSome ? {
    accountId: accountId2,
    isDefenderVoter: defenderVotes[index].isSome,
    isSuspended: suspendedMembers[index].isSome,
    member: members7[index].unwrap(),
    payouts: payouts[index].payouts
  } : null).filter((m2) => !!m2).map(({ accountId: accountId2, isDefenderVoter, isSuspended, member: member2, payouts: payouts2 }) => ({
    accountId: accountId2,
    isDefenderVoter,
    isSuspended,
    payouts: payouts2,
    strikes: member2.strikes,
    vouching: member2.vouching.unwrapOr(void 0)
  }))));
}
function _members(instanceId, api) {
  return memo(instanceId, (accountIds) => api.query.society.members.creator.meta.type.isMap ? _membersCurr(api, accountIds) : _membersPrev(api, accountIds));
}
function members5(instanceId, api) {
  return memo(instanceId, () => api.query.society.members.creator.meta.type.isMap ? api.query.society.members.keys().pipe((0, import_rxjs60.switchMap)((keys2) => api.derive.society._members(keys2.map(({ args: [accountId2] }) => accountId2)))) : api.query.society.members().pipe((0, import_rxjs60.switchMap)((members7) => api.derive.society._members(members7))));
}
var import_rxjs60;
var init_members2 = __esm({
  "../../node_modules/@polkadot/api-derive/society/members.js"() {
    import_rxjs60 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/society/index.js
var society_exports = {};
__export(society_exports, {
  _members: () => _members,
  candidates: () => candidates,
  info: () => info5,
  member: () => member,
  members: () => members5
});
var init_society = __esm({
  "../../node_modules/@polkadot/api-derive/society/index.js"() {
    init_candidates();
    init_info5();
    init_member();
    init_members2();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/account.js
function groupByEra(list) {
  return list.reduce((map79, { era, value }) => {
    const key = era.toString();
    map79[key] = (map79[key] || BN_ZERO).add(value.unwrap());
    return map79;
  }, {});
}
function calculateUnlocking(api, stakingLedger, sessionInfo) {
  const results = Object.entries(groupByEra((stakingLedger?.unlocking || []).filter(({ era }) => era.unwrap().gt(sessionInfo.activeEra)))).map(([eraString, value]) => ({
    remainingEras: new import_bn.default(eraString).isub(sessionInfo.activeEra),
    value: api.registry.createType("Balance", value)
  }));
  return results.length ? results : void 0;
}
function redeemableSum(api, stakingLedger, sessionInfo) {
  return api.registry.createType("Balance", (stakingLedger?.unlocking || []).reduce((total, { era, value }) => {
    return era.unwrap().gt(sessionInfo.currentEra) ? total : total.iadd(value.unwrap());
  }, new import_bn.default(0)));
}
function parseResult2(api, sessionInfo, keys2, query2) {
  return objectSpread({}, keys2, query2, {
    redeemable: redeemableSum(api, query2.stakingLedger, sessionInfo),
    unlocking: calculateUnlocking(api, query2.stakingLedger, sessionInfo)
  });
}
function accounts(instanceId, api) {
  return memo(instanceId, (accountIds, opts = QUERY_OPTS) => api.derive.session.info().pipe((0, import_rxjs61.switchMap)((sessionInfo) => (0, import_rxjs61.combineLatest)([
    api.derive.staking.keysMulti(accountIds),
    api.derive.staking.queryMulti(accountIds, opts)
  ]).pipe((0, import_rxjs61.map)(([keys2, queries]) => queries.map((q, index) => parseResult2(api, sessionInfo, keys2[index], q)))))));
}
var import_rxjs61, QUERY_OPTS, account2;
var init_account2 = __esm({
  "../../node_modules/@polkadot/api-derive/staking/account.js"() {
    import_rxjs61 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    QUERY_OPTS = {
      withDestination: true,
      withLedger: true,
      withNominations: true,
      withPrefs: true
    };
    account2 = /* @__PURE__ */ firstMemo((api, accountId2, opts) => api.derive.staking.accounts([accountId2], opts));
  }
});

// ../../node_modules/@polkadot/api-derive/staking/currentPoints.js
function currentPoints(instanceId, api) {
  return memo(instanceId, () => api.derive.session.indexes().pipe((0, import_rxjs62.switchMap)(({ activeEra }) => api.query.staking.erasRewardPoints(activeEra))));
}
var import_rxjs62;
var init_currentPoints = __esm({
  "../../node_modules/@polkadot/api-derive/staking/currentPoints.js"() {
    import_rxjs62 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/electedInfo.js
function combineAccounts(nextElected2, validators2) {
  return arrayFlatten([nextElected2, validators2.filter((v) => !nextElected2.find((n) => n.eq(v)))]);
}
function electedInfo(instanceId, api) {
  return memo(instanceId, (flags2 = DEFAULT_FLAGS, page = 0) => api.derive.staking.validators().pipe((0, import_rxjs63.switchMap)(({ nextElected: nextElected2, validators: validators2 }) => api.derive.staking.queryMulti(combineAccounts(nextElected2, validators2), flags2, page).pipe((0, import_rxjs63.map)((info6) => ({
    info: info6,
    nextElected: nextElected2,
    validators: validators2
  }))))));
}
var import_rxjs63, DEFAULT_FLAGS;
var init_electedInfo = __esm({
  "../../node_modules/@polkadot/api-derive/staking/electedInfo.js"() {
    import_rxjs63 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    DEFAULT_FLAGS = { withController: true, withExposure: true, withPrefs: true };
  }
});

// ../../node_modules/@polkadot/api-derive/staking/cache.js
function getEraCache(CACHE_KEY6, era, withActive) {
  const cacheKey = `${CACHE_KEY6}-${era.toString()}`;
  return [
    cacheKey,
    withActive ? void 0 : deriveCache.get(cacheKey)
  ];
}
function getEraMultiCache(CACHE_KEY6, eras, withActive) {
  const cached = withActive ? [] : eras.map((e2) => deriveCache.get(`${CACHE_KEY6}-${e2.toString()}`)).filter((v) => !!v);
  return cached;
}
function setEraCache(cacheKey, withActive, value) {
  !withActive && deriveCache.set(cacheKey, value);
  return value;
}
function setEraMultiCache(CACHE_KEY6, withActive, values) {
  !withActive && values.forEach((v) => deriveCache.set(`${CACHE_KEY6}-${v.era.toString()}`, v));
  return values;
}
function filterCachedEras(eras, cached, query2) {
  return eras.map((e2) => cached.find(({ era }) => e2.eq(era)) || query2.find(({ era }) => e2.eq(era))).filter((e2) => !!e2);
}
var init_cache2 = __esm({
  "../../node_modules/@polkadot/api-derive/staking/cache.js"() {
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/util.js
function chunkEras(eras, fn) {
  const chunked = arrayChunk(eras, ERA_CHUNK_SIZE);
  let index = 0;
  const subject = new import_rxjs64.BehaviorSubject(chunked[index]);
  return subject.pipe((0, import_rxjs64.switchMap)(fn), (0, import_rxjs64.tap)(() => {
    nextTick(() => {
      index++;
      index === chunked.length ? subject.complete() : subject.next(chunked[index]);
    });
  }), (0, import_rxjs64.toArray)(), (0, import_rxjs64.map)(arrayFlatten));
}
function filterEras(eras, list) {
  return eras.filter((e2) => !list.some(({ era }) => e2.eq(era)));
}
function erasHistoricApply(fn) {
  return (instanceId, api) => (
    // Cannot quite get the typing right, but it is right in the code
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    memo(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, import_rxjs64.switchMap)((e2) => api.derive.staking[fn](e2, withActive))))
  );
}
function erasHistoricApplyAccount(fn) {
  return (instanceId, api) => (
    // Cannot quite get the typing right, but it is right in the code
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    memo(instanceId, (accountId2, withActive = false, page) => api.derive.staking.erasHistoric(withActive).pipe((0, import_rxjs64.switchMap)((e2) => api.derive.staking[fn](accountId2, e2, withActive, page || 0))))
  );
}
function singleEra(fn) {
  return (instanceId, api) => (
    // Cannot quite get the typing right, but it is right in the code
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    memo(instanceId, (era) => api.derive.staking[fn](era, true))
  );
}
function combineEras(fn) {
  return (instanceId, api) => (
    // Cannot quite get the typing right, but it is right in the code
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    memo(instanceId, (eras, withActive) => !eras.length ? (0, import_rxjs64.of)([]) : chunkEras(eras, (eras2) => (0, import_rxjs64.combineLatest)(eras2.map((e2) => api.derive.staking[fn](e2, withActive)))))
  );
}
var import_rxjs64, ERA_CHUNK_SIZE;
var init_util17 = __esm({
  "../../node_modules/@polkadot/api-derive/staking/util.js"() {
    import_rxjs64 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    ERA_CHUNK_SIZE = 14;
  }
});

// ../../node_modules/@polkadot/api-derive/staking/erasExposure.js
function mapStakersClipped(era, stakers) {
  const nominators = {};
  const validators2 = {};
  stakers.forEach(([key, exposure]) => {
    const validatorId = key.args[1].toString();
    validators2[validatorId] = exposure;
    exposure.others.forEach(({ who }, validatorIndex) => {
      const nominatorId = who.toString();
      nominators[nominatorId] = nominators[nominatorId] || [];
      nominators[nominatorId].push({ validatorId, validatorIndex });
    });
  });
  return { era, nominators, validators: validators2 };
}
function mapStakersPaged(era, stakers) {
  const nominators = {};
  const validators2 = {};
  stakers.forEach(([key, exposureOpt]) => {
    if (exposureOpt.isSome) {
      const validatorId = key.args[1].toString();
      const exposure = exposureOpt.unwrap();
      validators2[validatorId] = exposure;
      exposure.others.forEach(({ who }, validatorIndex) => {
        const nominatorId = who.toString();
        nominators[nominatorId] = nominators[nominatorId] || [];
        nominators[nominatorId].push({ validatorId, validatorIndex });
      });
    }
  });
  return { era, nominators, validators: validators2 };
}
function _eraExposure(instanceId, api) {
  return memo(instanceId, (era, withActive = false) => {
    const [cacheKey, cached] = getEraCache(CACHE_KEY, era, withActive);
    return cached ? (0, import_rxjs65.of)(cached) : api.query.staking.erasStakersPaged ? api.query.staking.erasStakersPaged.entries(era).pipe((0, import_rxjs65.map)((r2) => setEraCache(cacheKey, withActive, mapStakersPaged(era, r2)))) : api.query.staking.erasStakersClipped.entries(era).pipe((0, import_rxjs65.map)((r2) => setEraCache(cacheKey, withActive, mapStakersClipped(era, r2))));
  });
}
var import_rxjs65, CACHE_KEY, eraExposure, _erasExposure, erasExposure;
var init_erasExposure = __esm({
  "../../node_modules/@polkadot/api-derive/staking/erasExposure.js"() {
    import_rxjs65 = __toESM(require_cjs(), 1);
    init_util10();
    init_cache2();
    init_util17();
    CACHE_KEY = "eraExposure";
    eraExposure = /* @__PURE__ */ singleEra("_eraExposure");
    _erasExposure = /* @__PURE__ */ combineEras("_eraExposure");
    erasExposure = /* @__PURE__ */ erasHistoricApply("_erasExposure");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/erasHistoric.js
function erasHistoric(instanceId, api) {
  return memo(instanceId, (withActive) => (0, import_rxjs66.combineLatest)([
    api.query.staking.activeEra(),
    api.consts.staking.historyDepth ? (0, import_rxjs66.of)(api.consts.staking.historyDepth) : api.query.staking["historyDepth"]()
  ]).pipe((0, import_rxjs66.map)(([activeEraOpt, historyDepth]) => {
    const result = [];
    const max2 = historyDepth.toNumber();
    const activeEra = activeEraOpt.unwrapOrDefault().index;
    let lastEra = activeEra;
    while (lastEra.gte(BN_ZERO) && result.length < max2) {
      if (lastEra !== activeEra || withActive === true) {
        result.push(api.registry.createType("EraIndex", lastEra));
      }
      lastEra = lastEra.sub(BN_ONE);
    }
    return result.reverse();
  })));
}
var import_rxjs66;
var init_erasHistoric = __esm({
  "../../node_modules/@polkadot/api-derive/staking/erasHistoric.js"() {
    import_rxjs66 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/erasPoints.js
function mapValidators({ individual }) {
  return [...individual.entries()].filter(([, points]) => points.gt(BN_ZERO)).reduce((result, [validatorId, points]) => {
    result[validatorId.toString()] = points;
    return result;
  }, {});
}
function mapPoints(eras, points) {
  return eras.map((era, index) => ({
    era,
    eraPoints: points[index].total,
    validators: mapValidators(points[index])
  }));
}
function _erasPoints(instanceId, api) {
  return memo(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return (0, import_rxjs67.of)([]);
    }
    const cached = getEraMultiCache(CACHE_KEY2, eras, withActive);
    const remaining = filterEras(eras, cached);
    return !remaining.length ? (0, import_rxjs67.of)(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe((0, import_rxjs67.map)((p) => filterCachedEras(eras, cached, setEraMultiCache(CACHE_KEY2, withActive, mapPoints(remaining, p)))));
  });
}
var import_rxjs67, CACHE_KEY2, erasPoints;
var init_erasPoints = __esm({
  "../../node_modules/@polkadot/api-derive/staking/erasPoints.js"() {
    import_rxjs67 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_cache2();
    init_util17();
    CACHE_KEY2 = "eraPoints";
    erasPoints = /* @__PURE__ */ erasHistoricApply("_erasPoints");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/erasPrefs.js
function mapPrefs(era, all3) {
  const validators2 = {};
  all3.forEach(([key, prefs]) => {
    validators2[key.args[1].toString()] = prefs;
  });
  return { era, validators: validators2 };
}
function _eraPrefs(instanceId, api) {
  return memo(instanceId, (era, withActive) => {
    const [cacheKey, cached] = getEraCache(CACHE_KEY3, era, withActive);
    return cached ? (0, import_rxjs68.of)(cached) : api.query.staking.erasValidatorPrefs.entries(era).pipe((0, import_rxjs68.map)((r2) => setEraCache(cacheKey, withActive, mapPrefs(era, r2))));
  });
}
var import_rxjs68, CACHE_KEY3, eraPrefs, _erasPrefs, erasPrefs;
var init_erasPrefs = __esm({
  "../../node_modules/@polkadot/api-derive/staking/erasPrefs.js"() {
    import_rxjs68 = __toESM(require_cjs(), 1);
    init_util10();
    init_cache2();
    init_util17();
    CACHE_KEY3 = "eraPrefs";
    eraPrefs = /* @__PURE__ */ singleEra("_eraPrefs");
    _erasPrefs = /* @__PURE__ */ combineEras("_eraPrefs");
    erasPrefs = /* @__PURE__ */ erasHistoricApply("_erasPrefs");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/erasRewards.js
function mapRewards(eras, optRewards) {
  return eras.map((era, index) => ({
    era,
    eraReward: optRewards[index].unwrapOrDefault()
  }));
}
function _erasRewards(instanceId, api) {
  return memo(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return (0, import_rxjs69.of)([]);
    }
    const cached = getEraMultiCache(CACHE_KEY4, eras, withActive);
    const remaining = filterEras(eras, cached);
    if (!remaining.length) {
      return (0, import_rxjs69.of)(cached);
    }
    return api.query.staking.erasValidatorReward.multi(remaining).pipe((0, import_rxjs69.map)((r2) => filterCachedEras(eras, cached, setEraMultiCache(CACHE_KEY4, withActive, mapRewards(remaining, r2)))));
  });
}
var import_rxjs69, CACHE_KEY4, erasRewards;
var init_erasRewards = __esm({
  "../../node_modules/@polkadot/api-derive/staking/erasRewards.js"() {
    import_rxjs69 = __toESM(require_cjs(), 1);
    init_util10();
    init_cache2();
    init_util17();
    CACHE_KEY4 = "eraRewards";
    erasRewards = /* @__PURE__ */ erasHistoricApply("_erasRewards");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/erasSlashes.js
function mapSlashes(era, noms, vals) {
  const nominators = {};
  const validators2 = {};
  noms.forEach(([key, optBalance]) => {
    nominators[key.args[1].toString()] = optBalance.unwrap();
  });
  vals.forEach(([key, optRes]) => {
    validators2[key.args[1].toString()] = optRes.unwrapOrDefault()[1];
  });
  return { era, nominators, validators: validators2 };
}
function _eraSlashes(instanceId, api) {
  return memo(instanceId, (era, withActive) => {
    const [cacheKey, cached] = getEraCache(CACHE_KEY5, era, withActive);
    return cached ? (0, import_rxjs70.of)(cached) : (0, import_rxjs70.combineLatest)([
      api.query.staking.nominatorSlashInEra.entries(era),
      api.query.staking.validatorSlashInEra.entries(era)
    ]).pipe((0, import_rxjs70.map)(([n, v]) => setEraCache(cacheKey, withActive, mapSlashes(era, n, v))));
  });
}
var import_rxjs70, CACHE_KEY5, eraSlashes, _erasSlashes, erasSlashes;
var init_erasSlashes = __esm({
  "../../node_modules/@polkadot/api-derive/staking/erasSlashes.js"() {
    import_rxjs70 = __toESM(require_cjs(), 1);
    init_util10();
    init_cache2();
    init_util17();
    CACHE_KEY5 = "eraSlashes";
    eraSlashes = /* @__PURE__ */ singleEra("_eraSlashes");
    _erasSlashes = /* @__PURE__ */ combineEras("_eraSlashes");
    erasSlashes = /* @__PURE__ */ erasHistoricApply("_erasSlashes");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/keys.js
function extractsIds(stashId, queuedKeys, nextKeys) {
  const sessionIds = (queuedKeys.find(([currentId]) => currentId.eq(stashId)) || [void 0, []])[1];
  const nextSessionIds = nextKeys.unwrapOr([]);
  return {
    nextSessionIds: Array.isArray(nextSessionIds) ? nextSessionIds : [...nextSessionIds.values()],
    sessionIds: Array.isArray(sessionIds) ? sessionIds : [...sessionIds.values()]
  };
}
function keysMulti(instanceId, api) {
  return memo(instanceId, (stashIds) => stashIds.length ? api.query.session.queuedKeys().pipe((0, import_rxjs71.switchMap)((queuedKeys) => (0, import_rxjs71.combineLatest)([
    (0, import_rxjs71.of)(queuedKeys),
    api.consts["session"]?.["dedupKeyPrefix"] ? api.query.session.nextKeys.multi(stashIds.map((s2) => [api.consts["session"]["dedupKeyPrefix"], s2])) : (0, import_rxjs71.combineLatest)(stashIds.map((s2) => api.query.session.nextKeys(s2)))
  ])), (0, import_rxjs71.map)(([queuedKeys, nextKeys]) => stashIds.map((stashId, index) => extractsIds(stashId, queuedKeys, nextKeys[index])))) : (0, import_rxjs71.of)([]));
}
var import_rxjs71, keys;
var init_keys = __esm({
  "../../node_modules/@polkadot/api-derive/staking/keys.js"() {
    import_rxjs71 = __toESM(require_cjs(), 1);
    init_util10();
    keys = /* @__PURE__ */ firstMemo((api, stashId) => api.derive.staking.keysMulti([stashId]));
  }
});

// ../../node_modules/@polkadot/api-derive/staking/overview.js
function overview2(instanceId, api) {
  return memo(instanceId, () => (0, import_rxjs72.combineLatest)([
    api.derive.session.indexes(),
    api.derive.staking.validators()
  ]).pipe((0, import_rxjs72.map)(([indexes3, { nextElected: nextElected2, validators: validators2 }]) => objectSpread({}, indexes3, {
    nextElected: nextElected2,
    validators: validators2
  }))));
}
var import_rxjs72;
var init_overview2 = __esm({
  "../../node_modules/@polkadot/api-derive/staking/overview.js"() {
    import_rxjs72 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/ownExposure.js
function _ownExposures(instanceId, api) {
  return memo(instanceId, (accountId2, eras, _withActive, page) => {
    const emptyStakingExposure = api.registry.createType("Exposure");
    const emptyOptionPage = api.registry.createType("Option<Null>");
    const emptyOptionMeta = api.registry.createType("Option<Null>");
    return eras.length ? (0, import_rxjs73.combineLatest)([
      // Backwards and forward compat for historical integrity when using `erasHistoricApplyAccount`
      api.query.staking.erasStakersClipped ? (0, import_rxjs73.combineLatest)(eras.map((e2) => api.query.staking.erasStakersClipped(e2, accountId2))) : (0, import_rxjs73.of)(eras.map((_) => emptyStakingExposure)),
      api.query.staking.erasStakers ? (0, import_rxjs73.combineLatest)(eras.map((e2) => api.query.staking.erasStakers(e2, accountId2))) : (0, import_rxjs73.of)(eras.map((_) => emptyStakingExposure)),
      api.query.staking.erasStakersPaged ? (0, import_rxjs73.combineLatest)(eras.map((e2) => api.query.staking.erasStakersPaged(e2, accountId2, page))) : (0, import_rxjs73.of)(eras.map((_) => emptyOptionPage)),
      api.query.staking.erasStakersOverview ? (0, import_rxjs73.combineLatest)(eras.map((e2) => api.query.staking.erasStakersOverview(e2, accountId2))) : (0, import_rxjs73.of)(eras.map((_) => emptyOptionMeta))
    ]).pipe((0, import_rxjs73.map)(([clp, exp, paged, expMeta]) => eras.map((era, index) => ({ clipped: clp[index], era, exposure: exp[index], exposureMeta: expMeta[index], exposurePaged: paged[index] })))) : (0, import_rxjs73.of)([]);
  });
}
var import_rxjs73, ownExposure, ownExposures;
var init_ownExposure = __esm({
  "../../node_modules/@polkadot/api-derive/staking/ownExposure.js"() {
    import_rxjs73 = __toESM(require_cjs(), 1);
    init_util10();
    init_util17();
    ownExposure = /* @__PURE__ */ firstMemo((api, accountId2, era, page) => api.derive.staking._ownExposures(accountId2, [era], true, page || 0));
    ownExposures = /* @__PURE__ */ erasHistoricApplyAccount("_ownExposures");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/ownSlashes.js
function _ownSlashes(instanceId, api) {
  return memo(instanceId, (accountId2, eras, _withActive) => eras.length ? (0, import_rxjs74.combineLatest)([
    (0, import_rxjs74.combineLatest)(eras.map((e2) => api.query.staking.validatorSlashInEra(e2, accountId2))),
    (0, import_rxjs74.combineLatest)(eras.map((e2) => api.query.staking.nominatorSlashInEra(e2, accountId2)))
  ]).pipe((0, import_rxjs74.map)(([vals, noms]) => eras.map((era, index) => ({
    era,
    total: vals[index].isSome ? vals[index].unwrap()[1] : noms[index].unwrapOrDefault()
  })))) : (0, import_rxjs74.of)([]));
}
var import_rxjs74, ownSlash, ownSlashes;
var init_ownSlashes = __esm({
  "../../node_modules/@polkadot/api-derive/staking/ownSlashes.js"() {
    import_rxjs74 = __toESM(require_cjs(), 1);
    init_util10();
    init_util17();
    ownSlash = /* @__PURE__ */ firstMemo((api, accountId2, era) => api.derive.staking._ownSlashes(accountId2, [era], true));
    ownSlashes = /* @__PURE__ */ erasHistoricApplyAccount("_ownSlashes");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/query.js
function rewardDestinationCompat(rewardDestination) {
  return typeof rewardDestination.isSome === "boolean" ? rewardDestination.unwrapOr(null) : rewardDestination;
}
function filterClaimedRewards(api, cl) {
  return api.registry.createType("Vec<u32>", cl.filter((c) => c !== -1));
}
function filterRewards(stashIds, eras, claimedRewards, stakersOverview) {
  const claimedData = {};
  const overviewData = {};
  const ids = stashIds.map((i2) => i2.toString());
  claimedRewards.forEach(([keys2, rewards]) => {
    const id = keys2.args[1].toString();
    const era = keys2.args[0].toNumber();
    if (ids.includes(id)) {
      if (claimedData[id]) {
        claimedData[id].set(era, rewards.toArray());
      } else {
        claimedData[id] = /* @__PURE__ */ new Map();
        claimedData[id].set(era, rewards.toArray());
      }
    }
  });
  stakersOverview.forEach(([keys2, overview3]) => {
    const id = keys2.args[1].toString();
    const era = keys2.args[0].toNumber();
    if (ids.includes(id) && overview3.isSome) {
      if (overviewData[id]) {
        overviewData[id].set(era, overview3.unwrap().pageCount);
      } else {
        overviewData[id] = /* @__PURE__ */ new Map();
        overviewData[id].set(era, overview3.unwrap().pageCount);
      }
    }
  });
  return stashIds.map((id) => {
    const rewardsPerEra = claimedData[id.toString()];
    const overviewPerEra = overviewData[id.toString()];
    return eras.map((era) => {
      if (rewardsPerEra && rewardsPerEra.has(era) && overviewPerEra && overviewPerEra.has(era)) {
        const rewards = rewardsPerEra.get(era);
        const pageCount = overviewPerEra.get(era);
        return rewards.length === pageCount.toNumber() ? era : -1;
      }
      return -1;
    });
  });
}
function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers) {
  return {
    accountId: stashId,
    claimedRewardsEras: filterClaimedRewards(api, claimedRewards),
    controllerId: controllerIdOpt?.unwrapOr(null) || null,
    exposureEraStakers,
    exposureMeta,
    exposurePaged: exposure,
    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],
    rewardDestination: rewardDestinationCompat(rewardDestinationOpts),
    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
    stashId,
    validatorPrefs
  };
}
function getLedgers(api, optIds, { withLedger = false }) {
  const ids = optIds.filter((o) => withLedger && !!o && o.isSome).map((o) => o.unwrap());
  const emptyLed = api.registry.createType("Option<StakingLedger>");
  return (ids.length ? (0, import_rxjs75.combineLatest)(ids.map((s2) => api.query.staking.ledger(s2))) : (0, import_rxjs75.of)([])).pipe((0, import_rxjs75.map)((optLedgers) => {
    let offset = -1;
    return optIds.map((o) => o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);
  }));
}
function getStashInfo(api, stashIds, activeEra, { withClaimedRewardsEras, withController, withDestination, withExposure, withExposureErasStakersLegacy, withExposureMeta, withLedger, withNominations, withPrefs }, page) {
  const emptyNoms = api.registry.createType("Option<Nominations>");
  const emptyRewa = api.registry.createType("RewardDestination");
  const emptyExpoEraStakers = api.registry.createType("Exposure");
  const emptyPrefs = api.registry.createType("ValidatorPrefs");
  const emptyExpo = api.registry.createType("Option<Null>");
  const emptyExpoMeta = api.registry.createType("Option<Null>");
  const emptyClaimedRewards = [-1];
  const depth = Number(api.consts.staking.historyDepth.toNumber());
  const eras = new Array(depth).fill(0).map((_, idx) => {
    if (idx === 0) {
      return activeEra.toNumber() - 1;
    }
    return activeEra.toNumber() - idx - 1;
  });
  return (0, import_rxjs75.combineLatest)([
    withController || withLedger ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.bonded(s2))) : (0, import_rxjs75.of)(stashIds.map(() => null)),
    withNominations ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.nominators(s2))) : (0, import_rxjs75.of)(stashIds.map(() => emptyNoms)),
    withDestination ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.payee(s2))) : (0, import_rxjs75.of)(stashIds.map(() => emptyRewa)),
    withPrefs ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.validators(s2))) : (0, import_rxjs75.of)(stashIds.map(() => emptyPrefs)),
    withExposure && api.query.staking.erasStakersPaged ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.erasStakersPaged(activeEra, s2, page))) : (0, import_rxjs75.of)(stashIds.map(() => emptyExpo)),
    withExposureMeta && api.query.staking.erasStakersOverview ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.erasStakersOverview(activeEra, s2))) : (0, import_rxjs75.of)(stashIds.map(() => emptyExpoMeta)),
    withClaimedRewardsEras && api.query.staking.claimedRewards ? (0, import_rxjs75.combineLatest)([
      api.query.staking.claimedRewards.entries(),
      api.query.staking.erasStakersOverview.entries()
    ]).pipe((0, import_rxjs75.map)(([rewardsStorageVec, overviewStorageVec]) => filterRewards(stashIds, eras, rewardsStorageVec, overviewStorageVec))) : (0, import_rxjs75.of)(stashIds.map(() => emptyClaimedRewards)),
    withExposureErasStakersLegacy && api.query.staking.erasStakers ? (0, import_rxjs75.combineLatest)(stashIds.map((s2) => api.query.staking.erasStakers(activeEra, s2))) : (0, import_rxjs75.of)(stashIds.map(() => emptyExpoEraStakers))
  ]);
}
function getBatch(api, activeEra, stashIds, flags2, page) {
  return getStashInfo(api, stashIds, activeEra, flags2, page).pipe((0, import_rxjs75.switchMap)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers]) => getLedgers(api, controllerIdOpt, flags2).pipe((0, import_rxjs75.map)((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index]))))));
}
function queryMulti(instanceId, api) {
  return memo(instanceId, (accountIds, flags2, page) => api.derive.session.indexes().pipe((0, import_rxjs75.switchMap)(({ activeEra }) => {
    const stashIds = accountIds.map((a) => api.registry.createType("AccountId", a));
    const p = page || 0;
    return stashIds.length ? getBatch(api, activeEra, stashIds, flags2, p) : (0, import_rxjs75.of)([]);
  })));
}
var import_rxjs75, query;
var init_query = __esm({
  "../../node_modules/@polkadot/api-derive/staking/query.js"() {
    import_rxjs75 = __toESM(require_cjs(), 1);
    init_util10();
    query = /* @__PURE__ */ firstMemo((api, accountId2, flags2, page) => api.derive.staking.queryMulti([accountId2], flags2, page));
  }
});

// ../../node_modules/@polkadot/api-derive/staking/stakerExposure.js
function _stakerExposures(instanceId, api) {
  return memo(instanceId, (accountIds, eras, withActive = false) => {
    const stakerIds = accountIds.map((a) => api.registry.createType("AccountId", a).toString());
    return api.derive.staking._erasExposure(eras, withActive).pipe((0, import_rxjs76.map)((exposures) => stakerIds.map((stakerId) => exposures.map(({ era, nominators: allNominators, validators: allValidators }) => {
      const isValidator = !!allValidators[stakerId];
      const validators2 = {};
      const nominating = allNominators[stakerId] || [];
      if (isValidator) {
        validators2[stakerId] = allValidators[stakerId];
      } else if (nominating) {
        nominating.forEach(({ validatorId }) => {
          validators2[validatorId] = allValidators[validatorId];
        });
      }
      return { era, isEmpty: !Object.keys(validators2).length, isValidator, nominating, validators: validators2 };
    }))));
  });
}
function stakerExposures(instanceId, api) {
  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, import_rxjs76.switchMap)((eras) => api.derive.staking._stakerExposures(accountIds, eras, withActive))));
}
var import_rxjs76, stakerExposure;
var init_stakerExposure = __esm({
  "../../node_modules/@polkadot/api-derive/staking/stakerExposure.js"() {
    import_rxjs76 = __toESM(require_cjs(), 1);
    init_util10();
    stakerExposure = /* @__PURE__ */ firstMemo((api, accountId2, withActive) => api.derive.staking.stakerExposures([accountId2], withActive));
  }
});

// ../../node_modules/@polkadot/api-derive/staking/stakerPoints.js
function _stakerPoints(instanceId, api) {
  return memo(instanceId, (accountId2, eras, withActive) => {
    const stakerId = api.registry.createType("AccountId", accountId2).toString();
    return api.derive.staking._erasPoints(eras, withActive).pipe((0, import_rxjs77.map)((points) => points.map(({ era, eraPoints, validators: validators2 }) => ({
      era,
      eraPoints,
      points: validators2[stakerId] || api.registry.createType("RewardPoint")
    }))));
  });
}
var import_rxjs77, stakerPoints;
var init_stakerPoints = __esm({
  "../../node_modules/@polkadot/api-derive/staking/stakerPoints.js"() {
    import_rxjs77 = __toESM(require_cjs(), 1);
    init_util10();
    init_util17();
    stakerPoints = /* @__PURE__ */ erasHistoricApplyAccount("_stakerPoints");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/stakerPrefs.js
function _stakerPrefs(instanceId, api) {
  return memo(instanceId, (accountId2, eras, _withActive) => api.query.staking.erasValidatorPrefs.multi(eras.map((e2) => [e2, accountId2])).pipe((0, import_rxjs78.map)((all3) => all3.map((validatorPrefs, index) => ({
    era: eras[index],
    validatorPrefs
  })))));
}
var import_rxjs78, stakerPrefs;
var init_stakerPrefs = __esm({
  "../../node_modules/@polkadot/api-derive/staking/stakerPrefs.js"() {
    import_rxjs78 = __toESM(require_cjs(), 1);
    init_util10();
    init_util17();
    stakerPrefs = /* @__PURE__ */ erasHistoricApplyAccount("_stakerPrefs");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/stakerRewards.js
function extractCompatRewards(claimedRewardsEras, ledger) {
  const l15 = ledger ? (ledger.legacyClaimedRewards || ledger.claimedRewards).toArray() : [];
  return claimedRewardsEras.toArray().concat(l15);
}
function parseRewards(api, stashId, [erasPoints2, erasPrefs2, erasRewards2], exposures, claimedRewardsEras) {
  return exposures.map(({ era, isEmpty, isValidator, nominating, validators: eraValidators }) => {
    const { eraPoints, validators: allValPoints } = erasPoints2.find((p) => p.era.eq(era)) || { eraPoints: BN_ZERO, validators: {} };
    const { eraReward } = erasRewards2.find((r2) => r2.era.eq(era)) || { eraReward: api.registry.createType("Balance") };
    const { validators: allValPrefs } = erasPrefs2.find((p) => p.era.eq(era)) || { validators: {} };
    const validators2 = {};
    const stakerId = stashId.toString();
    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {
      const valPoints = allValPoints[validatorId] || BN_ZERO;
      const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;
      const expTotal = exposure.total ? exposure.total?.unwrap() : exposure.pageTotal ? exposure.pageTotal?.unwrap() : BN_ZERO;
      let avail = BN_ZERO;
      let value;
      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {
        avail = eraReward.mul(valPoints).div(eraPoints);
        const valCut = valComm.mul(avail).div(BN_BILLION);
        let staked;
        if (validatorId === stakerId) {
          if (exposure.own) {
            staked = exposure.own.unwrap();
          } else {
            const expAccount = exposure.others.find(({ who }) => who.eq(validatorId));
            staked = expAccount ? expAccount.value.unwrap() : BN_ZERO;
          }
        } else {
          const stakerExp = exposure.others.find(({ who }) => who.eq(stakerId));
          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;
        }
        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);
      }
      validators2[validatorId] = {
        total: api.registry.createType("Balance", avail),
        value: api.registry.createType("Balance", value)
      };
    });
    return {
      era,
      eraReward,
      // This might not always be accurate as you need validator account information in order to see if the rewards have been claimed.
      // This is possibly adjusted in `filterRewards` when need be.
      isClaimed: claimedRewardsEras.some((c) => c.eq(era)),
      isEmpty,
      isValidator,
      nominating,
      validators: validators2
    };
  });
}
function allUniqValidators(rewards) {
  return rewards.reduce(([all3, perStash], rewards2) => {
    const uniq = [];
    perStash.push(uniq);
    rewards2.forEach(({ validators: validators2 }) => Object.keys(validators2).forEach((validatorId) => {
      if (!uniq.includes(validatorId)) {
        uniq.push(validatorId);
        if (!all3.includes(validatorId)) {
          all3.push(validatorId);
        }
      }
    }));
    return [all3, perStash];
  }, [[], []]);
}
function removeClaimed(validators2, queryValidators, reward, claimedRewardsEras) {
  const rm = [];
  Object.keys(reward.validators).forEach((validatorId) => {
    const index = validators2.indexOf(validatorId);
    if (index !== -1) {
      const valLedger = queryValidators[index].stakingLedger;
      if (extractCompatRewards(claimedRewardsEras, valLedger).some((e2) => reward.era.eq(e2))) {
        rm.push(validatorId);
      }
    }
  });
  rm.forEach((validatorId) => {
    delete reward.validators[validatorId];
  });
}
function filterRewards2(eras, valInfo, { claimedRewardsEras, rewards, stakingLedger }) {
  const filter = eras.filter((e2) => !extractCompatRewards(claimedRewardsEras, stakingLedger).some((s2) => s2.eq(e2)));
  const validators2 = valInfo.map(([v]) => v);
  const queryValidators = valInfo.map(([, q]) => q);
  return rewards.filter(({ isEmpty }) => !isEmpty).filter((reward) => {
    if (!filter.some((e2) => reward.era.eq(e2))) {
      return false;
    }
    removeClaimed(validators2, queryValidators, reward, claimedRewardsEras);
    return true;
  }).filter(({ validators: validators3 }) => Object.keys(validators3).length !== 0).map((reward) => {
    let isClaimed = reward.isClaimed;
    const valKeys = Object.keys(reward.validators);
    if (!reward.isClaimed && valKeys.length) {
      for (const key of valKeys) {
        const info6 = queryValidators.find((i2) => i2.accountId.toString() === key);
        if (info6) {
          isClaimed = info6.claimedRewardsEras.toArray().some((era) => era.eq(reward.era));
          break;
        }
      }
    }
    return objectSpread({}, reward, {
      isClaimed,
      nominators: reward.nominating.filter((n) => reward.validators[n.validatorId])
    });
  });
}
function _stakerRewardsEras(instanceId, api) {
  return memo(instanceId, (eras, withActive = false) => (0, import_rxjs79.combineLatest)([
    api.derive.staking._erasPoints(eras, withActive),
    api.derive.staking._erasPrefs(eras, withActive),
    api.derive.staking._erasRewards(eras, withActive)
  ]));
}
function _stakerRewards(instanceId, api) {
  return memo(instanceId, (accountIds, eras, withActive = false) => {
    const sanitizedEras = eras.map((e2) => typeof e2 === "number" || typeof e2 === "string" ? api.registry.createType("u32", e2) : e2);
    return (0, import_rxjs79.combineLatest)([
      api.derive.staking.queryMulti(accountIds, { withClaimedRewardsEras: true, withLedger: true }),
      api.derive.staking._stakerExposures(accountIds, sanitizedEras, withActive),
      api.derive.staking._stakerRewardsEras(sanitizedEras, withActive)
    ]).pipe((0, import_rxjs79.switchMap)(([queries, exposures, erasResult]) => {
      const allRewards = queries.map(({ claimedRewardsEras, stakingLedger, stashId }, index) => !stashId || !stakingLedger && !claimedRewardsEras ? [] : parseRewards(api, stashId, erasResult, exposures[index], claimedRewardsEras));
      if (withActive) {
        return (0, import_rxjs79.of)(allRewards);
      }
      const [allValidators, stashValidators] = allUniqValidators(allRewards);
      return api.derive.staking.queryMulti(allValidators, { withClaimedRewardsEras: true, withLedger: true }).pipe((0, import_rxjs79.map)((queriedVals) => queries.map(({ claimedRewardsEras, stakingLedger }, index) => filterRewards2(eras, stashValidators[index].map((validatorId) => [
        validatorId,
        queriedVals.find((q) => q.accountId.eq(validatorId))
      ]).filter((v) => !!v[1]), {
        claimedRewardsEras,
        rewards: allRewards[index],
        stakingLedger
      }))));
    }));
  });
}
function stakerRewardsMultiEras(instanceId, api) {
  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : (0, import_rxjs79.of)([]));
}
function stakerRewardsMulti(instanceId, api) {
  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, import_rxjs79.switchMap)((eras) => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));
}
var import_rxjs79, stakerRewards;
var init_stakerRewards = __esm({
  "../../node_modules/@polkadot/api-derive/staking/stakerRewards.js"() {
    import_rxjs79 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    stakerRewards = /* @__PURE__ */ firstMemo((api, accountId2, withActive) => api.derive.staking.erasHistoric(withActive).pipe((0, import_rxjs79.switchMap)((eras) => api.derive.staking._stakerRewards([accountId2], eras, withActive))));
  }
});

// ../../node_modules/@polkadot/api-derive/staking/stakerSlashes.js
function _stakerSlashes(instanceId, api) {
  return memo(instanceId, (accountId2, eras, withActive) => {
    const stakerId = api.registry.createType("AccountId", accountId2).toString();
    return api.derive.staking._erasSlashes(eras, withActive).pipe((0, import_rxjs80.map)((slashes) => slashes.map(({ era, nominators, validators: validators2 }) => ({
      era,
      total: nominators[stakerId] || validators2[stakerId] || api.registry.createType("Balance")
    }))));
  });
}
var import_rxjs80, stakerSlashes;
var init_stakerSlashes = __esm({
  "../../node_modules/@polkadot/api-derive/staking/stakerSlashes.js"() {
    import_rxjs80 = __toESM(require_cjs(), 1);
    init_util10();
    init_util17();
    stakerSlashes = /* @__PURE__ */ erasHistoricApplyAccount("_stakerSlashes");
  }
});

// ../../node_modules/@polkadot/api-derive/staking/stashes.js
function onBondedEvent(api) {
  let current = Date.now();
  return api.query.system.events().pipe((0, import_rxjs81.map)((events2) => {
    current = events2.filter(({ event, phase }) => {
      try {
        return phase.isApplyExtrinsic && event.section === "staking" && event.method === "Bonded";
      } catch {
        return false;
      }
    }) ? Date.now() : current;
    return current;
  }), (0, import_rxjs81.startWith)(current), drr({ skipTimeout: true }));
}
function stashes(instanceId, api) {
  return memo(instanceId, () => onBondedEvent(api).pipe((0, import_rxjs81.switchMap)(() => api.query.staking.validators.keys()), (0, import_rxjs81.map)((keys2) => keys2.map(({ args: [v] }) => v).filter((a) => a))));
}
var import_rxjs81;
var init_stashes = __esm({
  "../../node_modules/@polkadot/api-derive/staking/stashes.js"() {
    import_rxjs81 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/validators.js
function nextElected(instanceId, api) {
  return memo(instanceId, () => (
    // Compatibility for future generation changes in staking.
    api.query.staking.erasStakersOverview ? api.derive.session.indexes().pipe(
      // only populate for next era in the last session, so track both here - entries are not
      // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
      (0, import_rxjs82.switchMap)(({ currentEra }) => api.query.staking.erasStakersOverview.keys(currentEra)),
      // Dedupe any duplicates
      (0, import_rxjs82.map)((keys2) => [...new Set(keys2.map(({ args: [, accountId2] }) => accountId2.toString()))].map((a) => api.registry.createType("AccountId", a)))
    ) : api.query.staking.erasStakers ? api.derive.session.indexes().pipe(
      // only populate for next era in the last session, so track both here - entries are not
      // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
      (0, import_rxjs82.switchMap)(({ currentEra }) => api.query.staking.erasStakers.keys(currentEra)),
      // Dedupe any duplicates
      (0, import_rxjs82.map)((keys2) => [...new Set(keys2.map(({ args: [, accountId2] }) => accountId2.toString()))].map((a) => api.registry.createType("AccountId", a)))
    ) : api.query.staking["currentElected"]()
  ));
}
function validators(instanceId, api) {
  return memo(instanceId, () => (
    // Sadly the node-template is (for some obscure reason) not comprehensive, so while the derive works
    // in all actual real-world deployed chains, it does create some confusion for limited template chains
    (0, import_rxjs82.combineLatest)([
      api.query.session ? api.query.session.validators() : (0, import_rxjs82.of)([]),
      api.query.staking ? api.derive.staking.nextElected() : (0, import_rxjs82.of)([])
    ]).pipe((0, import_rxjs82.map)(([validators2, nextElected2]) => ({
      nextElected: nextElected2.length ? nextElected2 : validators2,
      validators: validators2
    })))
  ));
}
var import_rxjs82;
var init_validators = __esm({
  "../../node_modules/@polkadot/api-derive/staking/validators.js"() {
    import_rxjs82 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/staking/waitingInfo.js
function waitingInfo(instanceId, api) {
  return memo(instanceId, (flags2 = DEFAULT_FLAGS2) => (0, import_rxjs83.combineLatest)([
    api.derive.staking.validators(),
    api.derive.staking.stashes()
  ]).pipe((0, import_rxjs83.switchMap)(([{ nextElected: nextElected2 }, stashes2]) => {
    const elected = nextElected2.map((a) => a.toString());
    const waiting = stashes2.filter((v) => !elected.includes(v.toString()));
    return api.derive.staking.queryMulti(waiting, flags2).pipe((0, import_rxjs83.map)((info6) => ({
      info: info6,
      waiting
    })));
  })));
}
var import_rxjs83, DEFAULT_FLAGS2;
var init_waitingInfo = __esm({
  "../../node_modules/@polkadot/api-derive/staking/waitingInfo.js"() {
    import_rxjs83 = __toESM(require_cjs(), 1);
    init_util10();
    DEFAULT_FLAGS2 = { withController: true, withPrefs: true };
  }
});

// ../../node_modules/@polkadot/api-derive/staking/index.js
var staking_exports = {};
__export(staking_exports, {
  _eraExposure: () => _eraExposure,
  _eraPrefs: () => _eraPrefs,
  _eraSlashes: () => _eraSlashes,
  _erasExposure: () => _erasExposure,
  _erasPoints: () => _erasPoints,
  _erasPrefs: () => _erasPrefs,
  _erasRewards: () => _erasRewards,
  _erasSlashes: () => _erasSlashes,
  _ownExposures: () => _ownExposures,
  _ownSlashes: () => _ownSlashes,
  _stakerExposures: () => _stakerExposures,
  _stakerPoints: () => _stakerPoints,
  _stakerPrefs: () => _stakerPrefs,
  _stakerRewards: () => _stakerRewards,
  _stakerRewardsEras: () => _stakerRewardsEras,
  _stakerSlashes: () => _stakerSlashes,
  account: () => account2,
  accounts: () => accounts,
  currentPoints: () => currentPoints,
  electedInfo: () => electedInfo,
  eraExposure: () => eraExposure,
  eraPrefs: () => eraPrefs,
  eraSlashes: () => eraSlashes,
  erasExposure: () => erasExposure,
  erasHistoric: () => erasHistoric,
  erasPoints: () => erasPoints,
  erasPrefs: () => erasPrefs,
  erasRewards: () => erasRewards,
  erasSlashes: () => erasSlashes,
  keys: () => keys,
  keysMulti: () => keysMulti,
  nextElected: () => nextElected,
  overview: () => overview2,
  ownExposure: () => ownExposure,
  ownExposures: () => ownExposures,
  ownSlash: () => ownSlash,
  ownSlashes: () => ownSlashes,
  query: () => query,
  queryMulti: () => queryMulti,
  stakerExposure: () => stakerExposure,
  stakerExposures: () => stakerExposures,
  stakerPoints: () => stakerPoints,
  stakerPrefs: () => stakerPrefs,
  stakerRewards: () => stakerRewards,
  stakerRewardsMulti: () => stakerRewardsMulti,
  stakerRewardsMultiEras: () => stakerRewardsMultiEras,
  stakerSlashes: () => stakerSlashes,
  stashes: () => stashes,
  validators: () => validators,
  waitingInfo: () => waitingInfo
});
var init_staking = __esm({
  "../../node_modules/@polkadot/api-derive/staking/index.js"() {
    init_account2();
    init_currentPoints();
    init_electedInfo();
    init_erasExposure();
    init_erasHistoric();
    init_erasPoints();
    init_erasPrefs();
    init_erasRewards();
    init_erasSlashes();
    init_keys();
    init_overview2();
    init_ownExposure();
    init_ownSlashes();
    init_query();
    init_stakerExposure();
    init_stakerPoints();
    init_stakerPrefs();
    init_stakerRewards();
    init_stakerSlashes();
    init_stashes();
    init_validators();
    init_waitingInfo();
  }
});

// ../../node_modules/@polkadot/api-derive/technicalCommittee/index.js
var technicalCommittee_exports = {};
__export(technicalCommittee_exports, {
  hasProposals: () => hasProposals5,
  members: () => members6,
  prime: () => prime5,
  proposal: () => proposal5,
  proposalCount: () => proposalCount5,
  proposalHashes: () => proposalHashes5,
  proposals: () => proposals6
});
var members6, hasProposals5, proposal5, proposalCount5, proposalHashes5, proposals6, prime5;
var init_technicalCommittee = __esm({
  "../../node_modules/@polkadot/api-derive/technicalCommittee/index.js"() {
    init_collective();
    members6 = /* @__PURE__ */ members("technicalCommittee");
    hasProposals5 = /* @__PURE__ */ hasProposals("technicalCommittee");
    proposal5 = /* @__PURE__ */ proposal("technicalCommittee");
    proposalCount5 = /* @__PURE__ */ proposalCount("technicalCommittee");
    proposalHashes5 = /* @__PURE__ */ proposalHashes("technicalCommittee");
    proposals6 = /* @__PURE__ */ proposals("technicalCommittee");
    prime5 = /* @__PURE__ */ prime("technicalCommittee");
  }
});

// ../../node_modules/@polkadot/api-derive/treasury/proposals.js
function parseResult3(api, { allIds, allProposals, approvalIds, councilProposals, proposalCount: proposalCount6 }) {
  const approvals = [];
  const proposals8 = [];
  const councilTreasury = councilProposals.filter(({ proposal: proposal6 }) => (
    // FIXME `approveProposal` and `rejectProposal` have been removed in substrate and released in 1.14
    // in favor of `spend`. See: https://github.com/paritytech/polkadot-sdk/pull/3820
    proposal6 && (api.tx.treasury["approveProposal"] && api.tx.treasury["approveProposal"].is(proposal6) || api.tx.treasury["rejectProposal"] && api.tx.treasury["rejectProposal"].is(proposal6))
  ));
  allIds.forEach((id, index) => {
    if (allProposals[index].isSome) {
      const council = councilTreasury.filter(({ proposal: proposal6 }) => proposal6 && id.eq(proposal6.args[0])).sort((a, b) => a.proposal && b.proposal ? a.proposal.method.localeCompare(b.proposal.method) : a.proposal ? -1 : 1);
      const isApproval = approvalIds.some((approvalId) => approvalId.eq(id));
      const derived = { council, id, proposal: allProposals[index].unwrap() };
      if (isApproval) {
        approvals.push(derived);
      } else {
        proposals8.push(derived);
      }
    }
  });
  return { approvals, proposalCount: proposalCount6, proposals: proposals8 };
}
function retrieveProposals(api, proposalCount6, approvalIds) {
  const proposalIds = [];
  const count = proposalCount6.toNumber();
  for (let index = 0; index < count; index++) {
    if (!approvalIds.some((id) => id.eqn(index))) {
      proposalIds.push(api.registry.createType("ProposalIndex", index));
    }
  }
  const allIds = [...proposalIds, ...approvalIds];
  return (0, import_rxjs84.combineLatest)([
    api.query.treasury.proposals.multi(allIds),
    api.derive.council ? api.derive.council.proposals() : (0, import_rxjs84.of)([])
  ]).pipe((0, import_rxjs84.map)(([allProposals, councilProposals]) => parseResult3(api, { allIds, allProposals, approvalIds, councilProposals, proposalCount: proposalCount6 })));
}
function proposals7(instanceId, api) {
  return memo(instanceId, () => api.query.treasury ? (0, import_rxjs84.combineLatest)([
    api.query.treasury.proposalCount(),
    api.query.treasury.approvals()
  ]).pipe((0, import_rxjs84.switchMap)(([proposalCount6, approvalIds]) => retrieveProposals(api, proposalCount6, approvalIds))) : (0, import_rxjs84.of)({
    approvals: [],
    proposalCount: api.registry.createType("ProposalIndex"),
    proposals: []
  }));
}
var import_rxjs84;
var init_proposals3 = __esm({
  "../../node_modules/@polkadot/api-derive/treasury/proposals.js"() {
    import_rxjs84 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/treasury/index.js
var treasury_exports = {};
__export(treasury_exports, {
  proposals: () => proposals7
});
var init_treasury = __esm({
  "../../node_modules/@polkadot/api-derive/treasury/index.js"() {
    init_proposals3();
  }
});

// ../../node_modules/@polkadot/api-derive/tx/events.js
function events(instanceId, api) {
  return memo(instanceId, (blockHash) => (0, import_rxjs85.combineLatest)([
    api.rpc.chain.getBlock(blockHash),
    api.queryAt(blockHash).pipe((0, import_rxjs85.switchMap)((queryAt) => queryAt.system.events()))
  ]).pipe((0, import_rxjs85.map)(([block, events2]) => ({ block, events: events2 }))));
}
var import_rxjs85;
var init_events2 = __esm({
  "../../node_modules/@polkadot/api-derive/tx/events.js"() {
    import_rxjs85 = __toESM(require_cjs(), 1);
    init_util10();
  }
});

// ../../node_modules/@polkadot/api-derive/tx/constants.js
var FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD;
var init_constants4 = __esm({
  "../../node_modules/@polkadot/api-derive/tx/constants.js"() {
    init_util();
    FALLBACK_MAX_HASH_COUNT = 250;
    FALLBACK_PERIOD = new import_bn.default(6 * 1e3);
    MAX_FINALITY_LAG = new import_bn.default(5);
    MORTAL_PERIOD = new import_bn.default(5 * 60 * 1e3);
  }
});

// ../../node_modules/@polkadot/api-derive/tx/signingInfo.js
function latestNonce(api, address) {
  return api.derive.balances.account(address).pipe((0, import_rxjs86.map)(({ accountNonce }) => accountNonce));
}
function nextNonce(api, address) {
  if (api.call.accountNonceApi) {
    return api.call.accountNonceApi.accountNonce(address);
  } else {
    return api.rpc.system?.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);
  }
}
function signingHeader(api) {
  return (0, import_rxjs86.combineLatest)([
    api.rpc.chain.getHeader().pipe((0, import_rxjs86.switchMap)((header) => (
      // check for chains at genesis (until block 1 is produced, e.g. 6s), since
      // we do need to allow transactions at chain start (also dev/seal chains)
      header.parentHash.isEmpty ? (0, import_rxjs86.of)(header) : api.rpc.chain.getHeader(header.parentHash).pipe((0, import_rxjs86.catchError)(() => (0, import_rxjs86.of)(header)))
    ))),
    api.rpc.chain.getFinalizedHead().pipe((0, import_rxjs86.switchMap)((hash) => api.rpc.chain.getHeader(hash).pipe((0, import_rxjs86.catchError)(() => (0, import_rxjs86.of)(null)))))
  ]).pipe((0, import_rxjs86.map)(([current, finalized]) => (
    // determine the hash to use, current when lag > max, else finalized
    !finalized || unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG) ? current : finalized
  )));
}
function babeOrAuraPeriod(api) {
  const period = api.consts.babe?.expectedBlockTime || // this will be present ones https://github.com/paritytech/polkadot-sdk/pull/3732 is merged
  api.consts["aura"]?.slotDuration || api.consts.timestamp?.minimumPeriod.muln(2);
  return period && period.isZero && !period.isZero() ? period : void 0;
}
function signingInfo(_instanceId, api) {
  return (address, nonce, era) => (0, import_rxjs86.combineLatest)([
    // retrieve nonce if none was specified
    isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : (0, import_rxjs86.of)(api.registry.createType("Index", nonce)),
    // if no era (create) or era > 0 (mortal), do block retrieval
    isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : (0, import_rxjs86.of)(null)
  ]).pipe((0, import_rxjs86.map)(([nonce2, header]) => ({
    header,
    mortalLength: Math.min(api.consts.system?.blockHashCount?.toNumber() || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(babeOrAuraPeriod(api) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),
    nonce: nonce2
  })));
}
var import_rxjs86;
var init_signingInfo = __esm({
  "../../node_modules/@polkadot/api-derive/tx/signingInfo.js"() {
    import_rxjs86 = __toESM(require_cjs(), 1);
    init_util();
    init_util10();
    init_constants4();
  }
});

// ../../node_modules/@polkadot/api-derive/tx/index.js
var tx_exports = {};
__export(tx_exports, {
  events: () => events,
  signingInfo: () => signingInfo
});
var init_tx = __esm({
  "../../node_modules/@polkadot/api-derive/tx/index.js"() {
    init_events2();
    init_signingInfo();
  }
});

// ../../node_modules/@polkadot/api-derive/derive.js
var derive;
var init_derive2 = __esm({
  "../../node_modules/@polkadot/api-derive/derive.js"() {
    init_accounts();
    init_alliance();
    init_bagsList();
    init_balances();
    init_bounties2();
    init_chain();
    init_contracts();
    init_council();
    init_crowdloan();
    init_democracy();
    init_elections();
    init_imOnline();
    init_membership();
    init_parachains();
    init_session();
    init_society();
    init_staking();
    init_technicalCommittee();
    init_treasury();
    init_tx();
    derive = { accounts: accounts_exports, alliance: alliance_exports, bagsList: bagsList_exports, balances: balances_exports, bounties: bounties_exports, chain: chain_exports, contracts: contracts_exports, council: council_exports, crowdloan: crowdloan_exports, democracy: democracy_exports, elections: elections_exports, imOnline: imOnline_exports, membership: membership_exports, parachains: parachains_exports, session: session_exports, society: society_exports, staking: staking_exports, technicalCommittee: technicalCommittee_exports, treasury: treasury_exports, tx: tx_exports };
  }
});

// ../../node_modules/@polkadot/api-derive/bundle.js
function getModuleInstances(api, specName, moduleName) {
  return api.registry.getModuleInstances(specName, moduleName) || [];
}
function injectFunctions(instanceId, api, derives) {
  const result = {};
  const names = Object.keys(derives);
  const keys2 = Object.keys(api.query);
  const specName = api.runtimeVersion.specName;
  const filterKeys = (q) => keys2.includes(q);
  const filterInstances = (q) => getModuleInstances(api, specName, q).some(filterKeys);
  const filterMethods = (all3) => (m2) => all3.some((q) => keys2.includes(q) && api.query[q][m2]);
  const getKeys = (s2) => Object.keys(derives[s2]);
  const creator = (s2, m2) => derives[s2][m2](instanceId, api);
  const isIncluded = (c) => !checks[c] || (checks[c].instances.some(filterKeys) && (!checks[c].methods.length || checks[c].methods.every(filterMethods(checks[c].instances))) || checks[c].withDetect && checks[c].instances.some(filterInstances));
  for (let i2 = 0, count = names.length; i2 < count; i2++) {
    const name = names[i2];
    isIncluded(name) && lazyDeriveSection(result, name, getKeys, creator);
  }
  return result;
}
function getAvailableDerives(instanceId, api, custom = {}) {
  return {
    ...injectFunctions(instanceId, api, derive),
    ...injectFunctions(instanceId, api, custom)
  };
}
var checks;
var init_bundle13 = __esm({
  "../../node_modules/@polkadot/api-derive/bundle.js"() {
    init_util10();
    init_derive2();
    init_derive2();
    init_type2();
    checks = {
      allianceMotion: {
        instances: ["allianceMotion"],
        methods: []
      },
      bagsList: {
        instances: ["voterBagsList", "voterList", "bagsList"],
        methods: [],
        withDetect: true
      },
      contracts: {
        instances: ["contracts"],
        methods: []
      },
      council: {
        instances: ["council"],
        methods: [],
        withDetect: true
      },
      crowdloan: {
        instances: ["crowdloan"],
        methods: []
      },
      democracy: {
        instances: ["democracy"],
        methods: []
      },
      elections: {
        instances: ["phragmenElection", "electionsPhragmen", "elections", "council"],
        methods: [],
        withDetect: true
      },
      imOnline: {
        instances: ["imOnline"],
        methods: []
      },
      membership: {
        instances: ["membership"],
        methods: []
      },
      parachains: {
        instances: ["parachains", "registrar"],
        methods: []
      },
      session: {
        instances: ["session"],
        methods: []
      },
      society: {
        instances: ["society"],
        methods: []
      },
      staking: {
        instances: ["staking"],
        methods: ["erasRewardPoints"]
      },
      technicalCommittee: {
        instances: ["technicalCommittee"],
        methods: [],
        withDetect: true
      },
      treasury: {
        instances: ["treasury"],
        methods: []
      }
    };
  }
});

// ../../node_modules/@polkadot/api-derive/index.js
var init_api_derive = __esm({
  "../../node_modules/@polkadot/api-derive/index.js"() {
    init_packageDetect10();
    init_bundle13();
  }
});

// ../../node_modules/@polkadot/api/util/decorate.js
function decorateDeriveSections(decorateMethod, derives) {
  const getKeys = (s2) => Object.keys(derives[s2]);
  const creator = (s2, m2) => decorateMethod(derives[s2][m2]);
  const result = {};
  const names = Object.keys(derives);
  for (let i2 = 0, count = names.length; i2 < count; i2++) {
    lazyDeriveSection(result, names[i2], getKeys, creator);
  }
  return result;
}
var init_decorate2 = __esm({
  "../../node_modules/@polkadot/api/util/decorate.js"() {
    init_api_derive();
  }
});

// ../../node_modules/@polkadot/api/util/index.js
var init_util18 = __esm({
  "../../node_modules/@polkadot/api/util/index.js"() {
    init_filterEvents();
    init_isKeyringPair();
    init_decorate2();
  }
});

// ../../node_modules/@polkadot/api/submittable/Result.js
function filterAndApply(events2, section2, methods, onFound) {
  return events2.filter(({ event }) => section2 === event.section && methods.includes(event.method)).map((record) => onFound(record));
}
function getDispatchError({ event: { data: [dispatchError] } }) {
  return dispatchError;
}
function getDispatchInfo({ event: { data, method } }) {
  return method === "ExtrinsicSuccess" ? data[0] : data[1];
}
function extractError(events2 = []) {
  return filterAndApply(events2, "system", ["ExtrinsicFailed"], getDispatchError)[0];
}
function extractInfo(events2 = []) {
  return filterAndApply(events2, "system", ["ExtrinsicFailed", "ExtrinsicSuccess"], getDispatchInfo)[0];
}
var recordIdentity, SubmittableResult;
var init_Result2 = __esm({
  "../../node_modules/@polkadot/api/submittable/Result.js"() {
    recordIdentity = (record) => record;
    SubmittableResult = class {
      dispatchError;
      dispatchInfo;
      internalError;
      events;
      status;
      txHash;
      txIndex;
      blockNumber;
      constructor({ blockNumber, dispatchError, dispatchInfo, events: events2, internalError, status, txHash, txIndex }) {
        this.dispatchError = dispatchError || extractError(events2);
        this.dispatchInfo = dispatchInfo || extractInfo(events2);
        this.events = events2 || [];
        this.internalError = internalError;
        this.status = status;
        this.txHash = txHash;
        this.txIndex = txIndex;
        this.blockNumber = blockNumber;
      }
      get isCompleted() {
        return this.isError || this.status.isInBlock || this.status.isFinalized;
      }
      get isError() {
        return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
      }
      get isFinalized() {
        return this.status.isFinalized;
      }
      get isInBlock() {
        return this.status.isInBlock;
      }
      get isWarning() {
        return this.status.isRetracted;
      }
      /**
       * @description Filters EventRecords for the specified method & section (there could be multiple)
       */
      filterRecords(section2, method) {
        return filterAndApply(this.events, section2, Array.isArray(method) ? method : [method], recordIdentity);
      }
      /**
       * @description Finds an EventRecord for the specified method & section
       */
      findRecord(section2, method) {
        return this.filterRecords(section2, method)[0];
      }
      /**
       * @description Creates a human representation of the output
       */
      toHuman(isExtended) {
        return {
          dispatchError: this.dispatchError?.toHuman(),
          dispatchInfo: this.dispatchInfo?.toHuman(),
          events: this.events.map((e2) => e2.toHuman(isExtended)),
          internalError: this.internalError?.message.toString(),
          status: this.status.toHuman(isExtended)
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/api/submittable/createClass.js
function makeEraOptions(api, registry, partialOptions, { header, mortalLength, nonce }) {
  if (!header) {
    if (partialOptions.era && !partialOptions.blockHash) {
      throw new Error("Expected blockHash to be passed alongside non-immortal era options");
    }
    if (isNumber(partialOptions.era)) {
      delete partialOptions.era;
      delete partialOptions.blockHash;
    }
    return makeSignOptions(api, partialOptions, { nonce });
  }
  return makeSignOptions(api, partialOptions, {
    blockHash: header.hash,
    era: registry.createTypeUnsafe("ExtrinsicEra", [{
      current: header.number,
      period: partialOptions.era || mortalLength
    }]),
    nonce
  });
}
function makeSignAndSendOptions(partialOptions, statusCb) {
  let options = {};
  if (isFunction(partialOptions)) {
    statusCb = partialOptions;
  } else {
    options = objectSpread({}, partialOptions);
  }
  return [options, statusCb];
}
function makeSignOptions(api, partialOptions, extras) {
  return objectSpread({ blockHash: api.genesisHash, genesisHash: api.genesisHash }, partialOptions, extras, { runtimeVersion: api.runtimeVersion, signedExtensions: api.registry.signedExtensions, version: api.extrinsicType });
}
function optionsOrNonce(partialOptions = {}) {
  return isBn(partialOptions) || isNumber(partialOptions) ? { nonce: partialOptions } : partialOptions;
}
function createClass({ api, apiType, blockHash, decorateMethod }) {
  const ExtrinsicBase2 = api.registry.createClass("Extrinsic");
  class Submittable extends ExtrinsicBase2 {
    __internal__ignoreStatusCb;
    __internal__transformResult = identity;
    constructor(registry, extrinsic) {
      super(registry, extrinsic, { version: api.extrinsicType });
      this.__internal__ignoreStatusCb = apiType === "rxjs";
    }
    get hasDryRun() {
      return isFunction(api.rpc.system?.dryRun);
    }
    get hasPaymentInfo() {
      return isFunction(api.call.transactionPaymentApi?.queryInfo);
    }
    // dry run an extrinsic
    dryRun(account3, optionsOrHash) {
      if (!this.hasDryRun) {
        throw new Error("The system.dryRun RPC call is not available in your environment");
      }
      if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {
        return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));
      }
      return decorateMethod(() => this.__internal__observeSign(account3, optionsOrHash).pipe((0, import_rxjs87.switchMap)(() => api.rpc.system.dryRun(this.toHex()))))();
    }
    // calculate the payment info for this transaction (if signed and submitted)
    paymentInfo(account3, optionsOrHash) {
      if (!this.hasPaymentInfo) {
        throw new Error("The transactionPaymentApi.queryInfo runtime call is not available in your environment");
      }
      if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {
        return decorateMethod(() => api.callAt(blockHash || optionsOrHash).pipe((0, import_rxjs87.switchMap)((callAt) => {
          const u8a = this.toU8a();
          return callAt.transactionPaymentApi.queryInfo(u8a, u8a.length);
        })));
      }
      const [allOptions] = makeSignAndSendOptions(optionsOrHash);
      const address = isKeyringPair(account3) ? account3.address : account3.toString();
      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0, import_rxjs87.first)(), (0, import_rxjs87.switchMap)((signingInfo2) => {
        const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo2);
        const signOptions = makeSignOptions(api, eraOptions, {});
        const u8a = api.tx(this.toU8a()).signFake(address, signOptions).toU8a();
        return api.call.transactionPaymentApi.queryInfo(u8a, u8a.length);
      })))();
    }
    // send implementation for both immediate Hash and statusCb variants
    send(statusCb) {
      const isSubscription = api.hasSubscriptions && (this.__internal__ignoreStatusCb || !!statusCb);
      return decorateMethod(isSubscription ? this.__internal__observeSubscribe : this.__internal__observeSend)(statusCb);
    }
    /**
     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `signAsync(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
     */
    signAsync(account3, partialOptions) {
      return decorateMethod(() => this.__internal__observeSign(account3, partialOptions).pipe((0, import_rxjs87.map)(() => this)))();
    }
    // signAndSend implementation for all 3 cases above
    signAndSend(account3, partialOptions, optionalStatusCb) {
      const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);
      const isSubscription = api.hasSubscriptions && (this.__internal__ignoreStatusCb || !!statusCb);
      return decorateMethod(
        () => this.__internal__observeSign(account3, options).pipe((0, import_rxjs87.switchMap)((info6) => isSubscription ? this.__internal__observeSubscribe(info6) : this.__internal__observeSend(info6)))
        // FIXME This is wrong, SubmittableResult is _not_ a codec
      )(statusCb);
    }
    // adds a transform to the result, applied before result is returned
    withResultTransform(transform) {
      this.__internal__transformResult = transform;
      return this;
    }
    __internal__observeSign = (account3, partialOptions) => {
      const address = isKeyringPair(account3) ? account3.address : account3.toString();
      const options = optionsOrNonce(partialOptions);
      return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0, import_rxjs87.first)(), (0, import_rxjs87.mergeMap)(async (signingInfo2) => {
        const eraOptions = makeEraOptions(api, this.registry, options, signingInfo2);
        let updateId = -1;
        let signedTx = null;
        if (isKeyringPair(account3)) {
          this.sign(account3, eraOptions);
        } else {
          const result = await this.__internal__signViaSigner(address, eraOptions, signingInfo2.header);
          updateId = result.id;
          if (result.signedTransaction) {
            signedTx = result.signedTransaction;
          }
        }
        return { options: eraOptions, signedTransaction: signedTx, updateId };
      }));
    };
    __internal__observeStatus = (txHash, status) => {
      if (!status.isFinalized && !status.isInBlock) {
        return (0, import_rxjs87.of)(this.__internal__transformResult(new SubmittableResult({
          status,
          txHash
        })));
      }
      const blockHash2 = status.isInBlock ? status.asInBlock : status.asFinalized;
      return api.derive.tx.events(blockHash2).pipe((0, import_rxjs87.map)(({ block, events: events2 }) => this.__internal__transformResult(new SubmittableResult({
        ...filterEvents(txHash, block, events2, status),
        status,
        txHash
      }))), (0, import_rxjs87.catchError)((internalError) => (0, import_rxjs87.of)(this.__internal__transformResult(new SubmittableResult({
        internalError,
        status,
        txHash
      })))));
    };
    __internal__observeSend = (info6) => {
      return api.rpc.author.submitExtrinsic(info6?.signedTransaction || this).pipe((0, import_rxjs87.tap)((hash) => {
        this.__internal__updateSigner(hash, info6);
      }));
    };
    __internal__observeSubscribe = (info6) => {
      const txHash = this.hash;
      return api.rpc.author.submitAndWatchExtrinsic(info6?.signedTransaction || this).pipe((0, import_rxjs87.switchMap)((status) => this.__internal__observeStatus(txHash, status)), (0, import_rxjs87.tap)((status) => {
        this.__internal__updateSigner(status, info6);
      }));
    };
    __internal__signViaSigner = async (address, options, header) => {
      const signer = options.signer || api.signer;
      const allowCallDataAlteration = options.allowCallDataAlteration ?? true;
      if (!signer) {
        throw new Error("No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
      }
      const payload = this.registry.createTypeUnsafe("SignerPayload", [objectSpread({}, options, {
        address,
        blockNumber: header ? header.number : 0,
        method: this.method
      })]);
      let result;
      if (isFunction(signer.signPayload)) {
        result = await signer.signPayload(payload.toPayload());
        if (result.signedTransaction && !options.withSignedTransaction) {
          throw new Error("The `signedTransaction` field may not be submitted when `withSignedTransaction` is disabled");
        }
        if (result.signedTransaction && options.withSignedTransaction) {
          const ext = this.registry.createTypeUnsafe("Extrinsic", [result.signedTransaction]);
          const newSignerPayload = this.registry.createTypeUnsafe("SignerPayload", [objectSpread({}, {
            address,
            assetId: ext.assetId && ext.assetId.isSome ? ext.assetId.toHex() : null,
            blockHash: payload.blockHash,
            blockNumber: header ? header.number : 0,
            era: ext.era.toHex(),
            genesisHash: payload.genesisHash,
            metadataHash: ext.metadataHash ? ext.metadataHash.toHex() : null,
            method: ext.method.toHex(),
            mode: ext.mode ? ext.mode.toHex() : null,
            nonce: ext.nonce.toHex(),
            runtimeVersion: payload.runtimeVersion,
            signedExtensions: payload.signedExtensions,
            tip: ext.tip ? ext.tip.toHex() : null,
            version: payload.version
          })]);
          if (!ext.isSigned) {
            throw new Error(`When using the signedTransaction field, the transaction must be signed. Recieved isSigned: ${ext.isSigned}`);
          }
          if (!allowCallDataAlteration) {
            this.__internal__validateSignedTransaction(payload, ext);
          }
          super.addSignature(address, result.signature, newSignerPayload.toPayload());
          return { id: result.id, signedTransaction: result.signedTransaction };
        }
      } else if (isFunction(signer.signRaw)) {
        result = await signer.signRaw(payload.toRaw());
      } else {
        throw new Error("Invalid signer interface, it should implement either signPayload or signRaw (or both)");
      }
      super.addSignature(address, result.signature, payload.toPayload());
      return { id: result.id };
    };
    __internal__updateSigner = (status, info6) => {
      if (info6 && info6.updateId !== -1) {
        const { options, updateId } = info6;
        const signer = options.signer || api.signer;
        if (signer && isFunction(signer.update)) {
          signer.update(updateId, status);
        }
      }
    };
    /**
     * When a signer includes `signedTransaction` within the SignerResult this will validate
     * specific fields within the signed extrinsic against the original payload that was passed
     * to the signer.
     */
    __internal__validateSignedTransaction = (signerPayload, signedExt) => {
      const payload = signerPayload.toPayload();
      const errMsg = (field) => `signAndSend: ${field} does not match the original payload`;
      if (payload.method !== signedExt.method.toHex()) {
        throw new Error(errMsg("call data"));
      }
    };
  }
  return Submittable;
}
var import_rxjs87;
var init_createClass2 = __esm({
  "../../node_modules/@polkadot/api/submittable/createClass.js"() {
    import_rxjs87 = __toESM(require_cjs(), 1);
    init_util();
    init_util18();
    init_Result2();
  }
});

// ../../node_modules/@polkadot/api/submittable/createSubmittable.js
function createSubmittable(apiType, api, decorateMethod, registry, blockHash) {
  const Submittable = createClass({ api, apiType, blockHash, decorateMethod });
  return (extrinsic) => new Submittable(registry || api.registry, extrinsic);
}
var init_createSubmittable = __esm({
  "../../node_modules/@polkadot/api/submittable/createSubmittable.js"() {
    init_createClass2();
  }
});

// ../../node_modules/@polkadot/api/submittable/index.js
var init_submittable = __esm({
  "../../node_modules/@polkadot/api/submittable/index.js"() {
    init_createSubmittable();
    init_Result2();
  }
});

// ../../node_modules/@polkadot/api/base/find.js
function findCall(registry, callIndex) {
  return registry.findMetaCall(u8aToU8a(callIndex));
}
function findError(registry, errorIndex) {
  return registry.findMetaError(u8aToU8a(errorIndex));
}
var init_find = __esm({
  "../../node_modules/@polkadot/api/base/find.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/types-known/packageDetect.js
var init_packageDetect15 = __esm({
  "../../node_modules/@polkadot/types-known/packageDetect.js"() {
    init_packageInfo4();
    init_util();
    init_packageInfo5();
    detectPackage(packageInfo5, null, [packageInfo4]);
  }
});

// ../../node_modules/@polkadot/types-known/chain/index.js
var typesChain;
var init_chain2 = __esm({
  "../../node_modules/@polkadot/types-known/chain/index.js"() {
    typesChain = {};
  }
});

// ../../node_modules/@polkadot/types-known/spec/centrifuge-chain.js
var sharedTypes, standaloneTypes, versioned;
var init_centrifuge_chain = __esm({
  "../../node_modules/@polkadot/types-known/spec/centrifuge-chain.js"() {
    sharedTypes = {
      // Anchor
      AnchorData: {
        anchoredBlock: "u64",
        docRoot: "H256",
        id: "H256"
      },
      DispatchErrorModule: "DispatchErrorModuleU8",
      PreCommitData: {
        expirationBlock: "u64",
        identity: "H256",
        signingRoot: "H256"
      },
      // Fees
      Fee: {
        key: "Hash",
        price: "Balance"
      },
      // MultiAccount
      MultiAccountData: {
        deposit: "Balance",
        depositor: "AccountId",
        signatories: "Vec<AccountId>",
        threshold: "u16"
      },
      // Bridge
      ChainId: "u8",
      DepositNonce: "u64",
      ResourceId: "[u8; 32]",
      "chainbridge::ChainId": "u8",
      // NFT
      RegistryId: "H160",
      TokenId: "U256",
      AssetId: {
        registryId: "RegistryId",
        tokenId: "TokenId"
      },
      AssetInfo: {
        metadata: "Bytes"
      },
      MintInfo: {
        anchorId: "Hash",
        proofs: "Vec<ProofMint>",
        staticHashes: "[Hash; 3]"
      },
      Proof: {
        leafHash: "H256",
        sortedHashes: "H256"
      },
      ProofMint: {
        hashes: "Vec<Hash>",
        property: "Bytes",
        salt: "[u8; 32]",
        value: "Bytes"
      },
      RegistryInfo: {
        fields: "Vec<Bytes>",
        ownerCanBurn: "bool"
      },
      ProxyType: {
        _enum: [
          "Any",
          "NonTransfer",
          "Governance",
          "Staking",
          "NonProxy"
        ]
      }
    };
    standaloneTypes = {
      ...sharedTypes,
      AccountInfo: "AccountInfoWithRefCount",
      Address: "LookupSource",
      LookupSource: "IndicesLookupSource",
      Multiplier: "Fixed64",
      RefCount: "RefCountTo259"
    };
    versioned = [
      {
        minmax: [240, 243],
        types: {
          ...standaloneTypes,
          ProxyType: {
            _enum: [
              "Any",
              "NonTransfer",
              "Governance",
              "Staking",
              "Vesting"
            ]
          }
        }
      },
      {
        minmax: [244, 999],
        types: { ...standaloneTypes }
      },
      {
        minmax: [1e3, void 0],
        types: { ...sharedTypes }
      }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/kusama.js
var sharedTypes2, addrIndicesTypes, addrAccountIdTypes, versioned2;
var init_kusama = __esm({
  "../../node_modules/@polkadot/types-known/spec/kusama.js"() {
    init_types_create();
    sharedTypes2 = {
      CompactAssignments: "CompactAssignmentsWith24",
      DispatchErrorModule: "DispatchErrorModuleU8",
      RawSolution: "RawSolutionWith24",
      Keys: "SessionKeys6",
      ProxyType: {
        _enum: ["Any", "NonTransfer", "Governance", "Staking", "IdentityJudgement", "CancelProxy", "Auction"]
      },
      Weight: "WeightV1"
    };
    addrIndicesTypes = {
      AccountInfo: "AccountInfoWithRefCount",
      Address: "LookupSource",
      CompactAssignments: "CompactAssignmentsWith16",
      DispatchErrorModule: "DispatchErrorModuleU8",
      RawSolution: "RawSolutionWith16",
      Keys: "SessionKeys5",
      LookupSource: "IndicesLookupSource",
      ValidatorPrefs: "ValidatorPrefsWithCommission"
    };
    addrAccountIdTypes = {
      AccountInfo: "AccountInfoWithRefCount",
      Address: "AccountId",
      CompactAssignments: "CompactAssignmentsWith16",
      DispatchErrorModule: "DispatchErrorModuleU8",
      RawSolution: "RawSolutionWith16",
      Keys: "SessionKeys5",
      LookupSource: "AccountId",
      ValidatorPrefs: "ValidatorPrefsWithCommission"
    };
    versioned2 = [
      {
        // 1020 is first CC3
        minmax: [1019, 1031],
        types: {
          ...addrIndicesTypes,
          BalanceLock: "BalanceLockTo212",
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchError: "DispatchErrorTo198",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          IdentityInfo: "IdentityInfoTo198",
          Keys: "SessionKeys5",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          ReferendumInfo: "ReferendumInfoTo239",
          Scheduled: "ScheduledTo254",
          SlashingSpans: "SlashingSpansTo204",
          StakingLedger: "StakingLedgerTo223",
          Votes: "VotesTo230",
          Weight: "u32"
        }
      },
      {
        minmax: [1032, 1042],
        types: {
          ...addrIndicesTypes,
          BalanceLock: "BalanceLockTo212",
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          Keys: "SessionKeys5",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          ReferendumInfo: "ReferendumInfoTo239",
          Scheduled: "ScheduledTo254",
          SlashingSpans: "SlashingSpansTo204",
          StakingLedger: "StakingLedgerTo223",
          Votes: "VotesTo230",
          Weight: "u32"
        }
      },
      {
        // actual at 1045 (1043-1044 is dev)
        minmax: [1043, 1045],
        types: {
          ...addrIndicesTypes,
          BalanceLock: "BalanceLockTo212",
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          Keys: "SessionKeys5",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          ReferendumInfo: "ReferendumInfoTo239",
          Scheduled: "ScheduledTo254",
          StakingLedger: "StakingLedgerTo223",
          Votes: "VotesTo230",
          Weight: "u32"
        }
      },
      {
        minmax: [1046, 1049],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          ReferendumInfo: "ReferendumInfoTo239",
          Scheduled: "ScheduledTo254",
          StakingLedger: "StakingLedgerTo223",
          Weight: "u32"
        }
      },
      {
        minmax: [1050, 1054],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          ReferendumInfo: "ReferendumInfoTo239",
          Scheduled: "ScheduledTo254",
          StakingLedger: "StakingLedgerTo240",
          Weight: "u32"
        }
      },
      {
        minmax: [1055, 1056],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          Scheduled: "ScheduledTo254",
          StakingLedger: "StakingLedgerTo240",
          Weight: "u32"
        }
      },
      {
        minmax: [1057, 1061],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          // Last 100% known problematic runtime range - this quite possibly need to
          // apply to more runtime ranges that follow, we just don't know how far this
          // should be applied to
          //
          // TL;DR whack-a-mole since this was not histrically checked
          //
          // See https://github.com/polkadot-js/api/issues/5618#issuecomment-1530970316
          Scheduled: "ScheduledTo254"
        }
      },
      {
        minmax: [1062, 2012],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          CompactAssignments: "CompactAssignmentsTo257",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [2013, 2022],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          CompactAssignments: "CompactAssignmentsTo257",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [2023, 2024],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes,
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [2025, 2027],
        types: {
          ...sharedTypes2,
          ...addrAccountIdTypes
        }
      },
      {
        minmax: [2028, 2029],
        types: {
          ...sharedTypes2,
          AccountInfo: "AccountInfoWithDualRefCount",
          CompactAssignments: "CompactAssignmentsWith16",
          RawSolution: "RawSolutionWith16"
        }
      },
      {
        minmax: [2030, 9e3],
        types: {
          ...sharedTypes2,
          CompactAssignments: "CompactAssignmentsWith16",
          RawSolution: "RawSolutionWith16"
        }
      },
      {
        minmax: [9010, 9099],
        types: {
          ...sharedTypes2,
          ...mapXcmTypes("V0")
        }
      },
      {
        // jump from 9100 to 9110, however align with Rococo
        minmax: [9100, 9105],
        types: {
          ...sharedTypes2,
          ...mapXcmTypes("V1")
        }
      },
      {
        // metadata v14
        minmax: [9106, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
      // ,
      // {
      //   // weight v2 introduction
      //   minmax: [9300, undefined],
      //   types: {
      //     Weight: 'WeightV2'
      //   }
      // }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/node.js
var versioned3;
var init_node6 = __esm({
  "../../node_modules/@polkadot/types-known/spec/node.js"() {
    versioned3 = [
      {
        minmax: [0, void 0],
        types: {
          // nothing, API tracks master
          // (v2 weights are not yet the default)
          Weight: "WeightV2"
        }
      }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/node-template.js
var versioned4;
var init_node_template = __esm({
  "../../node_modules/@polkadot/types-known/spec/node-template.js"() {
    versioned4 = [
      {
        minmax: [0, void 0],
        types: {
          // nothing, API tracks master
          // (v2 weights are not yet the default)
          Weight: "WeightV2"
        }
      }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/polkadot.js
var sharedTypes3, addrAccountIdTypes2, versioned5;
var init_polkadot2 = __esm({
  "../../node_modules/@polkadot/types-known/spec/polkadot.js"() {
    sharedTypes3 = {
      CompactAssignments: "CompactAssignmentsWith16",
      DispatchErrorModule: "DispatchErrorModuleU8",
      RawSolution: "RawSolutionWith16",
      Keys: "SessionKeys6",
      ProxyType: {
        _enum: {
          Any: 0,
          NonTransfer: 1,
          Governance: 2,
          Staking: 3,
          UnusedSudoBalances: 4,
          IdentityJudgement: 5,
          CancelProxy: 6,
          Auction: 7
        }
      },
      Weight: "WeightV1"
    };
    addrAccountIdTypes2 = {
      AccountInfo: "AccountInfoWithRefCount",
      Address: "AccountId",
      DispatchErrorModule: "DispatchErrorModuleU8",
      Keys: "SessionKeys5",
      LookupSource: "AccountId",
      ValidatorPrefs: "ValidatorPrefsWithCommission"
    };
    versioned5 = [
      {
        minmax: [0, 12],
        types: {
          ...sharedTypes3,
          ...addrAccountIdTypes2,
          CompactAssignments: "CompactAssignmentsTo257",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [13, 22],
        types: {
          ...sharedTypes3,
          ...addrAccountIdTypes2,
          CompactAssignments: "CompactAssignmentsTo257",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [23, 24],
        types: {
          ...sharedTypes3,
          ...addrAccountIdTypes2,
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [25, 27],
        types: {
          ...sharedTypes3,
          ...addrAccountIdTypes2
        }
      },
      {
        minmax: [28, 29],
        types: {
          ...sharedTypes3,
          AccountInfo: "AccountInfoWithDualRefCount"
        }
      },
      {
        minmax: [30, 9109],
        types: {
          ...sharedTypes3
        }
      },
      {
        // metadata v14
        minmax: [9110, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
      // ,
      // {
      //   // weight v2 introduction
      //   minmax: [9300, undefined],
      //   types: {
      //     Weight: 'WeightV2'
      //   }
      // }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/rococo.js
var sharedTypes4, versioned6;
var init_rococo = __esm({
  "../../node_modules/@polkadot/types-known/spec/rococo.js"() {
    init_types_create();
    sharedTypes4 = {
      DispatchErrorModule: "DispatchErrorModuleU8",
      FullIdentification: "()",
      // No staking, only session (as per config)
      Keys: "SessionKeys7B",
      Weight: "WeightV1"
    };
    versioned6 = [
      {
        minmax: [0, 200],
        types: {
          ...sharedTypes4,
          AccountInfo: "AccountInfoWithDualRefCount",
          Address: "AccountId",
          LookupSource: "AccountId"
        }
      },
      {
        minmax: [201, 214],
        types: {
          ...sharedTypes4,
          AccountInfo: "AccountInfoWithDualRefCount"
        }
      },
      {
        minmax: [215, 228],
        types: {
          ...sharedTypes4,
          Keys: "SessionKeys6"
        }
      },
      {
        minmax: [229, 9099],
        types: {
          ...sharedTypes4,
          ...mapXcmTypes("V0")
        }
      },
      {
        minmax: [9100, 9105],
        types: {
          ...sharedTypes4,
          ...mapXcmTypes("V1")
        }
      },
      {
        // metadata v14
        minmax: [9106, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
      // ,
      // {
      //   // weight v2 introduction
      //   minmax: [9300, undefined],
      //   types: {
      //     Weight: 'WeightV2'
      //   }
      // }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/shell.js
var versioned7;
var init_shell2 = __esm({
  "../../node_modules/@polkadot/types-known/spec/shell.js"() {
    versioned7 = [
      {
        minmax: [0, void 0],
        types: {
          // nothing, limited runtime
        }
      }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/statemine.js
var sharedTypes5, versioned8;
var init_statemine = __esm({
  "../../node_modules/@polkadot/types-known/spec/statemine.js"() {
    init_types_create();
    sharedTypes5 = {
      DispatchErrorModule: "DispatchErrorModuleU8",
      TAssetBalance: "u128",
      ProxyType: {
        _enum: [
          "Any",
          "NonTransfer",
          "CancelProxy",
          "Assets",
          "AssetOwner",
          "AssetManager",
          "Staking"
        ]
      },
      Weight: "WeightV1"
    };
    versioned8 = [
      {
        minmax: [0, 3],
        types: {
          // Enum was modified mid-flight -
          // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
          DispatchError: "DispatchErrorPre6First",
          ...sharedTypes5,
          ...mapXcmTypes("V0")
        }
      },
      {
        minmax: [4, 5],
        types: {
          // As above, see https://github.com/polkadot-js/api/issues/5301
          DispatchError: "DispatchErrorPre6First",
          ...sharedTypes5,
          ...mapXcmTypes("V1")
        }
      },
      {
        // metadata V14
        minmax: [500, 9999],
        types: {
          Weight: "WeightV1",
          TAssetConversion: "Option<AssetId>"
        }
      },
      {
        minmax: [1e4, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/statemint.js
var sharedTypes6, versioned9;
var init_statemint2 = __esm({
  "../../node_modules/@polkadot/types-known/spec/statemint.js"() {
    init_types_create();
    sharedTypes6 = {
      DispatchErrorModule: "DispatchErrorModuleU8",
      TAssetBalance: "u128",
      ProxyType: {
        _enum: [
          "Any",
          "NonTransfer",
          "CancelProxy",
          "Assets",
          "AssetOwner",
          "AssetManager",
          "Staking"
        ]
      },
      Weight: "WeightV1"
    };
    versioned9 = [
      {
        minmax: [0, 3],
        types: {
          // Enum was modified mid-flight -
          // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
          DispatchError: "DispatchErrorPre6First",
          ...sharedTypes6,
          ...mapXcmTypes("V0")
        }
      },
      {
        minmax: [4, 5],
        types: {
          // As above, see https://github.com/polkadot-js/api/issues/5301
          DispatchError: "DispatchErrorPre6First",
          ...sharedTypes6,
          ...mapXcmTypes("V1")
        }
      },
      {
        // metadata V14
        minmax: [500, 1001003],
        types: {
          Weight: "WeightV1",
          TAssetConversion: "Option<AssetId>"
        }
      },
      {
        minmax: [1002e3, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
      // ,
      // {
      //   // weight v2 introduction
      //   minmax: [9300, undefined],
      //   types: {
      //     Weight: 'WeightV2'
      //   }
      // }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/westend.js
var sharedTypes7, addrAccountIdTypes3, versioned10;
var init_westend = __esm({
  "../../node_modules/@polkadot/types-known/spec/westend.js"() {
    init_types_create();
    sharedTypes7 = {
      // 16 validators
      CompactAssignments: "CompactAssignmentsWith16",
      DispatchErrorModule: "DispatchErrorModuleU8",
      RawSolution: "RawSolutionWith16",
      // general
      Keys: "SessionKeys6",
      ProxyType: {
        _enum: ["Any", "NonTransfer", "Staking", "SudoBalances", "IdentityJudgement", "CancelProxy"]
      },
      Weight: "WeightV1"
    };
    addrAccountIdTypes3 = {
      AccountInfo: "AccountInfoWithRefCount",
      Address: "AccountId",
      CompactAssignments: "CompactAssignmentsWith16",
      DispatchErrorModule: "DispatchErrorModuleU8",
      LookupSource: "AccountId",
      Keys: "SessionKeys5",
      RawSolution: "RawSolutionWith16",
      ValidatorPrefs: "ValidatorPrefsWithCommission"
    };
    versioned10 = [
      {
        minmax: [1, 2],
        types: {
          ...sharedTypes7,
          ...addrAccountIdTypes3,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          Multiplier: "Fixed64",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259",
          Weight: "u32"
        }
      },
      {
        minmax: [3, 22],
        types: {
          ...sharedTypes7,
          ...addrAccountIdTypes3,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          OpenTip: "OpenTipTo225",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [23, 42],
        types: {
          ...sharedTypes7,
          ...addrAccountIdTypes3,
          CompactAssignments: "CompactAssignmentsTo257",
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [43, 44],
        types: {
          ...sharedTypes7,
          ...addrAccountIdTypes3,
          DispatchInfo: "DispatchInfoTo244",
          Heartbeat: "HeartbeatTo244",
          RefCount: "RefCountTo259"
        }
      },
      {
        minmax: [45, 47],
        types: {
          ...sharedTypes7,
          ...addrAccountIdTypes3
        }
      },
      {
        minmax: [48, 49],
        types: {
          ...sharedTypes7,
          AccountInfo: "AccountInfoWithDualRefCount"
        }
      },
      {
        minmax: [50, 9099],
        types: {
          ...sharedTypes7,
          ...mapXcmTypes("V0")
        }
      },
      {
        minmax: [9100, 9105],
        types: {
          ...sharedTypes7,
          ...mapXcmTypes("V1")
        }
      },
      {
        // metadata v14
        minmax: [9106, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
      // ,
      // {
      //   // weight v2 introduction
      //   minmax: [9300, undefined],
      //   types: {
      //     Weight: 'WeightV2'
      //   }
      // }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/westmint.js
var sharedTypes8, versioned11;
var init_westmint = __esm({
  "../../node_modules/@polkadot/types-known/spec/westmint.js"() {
    init_types_create();
    sharedTypes8 = {
      DispatchErrorModule: "DispatchErrorModuleU8",
      TAssetBalance: "u128",
      ProxyType: {
        _enum: [
          "Any",
          "NonTransfer",
          "CancelProxy",
          "Assets",
          "AssetOwner",
          "AssetManager",
          "Staking"
        ]
      },
      Weight: "WeightV1"
    };
    versioned11 = [
      {
        minmax: [0, 3],
        types: {
          // Enum was modified mid-flight -
          // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
          DispatchError: "DispatchErrorPre6First",
          ...sharedTypes8,
          ...mapXcmTypes("V0")
        }
      },
      {
        minmax: [4, 5],
        types: {
          // As above, see https://github.com/polkadot-js/api/issues/5301
          DispatchError: "DispatchErrorPre6First",
          ...sharedTypes8,
          ...mapXcmTypes("V1")
        }
      },
      {
        // metadata V14
        minmax: [500, 9434],
        types: {
          Weight: "WeightV1",
          TAssetConversion: "Option<AssetId>"
        }
      },
      {
        minmax: [9435, void 0],
        types: {
          Weight: "WeightV1"
        }
      }
    ];
  }
});

// ../../node_modules/@polkadot/types-known/spec/index.js
var typesSpec;
var init_spec = __esm({
  "../../node_modules/@polkadot/types-known/spec/index.js"() {
    init_centrifuge_chain();
    init_kusama();
    init_node6();
    init_node_template();
    init_polkadot2();
    init_rococo();
    init_shell2();
    init_statemine();
    init_statemint2();
    init_westend();
    init_westmint();
    typesSpec = {
      "centrifuge-chain": versioned,
      kusama: versioned2,
      node: versioned3,
      "node-template": versioned4,
      polkadot: versioned5,
      rococo: versioned6,
      shell: versioned7,
      statemine: versioned8,
      statemint: versioned9,
      westend: versioned10,
      westmint: versioned11
    };
  }
});

// ../../node_modules/@polkadot/types-known/upgrades/e2e/kusama.js
var upgrades;
var init_kusama2 = __esm({
  "../../node_modules/@polkadot/types-known/upgrades/e2e/kusama.js"() {
    upgrades = [
      [
        0,
        1020,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        26669,
        1021,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        38245,
        1022,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        54248,
        1023,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        59659,
        1024,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        67651,
        1025,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        82191,
        1027,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        83238,
        1028,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        101503,
        1029,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        203466,
        1030,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        295787,
        1031,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        461692,
        1032,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        504329,
        1033,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        569327,
        1038,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            1
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        587687,
        1039,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        653183,
        1040,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        693488,
        1042,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        901442,
        1045,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1375086,
        1050,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1445458,
        1051,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1472960,
        1052,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1475648,
        1053,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1491596,
        1054,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1574408,
        1055,
        [
          [
            "0xdf6acb689907609b",
            2
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            1
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2064961,
        1058,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2201991,
        1062,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2671528,
        2005,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2704202,
        2007,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2728002,
        2008,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2832534,
        2011,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2962294,
        2012,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        324e4,
        2013,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3274408,
        2015,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3323565,
        2019,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3534175,
        2022,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3860281,
        2023,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4143129,
        2024,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4401242,
        2025,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4841367,
        2026,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5961600,
        2027,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6137912,
        2028,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6561855,
        2029,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7100891,
        2030,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7468792,
        9010,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7668600,
        9030,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7812476,
        9040,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8010981,
        9050,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8073833,
        9070,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8555825,
        9080,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8945245,
        9090,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9611377,
        9100,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9625129,
        9111,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9866422,
        9122,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10403784,
        9130,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10960765,
        9150,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11006614,
        9151,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11404482,
        9160,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11601803,
        9170,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        12008022,
        9180,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        12405451,
        9190,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        12665416,
        9200,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        12909508,
        9220,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        13109752,
        9230,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        13555777,
        9250,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        13727747,
        9260,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        14248044,
        9271,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        14433840,
        9280,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        14645900,
        9291,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        15048375,
        9300,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        15426015,
        9320,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        15680713,
        9340,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        15756296,
        9350,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        15912007,
        9360,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        16356547,
        9370,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        17335450,
        9381,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            3
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        18062739,
        9420,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        18625e3,
        9430,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        20465806,
        1e6,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            5
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        2157e4,
        1001e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            7
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21786291,
        1001002,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            7
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        22515962,
        1001003,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            7
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        2279e4,
        1002e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        23176015,
        1002001,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        23450253,
        1002004,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        23565293,
        1002005,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        23780224,
        1002006,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        24786390,
        1003e3,
        [
          [
            "0xc51ff1fa3f5d0cca",
            1
          ],
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            11
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x91b1c8b16328eb92",
            1
          ],
          [
            "0x9ffb505aa738d69c",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ]
    ];
  }
});

// ../../node_modules/@polkadot/types-known/upgrades/e2e/polkadot.js
var upgrades2;
var init_polkadot3 = __esm({
  "../../node_modules/@polkadot/types-known/upgrades/e2e/polkadot.js"() {
    upgrades2 = [
      [
        0,
        0,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        29231,
        1,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        188836,
        5,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        199405,
        6,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        214264,
        7,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        244358,
        8,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        303079,
        9,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        314201,
        10,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        342400,
        11,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        443963,
        12,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        528470,
        13,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        687751,
        14,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        746085,
        15,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        787923,
        16,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        799302,
        17,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1205128,
        18,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1603423,
        23,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1733218,
        24,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2005673,
        25,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2436698,
        26,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3613564,
        27,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3899547,
        28,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4345767,
        29,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4876134,
        30,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5661442,
        9050,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6321619,
        9080,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6713249,
        9090,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7217907,
        9100,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7229126,
        9110,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7560558,
        9122,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8115869,
        9140,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8638103,
        9151,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9280179,
        9170,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9738717,
        9180,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10156856,
        9190,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10458576,
        9200,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10655116,
        9220,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10879371,
        9230,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11328884,
        9250,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11532856,
        9260,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11933818,
        9270,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        12217535,
        9280,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ]
        ]
      ],
      [
        12245277,
        9281,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ]
        ]
      ],
      [
        12532644,
        9291,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ]
        ]
      ],
      [
        12876189,
        9300,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ]
        ]
      ],
      [
        13800015,
        9340,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ]
        ]
      ],
      [
        14188833,
        9360,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ]
        ]
      ],
      [
        14543918,
        9370,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ]
        ]
      ],
      [
        15978362,
        9420,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ]
        ]
      ],
      [
        1645e4,
        9430,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ]
        ]
      ],
      [
        1784e4,
        9431,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ]
        ]
      ],
      [
        18407475,
        1000001,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            5
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ]
        ]
      ],
      [
        19551e3,
        1001002,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            5
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        20181758,
        1001003,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            5
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        20438530,
        1002e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21169168,
        1002004,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21455374,
        1002005,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21558004,
        1002006,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21800141,
        1002007,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ]
    ];
  }
});

// ../../node_modules/@polkadot/types-known/upgrades/e2e/westend.js
var upgrades3;
var init_westend2 = __esm({
  "../../node_modules/@polkadot/types-known/upgrades/e2e/westend.js"() {
    upgrades3 = [
      [
        214356,
        4,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            1
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        392764,
        7,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        409740,
        8,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        809976,
        20,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        877581,
        24,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        879238,
        25,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        889472,
        26,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        902937,
        27,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        932751,
        28,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        991142,
        29,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1030162,
        31,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1119657,
        32,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1199282,
        33,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1342534,
        34,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1392263,
        35,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1431703,
        36,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1433369,
        37,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        1490972,
        41,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2087397,
        43,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2316688,
        44,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        2549864,
        45,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3925782,
        46,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        3925843,
        47,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4207800,
        48,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        4627944,
        49,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5124076,
        50,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5478664,
        900,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5482450,
        9e3,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            4
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5584305,
        9010,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5784566,
        9030,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5879822,
        9031,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5896856,
        9032,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        5897316,
        9033,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6117927,
        9050,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6210274,
        9070,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            2
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6379314,
        9080,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            2
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        6979141,
        9090,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7568453,
        9100,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7766394,
        9111,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7911691,
        9120,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7968866,
        9121,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        7982889,
        9122,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        8514322,
        9130,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9091726,
        9140,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9091774,
        9150,
        [
          [
            "0xdf6acb689907609b",
            3
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            1
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9406726,
        9160,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        9921066,
        9170,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10007115,
        9180,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            5
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10480973,
        9190,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10578091,
        9200,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10678509,
        9210,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        10811001,
        9220,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11096116,
        9230,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11409279,
        9250,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11584820,
        9251,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11716837,
        9260,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11876919,
        9261,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ]
        ]
      ],
      [
        11987927,
        9270,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        12077324,
        9271,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        12301871,
        9280,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        12604343,
        9290,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            2
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        12841034,
        9300,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        13128237,
        9310,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            1
          ],
          [
            "0xf3ff14d5ab527059",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        13272363,
        9320,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        13483497,
        9330,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        13649433,
        9340,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        13761100,
        9350,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        13847400,
        9360,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        14249200,
        9370,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            2
          ],
          [
            "0xf3ff14d5ab527059",
            2
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        14576855,
        9380,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            3
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            3
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ]
        ]
      ],
      [
        14849830,
        9390,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            1
          ],
          [
            "0x91d5df18b0d2cf58",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            3
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        15146832,
        9400,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            3
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        15332317,
        9401,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            1
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            3
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        15661793,
        9420,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        16165469,
        9430,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            4
          ],
          [
            "0x49eaaf1b548a0cb0",
            2
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ]
        ]
      ],
      [
        18293984,
        102e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            7
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        18293991,
        103e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            8
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        18451783,
        104e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            9
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        18679741,
        1005e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            9
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        19166695,
        1006e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        19234157,
        1006001,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        19542944,
        1007e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        19621258,
        1007001,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        19761406,
        1008e3,
        [
          [
            "0xdf6acb689907609b",
            4
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        20056997,
        1009e3,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        20368318,
        101e4,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            10
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        20649086,
        1011e3,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            11
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21217837,
        1011001,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            11
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21300429,
        1013e3,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            11
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x91b1c8b16328eb92",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21460051,
        1014e3,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            11
          ],
          [
            "0x49eaaf1b548a0cb0",
            3
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x91b1c8b16328eb92",
            1
          ],
          [
            "0x9ffb505aa738d69c",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ],
      [
        21925427,
        1015e3,
        [
          [
            "0xdf6acb689907609b",
            5
          ],
          [
            "0x37e397fc7c91f5e4",
            2
          ],
          [
            "0x40fe3ad401f8959a",
            6
          ],
          [
            "0xd2bc9897eed08f15",
            3
          ],
          [
            "0xf78b278be53f454c",
            2
          ],
          [
            "0xaf2c0297a23e6d3d",
            11
          ],
          [
            "0x49eaaf1b548a0cb0",
            4
          ],
          [
            "0x91d5df18b0d2cf58",
            2
          ],
          [
            "0x2a5e924655399e60",
            1
          ],
          [
            "0xed99c5acb25eedf5",
            3
          ],
          [
            "0xcbca25e39f142387",
            2
          ],
          [
            "0x687ad44ad37f03c2",
            1
          ],
          [
            "0xab3c0572291feb8b",
            1
          ],
          [
            "0xbc9d89904f5b923f",
            1
          ],
          [
            "0x37c8bb1350a9a2a8",
            4
          ],
          [
            "0xf3ff14d5ab527059",
            3
          ],
          [
            "0x6ff52ee858e6c5bd",
            1
          ],
          [
            "0x91b1c8b16328eb92",
            1
          ],
          [
            "0x9ffb505aa738d69c",
            1
          ],
          [
            "0x17a6bc0d0062aeb3",
            1
          ],
          [
            "0x18ef58a3b67ba770",
            1
          ],
          [
            "0xfbc577b9d747efd6",
            1
          ]
        ]
      ]
    ];
  }
});

// ../../node_modules/@polkadot/types-known/upgrades/e2e/index.js
var e2e_exports = {};
__export(e2e_exports, {
  kusama: () => upgrades,
  polkadot: () => upgrades2,
  westend: () => upgrades3
});
var init_e2e = __esm({
  "../../node_modules/@polkadot/types-known/upgrades/e2e/index.js"() {
    init_kusama2();
    init_polkadot3();
    init_westend2();
  }
});

// ../../node_modules/@polkadot/types-known/upgrades/index.js
function mapRaw([network, versions]) {
  const chain2 = selectableNetworks.find((n) => n.network === network) || NET_EXTRA[network];
  if (!chain2) {
    throw new Error(`Unable to find info for chain ${network}`);
  }
  return {
    genesisHash: hexToU8a(chain2.genesisHash[0]),
    network,
    versions: versions.map(([blockNumber, specVersion, apis]) => ({
      apis,
      blockNumber: new import_bn.default(blockNumber),
      specVersion: new import_bn.default(specVersion)
    }))
  };
}
var NET_EXTRA, upgrades4;
var init_upgrades = __esm({
  "../../node_modules/@polkadot/types-known/upgrades/index.js"() {
    init_networks();
    init_util();
    init_e2e();
    NET_EXTRA = {
      westend: {
        genesisHash: ["0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"]
      }
    };
    upgrades4 = Object.entries(e2e_exports).map(mapRaw);
  }
});

// ../../node_modules/@polkadot/types-known/util.js
function withNames(chainName, specName, fn) {
  return fn(chainName.toString(), specName.toString());
}
function filterVersions(versions = [], specVersion) {
  return versions.filter(({ minmax: [min, max2] }) => (min === void 0 || min === null || specVersion >= min) && (max2 === void 0 || max2 === null || specVersion <= max2)).reduce((result, { types: types4 }) => ({ ...result, ...types4 }), {});
}
function getSpecExtensions({ knownTypes: knownTypes2 }, chainName, specName) {
  return withNames(chainName, specName, (c, s2) => ({
    ...knownTypes2.typesBundle?.spec?.[s2]?.signedExtensions ?? {},
    ...knownTypes2.typesBundle?.chain?.[c]?.signedExtensions ?? {}
  }));
}
function getSpecTypes({ knownTypes: knownTypes2 }, chainName, specName, specVersion) {
  const _specVersion = bnToBn(specVersion).toNumber();
  return withNames(chainName, specName, (c, s2) => ({
    // The order here is always, based on -
    //   - spec then chain
    //   - typesBundle takes higher precedence
    //   - types is the final catch-all override
    ...filterVersions(typesSpec[s2], _specVersion),
    ...filterVersions(typesChain[c], _specVersion),
    ...filterVersions(knownTypes2.typesBundle?.spec?.[s2]?.types, _specVersion),
    ...filterVersions(knownTypes2.typesBundle?.chain?.[c]?.types, _specVersion),
    ...knownTypes2.typesSpec?.[s2] ?? {},
    ...knownTypes2.typesChain?.[c] ?? {},
    ...knownTypes2.types ?? {}
  }));
}
function getSpecHasher({ knownTypes: knownTypes2 }, chainName, specName) {
  return withNames(chainName, specName, (c, s2) => knownTypes2.hasher || knownTypes2.typesBundle?.chain?.[c]?.hasher || knownTypes2.typesBundle?.spec?.[s2]?.hasher || null);
}
function getSpecRpc({ knownTypes: knownTypes2 }, chainName, specName) {
  return withNames(chainName, specName, (c, s2) => ({
    ...knownTypes2.typesBundle?.spec?.[s2]?.rpc ?? {},
    ...knownTypes2.typesBundle?.chain?.[c]?.rpc ?? {}
  }));
}
function getSpecRuntime({ knownTypes: knownTypes2 }, chainName, specName) {
  return withNames(chainName, specName, (c, s2) => ({
    ...knownTypes2.typesBundle?.spec?.[s2]?.runtime ?? {},
    ...knownTypes2.typesBundle?.chain?.[c]?.runtime ?? {}
  }));
}
function getSpecAlias({ knownTypes: knownTypes2 }, chainName, specName) {
  return withNames(chainName, specName, (c, s2) => ({
    // as per versions, first spec, then chain then finally non-versioned
    ...knownTypes2.typesBundle?.spec?.[s2]?.alias ?? {},
    ...knownTypes2.typesBundle?.chain?.[c]?.alias ?? {},
    ...knownTypes2.typesAlias ?? {}
  }));
}
function getUpgradeVersion(genesisHash, blockNumber) {
  const known2 = upgrades4.find((u) => genesisHash.eq(u.genesisHash));
  return known2 ? [
    known2.versions.reduce((last, version) => {
      return blockNumber.gt(version.blockNumber) ? version : last;
    }, void 0),
    known2.versions.find((version) => blockNumber.lte(version.blockNumber))
  ] : [void 0, void 0];
}
var init_util19 = __esm({
  "../../node_modules/@polkadot/types-known/util.js"() {
    init_util();
    init_chain2();
    init_spec();
    init_upgrades();
  }
});

// ../../node_modules/@polkadot/types-known/bundle.js
var init_bundle14 = __esm({
  "../../node_modules/@polkadot/types-known/bundle.js"() {
    init_util19();
  }
});

// ../../node_modules/@polkadot/types-known/index.js
var init_types_known = __esm({
  "../../node_modules/@polkadot/types-known/index.js"() {
    init_packageDetect15();
    init_bundle14();
  }
});

// ../../node_modules/@polkadot/api/util/augmentObject.js
function logLength(type, values, and = []) {
  return values.length ? ` ${values.length} ${type}${and.length ? " and" : ""}` : "";
}
function logValues(type, values) {
  return values.length ? `
	${type.padStart(7)}: ${values.sort().join(", ")}` : "";
}
function warn2(prefix2, type, [added, removed]) {
  if (added.length || removed.length) {
    l12.warn(`api.${prefix2}: Found${logLength("added", added, removed)}${logLength("removed", removed)} ${type}:${logValues("added", added)}${logValues("removed", removed)}`);
  }
}
function findSectionExcludes(a, b) {
  return a.filter((s2) => !b.includes(s2));
}
function findSectionIncludes(a, b) {
  return a.filter((s2) => b.includes(s2));
}
function extractSections(src, dst) {
  const srcSections = Object.keys(src);
  const dstSections = Object.keys(dst);
  return [
    findSectionExcludes(srcSections, dstSections),
    findSectionExcludes(dstSections, srcSections)
  ];
}
function findMethodExcludes(src, dst) {
  const srcSections = Object.keys(src);
  const dstSections = findSectionIncludes(Object.keys(dst), srcSections);
  const excludes = [];
  for (let s2 = 0, scount = dstSections.length; s2 < scount; s2++) {
    const section2 = dstSections[s2];
    const srcMethods = Object.keys(src[section2]);
    const dstMethods = Object.keys(dst[section2]);
    for (let d = 0, mcount = dstMethods.length; d < mcount; d++) {
      const method = dstMethods[d];
      if (!srcMethods.includes(method)) {
        excludes.push(`${section2}.${method}`);
      }
    }
  }
  return excludes;
}
function extractMethods(src, dst) {
  return [
    findMethodExcludes(dst, src),
    findMethodExcludes(src, dst)
  ];
}
function augmentObject(prefix2, src, dst, fromEmpty = false) {
  fromEmpty && objectClear(dst);
  if (prefix2 && Object.keys(dst).length) {
    warn2(prefix2, "modules", extractSections(src, dst));
    warn2(prefix2, "calls", extractMethods(src, dst));
  }
  const sections = Object.keys(src);
  for (let i2 = 0, count = sections.length; i2 < count; i2++) {
    const section2 = sections[i2];
    const methods = src[section2];
    if (!dst[section2]) {
      dst[section2] = {};
    }
    lazyMethods(dst[section2], Object.keys(methods), (m2) => methods[m2]);
  }
  return dst;
}
var l12;
var init_augmentObject = __esm({
  "../../node_modules/@polkadot/api/util/augmentObject.js"() {
    init_util();
    l12 = logger("api/augment");
  }
});

// ../../node_modules/@polkadot/api/util/validate.js
function sig({ lookup }, { method, section: section2 }, args) {
  return `${section2}.${method}(${args.map((a) => lookup.getTypeDef(a).type).join(", ")})`;
}
function extractStorageArgs(registry, creator, _args) {
  const args = _args.filter((a) => !isUndefined(a));
  if (creator.meta.type.isPlain) {
    if (args.length !== 0) {
      throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);
    }
  } else {
    const { hashers, key } = creator.meta.type.asMap;
    const keys2 = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple.map((t2) => t2);
    if (args.length !== keys2.length) {
      throw new Error(`${sig(registry, creator, keys2)} is a map, requiring ${keys2.length} arguments, ${args.length} found`);
    }
  }
  return [creator, args];
}
var init_validate2 = __esm({
  "../../node_modules/@polkadot/api/util/validate.js"() {
    init_util();
  }
});

// ../../node_modules/@polkadot/api/base/Events.js
var Events;
var init_Events = __esm({
  "../../node_modules/@polkadot/api/base/Events.js"() {
    init_eventemitter3();
    Events = class {
      __internal__eventemitter = new import_index3.default();
      emit(type, ...args) {
        return this.__internal__eventemitter.emit(type, ...args);
      }
      /**
       * @description Attach an eventemitter handler to listen to a specific event
       *
       * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
       * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * api.on('connected', (): void => {
       *   console.log('API has been connected to the endpoint');
       * });
       *
       * api.on('disconnected', (): void => {
       *   console.log('API has been disconnected from the endpoint');
       * });
       * ```
       */
      on(type, handler) {
        this.__internal__eventemitter.on(type, handler);
        return this;
      }
      /**
       * @description Remove the given eventemitter handler
       *
       * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`
       * @param handler The callback to unregister.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * const handler = (): void => {
       *  console.log('Connected !);
       * };
       *
       * // Start listening
       * api.on('connected', handler);
       *
       * // Stop listening
       * api.off('connected', handler);
       * ```
       */
      off(type, handler) {
        this.__internal__eventemitter.removeListener(type, handler);
        return this;
      }
      /**
       * @description Attach an one-time eventemitter handler to listen to a specific event
       *
       * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
       * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * api.once('connected', (): void => {
       *   console.log('API has been connected to the endpoint');
       * });
       *
       * api.once('disconnected', (): void => {
       *   console.log('API has been disconnected from the endpoint');
       * });
       * ```
       */
      once(type, handler) {
        this.__internal__eventemitter.once(type, handler);
        return this;
      }
    };
  }
});

// ../../node_modules/@polkadot/api/base/Decorate.js
function getAtQueryFn(api, { method, section: section2 }) {
  return assertReturn(api.rx.query[section2] && api.rx.query[section2][method], () => `query.${section2}.${method} is not available in this version of the metadata`);
}
var import_rxjs88, PAGE_SIZE_K2, PAGE_SIZE_V, PAGE_SIZE_Q, l13, instanceCounter, Decorate;
var init_Decorate = __esm({
  "../../node_modules/@polkadot/api/base/Decorate.js"() {
    import_rxjs88 = __toESM(require_cjs(), 1);
    init_api_derive();
    init_rpc_core();
    init_rpc_provider();
    init_types3();
    init_types_known();
    init_util();
    init_util_crypto();
    init_submittable();
    init_augmentObject();
    init_decorate2();
    init_validate2();
    init_Events();
    init_find();
    PAGE_SIZE_K2 = 1e3;
    PAGE_SIZE_V = 250;
    PAGE_SIZE_Q = 50;
    l13 = logger("api/init");
    instanceCounter = 0;
    Decorate = class extends Events {
      __internal__instanceId;
      __internal__runtimeLog = {};
      __internal__registry;
      __internal__storageGetQ = [];
      __internal__storageSubQ = [];
      // HACK Use BN import so decorateDerive works... yes, wtf.
      __phantom = new import_bn.default(0);
      _type;
      _call = {};
      _consts = {};
      _derive;
      _errors = {};
      _events = {};
      _extrinsics;
      _extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;
      _genesisHash;
      _isConnected;
      _isReady = false;
      _query = {};
      _queryMulti;
      _rpc;
      _rpcCore;
      _runtimeMap = {};
      _runtimeChain;
      _runtimeMetadata;
      _runtimeVersion;
      _rx = { call: {}, consts: {}, query: {}, tx: {} };
      _options;
      /**
       * This is the one and only method concrete children classes need to implement.
       * It's a higher-order function, which takes one argument
       * `method: Method extends (...args: any[]) => Observable<any>`
       * (and one optional `options`), and should return the user facing method.
       * For example:
       * - For ApiRx, `decorateMethod` should just be identity, because the input
       * function is already an Observable
       * - For ApiPromise, `decorateMethod` should return a function that takes all
       * the parameters from `method`, adds an optional `callback` argument, and
       * returns a Promise.
       *
       * We could easily imagine other user-facing interfaces, which are simply
       * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon
       * via `decorateMethod`.
       */
      _decorateMethod;
      /**
       * @description Create an instance of the class
       *
       * @param options Options object to create API instance or a Provider instance
       *
       * @example
       * <BR>
       *
       * ```javascript
       * import Api from '@polkadot/api/promise';
       *
       * const api = new Api().isReady();
       *
       * api.rpc.subscribeNewHeads((header) => {
       *   console.log(`new block #${header.number.toNumber()}`);
       * });
       * ```
       */
      constructor(options, type, decorateMethod) {
        super();
        this.__internal__instanceId = `${++instanceCounter}`;
        this.__internal__registry = options.source?.registry || options.registry || new TypeRegistry();
        this._rx.callAt = (blockHash, knownVersion) => (0, import_rxjs88.from)(this.at(blockHash, knownVersion)).pipe((0, import_rxjs88.map)((a) => a.rx.call));
        this._rx.queryAt = (blockHash, knownVersion) => (0, import_rxjs88.from)(this.at(blockHash, knownVersion)).pipe((0, import_rxjs88.map)((a) => a.rx.query));
        this._rx.registry = this.__internal__registry;
        this._decorateMethod = decorateMethod;
        this._options = options;
        this._type = type;
        const provider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new WsProvider();
        this._rpcCore = new RpcCore(this.__internal__instanceId, this.__internal__registry, {
          isPedantic: this._options.isPedantic,
          provider,
          rpcCacheCapacity: this._options.rpcCacheCapacity,
          userRpc: this._options.rpc
        });
        this._isConnected = new import_rxjs88.BehaviorSubject(this._rpcCore.provider.isConnected);
        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
      }
      /**
       * @description Return the current used registry
       */
      get registry() {
        return this.__internal__registry;
      }
      /**
       * @description Creates an instance of a type as registered
       */
      createType(type, ...params) {
        return this.__internal__registry.createType(type, ...params);
      }
      /**
       * @description Register additional user-defined of chain-specific types in the type registry
       */
      registerTypes(types4) {
        types4 && this.__internal__registry.register(types4);
      }
      /**
       * @returns `true` if the API operates with subscriptions
       */
      get hasSubscriptions() {
        return this._rpcCore.provider.hasSubscriptions;
      }
      /**
       * @returns `true` if the API decorate multi-key queries
       */
      get supportMulti() {
        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;
      }
      _emptyDecorated(registry, blockHash) {
        return {
          call: {},
          consts: {},
          errors: {},
          events: {},
          query: {},
          registry,
          rx: {
            call: {},
            query: {}
          },
          tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)
        };
      }
      _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {
        if (!decoratedApi) {
          decoratedApi = this._emptyDecorated(registry.registry, blockHash);
        }
        if (fromEmpty || !registry.decoratedMeta) {
          registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);
        }
        const runtime37 = this._decorateCalls(registry, this._decorateMethod, blockHash);
        const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);
        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);
        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);
        augmentObject("consts", registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);
        augmentObject("errors", registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);
        augmentObject("events", registry.decoratedMeta.events, decoratedApi.events, fromEmpty);
        augmentObject("query", storage, decoratedApi.query, fromEmpty);
        augmentObject("query", storageRx, decoratedApi.rx.query, fromEmpty);
        augmentObject("call", runtime37, decoratedApi.call, fromEmpty);
        augmentObject("call", runtimeRx, decoratedApi.rx.call, fromEmpty);
        decoratedApi.findCall = (callIndex) => findCall(registry.registry, callIndex);
        decoratedApi.findError = (errorIndex) => findError(registry.registry, errorIndex);
        decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);
        decoratedApi.runtimeVersion = registry.runtimeVersion;
        return {
          createdAt: blockHash,
          decoratedApi,
          decoratedMeta: registry.decoratedMeta
        };
      }
      _injectMetadata(registry, fromEmpty = false) {
        if (fromEmpty || !registry.decoratedApi) {
          registry.decoratedApi = this._emptyDecorated(registry.registry);
        }
        const { decoratedApi, decoratedMeta } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);
        this._call = decoratedApi.call;
        this._consts = decoratedApi.consts;
        this._errors = decoratedApi.errors;
        this._events = decoratedApi.events;
        this._query = decoratedApi.query;
        this._rx.call = decoratedApi.rx.call;
        this._rx.query = decoratedApi.rx.query;
        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);
        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);
        if (fromEmpty || !this._extrinsics) {
          this._extrinsics = tx;
          this._rx.tx = rxtx;
        } else {
          augmentObject("tx", tx, this._extrinsics, false);
          augmentObject(null, rxtx, this._rx.tx, false);
        }
        augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);
        this.emit("decorated");
      }
      /**
       * @deprecated
       * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)
       */
      injectMetadata(metadata, fromEmpty, registry) {
        this._injectMetadata({ counter: 0, metadata, registry: registry || this.__internal__registry, runtimeVersion: this.__internal__registry.createType("RuntimeVersionPartial") }, fromEmpty);
      }
      _decorateFunctionMeta(input, output) {
        output.meta = input.meta;
        output.method = input.method;
        output.section = input.section;
        output.toJSON = input.toJSON;
        if (input.callIndex) {
          output.callIndex = input.callIndex;
        }
        return output;
      }
      // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following
      // manner to cater for both old and new:
      //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)
      //   - when non-zero, remove anything that is not in the array (we don't do this)
      _filterRpc(methods, additional) {
        if (Object.keys(additional).length !== 0) {
          this._rpcCore.addUserInterfaces(additional);
          this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);
          this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);
        }
        const sectionMap = {};
        for (let i2 = 0, count = methods.length; i2 < count; i2++) {
          const [section2] = methods[i2].split("_");
          sectionMap[section2] = true;
        }
        const sections = Object.keys(sectionMap);
        for (let i2 = 0, count = sections.length; i2 < count; i2++) {
          const nameA = stringUpperFirst(sections[i2]);
          const nameB = `${nameA}Api`;
          this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;
          this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;
        }
        this._filterRpcMethods(methods);
      }
      _filterRpcMethods(exposed) {
        const hasResults = exposed.length !== 0;
        const allKnown = [...this._rpcCore.mapping.entries()];
        const allKeys = [];
        const count = allKnown.length;
        for (let i2 = 0; i2 < count; i2++) {
          const [, { alias: alias2, endpoint, method, pubsub, section: section2 }] = allKnown[i2];
          allKeys.push(`${section2}_${method}`);
          if (pubsub) {
            allKeys.push(`${section2}_${pubsub[1]}`);
            allKeys.push(`${section2}_${pubsub[2]}`);
          }
          if (alias2) {
            allKeys.push(...alias2);
          }
          if (endpoint) {
            allKeys.push(endpoint);
          }
        }
        const unknown = exposed.filter((k) => !allKeys.includes(k) && !k.includes("_unstable_"));
        if (unknown.length && !this._options.noInitWarn) {
          l13.warn(`RPC methods not decorated: ${unknown.join(", ")}`);
        }
        for (let i2 = 0; i2 < count; i2++) {
          const [k, { method, section: section2 }] = allKnown[i2];
          if (hasResults && !exposed.includes(k) && k !== "rpc_methods") {
            if (this._rpc[section2]) {
              delete this._rpc[section2][method];
              delete this._rx.rpc[section2][method];
            }
          }
        }
      }
      _rpcSubmitter(decorateMethod) {
        const method = (method2, ...params) => {
          return (0, import_rxjs88.from)(this._rpcCore.provider.send(method2, params));
        };
        return decorateMethod(method);
      }
      _decorateRpc(rpc18, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {
        const out = input;
        const decorateFn = (section2, method) => {
          const source = rpc18[section2][method];
          const fn = decorateMethod(source, { methodName: method });
          fn.meta = source.meta;
          fn.raw = decorateMethod(source.raw, { methodName: method });
          return fn;
        };
        for (let s2 = 0, scount = rpc18.sections.length; s2 < scount; s2++) {
          const section2 = rpc18.sections[s2];
          if (!Object.prototype.hasOwnProperty.call(out, section2)) {
            const methods = Object.keys(rpc18[section2]);
            const decorateInternal = (method) => decorateFn(section2, method);
            for (let m2 = 0, mcount = methods.length; m2 < mcount; m2++) {
              const method = methods[m2];
              if (this.hasSubscriptions || !(method.startsWith("subscribe") || method.startsWith("unsubscribe"))) {
                if (!Object.prototype.hasOwnProperty.call(out, section2)) {
                  out[section2] = {};
                }
                lazyMethod(out[section2], method, decorateInternal);
              }
            }
          }
        }
        return out;
      }
      // add all definition entries
      _addRuntimeDef(result, additional) {
        if (!additional) {
          return;
        }
        const entries = Object.entries(additional);
        for (let j = 0, ecount = entries.length; j < ecount; j++) {
          const [key, defs] = entries[j];
          if (result[key]) {
            for (let k = 0, dcount = defs.length; k < dcount; k++) {
              const def = defs[k];
              const prev = result[key].find(({ version }) => def.version === version);
              if (prev) {
                objectSpread(prev.methods, def.methods);
              } else {
                result[key].push(def);
              }
            }
          } else {
            result[key] = defs;
          }
        }
      }
      // extract all runtime definitions
      _getRuntimeDefs(registry, specName, chain2 = "") {
        const result = {};
        const defValues = Object.values(definitions_exports);
        for (let i2 = 0, count = defValues.length; i2 < count; i2++) {
          this._addRuntimeDef(result, defValues[i2].runtime);
        }
        this._addRuntimeDef(result, getSpecRuntime(registry, chain2, specName));
        this._addRuntimeDef(result, this._options.runtime);
        return Object.entries(result);
      }
      // Helper for _getRuntimeDefsViaMetadata
      _getMethods(registry, methods) {
        const result = {};
        methods.forEach((m2) => {
          const { docs, inputs, name, output } = m2;
          result[name.toString()] = {
            description: docs.map((d) => d.toString()).join(),
            params: inputs.map(({ name: name2, type }) => {
              return { name: name2.toString(), type: registry.lookup.getName(type) || registry.lookup.getTypeDef(type).type };
            }),
            type: registry.lookup.getName(output) || registry.lookup.getTypeDef(output).type
          };
        });
        return result;
      }
      // Maintains the same structure as `_getRuntimeDefs` in order to make conversion easier.
      _getRuntimeDefsViaMetadata(registry) {
        const result = {};
        const { apis } = registry.metadata;
        for (let i2 = 0, count = apis.length; i2 < count; i2++) {
          const { methods, name } = apis[i2];
          result[name.toString()] = [{
            methods: this._getMethods(registry, methods),
            // We set the version to 0 here since it will not be relevant when we are grabbing the runtime apis
            // from the Metadata.
            version: 0
          }];
        }
        return Object.entries(result);
      }
      // When the calls are available in the metadata, it will generate them based off of the metadata.
      // When they are not available it will use the hardcoded calls generated in the static types.
      _decorateCalls({ registry, runtimeVersion: { apis, specName, specVersion } }, decorateMethod, blockHash) {
        const result = {};
        const named = {};
        const hashes = {};
        const isApiInMetadata = registry.metadata.apis.length > 0;
        const sections = isApiInMetadata ? this._getRuntimeDefsViaMetadata(registry) : this._getRuntimeDefs(registry, specName, this._runtimeChain);
        const older = [];
        const implName = `${specName.toString()}/${specVersion.toString()}`;
        const hasLogged = this.__internal__runtimeLog[implName] || false;
        this.__internal__runtimeLog[implName] = true;
        if (isApiInMetadata) {
          for (let i2 = 0, scount = sections.length; i2 < scount; i2++) {
            const [_section, secs] = sections[i2];
            const sec = secs[0];
            const sectionHash = blake2AsHex(_section, 64);
            const section2 = stringCamelCase(_section);
            const methods = Object.entries(sec.methods);
            if (!named[section2]) {
              named[section2] = {};
            }
            for (let m2 = 0, mcount = methods.length; m2 < mcount; m2++) {
              const [_method, def] = methods[m2];
              const method = stringCamelCase(_method);
              named[section2][method] = objectSpread({ method, name: `${_section}_${_method}`, section: section2, sectionHash }, def);
            }
          }
        } else {
          for (let i2 = 0, scount = sections.length; i2 < scount; i2++) {
            const [_section, secs] = sections[i2];
            const sectionHash = blake2AsHex(_section, 64);
            const rtApi = apis.find(([a]) => a.eq(sectionHash));
            hashes[sectionHash] = true;
            if (rtApi) {
              const all3 = secs.map(({ version }) => version).sort();
              const sec = secs.find(({ version }) => rtApi[1].eq(version));
              if (sec) {
                const section2 = stringCamelCase(_section);
                const methods = Object.entries(sec.methods);
                if (methods.length) {
                  if (!named[section2]) {
                    named[section2] = {};
                  }
                  for (let m2 = 0, mcount = methods.length; m2 < mcount; m2++) {
                    const [_method, def] = methods[m2];
                    const method = stringCamelCase(_method);
                    named[section2][method] = objectSpread({ method, name: `${_section}_${_method}`, section: section2, sectionHash }, def);
                  }
                }
              } else {
                older.push(`${_section}/${rtApi[1].toString()} (${all3.join("/")} known)`);
              }
            }
          }
          const notFound = apis.map(([a, v]) => [a.toHex(), v.toString()]).filter(([a]) => !hashes[a]).map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);
          if (!this._options.noInitWarn && !hasLogged) {
            if (older.length) {
              l13.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(", ")}`);
            }
            if (notFound.length) {
              l13.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(", ")}`);
            }
          }
        }
        const stateCall = blockHash ? (name, bytes2) => this._rpcCore.state.call(name, bytes2, blockHash) : (name, bytes2) => this._rpcCore.state.call(name, bytes2);
        const lazySection = (section2) => lazyMethods({}, Object.keys(named[section2]), (method) => this._decorateCall(registry, named[section2][method], stateCall, decorateMethod));
        const modules = Object.keys(named);
        for (let i2 = 0, count = modules.length; i2 < count; i2++) {
          lazyMethod(result, modules[i2], lazySection);
        }
        return result;
      }
      _decorateCall(registry, def, stateCall, decorateMethod) {
        const decorated = decorateMethod((...args) => {
          if (args.length !== def.params.length) {
            throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);
          }
          const bytes2 = registry.createType("Raw", u8aConcatStrict(args.map((a, i2) => registry.createTypeUnsafe(def.params[i2].type, [a]).toU8a())));
          return stateCall(def.name, bytes2).pipe((0, import_rxjs88.map)((r2) => registry.createTypeUnsafe(def.type, [r2])));
        });
        decorated.meta = def;
        return decorated;
      }
      // only be called if supportMulti is true
      _decorateMulti(decorateMethod) {
        return decorateMethod((keys2) => keys2.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys2.map((args) => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])) : (0, import_rxjs88.of)([]));
      }
      _decorateMultiAt(atApi, decorateMethod, blockHash) {
        return decorateMethod((calls) => calls.length ? this._rpcCore.state.queryStorageAt(calls.map((args) => {
          if (Array.isArray(args)) {
            const { creator } = getAtQueryFn(atApi, args[0].creator);
            return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];
          }
          return [getAtQueryFn(atApi, args.creator).creator];
        }), blockHash) : (0, import_rxjs88.of)([]));
      }
      _decorateExtrinsics({ tx }, decorateMethod) {
        const result = createSubmittable(this._type, this._rx, decorateMethod);
        const lazySection = (section2) => lazyMethods({}, Object.keys(tx[section2]), (method) => method.startsWith("$") ? tx[section2][method] : this._decorateExtrinsicEntry(tx[section2][method], result));
        const sections = Object.keys(tx);
        for (let i2 = 0, count = sections.length; i2 < count; i2++) {
          lazyMethod(result, sections[i2], lazySection);
        }
        return result;
      }
      _decorateExtrinsicEntry(method, creator) {
        const decorated = (...params) => creator(method(...params));
        decorated.is = (other) => method.is(other);
        return this._decorateFunctionMeta(method, decorated);
      }
      _decorateStorage({ query: query2, registry }, decorateMethod, blockHash) {
        const result = {};
        const lazySection = (section2) => lazyMethods({}, Object.keys(query2[section2]), (method) => blockHash ? this._decorateStorageEntryAt(registry, query2[section2][method], decorateMethod, blockHash) : this._decorateStorageEntry(query2[section2][method], decorateMethod));
        const sections = Object.keys(query2);
        for (let i2 = 0, count = sections.length; i2 < count; i2++) {
          lazyMethod(result, sections[i2], lazySection);
        }
        return result;
      }
      _decorateStorageEntry(creator, decorateMethod) {
        const getArgs = (args, registry) => extractStorageArgs(registry || this.__internal__registry, creator, args);
        const getQueryAt = (blockHash) => (0, import_rxjs88.from)(this.at(blockHash)).pipe((0, import_rxjs88.map)((api) => getAtQueryFn(api, creator)));
        const decorated = this._decorateStorageCall(creator, decorateMethod);
        decorated.creator = creator;
        decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe((0, import_rxjs88.switchMap)((q) => q(...args))));
        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));
        decorated.is = (key) => key.section === creator.section && key.method === creator.method;
        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);
        decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));
        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));
        decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe((0, import_rxjs88.switchMap)((q) => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));
        if (creator.iterKey && creator.meta.type.isMap) {
          decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, null, args)));
          decorated.entriesAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe((0, import_rxjs88.switchMap)((q) => this._retrieveMapEntries(q.creator, blockHash, args)))));
          decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapEntriesPaged(creator, void 0, opts)));
          decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, null, args)));
          decorated.keysAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe((0, import_rxjs88.switchMap)((q) => this._retrieveMapKeys(q.creator, blockHash, args)))));
          decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapKeysPaged(creator, void 0, opts)));
        }
        if (this.supportMulti && creator.meta.type.isMap) {
          decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a) => [creator, [a]])) : this._retrieveMulti(args.map((a) => [creator, a])));
        }
        return this._decorateFunctionMeta(creator, decorated);
      }
      _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {
        const getArgs = (args) => extractStorageArgs(registry, creator, args);
        const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));
        decorated.creator = creator;
        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));
        decorated.is = (key) => key.section === creator.section && key.method === creator.method;
        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);
        decorated.keyPrefix = (...keys2) => u8aToHex(creator.keyPrefix(...keys2));
        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));
        if (creator.iterKey && creator.meta.type.isMap) {
          decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, blockHash, args)));
          decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapEntriesPaged(creator, blockHash, opts)));
          decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, blockHash, args)));
          decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapKeysPaged(creator, blockHash, opts)));
        }
        if (this.supportMulti && creator.meta.type.isMap) {
          decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a) => [creator, [a]]), blockHash) : this._retrieveMulti(args.map((a) => [creator, a]), blockHash));
        }
        return this._decorateFunctionMeta(creator, decorated);
      }
      _queueStorage(call, queue) {
        const query2 = queue === this.__internal__storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
        let queueIdx = queue.length - 1;
        let valueIdx = 0;
        let valueObs;
        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {
          queueIdx++;
          valueObs = (0, import_rxjs88.from)(
            // we delay the execution until the next tick, this allows
            // any queries made in this timeframe to be added to the same
            // queue for a single query
            new Promise((resolve) => {
              nextTick(() => {
                const calls = queue[queueIdx][1];
                delete queue[queueIdx];
                resolve(calls);
              });
            })
          ).pipe((0, import_rxjs88.switchMap)((calls) => query2(calls)));
          queue.push([valueObs, [call]]);
        } else {
          valueObs = queue[queueIdx][0];
          valueIdx = queue[queueIdx][1].length;
          queue[queueIdx][1].push(call);
        }
        return valueObs.pipe(
          // return the single value at this index
          (0, import_rxjs88.map)((values) => values[valueIdx])
        );
      }
      // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)
      // we make a subscription, alternatively we push this through a single-shot query
      _decorateStorageCall(creator, decorateMethod) {
        const memoed = memo(this.__internal__instanceId, (...args) => {
          const call = extractStorageArgs(this.__internal__registry, creator, args);
          if (!this.hasSubscriptions) {
            return this._rpcCore.state.getStorage(call);
          }
          return this._queueStorage(call, this.__internal__storageSubQ);
        });
        return decorateMethod(memoed, {
          methodName: creator.method,
          overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(this.__internal__registry, creator, args), this.__internal__storageGetQ)
        });
      }
      // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes
      _retrieveMulti(keys2, blockHash) {
        if (!keys2.length) {
          return (0, import_rxjs88.of)([]);
        }
        const query2 = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
        if (keys2.length <= PAGE_SIZE_V) {
          return blockHash ? query2(keys2, blockHash) : query2(keys2);
        }
        return (0, import_rxjs88.combineLatest)(arrayChunk(keys2, PAGE_SIZE_V).map((k) => blockHash ? query2(k, blockHash) : query2(k))).pipe((0, import_rxjs88.map)(arrayFlatten));
      }
      _retrieveMapKeys({ iterKey, meta, method, section: section2 }, at, args) {
        if (!iterKey || !meta.type.isMap) {
          throw new Error("keys can only be retrieved on maps");
        }
        const headKey = iterKey(...args).toHex();
        const startSubject = new import_rxjs88.BehaviorSubject(headKey);
        const query2 = at ? (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K2, startKey, at) : (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K2, startKey);
        const setMeta = (key) => key.setMeta(meta, section2, method);
        return startSubject.pipe(
          (0, import_rxjs88.switchMap)(query2),
          (0, import_rxjs88.map)((keys2) => keys2.map(setMeta)),
          (0, import_rxjs88.tap)((keys2) => nextTick(() => {
            keys2.length === PAGE_SIZE_K2 ? startSubject.next(keys2[PAGE_SIZE_K2 - 1].toHex()) : startSubject.complete();
          })),
          (0, import_rxjs88.toArray)(),
          // toArray since we want to startSubject to be completed
          (0, import_rxjs88.map)(arrayFlatten)
        );
      }
      _retrieveMapKeysPaged({ iterKey, meta, method, section: section2 }, at, opts) {
        if (!iterKey || !meta.type.isMap) {
          throw new Error("keys can only be retrieved on maps");
        }
        const setMeta = (key) => key.setMeta(meta, section2, method);
        const query2 = at ? (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);
        return query2(iterKey(...opts.args).toHex()).pipe((0, import_rxjs88.map)((keys2) => keys2.map(setMeta)));
      }
      _retrieveMapEntries(entry, at, args) {
        const query2 = at ? (keys2) => this._rpcCore.state.queryStorageAt(keys2, at) : (keys2) => this._rpcCore.state.queryStorageAt(keys2);
        return this._retrieveMapKeys(entry, at, args).pipe((0, import_rxjs88.switchMap)((keys2) => keys2.length ? (0, import_rxjs88.combineLatest)(arrayChunk(keys2, PAGE_SIZE_V).map(query2)).pipe((0, import_rxjs88.map)((valsArr) => arrayFlatten(valsArr).map((value, index) => [keys2[index], value]))) : (0, import_rxjs88.of)([])));
      }
      _retrieveMapEntriesPaged(entry, at, opts) {
        const query2 = at ? (keys2) => this._rpcCore.state.queryStorageAt(keys2, at) : (keys2) => this._rpcCore.state.queryStorageAt(keys2);
        return this._retrieveMapKeysPaged(entry, at, opts).pipe((0, import_rxjs88.switchMap)((keys2) => keys2.length ? query2(keys2).pipe((0, import_rxjs88.map)((valsArr) => valsArr.map((value, index) => [keys2[index], value]))) : (0, import_rxjs88.of)([])));
      }
      _decorateDeriveRx(decorateMethod) {
        const specName = this._runtimeVersion?.specName.toString();
        const available = getAvailableDerives(this.__internal__instanceId, this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || ""]?.derives));
        return decorateDeriveSections(decorateMethod, available);
      }
      _decorateDerive(decorateMethod) {
        return decorateDeriveSections(decorateMethod, this._rx.derive);
      }
      /**
       * Put the `this.onCall` function of ApiRx here, because it is needed by
       * `api._rx`.
       */
      _rxDecorateMethod = (method) => {
        return method;
      };
    };
  }
});

// ../../node_modules/@polkadot/api/base/Init.js
function textToString(t2) {
  return t2.toString();
}
var import_rxjs89, KEEPALIVE_INTERVAL, WITH_VERSION_SHORTCUT, SUPPORTED_METADATA_VERSIONS, l14, Init;
var init_Init = __esm({
  "../../node_modules/@polkadot/api/base/Init.js"() {
    import_rxjs89 = __toESM(require_cjs(), 1);
    init_types3();
    init_types_known();
    init_util();
    init_util_crypto();
    init_Decorate();
    KEEPALIVE_INTERVAL = 1e4;
    WITH_VERSION_SHORTCUT = false;
    SUPPORTED_METADATA_VERSIONS = [15, 14];
    l14 = logger("api/init");
    Init = class extends Decorate {
      __internal__atLast = null;
      __internal__healthTimer = null;
      __internal__registries = [];
      __internal__updateSub = null;
      __internal__waitingRegistries = {};
      constructor(options, type, decorateMethod) {
        super(options, type, decorateMethod);
        this.registry.setKnownTypes(options);
        if (!options.source) {
          this.registerTypes(options.types);
        } else {
          this.__internal__registries = options.source.__internal__registries;
        }
        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);
        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);
        if (this.supportMulti) {
          this._queryMulti = this._decorateMulti(this._decorateMethod);
          this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);
        }
        this._rx.signer = options.signer;
        this._rpcCore.setRegistrySwap((blockHash) => this.getBlockRegistry(blockHash));
        this._rpcCore.setResolveBlockHash((blockNumber) => (0, import_rxjs89.firstValueFrom)(this._rpcCore.chain.getBlockHash(blockNumber)));
        if (this.hasSubscriptions) {
          this._rpcCore.provider.on("disconnected", () => this.__internal__onProviderDisconnect());
          this._rpcCore.provider.on("error", (e2) => this.__internal__onProviderError(e2));
          this._rpcCore.provider.on("connected", () => this.__internal__onProviderConnect());
        } else if (!this._options.noInitWarn) {
          l14.warn("Api will be available in a limited mode since the provider does not support subscriptions");
        }
        if (this._rpcCore.provider.isConnected) {
          this.__internal__onProviderConnect().catch(noop);
        }
      }
      /**
       * @description Decorates a registry based on the runtime version
       */
      _initRegistry(registry, chain2, version, metadata, chainProps) {
        registry.clearCache();
        registry.setChainProperties(chainProps || this.registry.getChainProperties());
        registry.setKnownTypes(this._options);
        registry.register(getSpecTypes(registry, chain2, version.specName, version.specVersion));
        registry.setHasher(getSpecHasher(registry, chain2, version.specName));
        if (registry.knownTypes.typesBundle) {
          registry.knownTypes.typesAlias = getSpecAlias(registry, chain2, version.specName);
        }
        registry.setMetadata(metadata, void 0, objectSpread({}, getSpecExtensions(registry, chain2, version.specName), this._options.signedExtensions), this._options.noInitWarn);
      }
      /**
       * @description Returns the default versioned registry
       */
      _getDefaultRegistry() {
        return assertReturn(this.__internal__registries.find(({ isDefault }) => isDefault), "Initialization error, cannot find the default registry");
      }
      /**
       * @description Returns a decorated API instance at a specific point in time
       */
      async at(blockHash, knownVersion) {
        const u8aHash = u8aToU8a(blockHash);
        const u8aHex = u8aToHex(u8aHash);
        const registry = await this.getBlockRegistry(u8aHash, knownVersion);
        if (!this.__internal__atLast || this.__internal__atLast[0] !== u8aHex) {
          this.__internal__atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];
        }
        return this.__internal__atLast[1];
      }
      async _createBlockRegistry(blockHash, header, version) {
        const registry = new TypeRegistry(blockHash);
        const metadata = await this._retrieveMetadata(version.apis, header.parentHash, registry);
        const runtimeChain = this._runtimeChain;
        if (!runtimeChain) {
          throw new Error("Invalid initializion order, runtimeChain is not available");
        }
        this._initRegistry(registry, runtimeChain, version, metadata);
        const result = { counter: 0, lastBlockHash: blockHash, metadata, registry, runtimeVersion: version };
        this.__internal__registries.push(result);
        return result;
      }
      _cacheBlockRegistryProgress(key, creator) {
        let waiting = this.__internal__waitingRegistries[key];
        if (isUndefined(waiting)) {
          waiting = this.__internal__waitingRegistries[key] = new Promise((resolve, reject) => {
            creator().then((registry) => {
              delete this.__internal__waitingRegistries[key];
              resolve(registry);
            }).catch((error) => {
              delete this.__internal__waitingRegistries[key];
              reject(error);
            });
          });
        }
        return waiting;
      }
      _getBlockRegistryViaVersion(blockHash, version) {
        if (version) {
          const existingViaVersion = this.__internal__registries.find(({ runtimeVersion: { specName, specVersion } }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));
          if (existingViaVersion) {
            existingViaVersion.counter++;
            existingViaVersion.lastBlockHash = blockHash;
            return existingViaVersion;
          }
        }
        return null;
      }
      async _getBlockRegistryViaHash(blockHash) {
        if (!this._genesisHash || !this._runtimeVersion) {
          throw new Error("Cannot retrieve data on an uninitialized chain");
        }
        const header = this.registry.createType("HeaderPartial", this._genesisHash.eq(blockHash) ? { number: BN_ZERO, parentHash: this._genesisHash } : await (0, import_rxjs89.firstValueFrom)(this._rpcCore.chain.getHeader.raw(blockHash)));
        if (header.parentHash.isEmpty) {
          throw new Error("Unable to retrieve header and parent from supplied hash");
        }
        const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);
        const version = this.registry.createType("RuntimeVersionPartial", WITH_VERSION_SHORTCUT && (firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion))) ? { apis: firstVersion.apis, specName: this._runtimeVersion.specName, specVersion: firstVersion.specVersion } : await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));
        return (
          // try to find via version
          this._getBlockRegistryViaVersion(blockHash, version) || // return new or in-flight result
          await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version))
        );
      }
      /**
       * @description Sets up a registry based on the block hash defined
       */
      async getBlockRegistry(blockHash, knownVersion) {
        return (
          // try to find via blockHash
          this.__internal__registries.find(({ lastBlockHash }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) || // try to find via version
          this._getBlockRegistryViaVersion(blockHash, knownVersion) || // return new or in-flight result
          await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash))
        );
      }
      async _loadMeta() {
        if (this._isReady) {
          if (!this._options.source) {
            this._subscribeUpdates();
          }
          return true;
        }
        this._unsubscribeUpdates();
        [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);
        return this._initFromMeta(this._runtimeMetadata);
      }
      // eslint-disable-next-line @typescript-eslint/require-await
      async _metaFromSource(source) {
        this._extrinsicType = source.extrinsicVersion;
        this._runtimeChain = source.runtimeChain;
        this._runtimeVersion = source.runtimeVersion;
        const sections = Object.keys(source.rpc);
        const rpcs = [];
        for (let s2 = 0, scount = sections.length; s2 < scount; s2++) {
          const section2 = sections[s2];
          const methods = Object.keys(source.rpc[section2]);
          for (let m2 = 0, mcount = methods.length; m2 < mcount; m2++) {
            rpcs.push(`${section2}_${methods[m2]}`);
          }
        }
        this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));
        return [source.genesisHash, source.runtimeMetadata];
      }
      // subscribe to metadata updates, inject the types on changes
      _subscribeUpdates() {
        if (this.__internal__updateSub || !this.hasSubscriptions) {
          return;
        }
        this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, import_rxjs89.switchMap)((version) => (
          // only retrieve the metadata when the on-chain version has been changed
          this._runtimeVersion?.specVersion.eq(version.specVersion) ? (0, import_rxjs89.of)(false) : this._rpcCore.state.getMetadata().pipe((0, import_rxjs89.map)((metadata) => {
            l14.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);
            this._runtimeMetadata = metadata;
            this._runtimeVersion = version;
            this._rx.runtimeVersion = version;
            const thisRegistry = this._getDefaultRegistry();
            const runtimeChain = this._runtimeChain;
            if (!runtimeChain) {
              throw new Error("Invalid initializion order, runtimeChain is not available");
            }
            thisRegistry.metadata = metadata;
            thisRegistry.runtimeVersion = version;
            this._initRegistry(this.registry, runtimeChain, version, metadata);
            this._injectMetadata(thisRegistry, true);
            return true;
          }))
        ))).subscribe();
      }
      async _metaFromChain(optMetadata) {
        const [genesisHash, runtimeVersion, chain2, chainProps, rpcMethods] = await Promise.all([
          (0, import_rxjs89.firstValueFrom)(this._rpcCore.chain.getBlockHash(0)),
          (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.getRuntimeVersion()),
          (0, import_rxjs89.firstValueFrom)(this._rpcCore.system.chain()),
          (0, import_rxjs89.firstValueFrom)(this._rpcCore.system.properties()),
          (0, import_rxjs89.firstValueFrom)(this._rpcCore.rpc.methods())
        ]);
        this._runtimeChain = chain2;
        this._runtimeVersion = runtimeVersion;
        this._rx.runtimeVersion = runtimeVersion;
        const metadataKey = `${genesisHash.toHex() || "0x"}-${runtimeVersion.specVersion.toString()}`;
        const metadata = optMetadata?.[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await this._retrieveMetadata(runtimeVersion.apis);
        this._initRegistry(this.registry, chain2, runtimeVersion, metadata, chainProps);
        this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain2, runtimeVersion.specName));
        this._subscribeUpdates();
        if (!this.__internal__registries.length) {
          this.__internal__registries.push({ counter: 0, isDefault: true, metadata, registry: this.registry, runtimeVersion });
        }
        metadata.getUniqTypes(this._options.throwOnUnknown || false);
        return [genesisHash, metadata];
      }
      _initFromMeta(metadata) {
        const runtimeVersion = this._runtimeVersion;
        if (!runtimeVersion) {
          throw new Error("Invalid initializion order, runtimeVersion is not available");
        }
        this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();
        this._rx.extrinsicType = this._extrinsicType;
        this._rx.genesisHash = this._genesisHash;
        this._rx.runtimeVersion = runtimeVersion;
        this._injectMetadata(this._getDefaultRegistry(), true);
        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);
        this._derive = this._decorateDerive(this._decorateMethod);
        return true;
      }
      /**
       * @internal
       *
       * Tries to use runtime api calls to retrieve metadata. This ensures the api initializes with the latest metadata.
       * If the runtime call is not there it will use the rpc method.
       */
      async _retrieveMetadata(apis, at, registry) {
        let metadataVersion = null;
        const metadataApi = apis.find(([a]) => a.eq(blake2AsHex("Metadata", 64)));
        const typeRegistry = registry || this.registry;
        if (!metadataApi || metadataApi[1].toNumber() < 2) {
          l14.warn("MetadataApi not available, rpc::state::get_metadata will be used.");
          return at ? new Metadata(typeRegistry, await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.getMetadata.raw(at))) : await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.getMetadata());
        }
        try {
          const metadataVersionsAsBytes = at ? await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.call.raw("Metadata_metadata_versions", "0x", at)) : await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.call("Metadata_metadata_versions", "0x"));
          const versions = typeRegistry.createType("Vec<u32>", metadataVersionsAsBytes);
          metadataVersion = versions.reduce((largest, current) => current.gt(largest) ? current : largest);
        } catch (e2) {
          l14.debug(e2.message);
          l14.warn("error with state_call::Metadata_metadata_versions, rpc::state::get_metadata will be used");
        }
        if (metadataVersion && !SUPPORTED_METADATA_VERSIONS.includes(metadataVersion.toNumber())) {
          metadataVersion = null;
        }
        if (metadataVersion) {
          try {
            const metadataBytes = at ? await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.call.raw("Metadata_metadata_at_version", u8aToHex(metadataVersion.toU8a()), at)) : await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.call("Metadata_metadata_at_version", u8aToHex(metadataVersion.toU8a())));
            const rawMeta = at ? typeRegistry.createType("Raw", metadataBytes).toU8a() : metadataBytes;
            const opaqueMetadata = typeRegistry.createType("Option<OpaqueMetadata>", rawMeta).unwrapOr(null);
            if (opaqueMetadata) {
              return new Metadata(typeRegistry, opaqueMetadata.toHex());
            }
          } catch (e2) {
            l14.debug(e2.message);
            l14.warn("error with state_call::Metadata_metadata_at_version, rpc::state::get_metadata will be used");
          }
        }
        return at ? new Metadata(typeRegistry, await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.getMetadata.raw(at))) : await (0, import_rxjs89.firstValueFrom)(this._rpcCore.state.getMetadata());
      }
      _subscribeHealth() {
        this._unsubscribeHealth();
        this.__internal__healthTimer = this.hasSubscriptions ? setInterval(() => {
          (0, import_rxjs89.firstValueFrom)(this._rpcCore.system.health.raw()).catch(noop);
        }, KEEPALIVE_INTERVAL) : null;
      }
      _unsubscribeHealth() {
        if (this.__internal__healthTimer) {
          clearInterval(this.__internal__healthTimer);
          this.__internal__healthTimer = null;
        }
      }
      _unsubscribeUpdates() {
        if (this.__internal__updateSub) {
          this.__internal__updateSub.unsubscribe();
          this.__internal__updateSub = null;
        }
      }
      _unsubscribe() {
        this._unsubscribeHealth();
        this._unsubscribeUpdates();
      }
      async __internal__onProviderConnect() {
        this._isConnected.next(true);
        this.emit("connected");
        try {
          const cryptoReady = this._options.initWasm === false ? true : await cryptoWaitReady();
          const hasMeta = await this._loadMeta();
          this._subscribeHealth();
          if (hasMeta && !this._isReady && cryptoReady) {
            this._isReady = true;
            this.emit("ready", this);
          }
        } catch (_error) {
          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);
          l14.error(error);
          this.emit("error", error);
        }
      }
      __internal__onProviderDisconnect() {
        this._isConnected.next(false);
        this._unsubscribe();
        this.emit("disconnected");
      }
      __internal__onProviderError(error) {
        this.emit("error", error);
      }
    };
  }
});

// ../../node_modules/@polkadot/api/base/Getters.js
function assertResult(value) {
  if (value === void 0) {
    throw new Error("Api interfaces needs to be initialized before using, wait for 'isReady'");
  }
  return value;
}
var Getters;
var init_Getters = __esm({
  "../../node_modules/@polkadot/api/base/Getters.js"() {
    init_packageInfo9();
    init_find();
    init_Init();
    Getters = class extends Init {
      /**
       * @description Runtime call interfaces (currently untyped, only decorated via API options)
       */
      get call() {
        return assertResult(this._call);
      }
      /**
       * @description Contains the parameter types (constants) of all modules.
       *
       * The values are instances of the appropriate type and are accessible using `section`.`constantName`,
       *
       * @example
       * <BR>
       *
       * ```javascript
       * console.log(api.consts.democracy.enactmentPeriod.toString())
       * ```
       */
      get consts() {
        return assertResult(this._consts);
      }
      /**
       * @description Derived results that are injected into the API, allowing for combinations of various query results.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * api.derive.chain.bestNumber((number) => {
       *   console.log('best number', number);
       * });
       * ```
       */
      get derive() {
        return assertResult(this._derive);
      }
      /**
       * @description Errors from metadata
       */
      get errors() {
        return assertResult(this._errors);
      }
      /**
       * @description Events from metadata
       */
      get events() {
        return assertResult(this._events);
      }
      /**
       * @description  Returns the version of extrinsics in-use on this chain
       */
      get extrinsicVersion() {
        return this._extrinsicType;
      }
      /**
       * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.
       */
      get genesisHash() {
        return assertResult(this._genesisHash);
      }
      /**
       * @description true is the underlying provider is connected
       */
      get isConnected() {
        return this._isConnected.getValue();
      }
      /**
       * @description The library information name & version (from package.json)
       */
      get libraryInfo() {
        return `${packageInfo9.name} v${packageInfo9.version}`;
      }
      /**
       * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.
       *
       * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * api.query.system.account(<accountId>, ([nonce, balance]) => {
       *   console.log('new free balance', balance.free, 'new nonce', nonce);
       * });
       * ```
       */
      get query() {
        return assertResult(this._query);
      }
      /**
       * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * const unsub = await api.queryMulti(
       *   [
       *     // you can include the storage without any parameters
       *     api.query.balances.totalIssuance,
       *     // or you can pass parameters to the storage query
       *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']
       *   ],
       *   ([existential, [, { free }]]) => {
       *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);
       *
       *     unsub();
       *   }
       * );
       * ```
       */
      get queryMulti() {
        return assertResult(this._queryMulti);
      }
      /**
       * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.
       *
       * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * api.rpc.chain.subscribeNewHeads((header) => {
       *   console.log('new header', header);
       * });
       * ```
       */
      get rpc() {
        return assertResult(this._rpc);
      }
      /**
       * @description Contains the chain information for the current node.
       */
      get runtimeChain() {
        return assertResult(this._runtimeChain);
      }
      /**
       * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.
       */
      get runtimeMetadata() {
        return assertResult(this._runtimeMetadata);
      }
      /**
       * @description Contains the version information for the current runtime.
       */
      get runtimeVersion() {
        return assertResult(this._runtimeVersion);
      }
      /**
       * @description The underlying Rx API interface
       */
      get rx() {
        return assertResult(this._rx);
      }
      /**
       * @description Returns the underlying provider stats
       */
      get stats() {
        return this._rpcCore.stats;
      }
      /**
       * @description The type of this API instance, either 'rxjs' or 'promise'
       */
      get type() {
        return this._type;
      }
      /**
       * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.
       *
       * @example
       * <BR>
       *
       * ```javascript
       * api.tx.balances
       *   .transferAllowDeath(<recipientId>, <balance>)
       *   .signAndSend(<keyPair>, ({status}) => {
       *     console.log('tx status', status.asFinalized.toHex());
       *   });
       * ```
       */
      get tx() {
        return assertResult(this._extrinsics);
      }
      /**
       * @description Finds the definition for a specific [[CallFunction]] based on the index supplied
       */
      findCall(callIndex) {
        return findCall(this.registry, callIndex);
      }
      /**
       * @description Finds the definition for a specific [[RegistryError]] based on the index supplied
       */
      findError(errorIndex) {
        return findError(this.registry, errorIndex);
      }
    };
  }
});

// ../../node_modules/@polkadot/api/base/index.js
var ApiBase;
var init_base3 = __esm({
  "../../node_modules/@polkadot/api/base/index.js"() {
    init_util();
    init_Getters();
    ApiBase = class extends Getters {
      /**
       * @description Create an instance of the class
       *
       * @param options Options object to create API instance or a Provider instance
       *
       * @example
       * <BR>
       *
       * ```javascript
       * import Api from '@polkadot/api/promise';
       *
       * const api = new Api().isReady();
       *
       * api.rpc.subscribeNewHeads((header) => {
       *   console.log(`new block #${header.number.toNumber()}`);
       * });
       * ```
       */
      constructor(options = {}, type, decorateMethod) {
        super(options, type, decorateMethod);
      }
      /**
       * @description Connect from the underlying provider, halting all network traffic
       */
      connect() {
        return this._rpcCore.connect();
      }
      /**
       * @description Disconnect from the underlying provider, halting all network traffic
       */
      disconnect() {
        this._unsubscribe();
        return this._rpcCore.disconnect();
      }
      /**
       * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair
       */
      setSigner(signer) {
        this._rx.signer = signer;
      }
      /**
       * @description Signs a raw signer payload, string or Uint8Array
       */
      async sign(address, data, { signer } = {}) {
        if (isString(address)) {
          const _signer = signer || this._rx.signer;
          if (!_signer?.signRaw) {
            throw new Error("No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
          }
          return (await _signer.signRaw(objectSpread({ type: "bytes" }, data, { address }))).signature;
        }
        return u8aToHex(address.sign(u8aToU8a(data.data)));
      }
    };
  }
});

// ../../node_modules/@polkadot/api/promise/Combinator.js
var Combinator;
var init_Combinator = __esm({
  "../../node_modules/@polkadot/api/promise/Combinator.js"() {
    init_util();
    Combinator = class {
      __internal__allHasFired = false;
      __internal__callback;
      __internal__fired = [];
      __internal__fns = [];
      __internal__isActive = true;
      __internal__results = [];
      __internal__subscriptions = [];
      constructor(fns, callback) {
        this.__internal__callback = callback;
        this.__internal__subscriptions = fns.map(async (input, index) => {
          const [fn, ...args] = Array.isArray(input) ? input : [input];
          this.__internal__fired.push(false);
          this.__internal__fns.push(fn);
          return fn(...args, this._createCallback(index));
        });
      }
      _allHasFired() {
        this.__internal__allHasFired ||= this.__internal__fired.filter((hasFired) => !hasFired).length === 0;
        return this.__internal__allHasFired;
      }
      _createCallback(index) {
        return (value) => {
          this.__internal__fired[index] = true;
          this.__internal__results[index] = value;
          this._triggerUpdate();
        };
      }
      _triggerUpdate() {
        if (!this.__internal__isActive || !isFunction(this.__internal__callback) || !this._allHasFired()) {
          return;
        }
        try {
          Promise.resolve(this.__internal__callback(this.__internal__results)).catch(noop);
        } catch {
        }
      }
      unsubscribe() {
        if (!this.__internal__isActive) {
          return;
        }
        this.__internal__isActive = false;
        Promise.all(this.__internal__subscriptions.map(async (subscription) => {
          try {
            const unsubscribe = await subscription;
            if (isFunction(unsubscribe)) {
              unsubscribe();
            }
          } catch {
          }
        })).catch(() => {
        });
      }
    };
  }
});

// ../../node_modules/@polkadot/api/promise/decorateMethod.js
function promiseTracker(resolve, reject) {
  let isCompleted = false;
  return {
    reject: (error) => {
      if (!isCompleted) {
        isCompleted = true;
        reject(error);
      }
      return import_rxjs90.EMPTY;
    },
    resolve: (value) => {
      if (!isCompleted) {
        isCompleted = true;
        resolve(value);
      }
    }
  };
}
function extractArgs(args, needsCallback) {
  const actualArgs = args.slice();
  const callback = args.length && isFunction(args[args.length - 1]) ? actualArgs.pop() : void 0;
  if (needsCallback && !isFunction(callback)) {
    throw new Error("Expected a callback to be passed with subscriptions");
  }
  return [actualArgs, callback];
}
function decorateCall(method, args) {
  return new Promise((resolve, reject) => {
    const tracker = promiseTracker(resolve, reject);
    const subscription = method(...args).pipe((0, import_rxjs90.catchError)((error) => tracker.reject(error))).subscribe((result) => {
      tracker.resolve(result);
      nextTick(() => subscription.unsubscribe());
    });
  });
}
function decorateSubscribe(method, args, resultCb) {
  return new Promise((resolve, reject) => {
    const tracker = promiseTracker(resolve, reject);
    const subscription = method(...args).pipe((0, import_rxjs90.catchError)((error) => tracker.reject(error)), (0, import_rxjs90.tap)(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe((result) => {
      nextTick(() => resultCb(result));
    });
  });
}
function toPromiseMethod(method, options) {
  const needsCallback = !!(options?.methodName && options.methodName.includes("subscribe"));
  return function(...args) {
    const [actualArgs, resultCb] = extractArgs(args, needsCallback);
    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall(options?.overrideNoSub || method, actualArgs);
  };
}
var import_rxjs90;
var init_decorateMethod = __esm({
  "../../node_modules/@polkadot/api/promise/decorateMethod.js"() {
    import_rxjs90 = __toESM(require_cjs(), 1);
    init_util();
  }
});

// ../../node_modules/@polkadot/api/promise/Api.js
var ApiPromise;
var init_Api = __esm({
  "../../node_modules/@polkadot/api/promise/Api.js"() {
    init_util();
    init_base3();
    init_Combinator();
    init_decorateMethod();
    ApiPromise = class _ApiPromise extends ApiBase {
      __internal__isReadyPromise;
      __internal__isReadyOrErrorPromise;
      /**
       * @description Creates an instance of the ApiPromise class
       * @param options Options to create an instance. This can be either [[ApiOptions]] or
       * an [[WsProvider]].
       * @example
       * <BR>
       *
       * ```javascript
       * import Api from '@polkadot/api/promise';
       *
       * new Api().isReady.then((api) => {
       *   api.rpc.subscribeNewHeads((header) => {
       *     console.log(`new block #${header.number.toNumber()}`);
       *   });
       * });
       * ```
       */
      constructor(options) {
        super(options, "promise", toPromiseMethod);
        this.__internal__isReadyPromise = new Promise((resolve) => {
          super.once("ready", () => resolve(this));
        });
        this.__internal__isReadyOrErrorPromise = new Promise((resolve, reject) => {
          const tracker = promiseTracker(resolve, reject);
          super.once("ready", () => tracker.resolve(this));
          super.once("error", (error) => tracker.reject(error));
        });
      }
      /**
       * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.
       * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a
       * provider (see the constructor arguments)
       * @example
       * <BR>
       *
       * ```javascript
       * import Api from '@polkadot/api/promise';
       *
       * Api.create().then(async (api) => {
       *   const timestamp = await api.query.timestamp.now();
       *
       *   console.log(`lastest block timestamp ${timestamp}`);
       * });
       * ```
       */
      static create(options) {
        const instance = new _ApiPromise(options);
        if (options && options.throwOnConnect) {
          return instance.isReadyOrError;
        }
        instance.isReadyOrError.catch(noop);
        return instance.isReady;
      }
      /**
       * @description Promise that resolves the first time we are connected and loaded
       */
      get isReady() {
        return this.__internal__isReadyPromise;
      }
      /**
       * @description Promise that resolves if we can connect, or reject if there is an error
       */
      get isReadyOrError() {
        return this.__internal__isReadyOrErrorPromise;
      }
      /**
       * @description Returns a clone of this ApiPromise instance (new underlying provider connection)
       */
      clone() {
        return new _ApiPromise(objectSpread({}, this._options, { source: this }));
      }
      /**
       * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions
       * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`
       * @param callback A callback that will return an Array of all the values this combinator has been applied to
       * @example
       * <BR>
       *
       * ```javascript
       * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';
       *
       * // combines values from balance & nonce as it updates
       * api.combineLatest([
       *   api.rpc.chain.subscribeNewHeads,
       *   (cb) => api.query.system.account(address, cb)
       * ], ([head, [balance, nonce]]) => {
       *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);
       * });
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/require-await
      async combineLatest(fns, callback) {
        const combinator = new Combinator(fns, callback);
        return () => {
          combinator.unsubscribe();
        };
      }
    };
  }
});

// ../../node_modules/@polkadot/api/promise/index.js
var init_promise = __esm({
  "../../node_modules/@polkadot/api/promise/index.js"() {
    init_Api();
    init_decorateMethod();
  }
});

// ../../node_modules/@polkadot/api/rx/decorateMethod.js
function toRxMethod(method) {
  return method;
}
var init_decorateMethod2 = __esm({
  "../../node_modules/@polkadot/api/rx/decorateMethod.js"() {
  }
});

// ../../node_modules/@polkadot/api/rx/Api.js
var import_rxjs91, ApiRx;
var init_Api2 = __esm({
  "../../node_modules/@polkadot/api/rx/Api.js"() {
    import_rxjs91 = __toESM(require_cjs(), 1);
    init_util();
    init_base3();
    init_decorateMethod2();
    ApiRx = class _ApiRx extends ApiBase {
      __internal__isReadyRx;
      /**
       * @description Create an instance of the ApiRx class
       * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]
       * @example
       * <BR>
       *
       * ```javascript
       * import { switchMap } from 'rxjs';
       * import Api from '@polkadot/api/rx';
       *
       * new Api().isReady
       *   .pipe(
       *     switchMap((api) =>
       *       api.rpc.chain.subscribeNewHeads()
       *   ))
       *   .subscribe((header) => {
       *     console.log(`new block #${header.number.toNumber()}`);
       *   });
       * ```
       */
      constructor(options) {
        super(options, "rxjs", toRxMethod);
        this.__internal__isReadyRx = (0, import_rxjs91.from)(
          // You can create an observable from an event, however my mind groks this form better
          new Promise((resolve) => {
            super.on("ready", () => resolve(this));
          })
        );
      }
      /**
       * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.
       * @param options options that is passed to the class constructor. Can be either [[ApiOptions]] or [[WsProvider]]
       * @example
       * <BR>
       *
       * ```javascript
       * import { switchMap } from 'rxjs';
       * import Api from '@polkadot/api/rx';
       *
       * Api.create()
       *   .pipe(
       *     switchMap((api) =>
       *       api.rpc.chain.subscribeNewHeads()
       *   ))
       *   .subscribe((header) => {
       *     console.log(`new block #${header.number.toNumber()}`);
       *   });
       * ```
       */
      static create(options) {
        return new _ApiRx(options).isReady;
      }
      /**
       * @description Observable that returns the first time we are connected and loaded
       */
      get isReady() {
        return this.__internal__isReadyRx;
      }
      /**
       * @description Returns a clone of this ApiRx instance (new underlying provider connection)
       */
      clone() {
        return new _ApiRx(objectSpread({}, this._options, { source: this }));
      }
    };
  }
});

// ../../node_modules/@polkadot/api/rx/index.js
var init_rx = __esm({
  "../../node_modules/@polkadot/api/rx/index.js"() {
    init_Api2();
    init_decorateMethod2();
  }
});

// ../../node_modules/@polkadot/api/bundle.js
var init_bundle15 = __esm({
  "../../node_modules/@polkadot/api/bundle.js"() {
    init_keyring2();
    init_rpc_provider();
    init_packageInfo9();
    init_submittable();
    init_promise();
    init_rx();
  }
});

// ../../node_modules/@polkadot/api/index.js
var api_exports = {};
__export(api_exports, {
  ApiPromise: () => ApiPromise,
  ApiRx: () => ApiRx,
  HttpProvider: () => HttpProvider,
  Keyring: () => Keyring,
  ScProvider: () => ScProvider,
  SubmittableResult: () => SubmittableResult,
  WsProvider: () => WsProvider,
  packageInfo: () => packageInfo9,
  toPromiseMethod: () => toPromiseMethod,
  toRxMethod: () => toRxMethod
});
var init_api = __esm({
  "../../node_modules/@polkadot/api/index.js"() {
    init_packageDetect2();
    init_bundle15();
  }
});

// query_asset_state.js
var { ApiPromise: ApiPromise2, WsProvider: WsProvider2 } = (init_api(), __toCommonJS(api_exports));
(async () => {
  try {
    const provider = new WsProvider2("ws://127.0.0.1:PORT");
    const api = await ApiPromise2.create({ provider });
    const assetId = 42;
    const assetState = await api.query.omnipool.assetTradable(assetId);
    console.log(`Fetched asset tradable state for asset ${assetId}: ${assetState.toString()}`);
    if (assetState.isTrue) {
      console.log("Assertion passed: Asset is tradable.");
      process.exit(0);
    } else {
      console.error("Assertion failed: Asset is not tradable as expected.");
      process.exit(1);
    }
  } catch (err) {
    console.error("Error:", err.message);
    process.exit(1);
  }
})();
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

web-streams-polyfill/dist/ponyfill.es2018.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)
*/
