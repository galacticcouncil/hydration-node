File: ./pallets/omnipool/src/types.rs
#![allow(clippy::bad_bit_mask)]

use super::*;
use codec::MaxEncodedLen;
use frame_support::pallet_prelude::*;
use hydra_dx_math::omnipool::types::{AssetReserveState as MathReserveState, AssetStateChange, BalanceUpdate};
use sp_runtime::{FixedPointNumber, FixedU128};
use sp_std::ops::{Add, Sub};

/// Balance type used in Omnipool
pub type Balance = u128;

/// Fixed Balance type to represent asset price
pub type Price = FixedU128;

bitflags::bitflags! {
	/// Indicates whether asset can be bought or sold to/from Omnipool and/or liquidity added/removed.
	#[derive(Encode,Decode, MaxEncodedLen, TypeInfo)]
	pub struct Tradability: u8 {
		/// Asset is frozen. No operations are allowed.
		const FROZEN = 0b0000_0000;
		/// Asset is allowed to be sold into omnipool
		const SELL = 0b0000_0001;
		/// Asset is allowed to be bought into omnipool
		const BUY = 0b0000_0010;
		/// Adding liquidity of asset is allowed
		const ADD_LIQUIDITY = 0b0000_0100;
		/// Removing liquidity of asset is not allowed
		const REMOVE_LIQUIDITY = 0b0000_1000;
	}
}

impl Default for Tradability {
	fn default() -> Self {
		Tradability::SELL | Tradability::BUY | Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
	}
}

impl Tradability {
	pub(crate) fn is_safe_withdrawal(&self) -> bool {
		*self == Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY || *self == Tradability::REMOVE_LIQUIDITY
	}
}

#[derive(Clone, Default, Encode, Decode, Eq, PartialEq, RuntimeDebug, MaxEncodedLen, TypeInfo)]
pub struct AssetState<Balance> {
	/// Quantity of Hub Asset matching this asset
	pub(super) hub_reserve: Balance,
	/// Quantity of LP shares for this asset
	pub(super) shares: Balance,
	/// Quantity of LP shares for this asset owned by protocol
	pub(super) protocol_shares: Balance,
	/// Asset's weight cap
	/// Note: this should be Permill or FixedU128. But neither implements MaxEncodedLen in 0.9.16.
	/// TODO: upgrade to 0.9.17 resolves this.
	pub cap: u128,
	/// Asset's trade state
	pub tradable: Tradability,
}

impl<Balance> From<AssetReserveState<Balance>> for AssetState<Balance>
where
	Balance: Copy,
{
	fn from(s: AssetReserveState<Balance>) -> Self {
		Self {
			hub_reserve: s.hub_reserve,
			shares: s.shares,
			protocol_shares: s.protocol_shares,
			cap: s.cap,
			tradable: s.tradable,
		}
	}
}

impl<Balance> From<(MathReserveState<Balance>, Permill, Tradability)> for AssetState<Balance>
where
	Balance: Copy,
{
	fn from((state, cap, tradable): (MathReserveState<Balance>, Permill, Tradability)) -> Self {
		Self {
			hub_reserve: state.hub_reserve,
			shares: state.shares,
			protocol_shares: state.protocol_shares,
			cap: FixedU128::from(cap).into_inner(),
			tradable,
		}
	}
}

/// Position in Omnipool represents a moment when LP provided liquidity of an asset at that momentâ€™s price.
#[derive(Clone, Encode, Decode, Eq, PartialEq, RuntimeDebug, MaxEncodedLen, TypeInfo)]
pub struct Position<Balance, AssetId> {
	/// Provided Asset
	pub asset_id: AssetId,
	/// Amount of asset added to omnipool
	pub amount: Balance,
	/// Quantity of LP shares owned by LP
	pub shares: Balance,
	/// Price at which liquidity was provided - ( hub reserve, asset reserve ) at the time of creation
	pub price: (Balance, Balance),
}

impl<Balance, AssetId> From<&Position<Balance, AssetId>> for hydra_dx_math::omnipool::types::Position<Balance>
where
	Balance: Copy + Into<u128>,
{
	fn from(position: &Position<Balance, AssetId>) -> Self {
		Self {
			amount: position.amount,
			shares: position.shares,
			price: position.price,
		}
	}
}

impl<Balance, AssetId> Position<Balance, AssetId>
where
	Balance: Into<<FixedU128 as FixedPointNumber>::Inner> + Copy + CheckedAdd + CheckedSub + Default,
{
	pub(super) fn price_from_rational(&self) -> Option<FixedU128> {
		FixedU128::checked_from_rational(self.price.0.into(), self.price.1.into())
	}

	/// Update current position state with given delta changes.
	pub(super) fn delta_update(
		self,
		delta_reserve: &BalanceUpdate<Balance>,
		delta_shares: &BalanceUpdate<Balance>,
	) -> Option<Self> {
		Some(Self {
			asset_id: self.asset_id,
			amount: (*delta_reserve + self.amount)?,
			shares: (*delta_shares + self.shares)?,
			price: self.price,
		})
	}
}

/// Simple type to represent imbalance which can be positive or negative.
// Note: Simple prefix is used not to confuse with Imbalance trait from frame_support.
#[derive(Clone, Copy, Encode, Decode, Eq, PartialEq, RuntimeDebug, MaxEncodedLen, TypeInfo)]
pub struct SimpleImbalance<Balance> {
	pub value: Balance,
	pub negative: bool,
}

impl<Balance: Default> Default for SimpleImbalance<Balance> {
	fn default() -> Self {
		Self {
			value: Balance::default(),
			negative: true,
		}
	}
}

/// The addition operator + for SimpleImbalance.
///
/// Adds amount to imbalance.
///
/// Note that it returns Option<self> rather than Self.
///
/// Note: Implements `Add` instead of `CheckedAdd` because `CheckedAdd` requires the second parameter
/// to be the same type as the first while we want to add a `Balance` here.
///
/// # Example
///
/// ```ignore
/// let imbalance = SimpleImbalance{value: 100, negative: false} ;
/// assert_eq!(imbalance + 200 , Some(SimpleImbalance{value: 300, negative: false}));
/// ```
impl<Balance: CheckedAdd + CheckedSub + PartialOrd + Copy> Add<Balance> for SimpleImbalance<Balance> {
	type Output = Option<Self>;

	fn add(self, amount: Balance) -> Self::Output {
		let (value, sign) = if !self.negative {
			(self.value.checked_add(&amount)?, self.negative)
		} else if self.value < amount {
			(amount.checked_sub(&self.value)?, false)
		} else {
			(self.value.checked_sub(&amount)?, self.negative)
		};
		Some(Self { value, negative: sign })
	}
}

/// The subtraction operator - for SimpleImbalance.
///
/// Subtracts amount from imbalance.
///
/// Note that it returns Option<self> rather than Self.
///
/// # Example
///
/// ```ignore
/// let imbalance = SimpleImbalance{value: 200, negative: false} ;
/// assert_eq!(imbalance - 100 , Some(SimpleImbalance{value: 100, negative: false}));
/// ```
impl<Balance: CheckedAdd + CheckedSub + PartialOrd + Copy> Sub<Balance> for SimpleImbalance<Balance> {
	type Output = Option<Self>;

	fn sub(self, amount: Balance) -> Self::Output {
		let (value, sign) = if self.negative {
			(self.value.checked_add(&amount)?, self.negative)
		} else if self.value < amount {
			(amount.checked_sub(&self.value)?, true)
		} else if self.value == amount {
			(self.value.checked_sub(&amount)?, true)
		} else {
			(self.value.checked_sub(&amount)?, self.negative)
		};
		Some(Self { value, negative: sign })
	}
}

/// Asset state representation including asset pool reserve.
#[derive(Clone, Copy, Default, Debug, PartialEq, Eq)]
pub struct AssetReserveState<Balance> {
	/// Quantity of asset in omnipool
	pub reserve: Balance,
	/// Quantity of Hub Asset matching this asset
	pub hub_reserve: Balance,
	/// Quantity of LP shares for this asset
	pub shares: Balance,
	/// Quantity of LP shares for this asset owned by protocol
	pub protocol_shares: Balance,
	/// Asset's weight cap
	pub cap: u128,
	/// Asset's trade state
	pub tradable: Tradability,
}

impl<Balance> From<&AssetReserveState<Balance>> for MathReserveState<Balance>
where
	Balance: Copy,
{
	fn from(state: &AssetReserveState<Balance>) -> Self {
		Self {
			reserve: state.reserve,
			hub_reserve: state.hub_reserve,
			shares: state.shares,
			protocol_shares: state.protocol_shares,
		}
	}
}

impl<Balance> From<AssetReserveState<Balance>> for MathReserveState<Balance>
where
	Balance: Copy,
{
	fn from(state: AssetReserveState<Balance>) -> Self {
		Self {
			reserve: state.reserve,
			hub_reserve: state.hub_reserve,
			shares: state.shares,
			protocol_shares: state.protocol_shares,
		}
	}
}

impl<Balance> From<(&AssetState<Balance>, Balance)> for AssetReserveState<Balance>
where
	Balance: Copy,
{
	fn from((s, reserve): (&AssetState<Balance>, Balance)) -> Self {
		Self {
			reserve,
			hub_reserve: s.hub_reserve,
			shares: s.shares,
			protocol_shares: s.protocol_shares,
			cap: s.cap,
			tradable: s.tradable,
		}
	}
}

impl<Balance> From<(AssetState<Balance>, Balance)> for AssetReserveState<Balance>
where
	Balance: Copy,
{
	fn from((s, reserve): (AssetState<Balance>, Balance)) -> Self {
		Self {
			reserve,
			hub_reserve: s.hub_reserve,
			shares: s.shares,
			protocol_shares: s.protocol_shares,
			cap: s.cap,
			tradable: s.tradable,
		}
	}
}

impl<Balance> AssetReserveState<Balance>
where
	Balance: Into<<FixedU128 as FixedPointNumber>::Inner> + Copy + CheckedAdd + CheckedSub + Default,
{
	pub fn price_as_rational(&self) -> (Balance, Balance) {
		(self.hub_reserve, self.reserve)
	}

	/// Calculate price for actual state
	pub fn price(&self) -> Option<FixedU128> {
		FixedU128::checked_from_rational(self.hub_reserve.into(), self.reserve.into())
	}

	pub(crate) fn weight_cap(&self) -> FixedU128 {
		FixedU128::from_inner(self.cap)
	}

	/// Update current asset state with given delta changes.
	pub fn delta_update(self, delta: &AssetStateChange<Balance>) -> Option<Self> {
		Some(Self {
			reserve: (delta.delta_reserve + self.reserve)?,
			hub_reserve: (delta.delta_hub_reserve + self.hub_reserve)?,
			shares: (delta.delta_shares + self.shares)?,
			protocol_shares: (delta.delta_protocol_shares + self.protocol_shares)?,
			cap: self.cap,
			tradable: self.tradable,
		})
	}
}

File: ./pallets/omnipool/src/lib.rs
// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! # Omnipool pallet
//!
//! Omnipool implementation
//!
//! ## Overview
//!
//! Omnipool is type of AMM where all assets are pooled together into one single pool.
//!
//! Each asset is internally paired with so called Hub Asset ( LRNA ). When a liquidity is provided, corresponding
//! amount of hub asset is minted. When a liquidity is removed, corresponding amount of hub asset is burned.
//!
//! Liquidity provider can provide any asset of their choice to the Omnipool and in return
//! they will receive pool shares for this single asset.
//!
//! The position is represented as a NFT token which stores the amount of shares distributed
//! and the price of the asset at the time of provision.
//!
//! For traders this means that they can benefit from non-fragmented liquidity.
//! They can send any token to the pool using the swap mechanism
//! and in return they will receive the token of their choice in the appropriate quantity.
//!
//! Omnipool is implemented with concrete Balance type: u128.
//!
//! ### Imbalance mechanism
//! The Imbalance mechanism is designed to stabilize the value of LRNA. By design it is a weak and passive mechanism,
//! and is specifically meant to deal with one cause of LRNA volatility: LRNA being sold back to the pool.
//!
//! Imbalance is always negative, internally represented by a special type `SimpleImbalance` which uses unsigned integer and boolean flag.
//! This was done initially because of the intention that in future imbalance can also become positive.
//!
//! ### Omnipool Hooks
//!
//! Omnipool pallet supports multiple hooks which are triggerred on certain operations:
//! - on_liquidity_changed - called when liquidity is added or removed from the pool
//! - on_trade - called when trade is executed
//! - on_trade_fee - called after successful trade with fee amount that can be taken out of the pool if needed.
//!
//! This is currently used to update on-chain oracle and in the circuit breaker.
//!
//! ## Terminology
//!
//! * **LP:**  liquidity provider
//! * **Position:**  a moment when LP added liquidity to the pool. It stores amount,shares and price at the time
//!  of provision
//! * **Hub Asset:** dedicated 'hub' token for trade executions (LRNA)
//! * **Native Asset:** governance token
//! * **Imbalance:** Tracking of hub asset imbalance.
//!
//! ## Assumptions
//!
//! Below are assumptions that must be held when using this pallet.
//!
//! * Initial liquidity of new token being added to Omnipool must be transferred manually to pool account prior to calling add_token.
//! * All tokens added to the pool must be first registered in Asset Registry.
//!
//! ## Interface
//!
//! ### Dispatchable Functions
//!
//! * `add_token` - Adds token to the pool. Initial liquidity must be transffered to pool account prior to calling add_token.
//! * `add_liquidity` - Adds liquidity of selected asset to the pool. Mints corresponding position NFT.
//! * `remove_liquidity` - Removes liquidity of selected position from the pool. Partial withdrawals are allowed.
//! * `sell` - Trades an asset in for asset out by selling given amount of asset in.
//! * `buy` - Trades an asset in for asset out by buying given amount of asset out.
//! * `set_asset_tradable_state` - Updates asset's tradable state with new flags. This allows/forbids asset operation such SELL,BUY,ADD or  REMOVE liquidtityy.
//! * `refund_refused_asset` - Refunds the initial liquidity amount sent to pool account prior to add_token if the token has been refused to be added.
//! * `sacrifice_position` - Destroys a position and position's shares become protocol's shares.
//! * `withdraw_protocol_liquidity` - Withdraws protocol's liquidity from the pool. Used to withdraw liquidity from sacrificed position.

#![cfg_attr(not(feature = "std"), no_std)]

use frame_support::pallet_prelude::{DispatchResult, Get};
use frame_support::require_transactional;
use frame_support::PalletId;
use frame_support::{ensure, transactional};
use sp_runtime::traits::{AccountIdConversion, AtLeast32BitUnsigned, One};
use sp_runtime::traits::{CheckedAdd, CheckedSub, Zero};
use sp_std::ops::{Add, Sub};
use sp_std::prelude::*;

use crate::traits::ShouldAllow;
use frame_support::traits::tokens::nonfungibles::{Create, Inspect, Mutate};
use frame_system::ensure_signed;
use frame_system::pallet_prelude::OriginFor;
use hydra_dx_math::ema::EmaPrice;
use hydra_dx_math::omnipool::types::{AssetStateChange, BalanceUpdate, I129};
use hydradx_traits::registry::Inspect as RegistryInspect;
use orml_traits::{GetByKey, MultiCurrency};
#[cfg(feature = "try-runtime")]
use primitive_types::U256;
use scale_info::TypeInfo;
use sp_runtime::{ArithmeticError, DispatchError, FixedPointNumber, FixedU128, Permill};

#[cfg(test)]
mod tests;

pub mod provider;
pub mod router_execution;
pub mod traits;
pub mod types;
pub mod weights;

use crate::traits::{AssetInfo, OmnipoolHooks};
use crate::types::{AssetReserveState, AssetState, Balance, Position, SimpleImbalance, Tradability};
pub use pallet::*;
pub use weights::WeightInfo;

/// NFT class id type of provided nft implementation
pub type NFTCollectionIdOf<T> =
	<<T as Config>::NFTHandler as Inspect<<T as frame_system::Config>::AccountId>>::CollectionId;

#[frame_support::pallet]
pub mod pallet {
	use super::*;
	use crate::traits::{AssetInfo, ExternalPriceProvider, OmnipoolHooks};
	use crate::types::{Position, Price, Tradability};
	use codec::HasCompact;
	use frame_support::pallet_prelude::*;
	use frame_support::traits::DefensiveOption;
	use frame_system::pallet_prelude::*;
	use hydra_dx_math::ema::EmaPrice;
	use hydra_dx_math::omnipool::types::{BalanceUpdate, I129};
	use orml_traits::GetByKey;
	use sp_runtime::ArithmeticError;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	#[pallet::config]
	pub trait Config: frame_system::Config {
		/// The overarching event type.
		type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

		/// Asset type.
		type AssetId: Member
			+ Parameter
			+ Default
			+ Copy
			+ Ord
			+ HasCompact
			+ MaybeSerializeDeserialize
			+ MaxEncodedLen
			+ TypeInfo;

		/// Multi currency mechanism
		type Currency: MultiCurrency<Self::AccountId, CurrencyId = Self::AssetId, Balance = Balance>;

		/// Origin that can add token, refund refused asset and withdraw protocol liquidity.
		type AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;

		/// Origin that can change asset's tradability and weight.
		type TechnicalOrigin: EnsureOrigin<Self::RuntimeOrigin>;

		/// Asset Registry mechanism - used to check if asset is correctly registered in asset registry
		type AssetRegistry: RegistryInspect<AssetId = Self::AssetId>;

		/// Native Asset ID
		#[pallet::constant]
		type HdxAssetId: Get<Self::AssetId>;

		/// Hub Asset ID
		#[pallet::constant]
		type HubAssetId: Get<Self::AssetId>;

		/// Dynamic fee support - returns (Asset Fee, Protocol Fee) for given asset
		type Fee: GetByKey<Self::AssetId, (Permill, Permill)>;

		/// Minimum withdrawal fee
		#[pallet::constant]
		type MinWithdrawalFee: Get<Permill>;

		/// Minimum trading limit
		#[pallet::constant]
		type MinimumTradingLimit: Get<Balance>;

		/// Minimum pool liquidity which can be added
		#[pallet::constant]
		type MinimumPoolLiquidity: Get<Balance>;

		/// Max fraction of asset reserve to sell in single transaction
		#[pallet::constant]
		type MaxInRatio: Get<u128>;

		/// Max fraction of asset reserve to buy in single transaction
		#[pallet::constant]
		type MaxOutRatio: Get<u128>;

		/// Position identifier type
		type PositionItemId: Member + Parameter + Default + Copy + HasCompact + AtLeast32BitUnsigned + MaxEncodedLen;

		/// Collection id type
		type CollectionId: TypeInfo + MaxEncodedLen;

		/// Non fungible class id
		#[pallet::constant]
		type NFTCollectionId: Get<NFTCollectionIdOf<Self>>;

		/// Non fungible handling - mint,burn, check owner
		type NFTHandler: Mutate<Self::AccountId>
			+ Create<Self::AccountId>
			+ Inspect<Self::AccountId, ItemId = Self::PositionItemId, CollectionId = Self::CollectionId>;

		/// Weight information for extrinsics in this pallet.
		type WeightInfo: WeightInfo;

		/// Hooks are actions executed on add_liquidity, sell or buy.
		type OmnipoolHooks: OmnipoolHooks<
			Self::RuntimeOrigin,
			Self::AccountId,
			Self::AssetId,
			Balance,
			Error = DispatchError,
		>;

		/// Safety mechanism when adding and removing liquidity. Determines how much price can change between spot price and oracle price.
		type PriceBarrier: ShouldAllow<Self::AccountId, Self::AssetId, EmaPrice>;

		/// Oracle price provider. Provides price for given asset. Used in remove liquidity to support calculation of dynamic withdrawal fee.
		type ExternalPriceOracle: ExternalPriceProvider<Self::AssetId, EmaPrice, Error = DispatchError>;
	}

	#[pallet::storage]
	/// State of an asset in the omnipool
	#[pallet::getter(fn assets)]
	pub(super) type Assets<T: Config> = StorageMap<_, Blake2_128Concat, T::AssetId, AssetState<Balance>>;

	#[pallet::storage]
	/// Imbalance of hub asset
	#[pallet::getter(fn current_imbalance)]
	pub(super) type HubAssetImbalance<T: Config> = StorageValue<_, SimpleImbalance<Balance>, ValueQuery>;

	// LRNA is only allowed to be sold
	#[pallet::type_value]
	pub fn DefaultHubAssetTradability() -> Tradability {
		Tradability::SELL
	}

	#[pallet::storage]
	/// Tradable state of hub asset.
	pub(super) type HubAssetTradability<T: Config> =
		StorageValue<_, Tradability, ValueQuery, DefaultHubAssetTradability>;

	#[pallet::storage]
	/// LP positions. Maps NFT instance id to corresponding position
	#[pallet::getter(fn positions)]
	pub(super) type Positions<T: Config> =
		StorageMap<_, Blake2_128Concat, T::PositionItemId, Position<Balance, T::AssetId>>;

	#[pallet::storage]
	#[pallet::getter(fn next_position_id)]
	/// Position ids sequencer
	pub(super) type NextPositionId<T: Config> = StorageValue<_, T::PositionItemId, ValueQuery>;

	#[pallet::event]
	#[pallet::generate_deposit(pub(crate) fn deposit_event)]
	pub enum Event<T: Config> {
		/// An asset was added to Omnipool
		TokenAdded {
			asset_id: T::AssetId,
			initial_amount: Balance,
			initial_price: Price,
		},
		/// An asset was removed from Omnipool
		TokenRemoved {
			asset_id: T::AssetId,
			amount: Balance,
			hub_withdrawn: Balance,
		},
		/// Liquidity of an asset was added to Omnipool.
		LiquidityAdded {
			who: T::AccountId,
			asset_id: T::AssetId,
			amount: Balance,
			position_id: T::PositionItemId,
		},
		/// Liquidity of an asset was removed from Omnipool.
		LiquidityRemoved {
			who: T::AccountId,
			position_id: T::PositionItemId,
			asset_id: T::AssetId,
			shares_removed: Balance,
			fee: FixedU128,
		},
		/// PRotocol Liquidity was removed from Omnipool.
		ProtocolLiquidityRemoved {
			who: T::AccountId,
			asset_id: T::AssetId,
			amount: Balance,
			hub_amount: Balance,
			shares_removed: Balance,
		},
		/// Sell trade executed.
		SellExecuted {
			who: T::AccountId,
			asset_in: T::AssetId,
			asset_out: T::AssetId,
			amount_in: Balance,
			amount_out: Balance,
			hub_amount_in: Balance,
			hub_amount_out: Balance,
			asset_fee_amount: Balance,
			protocol_fee_amount: Balance,
		},
		/// Buy trade executed.
		BuyExecuted {
			who: T::AccountId,
			asset_in: T::AssetId,
			asset_out: T::AssetId,
			amount_in: Balance,
			amount_out: Balance,
			hub_amount_in: Balance,
			hub_amount_out: Balance,
			asset_fee_amount: Balance,
			protocol_fee_amount: Balance,
		},
		/// LP Position was created and NFT instance minted.
		PositionCreated {
			position_id: T::PositionItemId,
			owner: T::AccountId,
			asset: T::AssetId,
			amount: Balance,
			shares: Balance,
			price: Price,
		},
		/// LP Position was destroyed and NFT instance burned.
		PositionDestroyed {
			position_id: T::PositionItemId,
			owner: T::AccountId,
		},
		/// LP Position was updated.
		PositionUpdated {
			position_id: T::PositionItemId,
			owner: T::AccountId,
			asset: T::AssetId,
			amount: Balance,
			shares: Balance,
			price: Price,
		},
		/// Asset's tradable state has been updated.
		TradableStateUpdated { asset_id: T::AssetId, state: Tradability },

		/// Amount has been refunded for asset which has not been accepted to add to omnipool.
		AssetRefunded {
			asset_id: T::AssetId,
			amount: Balance,
			recipient: T::AccountId,
		},

		/// Asset's weight cap has been updated.
		AssetWeightCapUpdated { asset_id: T::AssetId, cap: Permill },
	}

	#[pallet::error]
	#[cfg_attr(test, derive(PartialEq, Eq))]
	pub enum Error<T> {
		/// Balance too low
		InsufficientBalance,
		/// Asset is already in omnipool
		AssetAlreadyAdded,
		/// Asset is not in omnipool
		AssetNotFound,
		/// Failed to add token to Omnipool due to insufficient initial liquidity.
		MissingBalance,
		/// Invalid initial asset price.
		InvalidInitialAssetPrice,
		/// Slippage protection - minimum limit has not been reached.
		BuyLimitNotReached,
		/// Slippage protection - maximum limit has been exceeded.
		SellLimitExceeded,
		/// Position has not been found.
		PositionNotFound,
		/// Insufficient shares in position
		InsufficientShares,
		/// Asset is not allowed to be traded.
		NotAllowed,
		/// Signed account is not owner of position instance.
		Forbidden,
		/// Asset weight cap has been exceeded.
		AssetWeightCapExceeded,
		/// Asset is not registered in asset registry
		AssetNotRegistered,
		/// Provided liquidity is below minimum allowed limit
		InsufficientLiquidity,
		/// Traded amount is below minimum allowed limit
		InsufficientTradingAmount,
		/// Sell or buy with same asset ids is not allowed.
		SameAssetTradeNotAllowed,
		/// LRNA update after trade results in positive value.
		HubAssetUpdateError,
		/// Imbalance results in positive value.
		PositiveImbalance,
		/// Amount of shares provided cannot be 0.
		InvalidSharesAmount,
		/// Hub asset is only allowed to be sold.
		InvalidHubAssetTradableState,
		/// Asset is not allowed to be refunded.
		AssetRefundNotAllowed,
		/// Max fraction of asset to buy has been exceeded.
		MaxOutRatioExceeded,
		/// Max fraction of asset to sell has been exceeded.
		MaxInRatioExceeded,
		/// Max allowed price difference has been exceeded.
		PriceDifferenceTooHigh,
		/// Invalid oracle price - division by zero.
		InvalidOraclePrice,
		/// Failed to calculate withdrawal fee.
		InvalidWithdrawalFee,
		/// More than allowed amount of fee has been transferred.
		FeeOverdraft,
		/// Token cannot be removed from Omnipool due to shares still owned by other users.
		SharesRemaining,
		/// Token cannot be removed from Omnipool because asset is not frozen.
		AssetNotFrozen,
		/// Calculated amount out from sell trade is zero.
		ZeroAmountOut,
		/// Existential deposit of asset is not available.
		ExistentialDepositNotAvailable,
		/// Slippage protection
		SlippageLimit,
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		/// Add new token to omnipool in quantity `amount` at price `initial_price`
		///
		/// Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.
		///
		/// Initial liquidity is pool's account balance of the token.
		///
		/// Position NFT token is minted for `position_owner`.
		///
		/// Parameters:
		/// - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry
		/// - `initial_price`: Initial price
		/// - `position_owner`: account id for which share are distributed in form on NFT
		/// - `weight_cap`: asset weight cap
		///
		/// Emits `TokenAdded` event when successful.
		///
		#[pallet::call_index(1)]
		#[pallet::weight(<T as Config>::WeightInfo::add_token().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]
		#[transactional]
		pub fn add_token(
			origin: OriginFor<T>,
			asset: T::AssetId,
			initial_price: Price,
			weight_cap: Permill,
			position_owner: T::AccountId,
		) -> DispatchResult {
			T::AuthorityOrigin::ensure_origin(origin.clone())?;

			ensure!(!Assets::<T>::contains_key(asset), Error::<T>::AssetAlreadyAdded);

			ensure!(T::AssetRegistry::exists(asset), Error::<T>::AssetNotRegistered);

			ensure!(initial_price > FixedU128::zero(), Error::<T>::InvalidInitialAssetPrice);

			// ensure collection is created, we can simply ignore the error if it was already created.
			let _ = T::NFTHandler::create_collection(
				&T::NFTCollectionId::get(),
				&Self::protocol_account(),
				&Self::protocol_account(),
			);

			let amount = T::Currency::free_balance(asset, &Self::protocol_account());

			let ed = T::AssetRegistry::existential_deposit(asset).ok_or(Error::<T>::ExistentialDepositNotAvailable)?;
			let minimum_pool_liquidity = ed.saturating_mul(20);

			ensure!(ed > 0 && amount >= minimum_pool_liquidity, Error::<T>::MissingBalance);

			let hub_reserve = initial_price.checked_mul_int(amount).ok_or(ArithmeticError::Overflow)?;

			// Initial state of asset
			let state = AssetState::<Balance> {
				hub_reserve,
				shares: amount,
				protocol_shares: Balance::zero(),
				cap: FixedU128::from(weight_cap).into_inner(),
				tradable: Tradability::default(),
			};

			let lp_position = Position::<Balance, T::AssetId> {
				asset_id: asset,
				amount,
				shares: amount,
				price: (initial_price.into_inner(), FixedU128::DIV),
			};

			let instance_id = Self::create_and_mint_position_instance(&position_owner)?;

			<Positions<T>>::insert(instance_id, lp_position);

			Self::deposit_event(Event::PositionCreated {
				position_id: instance_id,
				owner: position_owner,
				asset,
				amount,
				shares: amount,
				price: initial_price,
			});

			let current_imbalance = <HubAssetImbalance<T>>::get();
			let current_hub_asset_liquidity =
				T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

			let delta_imbalance = hydra_dx_math::omnipool::calculate_delta_imbalance(
				hub_reserve,
				I129 {
					value: current_imbalance.value,
					negative: current_imbalance.negative,
				},
				current_hub_asset_liquidity,
			)
			.ok_or(ArithmeticError::Overflow)?;

			Self::update_imbalance(BalanceUpdate::Decrease(delta_imbalance))?;

			let delta_hub_reserve = BalanceUpdate::Increase(hub_reserve);
			Self::update_hub_asset_liquidity(&delta_hub_reserve)?;

			let reserve = T::Currency::free_balance(asset, &Self::protocol_account());

			let reserve_state: AssetReserveState<_> = (state.clone(), reserve).into();
			let changes = AssetStateChange {
				delta_hub_reserve,
				delta_reserve: BalanceUpdate::Increase(reserve),
				delta_shares: BalanceUpdate::Increase(amount),
				delta_protocol_shares: BalanceUpdate::Increase(Balance::zero()),
			};
			T::OmnipoolHooks::on_liquidity_changed(
				origin,
				AssetInfo::new(asset, &AssetReserveState::default(), &reserve_state, &changes, false),
			)?;

			<Assets<T>>::insert(asset, state);

			Self::deposit_event(Event::TokenAdded {
				asset_id: asset,
				initial_amount: amount,
				initial_price,
			});

			Ok(())
		}

		/// Add liquidity of asset `asset` in quantity `amount` to Omnipool
		///
		/// `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
		/// corresponding shares amount in form of NFT at current price.
		///
		/// Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
		///
		/// NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
		///
		/// Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
		/// Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
		///
		/// Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
		///
		/// Parameters:
		/// - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
		/// - `amount`: Amount of asset added to omnipool
		///
		/// Emits `LiquidityAdded` event when successful.
		///
		#[pallet::call_index(2)]
		#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()
			.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()
			.saturating_add(T::ExternalPriceOracle::get_price_weight()))
		)]
		#[transactional]
		pub fn add_liquidity(origin: OriginFor<T>, asset: T::AssetId, amount: Balance) -> DispatchResult {
			Self::add_liquidity_with_limit(origin, asset, amount, Balance::MIN)
		}

		/// Add liquidity of asset `asset` in quantity `amount` to Omnipool.
		///
		/// Limit protection is applied.
		///
		/// `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
		/// corresponding shares amount in form of NFT at current price.
		///
		/// Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
		///
		/// NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
		///
		/// Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
		/// Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
		///
		/// Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
		///
		/// Parameters:
		/// - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
		/// - `amount`: Amount of asset added to omnipool
		/// - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
		///
		/// Emits `LiquidityAdded` event when successful.
		///
		#[pallet::call_index(13)]
		#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()
		.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()
		.saturating_add(T::ExternalPriceOracle::get_price_weight()))
		)]
		#[transactional]
		pub fn add_liquidity_with_limit(
			origin: OriginFor<T>,
			asset: T::AssetId,
			amount: Balance,
			min_shares_limit: Balance,
		) -> DispatchResult {
			let _ = Self::do_add_liquidity_with_limit(origin, asset, amount, min_shares_limit)?;

			Ok(())
		}

		/// Remove liquidity of asset `asset` in quantity `amount` from Omnipool
		///
		/// `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
		///
		/// Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
		///
		/// if all shares from given position are removed, position is destroyed and NFT is burned.
		///
		/// Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
		///
		/// Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
		/// Withdrawal is considered safe when trading is disabled.
		///
		/// Parameters:
		/// - `position_id`: The identifier of position which liquidity is removed from.
		/// - `amount`: Amount of shares removed from omnipool
		///
		/// Emits `LiquidityRemoved` event when successful.
		///
		#[pallet::call_index(3)]
		#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]
		#[transactional]
		pub fn remove_liquidity(
			origin: OriginFor<T>,
			position_id: T::PositionItemId,
			amount: Balance,
		) -> DispatchResult {
			Self::remove_liquidity_with_limit(origin, position_id, amount, Balance::MIN)
		}

		/// Remove liquidity of asset `asset` in quantity `amount` from Omnipool
		///
		/// Limit protection is applied.
		///
		/// `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
		///
		/// Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
		///
		/// if all shares from given position are removed, position is destroyed and NFT is burned.
		///
		/// Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
		///
		/// Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
		/// Withdrawal is considered safe when trading is disabled.
		///
		/// Parameters:
		/// - `position_id`: The identifier of position which liquidity is removed from.
		/// - `amount`: Amount of shares removed from omnipool
		/// - `min_limit`: The min amount of asset to be removed for the user
		///
		/// Emits `LiquidityRemoved` event when successful.
		///
		#[pallet::call_index(14)]
		#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]
		#[transactional]
		pub fn remove_liquidity_with_limit(
			origin: OriginFor<T>,
			position_id: T::PositionItemId,
			amount: Balance,
			min_limit: Balance,
		) -> DispatchResult {
			let who = ensure_signed(origin.clone())?;

			ensure!(amount > Balance::zero(), Error::<T>::InvalidSharesAmount);

			ensure!(
				T::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),
				Error::<T>::Forbidden
			);

			let position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;

			ensure!(position.shares >= amount, Error::<T>::InsufficientShares);

			let asset_id = position.asset_id;

			let asset_state = Self::load_asset_state(asset_id)?;

			ensure!(
				asset_state.tradable.contains(Tradability::REMOVE_LIQUIDITY),
				Error::<T>::NotAllowed
			);

			let safe_withdrawal = asset_state.tradable.is_safe_withdrawal();
			// Skip price check if safe withdrawal - trading disabled.
			if !safe_withdrawal {
				T::PriceBarrier::ensure_price(
					&who,
					T::HubAssetId::get(),
					asset_id,
					EmaPrice::new(asset_state.hub_reserve, asset_state.reserve),
				)
				.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;
			}
			let ext_asset_price = T::ExternalPriceOracle::get_price(T::HubAssetId::get(), asset_id)?;

			if ext_asset_price.is_zero() {
				return Err(Error::<T>::InvalidOraclePrice.into());
			}
			let withdrawal_fee = hydra_dx_math::omnipool::calculate_withdrawal_fee(
				asset_state.price().ok_or(ArithmeticError::DivisionByZero)?,
				FixedU128::checked_from_rational(ext_asset_price.n, ext_asset_price.d)
					.defensive_ok_or(Error::<T>::InvalidOraclePrice)?,
				T::MinWithdrawalFee::get(),
			);

			let current_imbalance = <HubAssetImbalance<T>>::get();
			let current_hub_asset_liquidity =
				T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

			//
			// calculate state changes of remove liquidity
			//
			let state_changes = hydra_dx_math::omnipool::calculate_remove_liquidity_state_changes(
				&(&asset_state).into(),
				amount,
				&(&position).into(),
				I129 {
					value: current_imbalance.value,
					negative: current_imbalance.negative,
				},
				current_hub_asset_liquidity,
				withdrawal_fee,
			)
			.ok_or(ArithmeticError::Overflow)?;

			ensure!(
				*state_changes.asset.delta_reserve >= min_limit,
				Error::<T>::SlippageLimit
			);

			let new_asset_state = asset_state
				.delta_update(&state_changes.asset)
				.ok_or(ArithmeticError::Overflow)?;

			// Update position state
			let updated_position = position
				.delta_update(
					&state_changes.delta_position_reserve,
					&state_changes.delta_position_shares,
				)
				.ok_or(ArithmeticError::Overflow)?;

			T::Currency::transfer(
				asset_id,
				&Self::protocol_account(),
				&who,
				*state_changes.asset.delta_reserve,
			)?;

			Self::update_imbalance(state_changes.delta_imbalance)?;

			// burn only difference between delta hub and lp hub amount.
			Self::update_hub_asset_liquidity(
				&state_changes
					.asset
					.delta_hub_reserve
					.merge(BalanceUpdate::Increase(state_changes.lp_hub_amount))
					.ok_or(ArithmeticError::Overflow)?,
			)?;

			// LP receives some hub asset
			Self::process_hub_amount(state_changes.lp_hub_amount, &who)?;

			if updated_position.shares == Balance::zero() {
				// All liquidity removed, remove position and burn NFT instance

				<Positions<T>>::remove(position_id);
				T::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;

				Self::deposit_event(Event::PositionDestroyed {
					position_id,
					owner: who.clone(),
				});
			} else {
				Self::deposit_event(Event::PositionUpdated {
					position_id,
					owner: who.clone(),
					asset: asset_id,
					amount: updated_position.amount,
					shares: updated_position.shares,
					price: updated_position
						.price_from_rational()
						.ok_or(ArithmeticError::DivisionByZero)?,
				});

				<Positions<T>>::insert(position_id, updated_position);
			}

			// Callback hook info
			let info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
				asset_id,
				&asset_state,
				&new_asset_state,
				&state_changes.asset,
				safe_withdrawal,
			);

			Self::set_asset_state(asset_id, new_asset_state);

			Self::deposit_event(Event::LiquidityRemoved {
				who,
				position_id,
				asset_id,
				shares_removed: amount,
				fee: withdrawal_fee,
			});

			T::OmnipoolHooks::on_liquidity_changed(origin, info)?;

			#[cfg(feature = "try-runtime")]
			Self::ensure_liquidity_invariant((asset_id, asset_state, new_asset_state));

			Ok(())
		}

		/// Sacrifice LP position in favor of pool.
		///
		/// A position is destroyed and liquidity owned by LP becomes pool owned liquidity.
		///
		/// Only owner of position can perform this action.
		///
		/// Emits `PositionDestroyed`.
		#[pallet::call_index(4)]
		#[pallet::weight(<T as Config>::WeightInfo::sacrifice_position())]
		#[transactional]
		pub fn sacrifice_position(origin: OriginFor<T>, position_id: T::PositionItemId) -> DispatchResult {
			let who = ensure_signed(origin)?;

			let position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;

			ensure!(
				T::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),
				Error::<T>::Forbidden
			);

			Assets::<T>::try_mutate(position.asset_id, |maybe_asset| -> DispatchResult {
				let asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;

				asset_state.protocol_shares = asset_state
					.protocol_shares
					.checked_add(position.shares)
					.ok_or(ArithmeticError::Overflow)?;

				Ok(())
			})?;

			// Destroy position and burn NFT
			<Positions<T>>::remove(position_id);
			T::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;

			Self::deposit_event(Event::PositionDestroyed {
				position_id,
				owner: who,
			});

			Ok(())
		}

		/// Execute a swap of `asset_in` for `asset_out`.
		///
		/// Price is determined by the Omnipool.
		///
		/// Hub asset is traded separately.
		///
		/// Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
		///
		/// Parameters:
		/// - `asset_in`: ID of asset sold to the pool
		/// - `asset_out`: ID of asset bought from the pool
		/// - `amount`: Amount of asset sold
		/// - `min_buy_amount`: Minimum amount required to receive
		///
		/// Emits `SellExecuted` event when successful.
		///
		#[pallet::call_index(5)]
		#[pallet::weight(<T as Config>::WeightInfo::sell()
			.saturating_add(T::OmnipoolHooks::on_trade_weight())
			.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight())
		)]
		#[transactional]
		pub fn sell(
			origin: OriginFor<T>,
			asset_in: T::AssetId,
			asset_out: T::AssetId,
			amount: Balance,
			min_buy_amount: Balance,
		) -> DispatchResult {
			let who = ensure_signed(origin.clone())?;

			ensure!(asset_in != asset_out, Error::<T>::SameAssetTradeNotAllowed);

			ensure!(
				amount >= T::MinimumTradingLimit::get(),
				Error::<T>::InsufficientTradingAmount
			);

			ensure!(
				T::Currency::ensure_can_withdraw(asset_in, &who, amount).is_ok(),
				Error::<T>::InsufficientBalance
			);

			// Special handling when one of the asset is Hub Asset
			// Math is simplified and asset_in is actually part of asset_out state in this case
			if asset_in == T::HubAssetId::get() {
				return Self::sell_hub_asset(origin, &who, asset_out, amount, min_buy_amount);
			}

			if asset_out == T::HubAssetId::get() {
				return Self::sell_asset_for_hub_asset(&who, asset_in, amount, min_buy_amount);
			}

			let asset_in_state = Self::load_asset_state(asset_in)?;
			let asset_out_state = Self::load_asset_state(asset_out)?;

			ensure!(
				Self::allow_assets(&asset_in_state, &asset_out_state),
				Error::<T>::NotAllowed
			);

			ensure!(
				amount
					<= asset_in_state
						.reserve
						.checked_div(T::MaxInRatio::get())
						.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.
				Error::<T>::MaxInRatioExceeded
			);

			let current_imbalance = <HubAssetImbalance<T>>::get();

			let (asset_fee, _) = T::Fee::get(&asset_out);
			let (_, protocol_fee) = T::Fee::get(&asset_in);

			let state_changes = hydra_dx_math::omnipool::calculate_sell_state_changes(
				&(&asset_in_state).into(),
				&(&asset_out_state).into(),
				amount,
				asset_fee,
				protocol_fee,
				current_imbalance.value,
			)
			.ok_or(ArithmeticError::Overflow)?;

			ensure!(
				*state_changes.asset_out.delta_reserve > Balance::zero(),
				Error::<T>::ZeroAmountOut
			);

			ensure!(
				*state_changes.asset_out.delta_reserve >= min_buy_amount,
				Error::<T>::BuyLimitNotReached
			);

			ensure!(
				*state_changes.asset_out.delta_reserve
					<= asset_out_state
						.reserve
						.checked_div(T::MaxOutRatio::get())
						.ok_or(ArithmeticError::DivisionByZero)?, // Note: Let's be safe. this can only fail if MaxOutRatio is zero.
				Error::<T>::MaxOutRatioExceeded
			);

			let new_asset_in_state = asset_in_state
				.delta_update(&state_changes.asset_in)
				.ok_or(ArithmeticError::Overflow)?;
			let new_asset_out_state = asset_out_state
				.delta_update(&state_changes.asset_out)
				.ok_or(ArithmeticError::Overflow)?;

			debug_assert_eq!(
				*state_changes.asset_in.delta_reserve, amount,
				"delta_reserve_in is not equal to given amount in"
			);

			T::Currency::transfer(
				asset_in,
				&who,
				&Self::protocol_account(),
				*state_changes.asset_in.delta_reserve,
			)?;
			T::Currency::transfer(
				asset_out,
				&Self::protocol_account(),
				&who,
				*state_changes.asset_out.delta_reserve,
			)?;

			// Hub liquidity update - work out difference between in and amount so only one update is needed.
			let delta_hub_asset = state_changes
				.asset_in
				.delta_hub_reserve
				.merge(
					state_changes
						.asset_out
						.delta_hub_reserve
						.merge(BalanceUpdate::Increase(state_changes.hdx_hub_amount))
						.ok_or(ArithmeticError::Overflow)?,
				)
				.ok_or(ArithmeticError::Overflow)?;

			match delta_hub_asset {
				BalanceUpdate::Increase(val) if val == Balance::zero() => {
					// nothing to do if zero.
				}
				BalanceUpdate::Increase(_) => {
					// trade can only burn some. This would be a bug.
					return Err(Error::<T>::HubAssetUpdateError.into());
				}
				BalanceUpdate::Decrease(amount) => {
					T::Currency::withdraw(T::HubAssetId::get(), &Self::protocol_account(), amount)?;
				}
			};

			// Callback hook info
			let info_in: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
				asset_in,
				&asset_in_state,
				&new_asset_in_state,
				&state_changes.asset_in,
				false,
			);

			let info_out: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
				asset_out,
				&asset_out_state,
				&new_asset_out_state,
				&state_changes.asset_out,
				false,
			);

			Self::update_imbalance(state_changes.delta_imbalance)?;

			Self::set_asset_state(asset_in, new_asset_in_state);
			Self::set_asset_state(asset_out, new_asset_out_state);

			T::OmnipoolHooks::on_trade(origin.clone(), info_in, info_out)?;

			Self::update_hdx_subpool_hub_asset(origin, state_changes.hdx_hub_amount)?;

			Self::process_trade_fee(&who, asset_out, state_changes.fee.asset_fee)?;

			debug_assert!(*state_changes.asset_in.delta_hub_reserve >= *state_changes.asset_out.delta_hub_reserve);
			debug_assert_eq!(
				*state_changes.asset_in.delta_hub_reserve - *state_changes.asset_out.delta_hub_reserve,
				state_changes.fee.protocol_fee
			);

			Self::deposit_event(Event::SellExecuted {
				who,
				asset_in,
				asset_out,
				amount_in: amount,
				amount_out: *state_changes.asset_out.delta_reserve,
				hub_amount_in: *state_changes.asset_in.delta_hub_reserve,
				hub_amount_out: *state_changes.asset_out.delta_hub_reserve,
				asset_fee_amount: state_changes.fee.asset_fee,
				protocol_fee_amount: state_changes.fee.protocol_fee,
			});

			#[cfg(feature = "try-runtime")]
			Self::ensure_trade_invariant(
				(asset_in, asset_in_state, new_asset_in_state),
				(asset_out, asset_out_state, new_asset_out_state),
			);

			Ok(())
		}

		/// Execute a swap of `asset_out` for `asset_in`.
		///
		/// Price is determined by the Omnipool.
		///
		/// Hub asset is traded separately.
		///
		/// Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
		///
		/// Parameters:
		/// - `asset_in`: ID of asset sold to the pool
		/// - `asset_out`: ID of asset bought from the pool
		/// - `amount`: Amount of asset sold
		/// - `max_sell_amount`: Maximum amount to be sold.
		///
		/// Emits `BuyExecuted` event when successful.
		///
		#[pallet::call_index(6)]
		#[pallet::weight(<T as Config>::WeightInfo::buy()
			.saturating_add(T::OmnipoolHooks::on_trade_weight())
			.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight())
		)]
		#[transactional]
		pub fn buy(
			origin: OriginFor<T>,
			asset_out: T::AssetId,
			asset_in: T::AssetId,
			amount: Balance,
			max_sell_amount: Balance,
		) -> DispatchResult {
			let who = ensure_signed(origin.clone())?;

			ensure!(asset_in != asset_out, Error::<T>::SameAssetTradeNotAllowed);

			ensure!(
				amount >= T::MinimumTradingLimit::get(),
				Error::<T>::InsufficientTradingAmount
			);

			// Special handling when one of the asset is Hub Asset
			if asset_out == T::HubAssetId::get() {
				return Self::buy_hub_asset(&who, asset_in, amount, max_sell_amount);
			}

			if asset_in == T::HubAssetId::get() {
				return Self::buy_asset_for_hub_asset(origin, &who, asset_out, amount, max_sell_amount);
			}

			let asset_in_state = Self::load_asset_state(asset_in)?;
			let asset_out_state = Self::load_asset_state(asset_out)?;

			ensure!(
				Self::allow_assets(&asset_in_state, &asset_out_state),
				Error::<T>::NotAllowed
			);

			ensure!(asset_out_state.reserve >= amount, Error::<T>::InsufficientLiquidity);

			ensure!(
				amount
					<= asset_out_state
						.reserve
						.checked_div(T::MaxOutRatio::get())
						.ok_or(ArithmeticError::DivisionByZero)?, // Note: Let's be safe. this can only fail if MaxOutRatio is zero.
				Error::<T>::MaxOutRatioExceeded
			);

			let current_imbalance = <HubAssetImbalance<T>>::get();

			let (asset_fee, _) = T::Fee::get(&asset_out);
			let (_, protocol_fee) = T::Fee::get(&asset_in);
			let state_changes = hydra_dx_math::omnipool::calculate_buy_state_changes(
				&(&asset_in_state).into(),
				&(&asset_out_state).into(),
				amount,
				asset_fee,
				protocol_fee,
				current_imbalance.value,
			)
			.ok_or(ArithmeticError::Overflow)?;

			ensure!(
				T::Currency::ensure_can_withdraw(asset_in, &who, *state_changes.asset_in.delta_reserve).is_ok(),
				Error::<T>::InsufficientBalance
			);

			ensure!(
				*state_changes.asset_in.delta_reserve <= max_sell_amount,
				Error::<T>::SellLimitExceeded
			);

			ensure!(
				*state_changes.asset_in.delta_reserve
					<= asset_in_state
						.reserve
						.checked_div(T::MaxInRatio::get())
						.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.
				Error::<T>::MaxInRatioExceeded
			);

			let new_asset_in_state = asset_in_state
				.delta_update(&state_changes.asset_in)
				.ok_or(ArithmeticError::Overflow)?;
			let new_asset_out_state = asset_out_state
				.delta_update(&state_changes.asset_out)
				.ok_or(ArithmeticError::Overflow)?;

			debug_assert_eq!(
				*state_changes.asset_out.delta_reserve, amount,
				"delta_reserve_out is not equal to given amount out"
			);

			T::Currency::transfer(
				asset_in,
				&who,
				&Self::protocol_account(),
				*state_changes.asset_in.delta_reserve,
			)?;
			T::Currency::transfer(
				asset_out,
				&Self::protocol_account(),
				&who,
				*state_changes.asset_out.delta_reserve,
			)?;

			// Hub liquidity update - work out difference between in and amount so only one update is needed.
			let delta_hub_asset = state_changes
				.asset_in
				.delta_hub_reserve
				.merge(
					state_changes
						.asset_out
						.delta_hub_reserve
						.merge(BalanceUpdate::Increase(state_changes.hdx_hub_amount))
						.ok_or(ArithmeticError::Overflow)?,
				)
				.ok_or(ArithmeticError::Overflow)?;

			match delta_hub_asset {
				BalanceUpdate::Increase(val) if val == Balance::zero() => {
					// nothing to do if zero.
				}
				BalanceUpdate::Increase(_) => {
					// trade can only burn some. This would be a bug.
					return Err(Error::<T>::HubAssetUpdateError.into());
				}
				BalanceUpdate::Decrease(amount) => {
					T::Currency::withdraw(T::HubAssetId::get(), &Self::protocol_account(), amount)?;
				}
			};

			// Callback hook info
			let info_in: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
				asset_in,
				&asset_in_state,
				&new_asset_in_state,
				&state_changes.asset_in,
				false,
			);

			let info_out: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
				asset_out,
				&asset_out_state,
				&new_asset_out_state,
				&state_changes.asset_out,
				false,
			);

			Self::update_imbalance(state_changes.delta_imbalance)?;
			Self::set_asset_state(asset_in, new_asset_in_state);
			Self::set_asset_state(asset_out, new_asset_out_state);

			T::OmnipoolHooks::on_trade(origin.clone(), info_in, info_out)?;

			Self::update_hdx_subpool_hub_asset(origin, state_changes.hdx_hub_amount)?;

			Self::process_trade_fee(&who, asset_out, state_changes.fee.asset_fee)?;

			debug_assert!(*state_changes.asset_in.delta_hub_reserve >= *state_changes.asset_out.delta_hub_reserve);
			debug_assert_eq!(
				*state_changes.asset_in.delta_hub_reserve - *state_changes.asset_out.delta_hub_reserve,
				state_changes.fee.protocol_fee
			);

			Self::deposit_event(Event::BuyExecuted {
				who,
				asset_in,
				asset_out,
				amount_in: *state_changes.asset_in.delta_reserve,
				amount_out: *state_changes.asset_out.delta_reserve,
				hub_amount_in: *state_changes.asset_in.delta_hub_reserve,
				hub_amount_out: *state_changes.asset_out.delta_hub_reserve,
				asset_fee_amount: state_changes.fee.asset_fee,
				protocol_fee_amount: state_changes.fee.protocol_fee,
			});

			#[cfg(feature = "try-runtime")]
			Self::ensure_trade_invariant(
				(asset_in, asset_in_state, new_asset_in_state),
				(asset_out, asset_out_state, new_asset_out_state),
			);

			Ok(())
		}

		/// Update asset's tradable state.
		///
		/// Parameters:
		/// - `asset_id`: asset id
		/// - `state`: new state
		///
		/// Emits `TradableStateUpdated` event when successful.
		///
		#[pallet::call_index(7)]
		#[pallet::weight((<T as Config>::WeightInfo::set_asset_tradable_state(), DispatchClass::Operational))]
		#[transactional]
		pub fn set_asset_tradable_state(
			origin: OriginFor<T>,
			asset_id: T::AssetId,
			state: Tradability,
		) -> DispatchResult {
			T::TechnicalOrigin::ensure_origin(origin)?;

			if asset_id == T::HubAssetId::get() {
				// Atm omnipool does not allow adding/removing liquidity of hub asset.
				// Although BUY is not supported yet, we can allow the new state to be set to SELL/BUY.
				ensure!(
					!state.contains(Tradability::ADD_LIQUIDITY) && !state.contains(Tradability::REMOVE_LIQUIDITY),
					Error::<T>::InvalidHubAssetTradableState
				);

				HubAssetTradability::<T>::mutate(|value| -> DispatchResult {
					*value = state;
					Self::deposit_event(Event::TradableStateUpdated { asset_id, state });
					Ok(())
				})
			} else {
				Assets::<T>::try_mutate(asset_id, |maybe_asset| -> DispatchResult {
					let asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;

					asset_state.tradable = state;
					Self::deposit_event(Event::TradableStateUpdated { asset_id, state });

					Ok(())
				})
			}
		}

		/// Refund given amount of asset to a recipient.
		///
		/// A refund is needed when a token is refused to be added to Omnipool, and initial liquidity of the asset has been already transferred to pool's account.
		///
		/// Transfer can be executed only if asset is not in Omnipool and pool's balance has sufficient amount.
		///
		/// Only `AuthorityOrigin` can perform this operation.
		///
		/// Emits `AssetRefunded`
		#[pallet::call_index(8)]
		#[pallet::weight(<T as Config>::WeightInfo::refund_refused_asset())]
		#[transactional]
		pub fn refund_refused_asset(
			origin: OriginFor<T>,
			asset_id: T::AssetId,
			amount: Balance,
			recipient: T::AccountId,
		) -> DispatchResult {
			T::AuthorityOrigin::ensure_origin(origin)?;

			// Hub asset cannot be refunded
			ensure!(asset_id != T::HubAssetId::get(), Error::<T>::AssetRefundNotAllowed);

			// Make sure that asset is not in the pool
			ensure!(!Assets::<T>::contains_key(asset_id), Error::<T>::AssetAlreadyAdded);

			ensure!(
				T::Currency::ensure_can_withdraw(asset_id, &Self::protocol_account(), amount).is_ok(),
				Error::<T>::InsufficientBalance
			);

			T::Currency::transfer(asset_id, &Self::protocol_account(), &recipient, amount)?;

			Self::deposit_event(Event::AssetRefunded {
				asset_id,
				amount,
				recipient,
			});

			Ok(())
		}

		/// Update asset's weight cap
		///
		/// Parameters:
		/// - `asset_id`: asset id
		/// - `cap`: new weight cap
		///
		/// Emits `AssetWeightCapUpdated` event when successful.
		///
		#[pallet::call_index(9)]
		#[pallet::weight(<T as Config>::WeightInfo::set_asset_weight_cap())]
		#[transactional]
		pub fn set_asset_weight_cap(origin: OriginFor<T>, asset_id: T::AssetId, cap: Permill) -> DispatchResult {
			T::TechnicalOrigin::ensure_origin(origin)?;

			Assets::<T>::try_mutate(asset_id, |maybe_asset| -> DispatchResult {
				let asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;

				asset_state.cap = FixedU128::from(cap).into_inner();
				Self::deposit_event(Event::AssetWeightCapUpdated { asset_id, cap });

				Ok(())
			})
		}

		/// Removes protocol liquidity.
		///
		/// Protocol liquidity is liquidity from sacrificed positions. In order to remove protocol liquidity,
		/// we need the know the price of the position at the time of sacrifice. Hence this specific call.
		///
		/// Only `AuthorityOrigin` can perform this call.
		///
		/// Note that sacrifice position will be deprecated in future. There is no longer a need for that.
		///
		/// It works the same way as remove liquidity call, but position is temporary reconstructed.
		///
		#[pallet::call_index(11)]
		#[pallet::weight(<T as Config>::WeightInfo::withdraw_protocol_liquidity())]
		#[transactional]
		pub fn withdraw_protocol_liquidity(
			origin: OriginFor<T>,
			asset_id: T::AssetId,
			amount: Balance,
			price: (Balance, Balance),
			dest: T::AccountId,
		) -> DispatchResult {
			T::AuthorityOrigin::ensure_origin(origin.clone())?;

			let asset_state = Self::load_asset_state(asset_id)?;
			ensure!(amount <= asset_state.protocol_shares, Error::<T>::InsufficientShares);

			let current_imbalance = <HubAssetImbalance<T>>::get();
			let current_hub_asset_liquidity =
				T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

			// dev note: as we no longer have the position details for sacrificed one, we just need to
			// construct temporary position.
			// Note that amount is ok to set to zero in this case. Although the remove liquidity calculation
			// calculates the delta for this field, it does not make any difference afterwards.
			let position = hydra_dx_math::omnipool::types::Position::<Balance> {
				amount: 0,
				price,
				shares: amount,
			};

			let state_changes = hydra_dx_math::omnipool::calculate_remove_liquidity_state_changes(
				&(&asset_state).into(),
				amount,
				&position,
				I129 {
					value: current_imbalance.value,
					negative: current_imbalance.negative,
				},
				current_hub_asset_liquidity,
				FixedU128::zero(),
			)
			.ok_or(ArithmeticError::Overflow)?;

			let mut new_asset_state = asset_state
				.delta_update(&state_changes.asset)
				.ok_or(ArithmeticError::Overflow)?;

			new_asset_state.protocol_shares = new_asset_state.protocol_shares.saturating_sub(amount);

			T::Currency::transfer(
				asset_id,
				&Self::protocol_account(),
				&dest,
				*state_changes.asset.delta_reserve,
			)?;

			Self::update_imbalance(state_changes.delta_imbalance)?;

			// burn only difference between delta hub and lp hub amount.
			Self::update_hub_asset_liquidity(
				&state_changes
					.asset
					.delta_hub_reserve
					.merge(BalanceUpdate::Increase(state_changes.lp_hub_amount))
					.ok_or(ArithmeticError::Overflow)?,
			)?;

			// LP receives some hub asset
			Self::process_hub_amount(state_changes.lp_hub_amount, &dest)?;

			// Callback hook info
			let info: AssetInfo<T::AssetId, Balance> =
				AssetInfo::new(asset_id, &asset_state, &new_asset_state, &state_changes.asset, true);

			Self::set_asset_state(asset_id, new_asset_state);

			Self::deposit_event(Event::ProtocolLiquidityRemoved {
				who: dest,
				asset_id,
				amount: *state_changes.asset.delta_reserve,
				hub_amount: state_changes.lp_hub_amount,
				shares_removed: amount,
			});

			T::OmnipoolHooks::on_liquidity_changed(origin, info)?;
			Ok(())
		}

		/// Removes token from Omnipool.
		///
		/// Asset's tradability must be FROZEN, otherwise `AssetNotFrozen` error is returned.
		///
		/// Remaining shares must belong to protocol, otherwise `SharesRemaining` error is returned.
		///
		/// Protocol's liquidity is transferred to the beneficiary account and hub asset amount is burned.
		///
		/// Only `AuthorityOrigin` can perform this call.
		///
		/// Emits `TokenRemoved` event when successful.
		#[pallet::call_index(12)]
		#[pallet::weight(<T as Config>::WeightInfo::remove_token())]
		#[transactional]
		pub fn remove_token(origin: OriginFor<T>, asset_id: T::AssetId, beneficiary: T::AccountId) -> DispatchResult {
			T::AuthorityOrigin::ensure_origin(origin)?;
			let asset_state = Self::load_asset_state(asset_id)?;

			// Allow only if no shares owned by LPs and asset is frozen.
			ensure!(asset_state.tradable == Tradability::FROZEN, Error::<T>::AssetNotFrozen);
			ensure!(
				asset_state.shares == asset_state.protocol_shares,
				Error::<T>::SharesRemaining
			);
			// Imbalance update
			let imbalance = <HubAssetImbalance<T>>::get();
			let hub_asset_liquidity = Self::get_hub_asset_balance_of_protocol_account();
			let delta_imbalance = hydra_dx_math::omnipool::calculate_delta_imbalance(
				asset_state.hub_reserve,
				I129 {
					value: imbalance.value,
					negative: imbalance.negative,
				},
				hub_asset_liquidity,
			)
			.ok_or(ArithmeticError::Overflow)?;
			Self::update_imbalance(BalanceUpdate::Increase(delta_imbalance))?;

			T::Currency::withdraw(T::HubAssetId::get(), &Self::protocol_account(), asset_state.hub_reserve)?;
			T::Currency::transfer(asset_id, &Self::protocol_account(), &beneficiary, asset_state.reserve)?;
			<Assets<T>>::remove(asset_id);
			Self::deposit_event(Event::TokenRemoved {
				asset_id,
				amount: asset_state.reserve,
				hub_withdrawn: asset_state.hub_reserve,
			});
			Ok(())
		}
	}

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
		fn integrity_test() {
			assert_ne!(
				T::MinimumPoolLiquidity::get(),
				Balance::zero(),
				"Minimum pool liquidity is 0."
			);
			assert_ne!(
				T::MinimumTradingLimit::get(),
				Balance::zero(),
				"Minimum trading limit is 0."
			);
			assert_ne!(T::MaxInRatio::get(), Balance::zero(), "MaxInRatio is 0.");
			assert_ne!(T::MaxOutRatio::get(), Balance::zero(), "MaxOutRatio is 0.");
		}

		#[cfg(feature = "try-runtime")]
		fn try_state(_n: BlockNumberFor<T>) -> Result<(), DispatchError> {
			use sp_std::collections::btree_map::BTreeMap;
			let asset_hub_amount: Balance = Assets::<T>::iter_values().map(|v| v.hub_reserve).sum();
			let account_balance = T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());
			assert_eq!(
				account_balance, asset_hub_amount,
				"LRNA amount in assets != amount in account"
			);

			let mut shares: BTreeMap<T::AssetId, u128> = BTreeMap::new();
			for position in Positions::<T>::iter_values() {
				if let Some(current) = shares.get(&position.asset_id) {
					shares.insert(position.asset_id, position.shares + current);
				} else {
					shares.insert(position.asset_id, position.shares);
				}
			}
			for (asset_id, total) in shares.into_iter() {
				let state = Assets::<T>::get(asset_id).unwrap();
				assert_eq!(
					state.shares - state.protocol_shares,
					total,
					"Asset {:?} shares in positions is not equal to shares in asset state",
					asset_id
				);
			}
			Ok(())
		}
	}
}

impl<T: Config> Pallet<T> {
	/// Protocol account address
	pub fn protocol_account() -> T::AccountId {
		PalletId(*b"omnipool").into_account_truncating()
	}

	/// Retrieve state of asset from the pool and its pool balance
	pub fn load_asset_state(asset_id: T::AssetId) -> Result<AssetReserveState<Balance>, DispatchError> {
		let state = <Assets<T>>::get(asset_id).ok_or(Error::<T>::AssetNotFound)?;
		let reserve = T::Currency::free_balance(asset_id, &Self::protocol_account());
		Ok((state, reserve).into())
	}

	/// Set new state of asset.
	/// This converts the new state into correct state type ( by removing the reserve)
	fn set_asset_state(asset_id: T::AssetId, new_state: AssetReserveState<Balance>) {
		<Assets<T>>::insert(asset_id, Into::<AssetState<Balance>>::into(new_state));
	}

	/// Generate an nft instance id and mint NFT into the class and instance.
	#[require_transactional]
	fn create_and_mint_position_instance(owner: &T::AccountId) -> Result<T::PositionItemId, DispatchError> {
		<NextPositionId<T>>::try_mutate(|current_value| -> Result<T::PositionItemId, DispatchError> {
			let next_position_id = *current_value;

			T::NFTHandler::mint_into(&T::NFTCollectionId::get(), &next_position_id, owner)?;

			*current_value = current_value
				.checked_add(&T::PositionItemId::one())
				.ok_or(ArithmeticError::Overflow)?;

			Ok(next_position_id)
		})
	}

	/// Update Hub asset side of HDX subpool and add given amount to hub_asset_reserve
	fn update_hdx_subpool_hub_asset(origin: T::RuntimeOrigin, hub_asset_amount: Balance) -> DispatchResult {
		if hub_asset_amount > Balance::zero() {
			let hdx_state = Self::load_asset_state(T::HdxAssetId::get())?;

			let mut native_subpool = Assets::<T>::get(T::HdxAssetId::get()).ok_or(Error::<T>::AssetNotFound)?;
			native_subpool.hub_reserve = native_subpool
				.hub_reserve
				.checked_add(hub_asset_amount)
				.ok_or(ArithmeticError::Overflow)?;
			<Assets<T>>::insert(T::HdxAssetId::get(), native_subpool);

			let updated_hdx_state = Self::load_asset_state(T::HdxAssetId::get())?;

			let delta_changes = AssetStateChange {
				delta_hub_reserve: BalanceUpdate::Increase(hub_asset_amount),
				..Default::default()
			};

			let info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
				T::HdxAssetId::get(),
				&hdx_state,
				&updated_hdx_state,
				&delta_changes,
				false,
			);

			T::OmnipoolHooks::on_liquidity_changed(origin, info)?;
		}
		Ok(())
	}

	/// Mint or burn hub asset amount
	#[require_transactional]
	fn update_hub_asset_liquidity(delta_amount: &BalanceUpdate<Balance>) -> DispatchResult {
		match delta_amount {
			BalanceUpdate::Increase(amount) => {
				T::Currency::deposit(T::HubAssetId::get(), &Self::protocol_account(), *amount)
			}
			BalanceUpdate::Decrease(amount) => {
				T::Currency::withdraw(T::HubAssetId::get(), &Self::protocol_account(), *amount)
			}
		}
	}

	/// Update imbalance with given delta_imbalance - increase or decrease.
	/// It cannot result in imbalance being > 0.
	fn update_imbalance(delta_imbalance: BalanceUpdate<Balance>) -> DispatchResult {
		<HubAssetImbalance<T>>::try_mutate(|current_imbalance| -> DispatchResult {
			*current_imbalance = match delta_imbalance {
				BalanceUpdate::Decrease(amount) => (*current_imbalance).sub(amount).ok_or(ArithmeticError::Overflow)?,
				BalanceUpdate::Increase(amount) => (*current_imbalance).add(amount).ok_or(ArithmeticError::Overflow)?,
			};

			ensure!(current_imbalance.negative, Error::<T>::PositiveImbalance);

			Ok(())
		})
	}

	/// Check if assets can be traded - asset_in must be allowed to be sold and asset_out allowed to be bought.
	fn allow_assets(asset_in: &AssetReserveState<Balance>, asset_out: &AssetReserveState<Balance>) -> bool {
		asset_in.tradable.contains(Tradability::SELL) && asset_out.tradable.contains(Tradability::BUY)
	}

	/// Swap hub asset for asset_out.
	/// Special handling of sell trade where asset in is Hub Asset.
	fn sell_hub_asset(
		origin: T::RuntimeOrigin,
		who: &T::AccountId,
		asset_out: T::AssetId,
		amount: Balance,
		limit: Balance,
	) -> DispatchResult {
		ensure!(
			HubAssetTradability::<T>::get().contains(Tradability::SELL),
			Error::<T>::NotAllowed
		);

		let asset_state = Self::load_asset_state(asset_out)?;

		ensure!(asset_state.tradable.contains(Tradability::BUY), Error::<T>::NotAllowed);
		ensure!(
			amount
				<= asset_state
					.hub_reserve
					.checked_div(T::MaxInRatio::get())
					.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.
			Error::<T>::MaxInRatioExceeded
		);

		let current_imbalance = <HubAssetImbalance<T>>::get();
		let current_hub_asset_liquidity = T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

		let (asset_fee, _) = T::Fee::get(&asset_out);

		let state_changes = hydra_dx_math::omnipool::calculate_sell_hub_state_changes(
			&(&asset_state).into(),
			amount,
			asset_fee,
			I129 {
				value: current_imbalance.value,
				negative: current_imbalance.negative,
			},
			current_hub_asset_liquidity,
		)
		.ok_or(ArithmeticError::Overflow)?;

		ensure!(
			*state_changes.asset.delta_reserve >= limit,
			Error::<T>::BuyLimitNotReached
		);

		ensure!(
			*state_changes.asset.delta_reserve
				<= asset_state
					.reserve
					.checked_div(T::MaxOutRatio::get())
					.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.
			Error::<T>::MaxOutRatioExceeded
		);

		let new_asset_out_state = asset_state
			.delta_update(&state_changes.asset)
			.ok_or(ArithmeticError::Overflow)?;

		// Token updates
		T::Currency::transfer(
			T::HubAssetId::get(),
			who,
			&Self::protocol_account(),
			*state_changes.asset.delta_hub_reserve,
		)?;
		T::Currency::transfer(
			asset_out,
			&Self::protocol_account(),
			who,
			*state_changes.asset.delta_reserve,
		)?;

		let info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
			asset_out,
			&asset_state,
			&new_asset_out_state,
			&state_changes.asset,
			false,
		);

		Self::update_imbalance(state_changes.delta_imbalance)?;

		Self::set_asset_state(asset_out, new_asset_out_state);

		Self::process_trade_fee(who, asset_out, state_changes.fee.asset_fee)?;

		Self::deposit_event(Event::SellExecuted {
			who: who.clone(),
			asset_in: T::HubAssetId::get(),
			asset_out,
			amount_in: *state_changes.asset.delta_hub_reserve,
			amount_out: *state_changes.asset.delta_reserve,
			hub_amount_in: 0,
			hub_amount_out: 0,
			asset_fee_amount: state_changes.fee.asset_fee,
			protocol_fee_amount: state_changes.fee.protocol_fee,
		});

		T::OmnipoolHooks::on_hub_asset_trade(origin, info)?;

		Ok(())
	}

	/// Swap asset for Hub Asset
	/// Special handling of buy trade where asset in is Hub Asset.
	fn buy_asset_for_hub_asset(
		origin: T::RuntimeOrigin,
		who: &T::AccountId,
		asset_out: T::AssetId,
		amount: Balance,
		limit: Balance,
	) -> DispatchResult {
		ensure!(
			HubAssetTradability::<T>::get().contains(Tradability::SELL),
			Error::<T>::NotAllowed
		);

		let asset_state = Self::load_asset_state(asset_out)?;

		ensure!(asset_state.tradable.contains(Tradability::BUY), Error::<T>::NotAllowed);

		ensure!(
			amount
				<= asset_state
					.reserve
					.checked_div(T::MaxOutRatio::get())
					.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.
			Error::<T>::MaxOutRatioExceeded
		);

		let current_imbalance = <HubAssetImbalance<T>>::get();

		let current_hub_asset_liquidity = Self::get_hub_asset_balance_of_protocol_account();

		let (asset_fee, _) = T::Fee::get(&asset_out);

		let state_changes = hydra_dx_math::omnipool::calculate_buy_for_hub_asset_state_changes(
			&(&asset_state).into(),
			amount,
			asset_fee,
			I129 {
				value: current_imbalance.value,
				negative: current_imbalance.negative,
			},
			current_hub_asset_liquidity,
		)
		.ok_or(ArithmeticError::Overflow)?;

		ensure!(
			*state_changes.asset.delta_hub_reserve <= limit,
			Error::<T>::SellLimitExceeded
		);

		ensure!(
			*state_changes.asset.delta_hub_reserve
				<= asset_state
					.hub_reserve
					.checked_div(T::MaxInRatio::get())
					.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.
			Error::<T>::MaxInRatioExceeded
		);

		let new_asset_out_state = asset_state
			.delta_update(&state_changes.asset)
			.ok_or(ArithmeticError::Overflow)?;

		T::Currency::transfer(
			T::HubAssetId::get(),
			who,
			&Self::protocol_account(),
			*state_changes.asset.delta_hub_reserve,
		)?;
		T::Currency::transfer(
			asset_out,
			&Self::protocol_account(),
			who,
			*state_changes.asset.delta_reserve,
		)?;

		let info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(
			asset_out,
			&asset_state,
			&new_asset_out_state,
			&state_changes.asset,
			false,
		);

		Self::update_imbalance(state_changes.delta_imbalance)?;

		Self::set_asset_state(asset_out, new_asset_out_state);

		Self::process_trade_fee(who, asset_out, state_changes.fee.asset_fee)?;

		Self::deposit_event(Event::BuyExecuted {
			who: who.clone(),
			asset_in: T::HubAssetId::get(),
			asset_out,
			amount_in: *state_changes.asset.delta_hub_reserve,
			amount_out: *state_changes.asset.delta_reserve,
			hub_amount_in: 0,
			hub_amount_out: 0,
			asset_fee_amount: state_changes.fee.asset_fee,
			protocol_fee_amount: state_changes.fee.protocol_fee,
		});

		T::OmnipoolHooks::on_hub_asset_trade(origin, info)?;

		Ok(())
	}

	/// Buy hub asset from the pool
	/// Special handling of buy trade where asset out is Hub Asset.
	fn buy_hub_asset(_who: &T::AccountId, _asset_in: T::AssetId, _amount: Balance, _limit: Balance) -> DispatchResult {
		ensure!(
			HubAssetTradability::<T>::get().contains(Tradability::BUY),
			Error::<T>::NotAllowed
		);

		// Note: Currently not allowed at all, neither math is done for this case
		// this is already ready when hub asset will be allowed to be bought from the pool

		Err(Error::<T>::NotAllowed.into())
	}

	/// Swap asset for Hub Asset
	/// Special handling of sell trade where asset out is Hub Asset.
	fn sell_asset_for_hub_asset(
		_who: &T::AccountId,
		_asset_in: T::AssetId,
		_amount: Balance,
		_limit: Balance,
	) -> DispatchResult {
		ensure!(
			HubAssetTradability::<T>::get().contains(Tradability::BUY),
			Error::<T>::NotAllowed
		);

		// Note: Currently not allowed at all, neither math is done for this case
		// this is already ready when hub asset will be allowed to be bought from the pool

		Err(Error::<T>::NotAllowed.into())
	}

	/// Get hub asset balance of protocol account
	fn get_hub_asset_balance_of_protocol_account() -> Balance {
		T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account())
	}

	/// Remove asset from list of Omnipool assets.
	/// No events emitted.
	pub fn remove_asset(asset_id: T::AssetId) -> DispatchResult {
		<Assets<T>>::remove(asset_id);
		Ok(())
	}

	/// Insert or update position with given position data.
	pub fn set_position(position_id: T::PositionItemId, position: &Position<Balance, T::AssetId>) -> DispatchResult {
		<Positions<T>>::insert(position_id, position);
		Ok(())
	}

	/// Add new asset to list of Omnipool assets.
	/// No events emitted.
	pub fn add_asset(asset_id: T::AssetId, state: AssetState<Balance>) -> DispatchResult {
		ensure!(!Assets::<T>::contains_key(asset_id), Error::<T>::AssetAlreadyAdded);
		ensure!(T::AssetRegistry::exists(asset_id), Error::<T>::AssetNotRegistered);

		<Assets<T>>::insert(asset_id, state);

		Ok(())
	}

	/// Load state of an asset and update it with given delta changes.
	pub fn update_asset_state(asset_id: T::AssetId, delta: AssetStateChange<Balance>) -> DispatchResult {
		let state = Self::load_asset_state(asset_id)?;
		let updated_state = state.delta_update(&delta).ok_or(ArithmeticError::Overflow)?;
		Self::set_asset_state(asset_id, updated_state);

		Ok(())
	}

	/// Load position and check its owner
	/// Returns Forbidden if not position owner
	pub fn load_position(
		position_id: T::PositionItemId,
		owner: T::AccountId,
	) -> Result<Position<Balance, T::AssetId>, DispatchError> {
		ensure!(
			T::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(owner),
			Error::<T>::Forbidden
		);

		Positions::<T>::get(position_id).ok_or_else(|| Error::<T>::PositionNotFound.into())
	}

	pub fn is_hub_asset_allowed(operation: Tradability) -> bool {
		HubAssetTradability::<T>::get().contains(operation)
	}

	/// Returns `true` if `asset` exists in the omnipool or `false`
	pub fn exists(asset: T::AssetId) -> bool {
		Assets::<T>::contains_key(asset)
	}

	/// Calls `on_trade_fee` hook and ensures that no more than the fee amount is transferred.
	fn process_trade_fee(trader: &T::AccountId, asset: T::AssetId, amount: Balance) -> DispatchResult {
		let account = Self::protocol_account();
		let original_asset_reserve = T::Currency::free_balance(asset, &account);

		// Let's give little bit less to process. Subtracting one due to potential rounding errors
		let allowed_amount = amount.saturating_sub(Balance::one());
		let used = T::OmnipoolHooks::on_trade_fee(account.clone(), trader.clone(), asset, allowed_amount)?;
		let asset_reserve = T::Currency::free_balance(asset, &account);
		let diff = original_asset_reserve.saturating_sub(asset_reserve);
		ensure!(diff <= allowed_amount, Error::<T>::FeeOverdraft);
		ensure!(diff == used, Error::<T>::FeeOverdraft);
		Ok(())
	}

	pub fn process_hub_amount(amount: Balance, dest: &T::AccountId) -> DispatchResult {
		if amount > Balance::zero() {
			// If transfers fails and the amount is less than ED, it failed due to ED limit, so we simply burn it
			if let Err(e) = T::Currency::transfer(T::HubAssetId::get(), &Self::protocol_account(), dest, amount) {
				if amount < 400_000_000u128 {
					T::Currency::withdraw(T::HubAssetId::get(), &Self::protocol_account(), amount)?;
				} else {
					return Err(e);
				}
			}
		}
		Ok(())
	}

	#[require_transactional]
	pub fn do_add_liquidity_with_limit(
		origin: OriginFor<T>,
		asset: T::AssetId,
		amount: Balance,
		min_shares_limit: Balance,
	) -> Result<T::PositionItemId, DispatchError> {
		let who = ensure_signed(origin.clone())?;

		ensure!(
			amount >= T::MinimumPoolLiquidity::get(),
			Error::<T>::InsufficientLiquidity
		);

		ensure!(
			T::Currency::ensure_can_withdraw(asset, &who, amount).is_ok(),
			Error::<T>::InsufficientBalance
		);

		let asset_state = Self::load_asset_state(asset)?;

		ensure!(
			asset_state.tradable.contains(Tradability::ADD_LIQUIDITY),
			Error::<T>::NotAllowed
		);

		T::PriceBarrier::ensure_price(
			&who,
			T::HubAssetId::get(),
			asset,
			EmaPrice::new(asset_state.hub_reserve, asset_state.reserve),
		)
		.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;

		let current_imbalance = <HubAssetImbalance<T>>::get();
		let current_hub_asset_liquidity = T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

		//
		// Calculate add liquidity state changes
		//
		let state_changes = hydra_dx_math::omnipool::calculate_add_liquidity_state_changes(
			&(&asset_state).into(),
			amount,
			I129 {
				value: current_imbalance.value,
				negative: current_imbalance.negative,
			},
			current_hub_asset_liquidity,
		)
		.ok_or(ArithmeticError::Overflow)?;

		ensure!(
			*state_changes.asset.delta_shares >= min_shares_limit,
			Error::<T>::SlippageLimit
		);

		let new_asset_state = asset_state
			.delta_update(&state_changes.asset)
			.ok_or(ArithmeticError::Overflow)?;

		let hub_reserve_ratio = FixedU128::checked_from_rational(
			new_asset_state.hub_reserve,
			T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account())
				.checked_add(*state_changes.asset.delta_hub_reserve)
				.ok_or(ArithmeticError::Overflow)?,
		)
		.ok_or(ArithmeticError::DivisionByZero)?;

		ensure!(
			hub_reserve_ratio <= new_asset_state.weight_cap(),
			Error::<T>::AssetWeightCapExceeded
		);

		// Create LP position with given shares
		let lp_position = Position::<Balance, T::AssetId> {
			asset_id: asset,
			amount,
			shares: *state_changes.asset.delta_shares,
			// Note: position needs price after asset state is updated.
			price: (new_asset_state.hub_reserve, new_asset_state.reserve),
		};

		let instance_id = Self::create_and_mint_position_instance(&who)?;

		<Positions<T>>::insert(instance_id, lp_position);

		Self::deposit_event(Event::PositionCreated {
			position_id: instance_id,
			owner: who.clone(),
			asset,
			amount,
			shares: *state_changes.asset.delta_shares,
			price: new_asset_state.price().ok_or(ArithmeticError::DivisionByZero)?,
		});

		T::Currency::transfer(
			asset,
			&who,
			&Self::protocol_account(),
			*state_changes.asset.delta_reserve,
		)?;

		debug_assert_eq!(*state_changes.asset.delta_reserve, amount);

		// Callback hook info
		let info: AssetInfo<T::AssetId, Balance> =
			AssetInfo::new(asset, &asset_state, &new_asset_state, &state_changes.asset, false);

		Self::update_imbalance(state_changes.delta_imbalance)?;

		Self::update_hub_asset_liquidity(&state_changes.asset.delta_hub_reserve)?;

		Self::set_asset_state(asset, new_asset_state);

		Self::deposit_event(Event::LiquidityAdded {
			who,
			asset_id: asset,
			amount,
			position_id: instance_id,
		});

		T::OmnipoolHooks::on_liquidity_changed(origin, info)?;

		#[cfg(feature = "try-runtime")]
		Self::ensure_liquidity_invariant((asset, asset_state, new_asset_state));

		Ok(instance_id)
	}

	#[cfg(feature = "try-runtime")]
	fn ensure_trade_invariant(
		asset_in: (T::AssetId, AssetReserveState<Balance>, AssetReserveState<Balance>),
		asset_out: (T::AssetId, AssetReserveState<Balance>, AssetReserveState<Balance>),
	) {
		let new_in_state = asset_in.2;
		let new_out_state = asset_out.2;

		let old_in_state = asset_in.1;
		let old_out_state = asset_out.1;
		assert!(new_in_state.reserve > old_in_state.reserve);
		assert!(new_out_state.reserve < old_out_state.reserve);

		let in_new_reserve = U256::from(new_in_state.reserve);
		let in_new_hub_reserve = U256::from(new_in_state.hub_reserve);
		let in_old_reserve = U256::from(old_in_state.reserve);
		let in_old_hub_reserve = U256::from(old_in_state.hub_reserve);

		let rq = in_old_reserve.checked_mul(in_old_hub_reserve).unwrap();
		let rq_plus = in_new_reserve.checked_mul(in_new_hub_reserve).unwrap();
		assert!(
			rq_plus >= rq,
			"Asset IN trade invariant, {:?}, {:?}",
			new_in_state,
			old_in_state
		);
		/*
		   let out_new_reserve = U256::from(new_out_state.reserve);
		   let out_new_hub_reserve = U256::from(new_out_state.hub_reserve);
		   let out_old_reserve = U256::from(old_out_state.reserve);
		   let out_old_hub_reserve = U256::from(old_out_state.hub_reserve);

		   let left = rq + sp_std::cmp::max(in_new_reserve, in_new_hub_reserve);
		   let right = rq_plus;
		   assert!(left >= right, "Asset IN margin {:?} >= {:?}", left,right);

		   let rq = out_old_reserve.checked_mul(out_old_hub_reserve).unwrap();
		   let rq_plus = out_new_reserve.checked_mul(out_new_hub_reserve).unwrap();
		   assert!(rq_plus >= rq, "Asset OUT trade invariant, {:?}, {:?}", new_out_state, old_out_state);
		   let left = rq + sp_std::cmp::max(out_new_reserve, out_new_hub_reserve);
		   let right = rq_plus;
		   assert!(left >= right, "Asset OUT margin {:?} >= {:?}", left,right);

		*/
	}

	#[cfg(feature = "try-runtime")]
	fn ensure_liquidity_invariant(asset: (T::AssetId, AssetReserveState<Balance>, AssetReserveState<Balance>)) {
		let old_state = asset.1;
		let new_state = asset.2;

		let new_reserve = U256::from(new_state.reserve);
		let new_hub_reserve = U256::from(new_state.hub_reserve);
		let old_reserve = U256::from(old_state.reserve);
		let old_hub_reserve = U256::from(old_state.hub_reserve);

		let one = U256::from(1_000_000_000_000u128);

		let left = new_hub_reserve.saturating_sub(one).checked_mul(old_reserve).unwrap();
		let middle = old_hub_reserve.checked_mul(new_reserve).unwrap();
		let right = new_hub_reserve
			.checked_add(one)
			.unwrap()
			.checked_mul(old_reserve)
			.unwrap();

		assert!(left <= middle, "Add liquidity first part");
		assert!(
			middle <= right,
			"Add liquidity second part - {:?} <= {:?} <= {:?}",
			left,
			middle,
			right
		);
	}
}

File: ./pallets/omnipool/src/provider.rs
use crate::pallet::Assets;
use crate::{Config, Pallet};
use hydradx_traits::pools::SpotPriceProvider;
use sp_runtime::traits::{CheckedMul, Get, One};
use sp_runtime::{FixedPointNumber, FixedU128};

impl<T: Config> SpotPriceProvider<T::AssetId> for Pallet<T> {
	type Price = FixedU128;

	fn pair_exists(asset_a: T::AssetId, asset_b: T::AssetId) -> bool {
		<Assets<T>>::get(asset_a).is_some() && <Assets<T>>::get(asset_b).is_some()
	}

	fn spot_price(asset_a: T::AssetId, asset_b: T::AssetId) -> Option<Self::Price> {
		if asset_a == asset_b {
			return Some(FixedU128::one());
		}
		if asset_a == T::HubAssetId::get() {
			let asset_b = Self::load_asset_state(asset_b).ok()?;
			FixedU128::checked_from_rational(asset_b.hub_reserve, asset_b.reserve)
		} else if asset_b == T::HubAssetId::get() {
			let asset_a = Self::load_asset_state(asset_a).ok()?;
			FixedU128::checked_from_rational(asset_a.reserve, asset_a.hub_reserve)
		} else {
			let asset_a = Self::load_asset_state(asset_a).ok()?;
			let asset_b = Self::load_asset_state(asset_b).ok()?;
			// (A / LRNA) * (LRNA / B) = A / B
			let price_a = FixedU128::checked_from_rational(asset_a.reserve, asset_a.hub_reserve)?;
			let price_b = FixedU128::checked_from_rational(asset_b.hub_reserve, asset_b.reserve)?;
			price_a.checked_mul(&price_b)
		}
	}
}

File: ./pallets/omnipool/src/weights.rs
// This file is part of HydraDX.

// Copyright (C) 2020-2023  Intergalactic, Limited (GIB).
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


//! Autogenerated weights for `pallet_omnipool`
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 32.0.0
//! DATE: 2024-09-10, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
//! WORST CASE MAP SIZE: `1000000`
//! HOSTNAME: `bench-bot`, CPU: `Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz`
//! WASM-EXECUTION: `Compiled`, CHAIN: `Some("dev")`, DB CACHE: `1024`

// Executed Command:
// target/release/hydradx
// benchmark
// pallet
// --chain=dev
// --steps=50
// --repeat=20
// --wasm-execution=compiled
// --pallet=pallet-omnipool
// --extrinsic=*
// --template=scripts/pallet-weight-template.hbs
// --output=./weights/pallet_omnipool.rs

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(missing_docs)]

use frame_support::{
	traits::Get,
	weights::{constants::RocksDbWeight, Weight},
};
use sp_std::marker::PhantomData;

/// Weight functions needed for pallet_omnipool.
pub trait WeightInfo {
	fn add_token() -> Weight;
	fn add_liquidity() -> Weight;
	fn remove_liquidity() -> Weight;
	fn sell() -> Weight;
	fn buy() -> Weight;
	fn set_asset_tradable_state() -> Weight;
	fn refund_refused_asset() -> Weight;
	fn sacrifice_position() -> Weight;
	fn set_asset_weight_cap() -> Weight;
	fn router_execution_sell(c: u32, e: u32) -> Weight;
	fn router_execution_buy(c: u32, e: u32) -> Weight;
	fn withdraw_protocol_liquidity() -> Weight;
	fn remove_token() -> Weight;
	fn calculate_spot_price_with_fee() -> Weight;
}

/// Weights for pallet_omnipool using the hydraDX node and recommended hardware.
impl WeightInfo for () {
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:2 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Class` (r:1 w:1)
	/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:2 w:1)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::NextPositionId` (r:1 w:1)
	/// Proof: `Omnipool::NextPositionId` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Asset` (r:1 w:1)
	/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::CollectionMaxSupply` (r:1 w:0)
	/// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(36), added: 2511, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:1 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::TotalIssuance` (r:1 w:1)
	/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Account` (r:0 w:1)
	/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Positions` (r:0 w:1)
	/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)
	fn add_token() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `3128`
		//  Estimated: `7406`
		// Minimum execution time: 129_737_000 picoseconds.
		Weight::from_parts(131_001_000, 7406)
			.saturating_add(RocksDbWeight::get().reads(13_u64))
			.saturating_add(RocksDbWeight::get().writes(10_u64))
	}
	/// Storage: `Tokens::Accounts` (r:3 w:3)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Oracles` (r:2 w:0)
	/// Proof: `EmaOracle::Oracles` (`max_values`: None, `max_size`: Some(177), added: 2652, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::NextPositionId` (r:1 w:1)
	/// Proof: `Omnipool::NextPositionId` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Asset` (r:1 w:1)
	/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Class` (r:1 w:1)
	/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::CollectionMaxSupply` (r:1 w:0)
	/// Proof: `Uniques::CollectionMaxSupply` (`max_values`: None, `max_size`: Some(36), added: 2511, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:1 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:2 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:2 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:1 w:0)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::TotalIssuance` (r:1 w:1)
	/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Account` (r:0 w:1)
	/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Positions` (r:0 w:1)
	/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)
	fn add_liquidity() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `4552`
		//  Estimated: `8739`
		// Minimum execution time: 218_146_000 picoseconds.
		Weight::from_parts(219_509_000, 8739)
			.saturating_add(RocksDbWeight::get().reads(24_u64))
			.saturating_add(RocksDbWeight::get().writes(14_u64))
	}
	/// Storage: `Uniques::Asset` (r:1 w:1)
	/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Positions` (r:1 w:1)
	/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:4 w:4)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Oracles` (r:2 w:0)
	/// Proof: `EmaOracle::Oracles` (`max_values`: None, `max_size`: Some(177), added: 2652, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:1 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:2 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:2 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:2 w:1)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::TotalIssuance` (r:1 w:1)
	/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:1 w:1)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Class` (r:1 w:1)
	/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Account` (r:0 w:1)
	/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::ItemPriceOf` (r:0 w:1)
	/// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(113), added: 2588, mode: `MaxEncodedLen`)
	fn remove_liquidity() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `7463`
		//  Estimated: `11322`
		// Minimum execution time: 288_313_000 picoseconds.
		Weight::from_parts(290_432_000, 11322)
			.saturating_add(RocksDbWeight::get().reads(27_u64))
			.saturating_add(RocksDbWeight::get().writes(16_u64))
	}
	/// Storage: `Tokens::Accounts` (r:5 w:5)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Assets` (r:3 w:3)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `DynamicFees::AssetFee` (r:2 w:0)
	/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:2 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:2 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:4 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:3 w:2)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)
	/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)
	/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::Referrer` (r:1 w:0)
	/// Proof: `Referrals::Referrer` (`max_values`: None, `max_size`: Some(65), added: 2540, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::AssetRewards` (r:1 w:0)
	/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TotalShares` (r:1 w:1)
	/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::ReferrerShares` (r:1 w:1)
	/// Proof: `Referrals::ReferrerShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TraderShares` (r:2 w:2)
	/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::PendingConversions` (r:1 w:1)
	/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)
	/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
	fn sell() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `7823`
		//  Estimated: `13905`
		// Minimum execution time: 333_717_000 picoseconds.
		Weight::from_parts(335_901_000, 13905)
			.saturating_add(RocksDbWeight::get().reads(42_u64))
			.saturating_add(RocksDbWeight::get().writes(23_u64))
	}
	/// Storage: `Omnipool::Assets` (r:3 w:3)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:5 w:5)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `DynamicFees::AssetFee` (r:2 w:0)
	/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:2 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:2 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:4 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:3 w:2)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)
	/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)
	/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::Referrer` (r:1 w:0)
	/// Proof: `Referrals::Referrer` (`max_values`: None, `max_size`: Some(65), added: 2540, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::AssetRewards` (r:1 w:0)
	/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TotalShares` (r:1 w:1)
	/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::ReferrerShares` (r:1 w:1)
	/// Proof: `Referrals::ReferrerShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TraderShares` (r:2 w:2)
	/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::PendingConversions` (r:1 w:1)
	/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)
	/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
	fn buy() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `7823`
		//  Estimated: `13905`
		// Minimum execution time: 335_910_000 picoseconds.
		Weight::from_parts(337_763_000, 13905)
			.saturating_add(RocksDbWeight::get().reads(42_u64))
			.saturating_add(RocksDbWeight::get().writes(23_u64))
	}
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	fn set_asset_tradable_state() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `1305`
		//  Estimated: `3550`
		// Minimum execution time: 28_270_000 picoseconds.
		Weight::from_parts(28_812_000, 3550)
			.saturating_add(RocksDbWeight::get().reads(1_u64))
			.saturating_add(RocksDbWeight::get().writes(1_u64))
	}
	/// Storage: `Omnipool::Assets` (r:1 w:0)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:2 w:2)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:1 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:1 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:1 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:2 w:2)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:1 w:1)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	fn refund_refused_asset() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `2850`
		//  Estimated: `6196`
		// Minimum execution time: 104_659_000 picoseconds.
		Weight::from_parts(105_287_000, 6196)
			.saturating_add(RocksDbWeight::get().reads(11_u64))
			.saturating_add(RocksDbWeight::get().writes(5_u64))
	}
	/// Storage: `Omnipool::Positions` (r:1 w:1)
	/// Proof: `Omnipool::Positions` (`max_values`: None, `max_size`: Some(100), added: 2575, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Asset` (r:1 w:1)
	/// Proof: `Uniques::Asset` (`max_values`: None, `max_size`: Some(146), added: 2621, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Class` (r:1 w:1)
	/// Proof: `Uniques::Class` (`max_values`: None, `max_size`: Some(190), added: 2665, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::Account` (r:0 w:1)
	/// Proof: `Uniques::Account` (`max_values`: None, `max_size`: Some(112), added: 2587, mode: `MaxEncodedLen`)
	/// Storage: `Uniques::ItemPriceOf` (r:0 w:1)
	/// Proof: `Uniques::ItemPriceOf` (`max_values`: None, `max_size`: Some(113), added: 2588, mode: `MaxEncodedLen`)
	fn sacrifice_position() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `2910`
		//  Estimated: `3655`
		// Minimum execution time: 67_565_000 picoseconds.
		Weight::from_parts(68_526_000, 3655)
			.saturating_add(RocksDbWeight::get().reads(4_u64))
			.saturating_add(RocksDbWeight::get().writes(6_u64))
	}
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	fn set_asset_weight_cap() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `1305`
		//  Estimated: `3550`
		// Minimum execution time: 28_717_000 picoseconds.
		Weight::from_parts(29_137_000, 3550)
			.saturating_add(RocksDbWeight::get().reads(1_u64))
			.saturating_add(RocksDbWeight::get().writes(1_u64))
	}
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:3 w:3)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:1 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:1 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:2 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:2 w:1)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::TotalIssuance` (r:1 w:1)
	/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	fn withdraw_protocol_liquidity() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `4545`
		//  Estimated: `8739`
		// Minimum execution time: 150_915_000 picoseconds.
		Weight::from_parts(152_374_000, 8739)
			.saturating_add(RocksDbWeight::get().reads(16_u64))
			.saturating_add(RocksDbWeight::get().writes(8_u64))
	}
	/// Storage: `Omnipool::Assets` (r:1 w:1)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:4 w:3)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:2 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::TotalIssuance` (r:1 w:1)
	/// Proof: `Tokens::TotalIssuance` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:1 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:1 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:2 w:2)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:0)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	fn remove_token() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `3636`
		//  Estimated: `11322`
		// Minimum execution time: 151_145_000 picoseconds.
		Weight::from_parts(152_034_000, 11322)
			.saturating_add(RocksDbWeight::get().reads(17_u64))
			.saturating_add(RocksDbWeight::get().writes(8_u64))
	}
	/// Storage: `Omnipool::Assets` (r:3 w:3)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:5 w:5)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `DynamicFees::AssetFee` (r:2 w:0)
	/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:2 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:2 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:4 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:3 w:2)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)
	/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)
	/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::AssetRewards` (r:1 w:0)
	/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TotalShares` (r:1 w:1)
	/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TraderShares` (r:1 w:1)
	/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::PendingConversions` (r:1 w:1)
	/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)
	/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
	/// The range of component `c` is `[1, 2]`.
	/// The range of component `e` is `[0, 1]`.
	fn router_execution_sell(c: u32, e: u32, ) -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `1974 + e * (5348 Â±0)`
		//  Estimated: `11390 + e * (7749 Â±0)`
		// Minimum execution time: 45_263_000 picoseconds.
		Weight::from_parts(45_693_748, 11390)
			// Standard Error: 134_488
			.saturating_add(Weight::from_parts(268_691, 0).saturating_mul(c.into()))
			// Standard Error: 134_488
			.saturating_add(Weight::from_parts(289_580_167, 0).saturating_mul(e.into()))
			.saturating_add(RocksDbWeight::get().reads(7_u64))
			.saturating_add(RocksDbWeight::get().reads((32_u64).saturating_mul(e.into())))
			.saturating_add(RocksDbWeight::get().writes((21_u64).saturating_mul(e.into())))
			.saturating_add(Weight::from_parts(0, 7749).saturating_mul(e.into()))
	}
	/// Storage: `Omnipool::Assets` (r:3 w:3)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:5 w:5)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::HubAssetImbalance` (r:1 w:1)
	/// Proof: `Omnipool::HubAssetImbalance` (`max_values`: Some(1), `max_size`: Some(17), added: 512, mode: `MaxEncodedLen`)
	/// Storage: `DynamicFees::AssetFee` (r:2 w:0)
	/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
	/// Storage: `Router::SkipEd` (r:1 w:0)
	/// Proof: `Router::SkipEd` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
	/// Storage: `Duster::AccountBlacklist` (r:2 w:0)
	/// Proof: `Duster::AccountBlacklist` (`max_values`: None, `max_size`: Some(48), added: 2523, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::BannedAssets` (r:2 w:0)
	/// Proof: `AssetRegistry::BannedAssets` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `AssetRegistry::Assets` (r:4 w:0)
	/// Proof: `AssetRegistry::Assets` (`max_values`: None, `max_size`: Some(125), added: 2600, mode: `MaxEncodedLen`)
	/// Storage: `System::Account` (r:3 w:2)
	/// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AccountCurrencyMap` (r:2 w:2)
	/// Proof: `MultiTransactionPayment::AccountCurrencyMap` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `MultiTransactionPayment::AcceptedCurrencies` (r:1 w:0)
	/// Proof: `MultiTransactionPayment::AcceptedCurrencies` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
	/// Storage: `EmaOracle::Accumulator` (r:1 w:1)
	/// Proof: `EmaOracle::Accumulator` (`max_values`: Some(1), `max_size`: Some(5921), added: 6416, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (r:2 w:2)
	/// Proof: `CircuitBreaker::AllowedTradeVolumeLimitPerAsset` (`max_values`: None, `max_size`: Some(68), added: 2543, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityAddLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityAddLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (r:1 w:1)
	/// Proof: `CircuitBreaker::AllowedAddLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::LiquidityRemoveLimitPerAsset` (`max_values`: None, `max_size`: Some(29), added: 2504, mode: `MaxEncodedLen`)
	/// Storage: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (r:1 w:0)
	/// Proof: `CircuitBreaker::AllowedRemoveLiquidityAmountPerAsset` (`max_values`: None, `max_size`: Some(52), added: 2527, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::LinkedAccounts` (r:1 w:0)
	/// Proof: `Referrals::LinkedAccounts` (`max_values`: None, `max_size`: Some(80), added: 2555, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::AssetRewards` (r:1 w:0)
	/// Proof: `Referrals::AssetRewards` (`max_values`: None, `max_size`: Some(49), added: 2524, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TotalShares` (r:1 w:1)
	/// Proof: `Referrals::TotalShares` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::TraderShares` (r:1 w:1)
	/// Proof: `Referrals::TraderShares` (`max_values`: None, `max_size`: Some(64), added: 2539, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::PendingConversions` (r:1 w:1)
	/// Proof: `Referrals::PendingConversions` (`max_values`: None, `max_size`: Some(20), added: 2495, mode: `MaxEncodedLen`)
	/// Storage: `Referrals::CounterForPendingConversions` (r:1 w:1)
	/// Proof: `Referrals::CounterForPendingConversions` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
	/// The range of component `c` is `[1, 2]`.
	/// The range of component `e` is `[0, 1]`.
	fn router_execution_buy(c: u32, _e: u32, ) -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `7322`
		//  Estimated: `13905`
		// Minimum execution time: 319_285_000 picoseconds.
		Weight::from_parts(311_604_346, 13905)
			// Standard Error: 213_268
			.saturating_add(Weight::from_parts(12_523_973, 0).saturating_mul(c.into()))
			.saturating_add(RocksDbWeight::get().reads(39_u64))
			.saturating_add(RocksDbWeight::get().writes(21_u64))
	}
	/// Storage: `DynamicFees::AssetFee` (r:2 w:0)
	/// Proof: `DynamicFees::AssetFee` (`max_values`: None, `max_size`: Some(24), added: 2499, mode: `MaxEncodedLen`)
	/// Storage: `Omnipool::Assets` (r:2 w:0)
	/// Proof: `Omnipool::Assets` (`max_values`: None, `max_size`: Some(85), added: 2560, mode: `MaxEncodedLen`)
	/// Storage: `Tokens::Accounts` (r:2 w:0)
	/// Proof: `Tokens::Accounts` (`max_values`: None, `max_size`: Some(108), added: 2583, mode: `MaxEncodedLen`)
	fn calculate_spot_price_with_fee() -> Weight {
		// Proof Size summary in bytes:
		//  Measured:  `1933`
		//  Estimated: `6156`
		// Minimum execution time: 44_268_000 picoseconds.
		Weight::from_parts(44_633_000, 6156)
			.saturating_add(RocksDbWeight::get().reads(6_u64))
	}
}

File: ./pallets/omnipool/src/traits.rs
use crate::types::AssetReserveState;
use frame_support::ensure;
use frame_support::traits::Contains;
use frame_support::weights::Weight;
use hydra_dx_math::ema::EmaPrice;
use hydra_dx_math::omnipool::types::AssetStateChange;
use sp_runtime::traits::{CheckedAdd, CheckedMul, Get, Saturating, Zero};
use sp_runtime::{DispatchError, FixedPointNumber, FixedU128, Permill};
use sp_std::fmt::Debug;

/// Asset In/Out information used in hooks.
pub struct AssetInfo<AssetId, Balance>
where
	Balance: Default + Clone,
{
	pub asset_id: AssetId,
	pub before: AssetReserveState<Balance>,
	pub after: AssetReserveState<Balance>,
	pub delta_changes: AssetStateChange<Balance>,
	pub safe_withdrawal: bool,
}

impl<AssetId, Balance> AssetInfo<AssetId, Balance>
where
	Balance: Default + Clone,
{
	pub fn new(
		asset_id: AssetId,
		before_state: &AssetReserveState<Balance>,
		after_state: &AssetReserveState<Balance>,
		delta_changes: &AssetStateChange<Balance>,
		safe_withdrawal: bool,
	) -> Self {
		Self {
			asset_id,
			before: (*before_state).clone(),
			after: (*after_state).clone(),
			delta_changes: (*delta_changes).clone(),
			safe_withdrawal,
		}
	}
}

pub trait OmnipoolHooks<Origin, AccountId, AssetId, Balance>
where
	Balance: Default + Clone,
{
	type Error;
	fn on_liquidity_changed(origin: Origin, asset: AssetInfo<AssetId, Balance>) -> Result<Weight, Self::Error>;
	fn on_trade(
		origin: Origin,
		asset_in: AssetInfo<AssetId, Balance>,
		asset_out: AssetInfo<AssetId, Balance>,
	) -> Result<Weight, Self::Error>;

	fn on_hub_asset_trade(origin: Origin, asset: AssetInfo<AssetId, Balance>) -> Result<Weight, Self::Error>;

	fn on_liquidity_changed_weight() -> Weight;
	fn on_trade_weight() -> Weight;

	/// Returns used amount
	fn on_trade_fee(
		fee_account: AccountId,
		trader: AccountId,
		asset: AssetId,
		amount: Balance,
	) -> Result<Balance, Self::Error>;
}

// Default implementation for no-op hooks.
impl<Origin, AccountId, AssetId, Balance> OmnipoolHooks<Origin, AccountId, AssetId, Balance> for ()
where
	Balance: Default + Clone + Zero,
{
	type Error = DispatchError;

	fn on_liquidity_changed(_: Origin, _: AssetInfo<AssetId, Balance>) -> Result<Weight, Self::Error> {
		Ok(Weight::zero())
	}

	fn on_trade(
		_: Origin,
		_: AssetInfo<AssetId, Balance>,
		_: AssetInfo<AssetId, Balance>,
	) -> Result<Weight, Self::Error> {
		Ok(Weight::zero())
	}

	fn on_hub_asset_trade(_: Origin, _: AssetInfo<AssetId, Balance>) -> Result<Weight, Self::Error> {
		Ok(Weight::zero())
	}

	fn on_liquidity_changed_weight() -> Weight {
		Weight::zero()
	}

	fn on_trade_weight() -> Weight {
		Weight::zero()
	}

	fn on_trade_fee(
		_fee_account: AccountId,
		_trader: AccountId,
		_asset: AssetId,
		_amount: Balance,
	) -> Result<Balance, Self::Error> {
		Ok(Balance::zero())
	}
}

pub trait ExternalPriceProvider<AssetId, Price> {
	type Error;
	fn get_price(asset_a: AssetId, asset_b: AssetId) -> Result<Price, Self::Error>;

	fn get_price_weight() -> Weight;
}

#[allow(clippy::result_unit_err)]
pub trait ShouldAllow<AccountId, AssetId, Price> {
	fn ensure_price(who: &AccountId, asset_a: AssetId, asset_b: AssetId, current_price: Price) -> Result<(), ()>;
}

#[impl_trait_for_tuples::impl_for_tuples(5)]
impl<AccountId, AssetId, Price> ShouldAllow<AccountId, AssetId, Price> for Tuple
where
	AccountId: Debug,
	AssetId: Debug + Copy,
	Price: Debug + Copy,
{
	fn ensure_price(who: &AccountId, asset_a: AssetId, asset_b: AssetId, current_price: Price) -> Result<(), ()> {
		for_tuples!( #(
			match Tuple::ensure_price(who, asset_a, asset_b, current_price) {
				Ok(()) => (),
				Err(_) => {
					log::trace!(
						target: "omnipool::should_allow_price_change",
						"did not pass the price check: who: {:?}, asset_a: {:?}, asset_b: {:?}, current_prie: {:?}",
						who,
						asset_a,
						asset_b,
						current_price,
					);
					return Err(());
				},
			}
		)* );

		Ok(())
	}
}

/// Ensures that the price is within the bounds of the current spot price and the external oracle price.
pub struct EnsurePriceWithin<AccountId, AssetId, ExternalOracle, MaxAllowed, WhitelistedAccounts>(
	sp_std::marker::PhantomData<(AccountId, AssetId, ExternalOracle, MaxAllowed, WhitelistedAccounts)>,
);

impl<AccountId, AssetId, ExternalOracle, MaxAllowed, WhitelistedAccounts> ShouldAllow<AccountId, AssetId, EmaPrice>
	for EnsurePriceWithin<AccountId, AssetId, ExternalOracle, MaxAllowed, WhitelistedAccounts>
where
	ExternalOracle: ExternalPriceProvider<AssetId, EmaPrice>,
	MaxAllowed: Get<Permill>,
	WhitelistedAccounts: Contains<AccountId>,
{
	fn ensure_price(who: &AccountId, asset_a: AssetId, asset_b: AssetId, current_price: EmaPrice) -> Result<(), ()> {
		if WhitelistedAccounts::contains(who) {
			return Ok(());
		}

		let max_allowed = FixedU128::from(MaxAllowed::get());

		let oracle_price = ExternalOracle::get_price(asset_a, asset_b).map_err(|_| ())?;
		let external_price = FixedU128::checked_from_rational(oracle_price.n, oracle_price.d).ok_or(())?;
		let current_spot_price = FixedU128::checked_from_rational(current_price.n, current_price.d).ok_or(())?;

		let max_allowed_difference = max_allowed
			.checked_mul(&current_spot_price.checked_add(&external_price).ok_or(())?)
			.ok_or(())?;

		let diff = if current_spot_price >= external_price {
			current_spot_price.saturating_sub(external_price)
		} else {
			external_price.saturating_sub(current_spot_price)
		};

		ensure!(
			diff.checked_mul(&FixedU128::from(2)).ok_or(())? <= max_allowed_difference,
			()
		);
		Ok(())
	}
}

File: ./pallets/omnipool/src/router_execution.rs
use crate::types::Balance;
use crate::{Config, Error, HubAssetImbalance, Pallet};
use frame_system::pallet_prelude::OriginFor;
use hydra_dx_math::omnipool::types::I129;

use hydradx_traits::router::{ExecutorError, PoolType, TradeExecution};
use orml_traits::{GetByKey, MultiCurrency};
use sp_runtime::traits::Get;
use sp_runtime::DispatchError::Corruption;
use sp_runtime::{ArithmeticError, DispatchError, FixedPointNumber, FixedU128};

// dev note: The code is calculate sell and buy is copied from the corresponding functions.
// This is not ideal and should be refactored to avoid code duplication.
impl<T: Config> TradeExecution<OriginFor<T>, T::AccountId, T::AssetId, Balance> for Pallet<T> {
	type Error = DispatchError;

	fn calculate_sell(
		pool_type: PoolType<T::AssetId>,
		asset_in: T::AssetId,
		asset_out: T::AssetId,
		amount_in: Balance,
	) -> Result<Balance, ExecutorError<Self::Error>> {
		if pool_type != PoolType::Omnipool {
			return Err(ExecutorError::NotSupported);
		}

		if asset_out == T::HubAssetId::get() {
			return Err(ExecutorError::Error(Error::<T>::NotAllowed.into()));
		}

		let asset_out_state = Self::load_asset_state(asset_out).map_err(ExecutorError::Error)?;
		let current_imbalance = <HubAssetImbalance<T>>::get();

		if asset_in == T::HubAssetId::get() {
			let current_hub_asset_liquidity =
				T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

			let (asset_fee, _) = T::Fee::get(&asset_out);

			let state_changes = hydra_dx_math::omnipool::calculate_sell_hub_state_changes(
				&(&asset_out_state).into(),
				amount_in,
				asset_fee,
				I129 {
					value: current_imbalance.value,
					negative: current_imbalance.negative,
				},
				current_hub_asset_liquidity,
			)
			.ok_or_else(|| ExecutorError::Error(ArithmeticError::Overflow.into()))?;

			return Ok(*state_changes.asset.delta_reserve);
		}

		let (asset_fee, _) = T::Fee::get(&asset_out);
		let (_, protocol_fee) = T::Fee::get(&asset_in);

		let asset_in_state = Self::load_asset_state(asset_in).map_err(ExecutorError::Error)?;
		let state_changes = hydra_dx_math::omnipool::calculate_sell_state_changes(
			&(&asset_in_state).into(),
			&(&asset_out_state).into(),
			amount_in,
			asset_fee,
			protocol_fee,
			current_imbalance.value,
		)
		.ok_or_else(|| ExecutorError::Error(ArithmeticError::Overflow.into()))?;

		Ok(*state_changes.asset_out.delta_reserve)
	}

	fn calculate_buy(
		pool_type: PoolType<T::AssetId>,
		asset_in: T::AssetId,
		asset_out: T::AssetId,
		amount_out: Balance,
	) -> Result<Balance, ExecutorError<Self::Error>> {
		if pool_type != PoolType::Omnipool {
			return Err(ExecutorError::NotSupported);
		}
		// Special handling when one of the asset is Hub Asset
		if asset_out == T::HubAssetId::get() {
			return Err(ExecutorError::Error(Error::<T>::NotAllowed.into()));
		}
		let asset_out_state = Self::load_asset_state(asset_out).map_err(ExecutorError::Error)?;
		let current_imbalance = <HubAssetImbalance<T>>::get();

		if asset_in == T::HubAssetId::get() {
			let current_hub_asset_liquidity =
				T::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());

			let (asset_fee, _) = T::Fee::get(&asset_out);

			let state_changes = hydra_dx_math::omnipool::calculate_buy_for_hub_asset_state_changes(
				&(&asset_out_state).into(),
				amount_out,
				asset_fee,
				I129 {
					value: current_imbalance.value,
					negative: current_imbalance.negative,
				},
				current_hub_asset_liquidity,
			)
			.ok_or_else(|| ExecutorError::Error(ArithmeticError::Overflow.into()))?;

			return Ok(*state_changes.asset.delta_hub_reserve);
		}

		let asset_in_state = Self::load_asset_state(asset_in).map_err(ExecutorError::Error)?;

		let (asset_fee, _) = T::Fee::get(&asset_out);
		let (_, protocol_fee) = T::Fee::get(&asset_in);

		let state_changes = hydra_dx_math::omnipool::calculate_buy_state_changes(
			&(&asset_in_state).into(),
			&(&asset_out_state).into(),
			amount_out,
			asset_fee,
			protocol_fee,
			current_imbalance.value,
		)
		.ok_or_else(|| ExecutorError::Error(ArithmeticError::Overflow.into()))?;

		Ok(*state_changes.asset_in.delta_reserve)
	}

	fn execute_sell(
		who: OriginFor<T>,
		pool_type: PoolType<T::AssetId>,
		asset_in: T::AssetId,
		asset_out: T::AssetId,
		amount_in: Balance,
		min_limit: Balance,
	) -> Result<(), ExecutorError<Self::Error>> {
		if pool_type != PoolType::Omnipool {
			return Err(ExecutorError::NotSupported);
		}

		Self::sell(who, asset_in, asset_out, amount_in, min_limit).map_err(ExecutorError::Error)
	}

	fn execute_buy(
		who: OriginFor<T>,
		pool_type: PoolType<T::AssetId>,
		asset_in: T::AssetId,
		asset_out: T::AssetId,
		amount_out: Balance,
		max_limit: Balance,
	) -> Result<(), ExecutorError<Self::Error>> {
		if pool_type != PoolType::Omnipool {
			return Err(ExecutorError::NotSupported);
		}

		Self::buy(who, asset_out, asset_in, amount_out, max_limit).map_err(ExecutorError::Error)
	}

	fn get_liquidity_depth(
		pool_type: PoolType<T::AssetId>,
		asset_a: T::AssetId,
		_asset_b: T::AssetId,
	) -> Result<Balance, ExecutorError<Self::Error>> {
		if pool_type != PoolType::Omnipool {
			return Err(ExecutorError::NotSupported);
		}

		let asset_state = Self::load_asset_state(asset_a).map_err(ExecutorError::Error)?;

		Ok(asset_state.reserve)
	}

	fn calculate_spot_price_with_fee(
		pool_type: PoolType<T::AssetId>,
		asset_a: T::AssetId,
		asset_b: T::AssetId,
	) -> Result<FixedU128, ExecutorError<Self::Error>> {
		if pool_type != PoolType::Omnipool {
			return Err(ExecutorError::NotSupported);
		}

		if asset_b == T::HubAssetId::get() {
			return Err(ExecutorError::Error(Error::<T>::NotAllowed.into()));
		}

		let (_, protocol_fee) = T::Fee::get(&asset_a);
		let (asset_fee, _) = T::Fee::get(&asset_b);

		let spot_price = if asset_a == T::HubAssetId::get() {
			let asset_b_state = Self::load_asset_state(asset_b).map_err(ExecutorError::Error)?;

			hydra_dx_math::omnipool::calculate_lrna_spot_price(&asset_b_state.into(), Some(asset_fee))
				.ok_or(ExecutorError::Error(Corruption))?
				.reciprocal()
				.ok_or(ExecutorError::Error(Corruption))?
		} else {
			let asset_a_state = Self::load_asset_state(asset_a).map_err(ExecutorError::Error)?;
			let asset_b_state = Self::load_asset_state(asset_b).map_err(ExecutorError::Error)?;

			hydra_dx_math::omnipool::calculate_spot_price(
				&asset_a_state.into(),
				&asset_b_state.into(),
				Some((protocol_fee, asset_fee)),
			)
			.ok_or(ExecutorError::Error(Corruption))?
			.reciprocal()
			.ok_or(ExecutorError::Error(Corruption))?
		};

		Ok(spot_price)
	}
}

File: ./pallets/omnipool/src/tests/add_token.rs
use super::*;
use frame_support::assert_noop;

#[test]
fn add_token_works() {
	ExtBuilder::default()
		.with_registered_asset(1000)
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), 1_000, 2000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			let token_price = FixedU128::from_float(0.65);

			let token_amount = 2000 * ONE;

			assert_ok!(Omnipool::add_token(
				RuntimeOrigin::root(),
				1_000,
				token_price,
				Permill::from_percent(100),
				LP1
			));

			assert_pool_state!(11_800 * ONE, 23_600 * ONE, SimpleImbalance::default());

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount,
					hub_reserve: 1300 * ONE,
					shares: token_amount,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			)
		});
}

#[test]
fn add_non_registered_asset_fails() {
	ExtBuilder::default()
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					2_000,
					FixedU128::from_float(0.5),
					Permill::from_percent(100),
					LP1
				),
				Error::<Test>::AssetNotRegistered
			);
		});
}

#[test]
fn add_asset_without_ed_fails() {
	ExtBuilder::default()
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					ASSET_WITHOUT_ED,
					FixedU128::from_float(0.5),
					Permill::from_percent(100),
					LP1
				),
				Error::<Test>::ExistentialDepositNotAvailable
			);
		});
}

#[test]
fn add_token_with_zero_price_fails() {
	ExtBuilder::default()
		.with_registered_asset(1000)
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			let token_price = FixedU128::from(0);

			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					1_000,
					token_price,
					Permill::from_percent(100),
					LP1
				),
				Error::<Test>::InvalidInitialAssetPrice
			);
		});
}

#[test]
fn cannot_add_existing_asset() {
	ExtBuilder::default()
		.with_registered_asset(1000)
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1000, FixedU128::from_float(0.5), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					1_000,
					FixedU128::from_float(0.5),
					Permill::from_percent(100),
					LP1
				),
				Error::<Test>::AssetAlreadyAdded
			);
			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					DAI,
					FixedU128::from_float(0.5),
					Permill::from_percent(100),
					LP1
				),
				Error::<Test>::AssetAlreadyAdded
			);
			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					HDX,
					FixedU128::from_float(0.5),
					Permill::from_percent(100),
					LP1
				),
				Error::<Test>::AssetAlreadyAdded
			);
		});
}

#[test]
fn add_token_with_insufficient_balance_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP3, 1_000, 100 * ONE))
		.with_registered_asset(1000)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_token(
					RuntimeOrigin::root(),
					1_000,
					FixedU128::from_float(0.6),
					Permill::from_percent(100),
					LP3
				),
				Error::<Test>::MissingBalance
			);
		});
}

#[test]
fn update_weight_cap_of_native_stable_asset_should_work_when_pool_is_initialized() {
	ExtBuilder::default()
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_weight_cap(
				RuntimeOrigin::root(),
				HDX,
				Permill::from_rational(1u32, 100000u32),
			));
			assert_asset_state!(
				HDX,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: 10_000_000_000_000,
					tradable: Tradability::default(),
				}
			);
			assert_ok!(Omnipool::set_asset_weight_cap(
				RuntimeOrigin::root(),
				DAI,
				Permill::from_percent(2u32),
			));
			assert_asset_state!(
				DAI,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: 20_000_000_000_000_000,
					tradable: Tradability::default(),
				}
			);
		});
}

File: ./pallets/omnipool/src/tests/positions.rs
use super::*;
use frame_support::assert_noop;
use pretty_assertions::assert_eq;

#[test]
fn sacrifice_position_should_work_when_position_exists_with_correct_owner() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((LP2, asset_id, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			// Arrange - create a position
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, 400 * ONE));

			let lp1_asset_balance = Tokens::free_balance(asset_id, &LP1);

			// Act
			assert_ok!(Omnipool::sacrifice_position(RuntimeOrigin::signed(LP1), position_id));

			// Assert
			// - shares becomes protocol owned shares
			// - position is destroyed
			// - nft is burned
			// - LP does not receives anything
			assert_asset_state!(
				asset_id,
				AssetReserveState {
					reserve: 2400 * ONE,
					hub_reserve: 1560 * ONE,
					shares: 2400 * ONE,
					protocol_shares: 400 * ONE,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_eq!(Positions::<Test>::get(position_id), None);

			assert_eq!(lp1_asset_balance, Tokens::free_balance(asset_id, &LP1));

			assert_eq!(POSITIONS.with(|v| v.borrow().get(&position_id).copied()), None);
		});
}

#[test]
fn sacrifice_position_should_fail_when_caller_is_not_position_owner() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((LP2, asset_id, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			// Arrange - create a position
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, 400 * ONE));

			// Act
			assert_noop!(
				Omnipool::sacrifice_position(RuntimeOrigin::signed(LP2), position_id),
				Error::<Test>::Forbidden
			);
		});
}

#[test]
fn sacrifice_position_should_fail_when_position_does_not_exist() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((LP2, asset_id, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			// Arrange - create a position
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, 400 * ONE));

			// Act
			assert_noop!(
				Omnipool::sacrifice_position(RuntimeOrigin::signed(LP1), position_id + 1),
				Error::<Test>::PositionNotFound
			);
		});
}

#[test]
fn sacrifice_position_should_emit_event_when_succesful() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((LP2, asset_id, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			System::set_block_number(1);
			// Arrange - create a position
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, 400 * ONE));

			// Act
			assert_ok!(Omnipool::sacrifice_position(RuntimeOrigin::signed(LP1), position_id));

			// Assert
			frame_system::Pallet::<Test>::assert_last_event(
				crate::Event::PositionDestroyed {
					position_id,
					owner: LP1,
				}
				.into(),
			);
		});
}

File: ./pallets/omnipool/src/tests/types.rs
use crate::{SimpleImbalance, Tradability};

#[test]
fn tradability_should_allow_all_when_default() {
	let default_tradability = Tradability::default();

	assert!(default_tradability.contains(Tradability::BUY));
	assert!(default_tradability.contains(Tradability::SELL));
	assert!(default_tradability.contains(Tradability::ADD_LIQUIDITY));
	assert!(default_tradability.contains(Tradability::REMOVE_LIQUIDITY));
}

#[test]
fn simple_imbalance_addition_works() {
	assert_eq!(
		SimpleImbalance {
			value: 100,
			negative: false
		} + 200,
		Some(SimpleImbalance {
			value: 300,
			negative: false
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 100,
			negative: true
		} + 200,
		Some(SimpleImbalance {
			value: 100,
			negative: false
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 500,
			negative: true
		} + 200,
		Some(SimpleImbalance {
			value: 300,
			negative: true
		})
	);

	assert_eq!(
		SimpleImbalance {
			value: 500,
			negative: true
		} + 500,
		Some(SimpleImbalance {
			value: 0,
			negative: true
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 0,
			negative: true
		} + 500,
		Some(SimpleImbalance {
			value: 500,
			negative: false
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 0,
			negative: false
		} + 500,
		Some(SimpleImbalance {
			value: 500,
			negative: false
		})
	);

	assert_eq!(
		SimpleImbalance {
			value: 1u128,
			negative: true
		} + u128::MAX,
		Some(SimpleImbalance {
			value: u128::MAX - 1,
			negative: false
		})
	);

	assert_eq!(
		SimpleImbalance {
			value: u128::MAX,
			negative: false
		} + 1,
		None
	);
	assert_eq!(
		SimpleImbalance {
			value: 1u128,
			negative: false
		} + u128::MAX,
		None
	);
}

#[test]
fn simple_imbalance_subtraction_works() {
	assert_eq!(
		SimpleImbalance {
			value: 200,
			negative: false
		} - 300,
		Some(SimpleImbalance {
			value: 100,
			negative: true
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 200,
			negative: true
		} - 300,
		Some(SimpleImbalance {
			value: 500,
			negative: true
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 300,
			negative: false
		} - 300,
		Some(SimpleImbalance {
			value: 0,
			negative: true,
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 0,
			negative: false
		} - 300,
		Some(SimpleImbalance {
			value: 300,
			negative: true
		})
	);
	assert_eq!(
		SimpleImbalance {
			value: 0,
			negative: true
		} - 300,
		Some(SimpleImbalance {
			value: 300,
			negative: true
		})
	);

	assert_eq!(
		SimpleImbalance {
			value: 1u128,
			negative: false
		} - u128::MAX,
		Some(SimpleImbalance {
			value: u128::MAX - 1,
			negative: true
		})
	);

	assert_eq!(
		SimpleImbalance {
			value: u128::MAX,
			negative: true
		} - 1,
		None
	);
	assert_eq!(
		SimpleImbalance {
			value: 1u128,
			negative: true
		} - u128::MAX,
		None
	);
}

File: ./pallets/omnipool/src/tests/barrier.rs
use crate::traits::{EnsurePriceWithin, ExternalPriceProvider, ShouldAllow};
use frame_support::weights::Weight;
use frame_support::{assert_err, assert_ok, parameter_types};
use hydra_dx_math::ema::EmaPrice;
use sp_runtime::Permill;
use std::cell::RefCell;

thread_local! {
	pub static EXTERNAL_PRICE: RefCell<EmaPrice> = RefCell::new(EmaPrice::default());
}

struct SinglePriceProvider;

impl ExternalPriceProvider<u32, EmaPrice> for SinglePriceProvider {
	type Error = ();

	fn get_price(_asset_a: u32, _asset_b: u32) -> Result<EmaPrice, Self::Error> {
		Ok(EXTERNAL_PRICE.with(|v| *v.borrow()))
	}

	fn get_price_weight() -> Weight {
		todo!()
	}
}

parameter_types! {
	pub const MaxAllowed: Permill = Permill::from_percent(1);
}

#[test]
fn ensure_price_should_be_ok_when_price_is_within_allowed_difference() {
	EXTERNAL_PRICE.with(|v| *v.borrow_mut() = EmaPrice::new(1, 10));
	let spot_price = EmaPrice::new(999, 10000);
	assert_ok!(EnsurePriceWithin::<u64, u32, SinglePriceProvider, MaxAllowed, ()>::ensure_price(&0, 1, 2, spot_price));

	let spot_price = EmaPrice::new(101, 1000);
	assert_ok!(EnsurePriceWithin::<u64, u32, SinglePriceProvider, MaxAllowed, ()>::ensure_price(&0, 1, 2, spot_price));
}

#[test]
fn ensure_price_should_fail_when_price_is_not_within_allowed_difference() {
	EXTERNAL_PRICE.with(|v| *v.borrow_mut() = EmaPrice::new(1, 10));
	let spot_price = EmaPrice::new(8, 1000);
	assert_err!(
		EnsurePriceWithin::<u64, u32, SinglePriceProvider, MaxAllowed, ()>::ensure_price(&0, 1, 2, spot_price),
		()
	);

	let spot_price = EmaPrice::new(2, 10);
	assert_err!(
		EnsurePriceWithin::<u64, u32, SinglePriceProvider, MaxAllowed, ()>::ensure_price(&0, 1, 2, spot_price),
		()
	);
}

File: ./pallets/omnipool/src/tests/remove_token.rs
use super::*;
use crate::types::Tradability;
use frame_support::assert_noop;
use sp_runtime::DispatchError::BadOrigin;

#[test]
fn remove_token_should_fail_when_not_root() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			assert_noop!(Omnipool::remove_token(RuntimeOrigin::signed(LP1), 1000, LP1), BadOrigin,);
		});
}

#[test]
fn remove_token_should_fail_when_asset_is_not_frozen() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			assert_noop!(
				Omnipool::remove_token(RuntimeOrigin::root(), 1000, LP1),
				Error::<Test>::AssetNotFrozen
			);
		});
}

#[test]
fn remove_token_should_fail_when_lp_shares_remaining() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::FROZEN
			));
			assert_noop!(
				Omnipool::remove_token(RuntimeOrigin::root(), 1000, LP1),
				Error::<Test>::SharesRemaining
			);
		});
}

#[test]
fn remove_token_should_remove_asset_from_omnipool() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::FROZEN
			));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP2),
				current_position_id - 1,
			));
			assert_ok!(Omnipool::remove_token(RuntimeOrigin::root(), 1000, LP1),);

			assert!(Assets::<Test>::get(1000).is_none());
		});
}

#[test]
fn remove_token_should_transfer_remaining_asset_to_beneficiary_account() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::FROZEN
			));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP2),
				current_position_id - 1,
			));
			let reserve = Tokens::free_balance(1000, &Omnipool::protocol_account());
			assert_ok!(Omnipool::remove_token(RuntimeOrigin::root(), 1000, 1234),);
			assert_balance!(1234, 1_000, reserve);
			assert_balance!(Omnipool::protocol_account(), 1_000, 0);
			assert_balance!(1234, LRNA, 0);
		});
}

#[test]
fn remove_token_should_burn_hub_asset() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::FROZEN
			));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP2),
				current_position_id - 1,
			));
			let state = Assets::<Test>::get(1000).unwrap();
			let lrna_reserve = Tokens::free_balance(LRNA, &Omnipool::protocol_account());
			let lrna_issuance = Tokens::total_issuance(LRNA);
			assert_ok!(Omnipool::remove_token(RuntimeOrigin::root(), 1000, 1234),);
			let lrna_issuance_after = Tokens::total_issuance(LRNA);
			assert_balance!(Omnipool::protocol_account(), LRNA, lrna_reserve - state.hub_reserve);
			assert_eq!(lrna_issuance_after, lrna_issuance - state.hub_reserve);
		});
}

File: ./pallets/omnipool/src/tests/imbalance.rs
use super::*;
use pretty_assertions::assert_eq;
use sp_runtime::Permill;

#[test]
fn imbalance_should_update_correctly() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_protocol_fee(Permill::from_percent(1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_pool_state!(
				13360000000000000,
				26720000000000000,
				SimpleImbalance {
					value: 0,
					negative: true
				}
			);

			let old_imbalance = HubAssetImbalance::<Test>::get();
			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				1,
				200,
				50000000000000,
				10000000000000
			));

			let updated_imbalance = HubAssetImbalance::<Test>::get();

			// After lrna is sold to pool, imbalance should increase (more negative)
			assert!(updated_imbalance.value > old_imbalance.value);

			let q = Tokens::free_balance(LRNA, &Omnipool::protocol_account());
			let old_imbalance = HubAssetImbalance::<Test>::get();
			assert_ok!(Omnipool::sell(RuntimeOrigin::signed(LP3), 200, 100, 1000000000000, 1,));
			let updated_imbalance = HubAssetImbalance::<Test>::get();
			let q_plus = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

			// After non-lrna trade - sell, imbalance should decrease ( less negative )
			assert!(updated_imbalance.value < old_imbalance.value);
			assert_eq!(
				q.checked_sub(old_imbalance.value).unwrap(),
				q_plus.checked_sub(updated_imbalance.value).unwrap()
			);

			let position_id = <NextPositionId<Test>>::get();
			let old_imbalance = HubAssetImbalance::<Test>::get();
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));
			let updated_imbalance = HubAssetImbalance::<Test>::get();

			// After add additional liquidity , imbalance should increase ( more negative )
			assert!(updated_imbalance.value > old_imbalance.value);

			let position = Positions::<Test>::get(position_id).unwrap();
			let old_imbalance = HubAssetImbalance::<Test>::get();
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP2),
				position_id,
				position.shares
			));
			let updated_imbalance = HubAssetImbalance::<Test>::get();

			// After remove additional liquidity , imbalance should decrease( less negative )
			assert!(updated_imbalance.value < old_imbalance.value);

			let q = Tokens::free_balance(LRNA, &Omnipool::protocol_account());
			let old_imbalance = HubAssetImbalance::<Test>::get();
			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				1000000000000,
				u128::MAX,
			));
			let updated_imbalance = HubAssetImbalance::<Test>::get();
			let q_plus = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

			// After non-lrna trade - buy, imbalance should decrease ( less negative )
			assert!(updated_imbalance.value < old_imbalance.value);
			assert_eq!(
				q.checked_sub(old_imbalance.value).unwrap(),
				q_plus.checked_sub(updated_imbalance.value).unwrap()
			);
		});
}

#[test]
fn imbalance_should_approach_zero_when_enough_trades_are_executed() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_protocol_fee(Permill::from_percent(10))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_pool_state!(
				13360000000000000,
				26720000000000000,
				SimpleImbalance {
					value: 0,
					negative: true
				}
			);
			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				1,
				200,
				50000000000000,
				10000000000000
			));

			loop {
				let old_imbalance = HubAssetImbalance::<Test>::get();

				assert_ok!(Omnipool::buy(
					RuntimeOrigin::signed(LP3),
					200,
					100,
					1000000000000,
					u128::MAX,
				));
				assert_ok!(Omnipool::sell(
					RuntimeOrigin::signed(LP3),
					200,
					100,
					1000000000000,
					0u128,
				));

				let updated_imbalance = HubAssetImbalance::<Test>::get();

				assert!(updated_imbalance.value <= old_imbalance.value);

				if updated_imbalance.value.is_zero() {
					break;
				}
			}

			// Operations should work correctly after that

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				1000000000000,
				u128::MAX,
			));
			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				1000000000000,
				0u128,
			));
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));
			let position = Positions::<Test>::get(position_id).unwrap();
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP2),
				position_id,
				position.shares
			));

			assert_eq!(HubAssetImbalance::<Test>::get(), SimpleImbalance::default());
		});
}

File: ./pallets/omnipool/src/tests/refund.rs
use super::*;
use frame_support::assert_noop;
use pretty_assertions::assert_eq;

#[test]
fn refund_refused_asset_should_work_when_asset_not_in_pool() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), asset_id, 1000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			let lp1_asset_balance = Tokens::free_balance(asset_id, &LP1);
			let pool_asset_balance = Tokens::free_balance(asset_id, &Omnipool::protocol_account());

			// Act
			assert_ok!(Omnipool::refund_refused_asset(
				RuntimeOrigin::root(),
				asset_id,
				1000 * ONE,
				LP1
			));

			// Assert
			assert_eq!(Tokens::free_balance(asset_id, &LP1), lp1_asset_balance + 1000 * ONE);
			assert_eq!(
				Tokens::free_balance(asset_id, &Omnipool::protocol_account()),
				pool_asset_balance - 1000 * ONE
			);
		});
}

#[test]
fn refund_refused_asset_should_work_when_refund_partial_amount() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), asset_id, 1000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			let lp1_asset_balance = Tokens::free_balance(asset_id, &LP1);
			let pool_asset_balance = Tokens::free_balance(asset_id, &Omnipool::protocol_account());

			// Act
			assert_ok!(Omnipool::refund_refused_asset(
				RuntimeOrigin::root(),
				asset_id,
				500 * ONE,
				LP1
			));

			// Assert
			assert_eq!(Tokens::free_balance(asset_id, &LP1), lp1_asset_balance + 500 * ONE);
			assert_eq!(
				Tokens::free_balance(asset_id, &Omnipool::protocol_account()),
				pool_asset_balance - 500 * ONE
			);
		});
}

#[test]
fn refund_refused_asset_should_fail_when_refund_asset_in_pool() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), asset_id, 1000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP1, 1000 * ONE)
		.build()
		.execute_with(|| {
			// Act
			assert_noop!(
				Omnipool::refund_refused_asset(RuntimeOrigin::root(), asset_id, 1000 * ONE, LP1),
				Error::<Test>::AssetAlreadyAdded
			);
		});
}

#[test]
fn refund_refused_asset_should_fail_when_refund_more_than_in_pool_account() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), asset_id, 1000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			// Act
			assert_noop!(
				Omnipool::refund_refused_asset(RuntimeOrigin::root(), asset_id, 2000 * ONE, LP1),
				Error::<Test>::InsufficientBalance
			);
		});
}

#[test]
fn refund_refused_asset_should_emit_correct_event_when_succesful() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), asset_id, 1000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			System::set_block_number(1);

			// Act
			assert_ok!(Omnipool::refund_refused_asset(
				RuntimeOrigin::root(),
				asset_id,
				1000 * ONE,
				LP1
			));

			// Assert
			frame_system::Pallet::<Test>::assert_last_event(
				crate::Event::AssetRefunded {
					asset_id,
					amount: 1000 * ONE,
					recipient: LP1,
				}
				.into(),
			);
		});
}

#[test]
fn refund_refused_asset_should_fail_when_refund_asset_is_hub_asset() {
	let asset_id: AssetId = 1_000;

	ExtBuilder::default()
		.add_endowed_accounts((LP1, asset_id, 5000 * ONE))
		.add_endowed_accounts((Omnipool::protocol_account(), asset_id, 1000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP1, 1000 * ONE)
		.build()
		.execute_with(|| {
			// Act
			assert_noop!(
				Omnipool::refund_refused_asset(RuntimeOrigin::root(), LRNA, 1000 * ONE, LP1),
				Error::<Test>::AssetRefundNotAllowed
			);
		});
}

File: ./pallets/omnipool/src/tests/remove_liquidity_with_limit.rs
use super::*;
use crate::types::Tradability;
use frame_support::assert_noop;
use orml_traits::MultiCurrencyExtended;
use sp_runtime::traits::One;
use sp_runtime::DispatchError::BadOrigin;

#[test]
fn remove_liquidity_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;

			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let liq_removed = 200 * ONE;
			assert_ok!(Omnipool::remove_liquidity_with_limit(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed,
				liq_removed
			));

			assert_pool_state!(11_930 * ONE, 23_860_000_000_000_000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4600 * ONE + liq_removed);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added - liq_removed,
					hub_reserve: 1430000000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn full_liquidity_removal_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;

			let liq_added = 400 * ONE;
			let lp1_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert!(
				get_mock_minted_position(lp1_position_id).is_some(),
				"Position instance was not minted"
			);

			let liq_removed = 400 * ONE;

			assert_ok!(Omnipool::remove_liquidity_with_limit(
				RuntimeOrigin::signed(LP1),
				lp1_position_id,
				liq_removed,
				liq_removed
			));

			assert!(
				Positions::<Test>::get(lp1_position_id).is_none(),
				"Position still found"
			);

			assert_pool_state!(11_800 * ONE, 23_600_000_000_000_000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 5000 * ONE);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added - liq_removed,
					hub_reserve: 1300000000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert!(
				get_mock_minted_position(lp1_position_id).is_none(),
				"Position instance was not burned"
			);
		});
}

#[test]
fn partial_liquidity_removal_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert!(
				get_mock_minted_position(current_position_id).is_some(),
				"Position instance was not minted"
			);

			let liq_removed = 200 * ONE;

			assert_ok!(Omnipool::remove_liquidity_with_limit(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed,
				liq_removed
			));

			assert!(
				Positions::<Test>::get(current_position_id).is_some(),
				"Position has been removed incorrectly"
			);

			assert_pool_state!(11_930 * ONE, 23_860_000_000_000_000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4800 * ONE);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added - liq_removed,
					hub_reserve: 1430000000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert!(
				get_mock_minted_position(current_position_id).is_some(),
				"Position instance was burned"
			);
			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn lp_receives_lrna_when_price_is_higher() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, 1_000, 100 * ONE),
			(LP1, 1_000, 5000 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP3, 100 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));

			assert_balance!(Omnipool::protocol_account(), 1000, 300 * ONE);
			let expected_state = AssetReserveState {
				reserve: 300 * ONE,
				hub_reserve: 541666666666667,
				shares: 500000000000000,
				protocol_shares: Balance::zero(),
				cap: DEFAULT_WEIGHT_CAP,
				tradable: Tradability::default(),
			};
			assert_asset_state!(1_000, expected_state);

			assert_ok!(Omnipool::remove_liquidity_with_limit(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_added,
				240 * ONE
			));
			assert_balance!(Omnipool::protocol_account(), 1000, 60 * ONE);
			assert_balance!(LP1, 1000, 4_840_000_000_000_000);
			assert_balance!(LP1, LRNA, 203_921_568_627_449);

			assert_pool_state!(10391666666666667, 64723183391003641, SimpleImbalance::default());
		});
}

#[test]
fn remove_liquiduity_should_burn_lrna_when_amount_is_below_ed() {
	let asset_id = 1_000;
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, asset_id, 500 * ONE),
			(LP1, asset_id, 2 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP3, 500 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 2 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				asset_id,
				DAI,
				100_000_000_000,
				500000 * ONE
			));

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_added
			));
			assert_balance!(LP1, LRNA, 0);
			let lrna_issuance = Tokens::total_issuance(LRNA);
			assert!(lrna_issuance < 10826000000025799); // this value is when lrna is transferred
		});
}

#[test]
fn remove_liquiduity_should_transfer_lrna_below_ed_when_lp_has_sufficient_lrna_amount() {
	let asset_id = 1_000;
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, asset_id, 500 * ONE),
			(LP1, asset_id, 2 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP3, 500 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 2 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				asset_id,
				DAI,
				100_000_000_000,
				500000 * ONE
			));

			Tokens::update_balance(LRNA, &LP1, ONE as i128).unwrap();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_added
			));
			assert_balance!(LP1, LRNA, 1000259041538);
			let lrna_issuance = Tokens::total_issuance(LRNA);
			assert_eq!(lrna_issuance, 10826000000025799);
		});
}

#[test]
fn protocol_shares_should_update_when_removing_asset_liquidity_after_price_change() {
	let asset_a: AssetId = 1_000;

	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, asset_a, 100 * ONE),
			(LP1, asset_a, 5000 * ONE),
			(LP2, asset_a, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_a, FixedU128::from_float(0.65), LP3, 100 * ONE)
		.build()
		.execute_with(|| {
			// Arrange
			// - init pool
			// - add asset_a with initial liquidity of 100 * ONE
			// - add more liquidity of asset a - 400 * ONE
			// - perform a sell so the price changes - adding 1000 * ONE of asset a
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_a, liq_added));

			let expected_state = AssetReserveState::<Balance> {
				reserve: 500000000000000,
				hub_reserve: 325000000000000,
				shares: 500000000000000,
				protocol_shares: 0,
				cap: DEFAULT_WEIGHT_CAP,
				tradable: Tradability::default(),
			};
			assert_asset_state!(asset_a, expected_state);

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				asset_a,
				HDX,
				100 * ONE,
				10 * ONE
			));

			// ACT
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				400 * ONE
			));

			// Assert
			// - check if balance of LP and protocol are correct
			// - check new state of asset a in the pool ( should have updated protocol shares)
			assert_balance!(Omnipool::protocol_account(), asset_a, 206557377049181);
			assert_balance!(LP1, asset_a, 4993442622950819);

			assert_pool_state!(10647404371584700, 21294808743169400, SimpleImbalance::default());

			let expected_state = AssetReserveState {
				reserve: 206557377049181,
				hub_reserve: 93237704918034,
				shares: 172131147540984,
				protocol_shares: 72131147540984,
				cap: DEFAULT_WEIGHT_CAP,
				tradable: Tradability::default(),
			};
			assert_asset_state!(asset_a, expected_state);
		});
}

#[test]
fn remove_liquidity_by_non_owner_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP3), current_position_id, 100 * ONE),
				Error::<Test>::Forbidden
			);
		});
}

#[test]
fn remove_liquidity_from_non_existing_position_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), 1_000_000, 100 * ONE),
				Error::<Test>::Forbidden
			);
		});
}

#[test]
fn remove_liquidity_cannot_exceed_position_shares() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 500 * ONE + 1),
				Error::<Test>::InsufficientShares
			);
		});
}

#[test]
fn remove_liquidity_should_fail_when_asset_is_not_allowed_to_remove() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1000,
				Tradability::BUY | Tradability::ADD_LIQUIDITY
			));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 400 * ONE),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn remove_liquidity_should_fail_when_shares_amount_is_zero() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 0u128),
				Error::<Test>::InvalidSharesAmount
			);
		});
}

#[test]
fn remove_liquidity_should_when_prices_differ_and_is_higher() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, false);
			});

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 200 * ONE,),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}
#[test]
fn remove_liquidity_should_when_prices_differ_and_is_lower() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, true);
			});

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 200 * ONE,),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}

#[test]
fn remove_liquidity_should_apply_min_fee_when_price_is_the_same() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let liq_removed = 200 * ONE;
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed
			));

			assert_pool_state!(11931300000000000, 23862600000000000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4798000000000000);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2202000000000000,
					hub_reserve: 1431300000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn remove_liquidity_should_apply_correct_fee_when_price_is_different() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.with_withdrawal_adjustment((5, 100, false))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let liq_removed = 200 * ONE;
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed
			));

			assert_pool_state!(11936190476190477, 23872380952380954, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4790476190476190);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2209523809523810,
					hub_reserve: 1436190476190477,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn safe_withdrawal_should_work_correctly_when_trading_is_disabled() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));

			let position = Positions::<Test>::get(current_position_id).unwrap();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				position.shares,
			));

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2004000000000000,
					hub_reserve: 1302600000000000,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
				}
			);

			let position = Positions::<Test>::get(current_position_id);
			assert!(position.is_none());

			assert_balance!(LP1, 1_000, 4996000000000000);
			assert_balance!(LP1, LRNA, 0);
		});
}

#[test]
fn safe_withdrawal_should_transfer_lrna() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));

			let position = Positions::<Test>::get(current_position_id).unwrap();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				position.shares,
			));

			let position = Positions::<Test>::get(current_position_id);
			assert!(position.is_none());

			assert_balance!(LP1, 1_000, 4962999999999999);
			assert_balance!(LP1, LRNA, 24371320754716);
		});
}

#[test]
fn withdraw_protocol_liquidity_should_work_correctly() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2400000000000000,
					hub_reserve: 1560000000000000,
					shares: 2400000000000000,
					protocol_shares: 400000000000000,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_ok!(Omnipool::withdraw_protocol_liquidity(
				RuntimeOrigin::root(),
				1000,
				position.shares,
				position.price,
				1234,
			));
			assert_balance!(1234, 1_000, 400 * ONE);
			assert_balance!(1234, LRNA, 0);
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2000000000000000,
					hub_reserve: 1300000000000000,
					shares: 2000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn withdraw_protocol_liquidity_should_transfer_lrna_when_price_is_different() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2400000000000000,
					hub_reserve: 1560000000000000,
					shares: 2400000000000000,
					protocol_shares: 400000000000000,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));

			assert_ok!(Omnipool::withdraw_protocol_liquidity(
				RuntimeOrigin::root(),
				1000,
				position.shares,
				position.price,
				1234,
			));

			let position = Positions::<Test>::get(current_position_id);
			assert!(position.is_none());

			assert_balance!(1234, 1_000, 366666666666666);
			assert_balance!(1234, LRNA, 24617495711835);
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 1_833_333_333_333_334,
					hub_reserve: 1418181818181819,
					shares: 2000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn withdraw_protocol_liquidity_fail_when_not_root() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			assert_noop!(
				Omnipool::withdraw_protocol_liquidity(
					RuntimeOrigin::signed(LP1),
					1000,
					position.shares,
					position.price,
					1234,
				),
				BadOrigin
			);
		});
}

#[test]
fn withdraw_protocol_liquidity_fail_when_withdrawing_more_protocol_shares() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			let state = Assets::<Test>::get(1_000).unwrap();

			assert_noop!(
				Omnipool::withdraw_protocol_liquidity(
					RuntimeOrigin::root(),
					1000,
					state.protocol_shares + 1,
					position.price,
					1234,
				),
				Error::<Test>::InsufficientShares
			);
		});
}

#[test]
fn remove_liquidity_should_skip_price_check_when_price_is_higher_and_is_safe_to_withdraw() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, false);
			});
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				200 * ONE,
			),);
		});
}

#[test]
fn remove_liquidity_should_skip_price_check_when_price_is_lower_and_is_safe_to_withdraw() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, true);
			});

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				200 * ONE,
			),);
		});
}

#[test]
fn remove_liquidity_should_fail_when_min_limit_not_reached() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, 1_000, 100 * ONE),
			(LP1, 1_000, 5000 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP3, 100 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));

			assert_noop!(
				Omnipool::remove_liquidity_with_limit(
					RuntimeOrigin::signed(LP1),
					current_position_id,
					liq_added,
					250 * ONE // user would receive 240, which is below limit
				),
				Error::<Test>::SlippageLimit
			);
		});
}

File: ./pallets/omnipool/src/tests/mod.rs
use crate::types::{Position, SimpleImbalance};
use crate::*;
use frame_support::assert_ok;
use sp_runtime::FixedU128;

mod add_liquidity;
mod add_token;
mod buy;
mod invariants;
mod remove_liquidity;
mod sell;

mod add_liquidity_with_limit;
mod barrier;
mod imbalance;
pub(crate) mod mock;
mod positions;
mod refund;
mod remove_liquidity_with_limit;
mod remove_token;
mod spot_price;
mod tradability;
mod types;
mod verification;

use crate::Balance;
use mock::*;

#[macro_export]
macro_rules! assert_eq_approx {
	( $x:expr, $y:expr, $z:expr, $r:expr) => {{
		let diff = if $x >= $y { $x - $y } else { $y - $x };
		if diff > $z {
			panic!("\n{} not equal\n left: {:?}\nright: {:?}\n", $r, $x, $y);
		}
	}};
}

#[macro_export]
macro_rules! assert_balance {
	( $x:expr, $y:expr, $z:expr) => {{
		assert_eq!(Tokens::free_balance($y, &$x), $z);
	}};
}

#[macro_export]
macro_rules! assert_balance_approx {
	( $x:expr, $y:expr, $z:expr, $l:expr) => {{
		let b = Tokens::free_balance($y, &$x);

		let diff = if $z >= b { $z - b } else { b - $z };
		if diff > $l {
			panic!("\nBalance not equal\n left: {}\nright: {}\n", b, $z);
		};
	}};
}

#[macro_export]
macro_rules! assert_hub_asset {
	( ) => {{
		let hub_reserves: Vec<Balance> = Assets::<Test>::iter().map(|v| v.1.hub_reserve).collect();
		assert_eq!(
			Tokens::free_balance(LRNA, &Omnipool::protocol_account()),
			hub_reserves.iter().sum::<Balance>(),
			"Hub liquidity incorrect\n"
		);
	}};
}

#[macro_export]
macro_rules! assert_pool_state {
	( $x:expr, $y:expr, $z:expr) => {{
		let hub_reserves: Vec<Balance> = Assets::<Test>::iter().map(|v| v.1.hub_reserve).collect();
		assert_eq!($x, hub_reserves.iter().sum::<Balance>());
		assert_eq!(
			Tokens::free_balance(LRNA, &Omnipool::protocol_account()),
			$x,
			"Hub liquidity incorrect\n"
		);
		let hub_reserve = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

		let stable_asset = <Assets<Test>>::get(DAI).unwrap();
		let stable_reserve = Tokens::free_balance(DAI, &Omnipool::protocol_account());

		let tvl =
			hydra_dx_math::omnipool::calculate_tvl(hub_reserve, (stable_reserve, stable_asset.hub_reserve)).unwrap();
		assert_eq!(tvl, $y, "Total tvl incorrect\n");
		assert_eq!(HubAssetImbalance::<Test>::get(), $z, "Imbalance incorrect\n");
	}};
}

#[macro_export]
macro_rules! assert_pool_state_approx {
	( $x:expr, $y:expr, $z:expr) => {{
		assert_eq_approx!(
			Tokens::free_balance(LRNA, &Omnipool::protocol_account()),
			$x,
			20u128,
			"Hub liquidity incorrect\n"
		);

		let hub_reserve = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

		let stable_asset = <Assets<Test>>::get(DAI).unwrap();
		let stable_reserve = Tokens::free_balance(DAI, &Omnipool::protocol_account());

		let tvl =
			hydra_dx_math::omnipool::calculate_tvl(hub_reserve, (stable_reserve, stable_asset.hub_reserve)).unwrap();
		assert_eq_approx!(tvl, $y, 20u128, "Total tvl incorrect\n");

		assert_eq!(HubAssetImbalance::<Test>::get(), $z, "Imbalance incorrect\n");
	}};
}

#[macro_export]
macro_rules! assert_asset_state {
	( $x:expr, $y:expr) => {{
		let reserve = Tokens::free_balance($x, &Omnipool::protocol_account());
		assert_eq!(reserve, $y.reserve);

		let actual = Assets::<Test>::get($x).unwrap();
		assert_eq!(actual, $y.into());
	}};
}

File: ./pallets/omnipool/src/tests/mock.rs
// This file is part of HydraDX.

// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Test environment for Assets pallet.

use crate::*;
use std::cell::RefCell;
use std::collections::HashMap;

use crate as pallet_omnipool;

use crate::traits::ExternalPriceProvider;
use frame_support::traits::{ConstU128, Everything};
use frame_support::weights::Weight;
use frame_support::{
	assert_ok, construct_runtime, parameter_types,
	traits::{ConstU32, ConstU64},
};
use frame_system::EnsureRoot;
use hydradx_traits::{registry::Inspect as InspectRegistry, AssetKind};
use orml_traits::parameter_type_with_key;
use primitive_types::{U128, U256};
use sp_core::H256;
use sp_runtime::{
	traits::{BlakeTwo256, IdentityLookup},
	BuildStorage,
};

type Block = frame_system::mocking::MockBlock<Test>;

pub type AccountId = u64;
pub type AssetId = u32;

pub const HDX: AssetId = 0;
pub const LRNA: AssetId = 1;
pub const DAI: AssetId = 2;

pub const REGISTERED_ASSET: AssetId = 1000;
pub const ASSET_WITHOUT_ED: AssetId = 1001;

pub const LP1: u64 = 1;
pub const LP2: u64 = 2;
pub const LP3: u64 = 3;

pub const ONE: Balance = 1_000_000_000_000;

pub const NATIVE_AMOUNT: Balance = 10_000 * ONE;

pub const DEFAULT_WEIGHT_CAP: u128 = 1_000_000_000_000_000_000;

thread_local! {
	pub static POSITIONS: RefCell<HashMap<u32, u64>> = RefCell::new(HashMap::default());
	pub static REGISTERED_ASSETS: RefCell<HashMap<AssetId, u32>> = RefCell::new(HashMap::default());
	pub static ASSET_WEIGHT_CAP: RefCell<Permill> = const { RefCell::new(Permill::from_percent(100)) };
	pub static ASSET_FEE: RefCell<Permill> = const { RefCell::new(Permill::from_percent(0)) };
	pub static PROTOCOL_FEE: RefCell<Permill> = const { RefCell::new(Permill::from_percent(0)) };
	pub static MIN_ADDED_LIQUDIITY: RefCell<Balance> = const { RefCell::new(1000u128) };
	pub static MIN_TRADE_AMOUNT: RefCell<Balance> = const { RefCell::new(1000u128) };
	pub static MAX_IN_RATIO: RefCell<Balance> = const { RefCell::new(1u128) };
	pub static MAX_OUT_RATIO: RefCell<Balance> = const { RefCell::new(1u128) };
	pub static MAX_PRICE_DIFF: RefCell<Permill> = const { RefCell::new(Permill::from_percent(0)) };
	pub static EXT_PRICE_ADJUSTMENT: RefCell<(u32,u32, bool)> = const { RefCell::new((0u32,0u32, false)) };
	pub static WITHDRAWAL_FEE: RefCell<Permill> = const { RefCell::new(Permill::from_percent(0)) };
	pub static WITHDRAWAL_ADJUSTMENT: RefCell<(u32,u32, bool)> = const { RefCell::new((0u32,0u32, false)) };
	pub static ON_TRADE_WITHDRAWAL: RefCell<Permill> = const { RefCell::new(Permill::from_percent(0)) };
}

construct_runtime!(
	pub enum Test
	{
		System: frame_system,
		Balances: pallet_balances,
		Omnipool: pallet_omnipool,
		Tokens: orml_tokens,
	}
);

impl frame_system::Config for Test {
	type BaseCallFilter = Everything;
	type BlockWeights = ();
	type BlockLength = ();
	type RuntimeOrigin = RuntimeOrigin;
	type RuntimeCall = RuntimeCall;
	type RuntimeTask = RuntimeTask;
	type Nonce = u64;
	type Block = Block;
	type Hash = H256;
	type Hashing = BlakeTwo256;
	type AccountId = u64;
	type Lookup = IdentityLookup<Self::AccountId>;
	type RuntimeEvent = RuntimeEvent;
	type BlockHashCount = ConstU64<250>;
	type DbWeight = ();
	type Version = ();
	type PalletInfo = PalletInfo;
	type AccountData = pallet_balances::AccountData<Balance>;
	type OnNewAccount = ();
	type OnKilledAccount = ();
	type SystemWeightInfo = ();
	type SS58Prefix = ();
	type OnSetCode = ();
	type MaxConsumers = ConstU32<16>;
	type SingleBlockMigrations = ();
	type MultiBlockMigrator = ();
	type PreInherents = ();
	type PostInherents = ();
	type PostTransactions = ();
}

impl pallet_balances::Config for Test {
	type Balance = Balance;
	type DustRemoval = ();
	type RuntimeEvent = RuntimeEvent;
	type ExistentialDeposit = ConstU128<1>;
	type AccountStore = System;
	type WeightInfo = ();
	type MaxLocks = ();
	type MaxReserves = ConstU32<50>;
	type ReserveIdentifier = [u8; 8];
	type FreezeIdentifier = ();
	type MaxFreezes = ();
	type RuntimeHoldReason = ();
	type RuntimeFreezeReason = ();
}

parameter_type_with_key! {
	pub ExistentialDeposits: |currency_id: AssetId| -> Balance {
		if *currency_id == LRNA{
			400_000_000
		}else{
			1
		}
	};
}

impl orml_tokens::Config for Test {
	type RuntimeEvent = RuntimeEvent;
	type Balance = Balance;
	type Amount = i128;
	type CurrencyId = AssetId;
	type WeightInfo = ();
	type ExistentialDeposits = ExistentialDeposits;
	type MaxLocks = ();
	type DustRemovalWhitelist = ();
	type MaxReserves = ();
	type ReserveIdentifier = ();
	type CurrencyHooks = ();
}

parameter_types! {
	pub const HDXAssetId: AssetId = HDX;
	pub const LRNAAssetId: AssetId = LRNA;
	pub const DAIAssetId: AssetId = DAI;
	pub const PosiitionCollectionId: u32= 1000;

	pub ProtocolFee: Permill = PROTOCOL_FEE.with(|v| *v.borrow());
	pub AssetFee: Permill = ASSET_FEE.with(|v| *v.borrow());
	pub AssetWeightCap: Permill =ASSET_WEIGHT_CAP.with(|v| *v.borrow());
	pub MinAddedLiquidity: Balance = MIN_ADDED_LIQUDIITY.with(|v| *v.borrow());
	pub MinTradeAmount: Balance = MIN_TRADE_AMOUNT.with(|v| *v.borrow());
	pub MaxInRatio: Balance = MAX_IN_RATIO.with(|v| *v.borrow());
	pub MaxOutRatio: Balance = MAX_OUT_RATIO.with(|v| *v.borrow());
	pub const TVLCap: Balance = Balance::MAX;
	pub MaxPriceDiff: Permill = MAX_PRICE_DIFF.with(|v| *v.borrow());
	pub FourPercentDiff: Permill = Permill::from_percent(4);
	pub MinWithdrawFee: Permill = WITHDRAWAL_FEE.with(|v| *v.borrow());
}

impl Config for Test {
	type RuntimeEvent = RuntimeEvent;
	type AssetId = AssetId;
	type PositionItemId = u32;
	type Currency = Tokens;
	type AuthorityOrigin = EnsureRoot<Self::AccountId>;
	type HubAssetId = LRNAAssetId;
	type WeightInfo = ();
	type HdxAssetId = HDXAssetId;
	type NFTCollectionId = PosiitionCollectionId;
	type NFTHandler = DummyNFT;
	type AssetRegistry = DummyRegistry<Test>;
	type MinimumTradingLimit = MinTradeAmount;
	type MinimumPoolLiquidity = MinAddedLiquidity;
	type TechnicalOrigin = EnsureRoot<Self::AccountId>;
	type MaxInRatio = MaxInRatio;
	type MaxOutRatio = MaxOutRatio;
	type CollectionId = u32;
	type OmnipoolHooks = MockHooks;
	type PriceBarrier = (
		EnsurePriceWithin<AccountId, AssetId, MockOracle, FourPercentDiff, ()>,
		EnsurePriceWithin<AccountId, AssetId, MockOracle, MaxPriceDiff, ()>,
	);
	type MinWithdrawalFee = MinWithdrawFee;
	type ExternalPriceOracle = WithdrawFeePriceOracle;
	type Fee = FeeProvider;
}

pub struct ExtBuilder {
	endowed_accounts: Vec<(u64, AssetId, Balance)>,
	registered_assets: Vec<AssetId>,
	asset_fee: Permill,
	protocol_fee: Permill,
	asset_weight_cap: Permill,
	min_liquidity: u128,
	min_trade_limit: u128,
	max_in_ratio: Balance,
	max_out_ratio: Balance,
	init_pool: Option<(FixedU128, FixedU128)>,
	pool_tokens: Vec<(AssetId, FixedU128, AccountId, Balance)>,
}

impl Default for ExtBuilder {
	fn default() -> Self {
		// If eg. tests running on one thread only, this thread local is shared.
		// let's make sure that it is empty for each  test case
		// or set to original default value
		REGISTERED_ASSETS.with(|v| {
			v.borrow_mut().clear();
		});
		POSITIONS.with(|v| {
			v.borrow_mut().clear();
		});
		ASSET_WEIGHT_CAP.with(|v| {
			*v.borrow_mut() = Permill::from_percent(100);
		});
		ASSET_FEE.with(|v| {
			*v.borrow_mut() = Permill::from_percent(0);
		});
		PROTOCOL_FEE.with(|v| {
			*v.borrow_mut() = Permill::from_percent(0);
		});
		MIN_ADDED_LIQUDIITY.with(|v| {
			*v.borrow_mut() = 1000u128;
		});
		MIN_TRADE_AMOUNT.with(|v| {
			*v.borrow_mut() = 1000u128;
		});
		MAX_IN_RATIO.with(|v| {
			*v.borrow_mut() = 1u128;
		});
		MAX_OUT_RATIO.with(|v| {
			*v.borrow_mut() = 1u128;
		});
		MAX_PRICE_DIFF.with(|v| {
			*v.borrow_mut() = Permill::from_percent(0);
		});
		EXT_PRICE_ADJUSTMENT.with(|v| {
			*v.borrow_mut() = (0, 0, false);
		});
		WITHDRAWAL_FEE.with(|v| {
			*v.borrow_mut() = Permill::from_percent(0);
		});
		WITHDRAWAL_ADJUSTMENT.with(|v| {
			*v.borrow_mut() = (0, 0, false);
		});

		Self {
			endowed_accounts: vec![
				(Omnipool::protocol_account(), DAI, 1000 * ONE),
				(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			],
			asset_fee: Permill::from_percent(0),
			protocol_fee: Permill::from_percent(0),
			asset_weight_cap: Permill::from_percent(100),
			min_liquidity: 0,
			registered_assets: vec![],
			min_trade_limit: 0,
			init_pool: None,
			pool_tokens: vec![],
			max_in_ratio: 1u128,
			max_out_ratio: 1u128,
		}
	}
}

impl ExtBuilder {
	pub fn with_endowed_accounts(mut self, accounts: Vec<(u64, AssetId, Balance)>) -> Self {
		self.endowed_accounts = accounts;
		self
	}
	pub fn add_endowed_accounts(mut self, account: (u64, AssetId, Balance)) -> Self {
		self.endowed_accounts.push(account);
		self
	}
	pub fn with_registered_asset(mut self, asset: AssetId) -> Self {
		self.registered_assets.push(asset);
		self
	}

	pub fn with_asset_weight_cap(mut self, cap: Permill) -> Self {
		self.asset_weight_cap = cap;
		self
	}

	pub fn with_asset_fee(mut self, fee: Permill) -> Self {
		self.asset_fee = fee;
		self
	}

	pub fn with_protocol_fee(mut self, fee: Permill) -> Self {
		self.protocol_fee = fee;
		self
	}
	pub fn with_min_added_liquidity(mut self, limit: Balance) -> Self {
		self.min_liquidity = limit;
		self
	}

	pub fn with_min_trade_amount(mut self, limit: Balance) -> Self {
		self.min_trade_limit = limit;
		self
	}

	pub fn with_initial_pool(mut self, stable_price: FixedU128, native_price: FixedU128) -> Self {
		self.init_pool = Some((stable_price, native_price));
		self
	}

	pub fn with_max_in_ratio(mut self, value: Balance) -> Self {
		self.max_in_ratio = value;
		self
	}
	pub fn with_max_out_ratio(mut self, value: Balance) -> Self {
		self.max_out_ratio = value;
		self
	}
	pub fn with_max_allowed_price_difference(self, max_allowed: Permill) -> Self {
		MAX_PRICE_DIFF.with(|v| {
			*v.borrow_mut() = max_allowed;
		});
		self
	}
	pub fn with_external_price_adjustment(self, price_adjustment: (u32, u32, bool)) -> Self {
		EXT_PRICE_ADJUSTMENT.with(|v| {
			*v.borrow_mut() = price_adjustment;
		});
		self
	}
	pub fn with_min_withdrawal_fee(self, fee: Permill) -> Self {
		WITHDRAWAL_FEE.with(|v| *v.borrow_mut() = fee);
		self
	}

	pub fn with_withdrawal_adjustment(self, adjustment: (u32, u32, bool)) -> Self {
		WITHDRAWAL_ADJUSTMENT.with(|v| *v.borrow_mut() = adjustment);
		self
	}

	pub fn with_on_trade_withdrawal(self, p: Permill) -> Self {
		ON_TRADE_WITHDRAWAL.with(|v| *v.borrow_mut() = p);
		self
	}

	pub fn with_token(
		mut self,
		asset_id: AssetId,
		price: FixedU128,
		position_owner: AccountId,
		amount: Balance,
	) -> Self {
		self.pool_tokens.push((asset_id, price, position_owner, amount));
		self
	}

	pub fn build(self) -> sp_io::TestExternalities {
		let mut t = frame_system::GenesisConfig::<Test>::default().build_storage().unwrap();

		// Add DAi and HDX as pre-registered assets
		REGISTERED_ASSETS.with(|v| {
			v.borrow_mut().insert(DAI, DAI);
			v.borrow_mut().insert(HDX, HDX);
			v.borrow_mut().insert(REGISTERED_ASSET, REGISTERED_ASSET);
			v.borrow_mut().insert(ASSET_WITHOUT_ED, ASSET_WITHOUT_ED);
			self.registered_assets.iter().for_each(|asset| {
				v.borrow_mut().insert(*asset, *asset);
			});
		});

		ASSET_FEE.with(|v| {
			*v.borrow_mut() = self.asset_fee;
		});
		ASSET_WEIGHT_CAP.with(|v| {
			*v.borrow_mut() = self.asset_weight_cap;
		});

		PROTOCOL_FEE.with(|v| {
			*v.borrow_mut() = self.protocol_fee;
		});

		MIN_ADDED_LIQUDIITY.with(|v| {
			*v.borrow_mut() = self.min_liquidity;
		});

		MIN_TRADE_AMOUNT.with(|v| {
			*v.borrow_mut() = self.min_trade_limit;
		});
		MAX_IN_RATIO.with(|v| {
			*v.borrow_mut() = self.max_in_ratio;
		});
		MAX_OUT_RATIO.with(|v| {
			*v.borrow_mut() = self.max_out_ratio;
		});

		orml_tokens::GenesisConfig::<Test> {
			balances: self
				.endowed_accounts
				.iter()
				.flat_map(|(x, asset, amount)| vec![(*x, *asset, *amount)])
				.collect(),
		}
		.assimilate_storage(&mut t)
		.unwrap();

		let mut r: sp_io::TestExternalities = t.into();

		if let Some((stable_price, native_price)) = self.init_pool {
			r.execute_with(|| {
				assert_ok!(Omnipool::add_token(
					RuntimeOrigin::root(),
					HDXAssetId::get(),
					native_price,
					Permill::from_percent(100),
					Omnipool::protocol_account(),
				));
				assert_ok!(Omnipool::add_token(
					RuntimeOrigin::root(),
					DAIAssetId::get(),
					stable_price,
					Permill::from_percent(100),
					Omnipool::protocol_account(),
				));

				for (asset_id, price, owner, amount) in self.pool_tokens {
					assert_ok!(Tokens::transfer(
						RuntimeOrigin::signed(owner),
						Omnipool::protocol_account(),
						asset_id,
						amount
					));
					assert_ok!(Omnipool::add_token(
						RuntimeOrigin::root(),
						asset_id,
						price,
						self.asset_weight_cap,
						owner
					));
				}
			});
		}

		r.execute_with(|| {
			System::set_block_number(1);
		});

		r
	}
}

use crate::traits::EnsurePriceWithin;
use frame_support::traits::tokens::nonfungibles::{Create, Inspect, Mutate};
use hydra_dx_math::ema::EmaPrice;
use hydra_dx_math::support::rational::Rounding;
use hydra_dx_math::to_u128_wrapper;

pub struct DummyNFT;

impl<AccountId: From<u64>> Inspect<AccountId> for DummyNFT {
	type ItemId = u32;
	type CollectionId = u32;

	fn owner(_class: &Self::CollectionId, instance: &Self::ItemId) -> Option<AccountId> {
		let mut owner: Option<AccountId> = None;

		POSITIONS.with(|v| {
			if let Some(o) = v.borrow().get(instance) {
				owner = Some((*o).into());
			}
		});
		owner
	}
}

impl<AccountId: From<u64>> Create<AccountId> for DummyNFT {
	fn create_collection(_class: &Self::CollectionId, _who: &AccountId, _admin: &AccountId) -> DispatchResult {
		Ok(())
	}
}

impl<AccountId: From<u64> + Into<u64> + Copy> Mutate<AccountId> for DummyNFT {
	fn mint_into(_class: &Self::CollectionId, _instance: &Self::ItemId, _who: &AccountId) -> DispatchResult {
		POSITIONS.with(|v| {
			let mut m = v.borrow_mut();
			m.insert(*_instance, (*_who).into());
		});
		Ok(())
	}

	fn burn(
		_class: &Self::CollectionId,
		instance: &Self::ItemId,
		_maybe_check_owner: Option<&AccountId>,
	) -> DispatchResult {
		POSITIONS.with(|v| {
			let mut m = v.borrow_mut();
			m.remove(instance);
		});
		Ok(())
	}
}

pub struct DummyRegistry<T>(sp_std::marker::PhantomData<T>);

impl<T: Config> InspectRegistry for DummyRegistry<T>
where
	T::AssetId: Into<AssetId> + From<u32>,
{
	type AssetId = T::AssetId;
	type Location = u8;

	fn is_sufficient(_id: Self::AssetId) -> bool {
		unimplemented!()
	}

	fn exists(asset_id: T::AssetId) -> bool {
		let asset = REGISTERED_ASSETS.with(|v| v.borrow().get(&(asset_id.into())).copied());
		asset.is_some()
	}

	fn decimals(_id: Self::AssetId) -> Option<u8> {
		unimplemented!()
	}

	fn asset_type(_id: Self::AssetId) -> Option<AssetKind> {
		unimplemented!()
	}

	fn is_banned(_id: Self::AssetId) -> bool {
		unimplemented!()
	}

	fn asset_name(_id: Self::AssetId) -> Option<Vec<u8>> {
		unimplemented!()
	}

	fn asset_symbol(_id: Self::AssetId) -> Option<Vec<u8>> {
		unimplemented!()
	}
	fn existential_deposit(id: Self::AssetId) -> Option<u128> {
		if id == ASSET_WITHOUT_ED.into() {
			None
		} else {
			Some(ExistentialDeposits::get(&id.into()))
		}
	}
}

pub(crate) fn get_mock_minted_position(position_id: u32) -> Option<u64> {
	POSITIONS.with(|v| v.borrow().get(&position_id).copied())
}

pub(crate) fn last_position_id() -> u32 {
	Omnipool::next_position_id()
}

pub struct MockOracle;

impl ExternalPriceProvider<AssetId, EmaPrice> for MockOracle {
	type Error = DispatchError;

	fn get_price(asset_a: AssetId, asset_b: AssetId) -> Result<EmaPrice, Self::Error> {
		assert_eq!(asset_a, LRNA);
		let asset_state = Omnipool::load_asset_state(asset_b)?;
		let price = EmaPrice::new(asset_state.hub_reserve, asset_state.reserve);
		let adjusted_price = EXT_PRICE_ADJUSTMENT.with(|v| {
			let (n, d, neg) = *v.borrow();
			let adjustment = EmaPrice::new(price.n * n as u128, price.d * d as u128);
			if neg {
				saturating_sub(price, adjustment)
			} else {
				saturating_add(price, adjustment)
			}
		});

		Ok(adjusted_price)
	}

	fn get_price_weight() -> Weight {
		todo!()
	}
}

pub struct WithdrawFeePriceOracle;

impl ExternalPriceProvider<AssetId, EmaPrice> for WithdrawFeePriceOracle {
	type Error = DispatchError;

	fn get_price(asset_a: AssetId, asset_b: AssetId) -> Result<EmaPrice, Self::Error> {
		assert_eq!(asset_a, LRNA);
		let asset_state = Omnipool::load_asset_state(asset_b)?;
		let price = EmaPrice::new(asset_state.hub_reserve, asset_state.reserve);

		let adjusted_price = WITHDRAWAL_ADJUSTMENT.with(|v| {
			let (n, d, neg) = *v.borrow();
			let adjustment = EmaPrice::new(price.n * n as u128, price.d * d as u128);
			if neg {
				saturating_sub(price, adjustment)
			} else {
				saturating_add(price, adjustment)
			}
		});

		Ok(adjusted_price)
	}

	fn get_price_weight() -> Weight {
		todo!()
	}
}

// Helper methods to work with Ema Price
pub(super) fn round_to_rational((n, d): (U256, U256), rounding: Rounding) -> EmaPrice {
	let shift = n.bits().max(d.bits()).saturating_sub(128);
	let (n, d) = if shift > 0 {
		let min_n = u128::from(!n.is_zero());
		let (bias_n, bias_d) = rounding.to_bias(1);
		let shifted_n = (n >> shift).low_u128();
		let shifted_d = (d >> shift).low_u128();
		(
			shifted_n.saturating_add(bias_n).max(min_n),
			shifted_d.saturating_add(bias_d).max(1),
		)
	} else {
		(n.low_u128(), d.low_u128())
	};
	EmaPrice::new(n, d)
}

pub(super) fn saturating_add(l: EmaPrice, r: EmaPrice) -> EmaPrice {
	if l.n.is_zero() || r.n.is_zero() {
		return EmaPrice::new(l.n, l.d);
	}
	let (l_n, l_d, r_n, r_d) = to_u128_wrapper!(l.n, l.d, r.n, r.d);
	// n = l.n * r.d - r.n * l.d
	let n = l_n.full_mul(r_d).saturating_add(r_n.full_mul(l_d));
	// d = l.d * r.d
	let d = l_d.full_mul(r_d);
	round_to_rational((n, d), Rounding::Nearest)
}

pub(super) fn saturating_sub(l: EmaPrice, r: EmaPrice) -> EmaPrice {
	if l.n.is_zero() || r.n.is_zero() {
		return EmaPrice::new(l.n, l.d);
	}
	let (l_n, l_d, r_n, r_d) = to_u128_wrapper!(l.n, l.d, r.n, r.d);
	// n = l.n * r.d - r.n * l.d
	let n = l_n.full_mul(r_d).saturating_sub(r_n.full_mul(l_d));
	// d = l.d * r.d
	let d = l_d.full_mul(r_d);
	round_to_rational((n, d), Rounding::Nearest)
}

pub struct FeeProvider;

impl GetByKey<AssetId, (Permill, Permill)> for FeeProvider {
	fn get(_: &AssetId) -> (Permill, Permill) {
		(ASSET_FEE.with(|v| *v.borrow()), PROTOCOL_FEE.with(|v| *v.borrow()))
	}
}

pub(crate) fn expect_events(e: Vec<RuntimeEvent>) {
	e.into_iter().for_each(frame_system::Pallet::<Test>::assert_has_event);
}

pub struct MockHooks;

impl OmnipoolHooks<RuntimeOrigin, AccountId, AssetId, Balance> for MockHooks {
	type Error = DispatchError;

	fn on_liquidity_changed(
		_origin: RuntimeOrigin,
		_asset: AssetInfo<AssetId, Balance>,
	) -> Result<Weight, Self::Error> {
		Ok(Weight::zero())
	}

	fn on_trade(
		_origin: RuntimeOrigin,
		_asset_in: AssetInfo<AssetId, Balance>,
		_asset_out: AssetInfo<AssetId, Balance>,
	) -> Result<Weight, Self::Error> {
		Ok(Weight::zero())
	}

	fn on_hub_asset_trade(_origin: RuntimeOrigin, _asset: AssetInfo<AssetId, Balance>) -> Result<Weight, Self::Error> {
		Ok(Weight::zero())
	}

	fn on_liquidity_changed_weight() -> Weight {
		Weight::zero()
	}

	fn on_trade_weight() -> Weight {
		Weight::zero()
	}

	fn on_trade_fee(
		fee_account: AccountId,
		_trader: AccountId,
		asset: AssetId,
		amount: Balance,
	) -> Result<Balance, Self::Error> {
		let percentage = ON_TRADE_WITHDRAWAL.with(|v| *v.borrow());
		let to_take = percentage.mul_floor(amount);
		Tokens::withdraw(asset, &fee_account, to_take)?;
		Ok(to_take)
	}
}

File: ./pallets/omnipool/src/tests/invariants.rs
use super::*;
use crate::{AssetReserveState, FixedU128};
use frame_support::assert_noop;
use primitive_types::U256;
use proptest::prelude::*;

pub const ONE: Balance = 1_000_000_000_000;
pub const TOLERANCE: Balance = 1_000_000_000;

const BALANCE_RANGE: (Balance, Balance) = (100_000 * ONE, 10_000_000 * ONE);

fn asset_reserve() -> impl Strategy<Value = Balance> {
	BALANCE_RANGE.0..BALANCE_RANGE.1
}

fn trade_amount() -> impl Strategy<Value = Balance> {
	1000..5000 * ONE
}

fn price() -> impl Strategy<Value = FixedU128> {
	(0.1f64..2f64).prop_map(FixedU128::from_float)
}

fn min_withdrawal_fee() -> impl Strategy<Value = Permill> {
	(0.001f64..2f64).prop_map(Permill::from_float)
}

fn adjustment() -> impl Strategy<Value = (u32, u32, bool)> {
	(
		0u32..50u32,
		prop_oneof![Just(100), Just(1000), Just(10000)],
		prop_oneof![Just(true), Just(false)],
	)
}

fn some_imbalance() -> impl Strategy<Value = SimpleImbalance<Balance>> {
	(0..10000 * ONE).prop_map(|value| SimpleImbalance { value, negative: true })
}

fn assert_asset_invariant(
	old_state: &AssetReserveState<Balance>,
	new_state: &AssetReserveState<Balance>,
	tolerance: FixedU128,
	desc: &str,
) {
	let new_s = U256::from(new_state.reserve) * U256::from(new_state.hub_reserve);
	let s1 = new_s.integer_sqrt();

	let old_s = U256::from(old_state.reserve) * U256::from(old_state.hub_reserve);
	let s2 = old_s.integer_sqrt();

	assert!(
		new_s >= old_s,
		"Invariant decreased for {desc} - {:?} >= {:?}",
		new_s,
		old_s
	);

	let s1_u128 = Balance::try_from(s1).unwrap();
	let s2_u128 = Balance::try_from(s2).unwrap();

	let invariant = FixedU128::from((s1_u128, ONE)) / FixedU128::from((s2_u128, ONE));
	assert_eq_approx!(invariant, FixedU128::from(1u128), tolerance, desc);
}
fn fee() -> impl Strategy<Value = Permill> {
	// Allow values between 0.001 and 3%
	(
		0u32..=30u32,
		prop_oneof![Just(1000u32), Just(10000u32), Just(100_000u32)],
	)
		.prop_map(|(n, d)| Permill::from_rational(n, d))
}

fn sum_asset_hub_liquidity() -> Balance {
	<Assets<Test>>::iter().fold(0, |acc, v| acc + v.1.hub_reserve)
}

#[derive(Debug)]
struct PoolToken {
	asset_id: AssetId,
	amount: Balance,
	price: FixedU128,
}

fn pool_token(asset_id: AssetId) -> impl Strategy<Value = PoolToken> {
	(asset_reserve(), price()).prop_map(move |(reserve, price)| PoolToken {
		asset_id,
		amount: reserve,
		price,
	})
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn sell_invariants_feeless(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, 200, amount + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_state_200 = Omnipool::load_asset_state(200).unwrap();
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();
				let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				assert_ok!(Omnipool::sell(RuntimeOrigin::signed(seller), 200, 300, amount, Balance::zero()));

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_state_300 = Omnipool::load_asset_state(300).unwrap();
				let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_200.reserve, old_state_200.reserve);
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_200, &new_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");
				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq!(old_hub_liquidity, new_hub_liquidity, "Total Hub liquidity has changed!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity, "Assets hub liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				// No LRNA lost
				let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
				let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
				let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
				let delta_imbalance= new_imbalance.value - old_imbalance.value; // note: in current implementation: imbalance cannot be positive, let's simply and ignore the sign for now

				let remaining = delta_q_300 - delta_q_200 - delta_q_hdx - delta_imbalance;
				assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn sell_invariants_with_fees(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		imbalance in some_imbalance(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, 200, amount + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_protocol_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				HubAssetImbalance::<Test>::set(imbalance);

				let old_state_200 = Omnipool::load_asset_state(200).unwrap();
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();
				let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				assert_ok!(Omnipool::sell(RuntimeOrigin::signed(seller), 200, 300, amount, Balance::zero()));

				let updated_imbalance = HubAssetImbalance::<Test>::get();

				assert!(updated_imbalance.value <= imbalance.value);

				let imbalance_diff = imbalance.value - updated_imbalance.value;

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_state_300 = Omnipool::load_asset_state(300).unwrap();
				let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_200.reserve, old_state_200.reserve);
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_200, &new_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");
				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq!(old_hub_liquidity, new_hub_liquidity + imbalance_diff, "Total Hub liquidity has changed!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity + imbalance_diff, "Assets hub liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				// No LRNA lost
				let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
				let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
				let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
				let delta_imbalance = old_imbalance.value - new_imbalance.value;

				let remaining = delta_q_200 - delta_q_300 - delta_q_hdx - delta_imbalance;
				assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn sell_invariants_with_fees_and_on_trade_withdrawal(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		imbalance in some_imbalance(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, 200, amount + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_protocol_fee(protocol_fee)
			.with_on_trade_withdrawal(Permill::from_percent(100))
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				HubAssetImbalance::<Test>::set(imbalance);

				let old_state_200 = Omnipool::load_asset_state(200).unwrap();
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();
				let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				assert_ok!(Omnipool::sell(RuntimeOrigin::signed(seller), 200, 300, amount, Balance::zero()));

				let updated_imbalance = HubAssetImbalance::<Test>::get();

				assert!(updated_imbalance.value <= imbalance.value);

				let imbalance_diff = imbalance.value - updated_imbalance.value;

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_state_300 = Omnipool::load_asset_state(300).unwrap();
				let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_200.reserve, old_state_200.reserve);
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_200, &new_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");
				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq!(old_hub_liquidity, new_hub_liquidity + imbalance_diff, "Total Hub liquidity has changed!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity + imbalance_diff, "Assets hub liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				// No LRNA lost
				let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
				let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
				let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
				let delta_imbalance = old_imbalance.value - new_imbalance.value;

				let remaining = delta_q_200 - delta_q_300 - delta_q_hdx - delta_imbalance;
				assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn buy_invariants_feeless(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let buyer: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(buyer, 200, amount * 1000 + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_state_200 = Omnipool::load_asset_state(200).unwrap();
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();
				let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(buyer), 300, 200, amount, Balance::max_value()));

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_state_300 = Omnipool::load_asset_state(300).unwrap();
				let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_200.reserve, old_state_200.reserve);
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_200, &new_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");
				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq!(old_hub_liquidity, new_hub_liquidity, "Total Hub liquidity has changed!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity, "Assets hub liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				// No LRNA lost
				let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
				let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
				let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
				let delta_imbalance= new_imbalance.value - old_imbalance.value; // note: in current implementation: imbalance cannot be positive, let's simply and ignore the sign for now

				let remaining = delta_q_300 - delta_q_200 - delta_q_hdx - delta_imbalance;
				assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn buy_invariants_with_fees(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		imbalance in some_imbalance(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let buyer: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(buyer, 200, amount * 1000 + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_protocol_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				HubAssetImbalance::<Test>::set(imbalance);
				let old_state_200 = Omnipool::load_asset_state(200).unwrap();
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();
				let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(buyer), 300, 200, amount, Balance::max_value()));

				let updated_imbalance = HubAssetImbalance::<Test>::get();
				assert!(updated_imbalance.value <= imbalance.value);

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_state_300 = Omnipool::load_asset_state(300).unwrap();
				let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_200.reserve, old_state_200.reserve);
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_200, &new_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");
				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let imbalance_diff = imbalance.value - updated_imbalance.value;

				assert_eq!(old_hub_liquidity, new_hub_liquidity + imbalance_diff, "Total Hub liquidity has changed!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity + imbalance_diff, "Assets hub liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				// No LRNA lost
				let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
				let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
				let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
				let delta_imbalance= old_imbalance.value - new_imbalance.value;

				let remaining = delta_q_200 - delta_q_300 - delta_q_hdx - delta_imbalance;
				assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn buy_invariants_with_fees_and_on_trade_withdrawal(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		imbalance in some_imbalance(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let buyer: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(buyer, 200, amount * 1000 + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_protocol_fee(protocol_fee)
			.with_on_trade_withdrawal(Permill::from_percent(100))
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				HubAssetImbalance::<Test>::set(imbalance);
				let old_state_200 = Omnipool::load_asset_state(200).unwrap();
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();
				let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(buyer), 300, 200, amount, Balance::max_value()));

				let updated_imbalance = HubAssetImbalance::<Test>::get();
				assert!(updated_imbalance.value <= imbalance.value);

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_state_300 = Omnipool::load_asset_state(300).unwrap();
				let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_200.reserve, old_state_200.reserve);
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_200, &new_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");
				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let imbalance_diff = imbalance.value - updated_imbalance.value;

				assert_eq!(old_hub_liquidity, new_hub_liquidity + imbalance_diff, "Total Hub liquidity has changed!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity + imbalance_diff, "Assets hub liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				// No LRNA lost
				let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
				let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
				let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
				let delta_imbalance= old_imbalance.value - new_imbalance.value;

				let remaining = delta_q_200 - delta_q_300 - delta_q_hdx - delta_imbalance;
				assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
			});
	}
}

#[test]
fn buy_invariant_case_01() {
	let lp1: u64 = 100;
	let lp2: u64 = 200;
	let lp3: u64 = 300;
	let lp4: u64 = 400;
	let buyer: u64 = 500;

	let amount = 1000000000000000;
	let stable_price = FixedU128::from_float(0.1);
	let stable_reserve = 10000000000000000;
	let native_reserve = 10000000000000000;
	let token_1 = PoolToken {
		asset_id: 100,
		amount: 10000000000000000,
		price: FixedU128::from_float(0.1),
	};
	let token_2 = PoolToken {
		asset_id: 200,
		amount: 10000000000000000,
		price: FixedU128::from_float(0.1),
	};
	let token_3 = PoolToken {
		asset_id: 300,
		amount: 4078272607222477550,
		price: FixedU128::from_float(0.1),
	};
	let token_4 = PoolToken {
		asset_id: 400,
		amount: 10000000000000000,
		price: FixedU128::from_float(0.1),
	};

	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, stable_reserve),
			(Omnipool::protocol_account(), HDX, native_reserve),
			(lp1, 100, token_1.amount + 2 * ONE),
			(lp2, 200, token_2.amount + 2 * ONE),
			(lp3, 300, token_3.amount + 2 * ONE),
			(lp4, 400, token_4.amount + 2 * ONE),
			(buyer, 200, amount * 1000 + 200 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_registered_asset(300)
		.with_registered_asset(400)
		.with_initial_pool(stable_price, FixedU128::from(1))
		.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
		.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
		.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
		.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
		.build()
		.execute_with(|| {
			let old_state_200 = Omnipool::load_asset_state(200).unwrap();
			let old_state_300 = Omnipool::load_asset_state(300).unwrap();
			let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

			let old_imbalance = <HubAssetImbalance<Test>>::get();

			let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

			let old_asset_hub_liquidity = sum_asset_hub_liquidity();

			assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(buyer),
				300,
				200,
				amount,
				Balance::max_value()
			));

			let new_state_200 = Omnipool::load_asset_state(200).unwrap();
			let new_state_300 = Omnipool::load_asset_state(300).unwrap();
			let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

			// invariant does not decrease
			assert_ne!(new_state_200.reserve, old_state_200.reserve);
			assert_ne!(new_state_300.reserve, old_state_300.reserve);

			assert_asset_invariant(
				&old_state_200,
				&new_state_200,
				FixedU128::from((TOLERANCE, ONE)),
				"Invariant 200",
			);
			assert_asset_invariant(
				&old_state_300,
				&new_state_300,
				FixedU128::from((TOLERANCE, ONE)),
				"Invariant 300",
			);

			// Total hub asset liquidity has not changed
			let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

			assert_eq!(old_hub_liquidity, new_hub_liquidity, "Total Hub liquidity has changed!");

			// total quantity of R_i remains unchanged
			let new_asset_hub_liquidity = sum_asset_hub_liquidity();

			assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity, "Assets hub liquidity");

			let new_imbalance = <HubAssetImbalance<Test>>::get();

			// No LRNA lost
			let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
			let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
			let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
			let delta_imbalance = new_imbalance.value - old_imbalance.value; // note: in current implementation: imbalance cannot be positive, let's simply and ignore the sign for now

			let remaining = delta_q_300 - delta_q_200 - delta_q_hdx - delta_imbalance;
			assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
		});
}

#[test]
fn buy_invariant_case_02() {
	let lp1: u64 = 100;
	let lp2: u64 = 200;
	let lp3: u64 = 300;
	let lp4: u64 = 400;
	let buyer: u64 = 500;

	let amount = 1_023_135_244_731_817;
	let stable_price = FixedU128::from_float(0.1);
	let stable_reserve = 10000000000000000;
	let native_reserve = 10000000000000000;
	let token_1 = PoolToken {
		asset_id: 100,
		amount: 10000000000000000,
		price: FixedU128::from_float(0.1),
	};
	let token_2 = PoolToken {
		asset_id: 200,
		amount: 10000000000000000,
		price: FixedU128::from_float(0.1),
	};
	let token_3 = PoolToken {
		asset_id: 300,
		amount: 10_000_000_000_000_000,
		price: FixedU128::from_float(1.827_143_565_363_142_7),
	};
	let token_4 = PoolToken {
		asset_id: 400,
		amount: 10000000000000000,
		price: FixedU128::from_float(0.1),
	};

	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, stable_reserve),
			(Omnipool::protocol_account(), HDX, native_reserve),
			(lp1, 100, token_1.amount + 2 * ONE),
			(lp2, 200, token_2.amount + 2 * ONE),
			(lp3, 300, token_3.amount + 2 * ONE),
			(lp4, 400, token_4.amount + 2 * ONE),
			(buyer, 200, amount * 1000 + 200 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_registered_asset(300)
		.with_registered_asset(400)
		.with_initial_pool(stable_price, FixedU128::from(1))
		.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
		.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
		.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
		.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
		.build()
		.execute_with(|| {
			let old_state_200 = Omnipool::load_asset_state(200).unwrap();
			let old_state_300 = Omnipool::load_asset_state(300).unwrap();
			let old_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

			let old_imbalance = <HubAssetImbalance<Test>>::get();

			let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

			let old_asset_hub_liquidity = sum_asset_hub_liquidity();

			assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

			// TODO: this fais with Overflow - but the real error should be Insufficient token amount after out calc
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(buyer), 300, 200, amount, Balance::max_value()),
				ArithmeticError::Overflow
			);

			let new_state_200 = Omnipool::load_asset_state(200).unwrap();
			let new_state_300 = Omnipool::load_asset_state(300).unwrap();
			let new_state_hdx = Omnipool::load_asset_state(HDX).unwrap();

			// invariant does not decrease
			// assert_ne!(new_state_200.reserve, old_state_200.reserve);
			// assert_ne!(new_state_300.reserve, old_state_300.reserve);

			assert_asset_invariant(
				&old_state_200,
				&new_state_200,
				FixedU128::from((TOLERANCE, ONE)),
				"Invariant 200",
			);
			assert_asset_invariant(
				&old_state_300,
				&new_state_300,
				FixedU128::from((TOLERANCE, ONE)),
				"Invariant 300",
			);

			// Total hub asset liquidity has not changed
			let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

			assert_eq!(old_hub_liquidity, new_hub_liquidity, "Total Hub liquidity has changed!");

			// total quantity of R_i remains unchanged
			let new_asset_hub_liquidity = sum_asset_hub_liquidity();

			assert_eq!(old_asset_hub_liquidity, new_asset_hub_liquidity, "Assets hub liquidity");

			let new_imbalance = <HubAssetImbalance<Test>>::get();

			// No LRNA lost
			let delta_q_200 = old_state_200.hub_reserve - new_state_200.hub_reserve;
			let delta_q_300 = new_state_300.hub_reserve - old_state_300.hub_reserve;
			let delta_q_hdx = new_state_hdx.hub_reserve - old_state_hdx.hub_reserve;
			let delta_imbalance = new_imbalance.value - old_imbalance.value; // note: in current implementation: imbalance cannot be positive, let's simply and ignore the sign for now

			let remaining = delta_q_300 - delta_q_200 - delta_q_hdx - delta_imbalance;
			assert_eq!(remaining, 0u128, "Some LRNA was lost along the way");
		});
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn sell_hub_invariants_with_fees(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee()
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, LRNA, amount + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				assert_ok!(Omnipool::sell(RuntimeOrigin::signed(seller), LRNA, 300, amount, Balance::zero()));

				let new_state_300 = Omnipool::load_asset_state(300).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq!(old_hub_liquidity + amount, new_hub_liquidity, "Total Hub liquidity increased incorrectly!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				assert_eq!(old_asset_hub_liquidity + amount, new_asset_hub_liquidity, "Assets hub liquidity");

				assert_imbalance_update(
					old_imbalance.value,
					new_imbalance.value,
					old_hub_liquidity,
					new_hub_liquidity,
					"Imbalance invariant in sell LRNA is incorrect"
				);
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn sell_hub_invariants_with_fees_and_on_trade_fee_withdrawal(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee()
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, LRNA, amount + 200 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_on_trade_withdrawal(Permill::from_percent(100))
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				assert_ok!(Omnipool::sell(RuntimeOrigin::signed(seller), LRNA, 300, amount, Balance::zero()));

				let new_state_300 = Omnipool::load_asset_state(300).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq!(old_hub_liquidity + amount, new_hub_liquidity, "Total Hub liquidity increased incorrectly!");

				// total quantity of R_i remains unchanged
				let new_asset_hub_liquidity = sum_asset_hub_liquidity();

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				assert_eq!(old_asset_hub_liquidity + amount, new_asset_hub_liquidity, "Assets hub liquidity");

				assert_imbalance_update(
					old_imbalance.value,
					new_imbalance.value,
					old_hub_liquidity,
					new_hub_liquidity,
					"Imbalance invariant in sell LRNA is incorrect"
				);
			});
	}
}

fn assert_imbalance_update(
	old_imbalance: Balance,
	new_imbalance: Balance,
	old_hub_reserve: Balance,
	new_hub_reserve: Balance,
	desc: &str,
) {
	let q = U256::from(old_hub_reserve);
	let q_plus = U256::from(new_hub_reserve);
	let l = U256::from(old_imbalance);
	let l_plus = U256::from(new_imbalance);

	let left = q.checked_mul(q.checked_sub(l).unwrap()).unwrap();
	let right = q_plus.checked_mul(q_plus.checked_sub(l_plus).unwrap()).unwrap();

	assert!(left >= right, "{}", desc);
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn buy_hub_invariants_with_fees(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee()
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, LRNA, 100_000* ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(seller), 300, LRNA, amount, Balance::max_value()));

				let new_state_300 = Omnipool::load_asset_state(300).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				assert!(old_hub_liquidity < new_hub_liquidity, "Total Hub liquidity increased incorrectly!");

				assert_imbalance_update(
					old_imbalance.value,
					new_imbalance.value,
					old_hub_liquidity,
					new_hub_liquidity,
					"Imbalance invariant in buy for LRNA is incorrect"
				);
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn buy_hub_invariants_with_fees_and_on_trade_fee_withdrawal(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee()
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, LRNA, 100_000* ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_on_trade_withdrawal(Permill::from_percent(100))
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_state_300 = Omnipool::load_asset_state(300).unwrap();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let old_asset_hub_liquidity = sum_asset_hub_liquidity();

				assert_eq!(old_hub_liquidity, old_asset_hub_liquidity);

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(seller), 300, LRNA, amount, Balance::max_value()));

				let new_state_300 = Omnipool::load_asset_state(300).unwrap();

				// invariant does not decrease
				assert_ne!(new_state_300.reserve, old_state_300.reserve);

				assert_asset_invariant(&old_state_300, &new_state_300, FixedU128::from((TOLERANCE,ONE)), "Invariant 300");

				// Total hub asset liquidity has not changed
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let new_imbalance = <HubAssetImbalance<Test>>::get();

				assert!(old_hub_liquidity < new_hub_liquidity, "Total Hub liquidity increased incorrectly!");

				assert_imbalance_update(
					old_imbalance.value,
					new_imbalance.value,
					old_hub_liquidity,
					new_hub_liquidity,
					"Imbalance invariant in buy for LRNA is incorrect"
				);
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn add_liquidity_invariants_with_fees(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		buy_amount in trade_amount(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;
		let buyer: u64 = 600;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(Omnipool::protocol_account(), token_1.asset_id, token_1.amount),
				(Omnipool::protocol_account(), token_2.asset_id, token_2.amount),
				(Omnipool::protocol_account(), token_3.asset_id, token_3.amount),
				(Omnipool::protocol_account(), token_4.asset_id, token_4.amount),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, 200, amount + 200 * ONE),
				(buyer, LRNA, 200_000 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.build()
			.execute_with(|| {
				let old_imbalance = <HubAssetImbalance<Test>>::get();
				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_ok!(Omnipool::add_token(RuntimeOrigin::root(), token_1.asset_id, token_1.price,Permill::from_percent(100),lp1));

				let new_imbalance = <HubAssetImbalance<Test>>::get();
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq_approx!( FixedU128::from((old_imbalance.value, old_hub_liquidity)),
								   FixedU128::from((new_imbalance.value, new_hub_liquidity)),
								   FixedU128::from_float(0.000000001),
								   "L/Q ratio changed"
				);

				assert_ok!(Omnipool::add_token(RuntimeOrigin::root(), token_2.asset_id, token_2.price,Permill::from_percent(100),lp2));
				assert_ok!(Omnipool::add_token(RuntimeOrigin::root(), token_3.asset_id, token_3.price,Permill::from_percent(100), lp3));

				let old_imbalance = <HubAssetImbalance<Test>>::get();
				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_ok!(Omnipool::add_token(RuntimeOrigin::root(), token_4.asset_id, token_4.price,Permill::from_percent(100),lp4));

				let new_imbalance = <HubAssetImbalance<Test>>::get();
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq_approx!( FixedU128::from((old_imbalance.value, old_hub_liquidity)),
								   FixedU128::from((new_imbalance.value, new_hub_liquidity)),
								   FixedU128::from_float(0.000000001),
								   "L/Q ratio changed"
				);

				// Let's do a trade so imbalance changes, so it is not always 0
				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(buyer), 300, LRNA, buy_amount, Balance::max_value()));

				let old_state_200 = Omnipool::load_asset_state(200).unwrap();

				let old_imbalance = <HubAssetImbalance<Test>>::get();

				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(seller), 200, amount));

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();

				// Price should not change
				assert_eq_approx!(old_state_200.price().unwrap(),
						new_state_200.price().unwrap(),
						FixedU128::from_float(0.0000000001),
						"Price has changed after add liquidity");

				let new_imbalance = <HubAssetImbalance<Test>>::get();
				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				assert_eq_approx!( FixedU128::from((old_imbalance.value, old_hub_liquidity)),
								   FixedU128::from((new_imbalance.value, new_hub_liquidity)),
								   FixedU128::from_float(0.000000001),
								   "L/Q ratio changed"
				);
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn remove_all_liquidity_invariants_with_fees(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		buy_amount in trade_amount(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;
		let buyer: u64 = 600;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, 200, amount + 200 * ONE),
				(buyer, DAI, 200_000_000 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.build()
			.execute_with(|| {
				let old_imbalance = <HubAssetImbalance<Test>>::get();
				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let position_id = <NextPositionId<Test>>::get();
				assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(seller), 200, amount));

				let position = <Positions<Test>>::get(position_id).unwrap();

				let before_buy_state_200 = Omnipool::load_asset_state(200).unwrap();

				// Let's do a trade so imbalance and price changes
				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(buyer), 200, DAI, buy_amount, Balance::max_value()));

				let old_state_200 = Omnipool::load_asset_state(200).unwrap();

				assert_asset_invariant(&before_buy_state_200, &old_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");

				assert_ok!(Omnipool::remove_liquidity(RuntimeOrigin::signed(seller), position_id, position.shares));

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_imbalance = <HubAssetImbalance<Test>>::get();

				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				// Price should not change
				assert_eq_approx!(old_state_200.price().unwrap(),
						new_state_200.price().unwrap(),
						FixedU128::from_float(0.0000000001),
						"Price has changed after remove liquidity");

				assert_eq_approx!( FixedU128::from((old_imbalance.value, old_hub_liquidity)),
								   FixedU128::from((new_imbalance.value, new_hub_liquidity)),
								   FixedU128::from_float(0.000000001),
								   "L/Q ratio changed after remove liquidity"
				);
			});
	}
}

proptest! {
	#![proptest_config(ProptestConfig::with_cases(100))]
	#[test]
	fn remove_liquidity_should_calculate_withdrawal_fee_correctly(amount in trade_amount(),
		stable_price in price(),
		stable_reserve in asset_reserve(),
		native_reserve in asset_reserve(),
		token_1 in pool_token(100),
		token_2 in pool_token(200),
		token_3 in pool_token(300),
		token_4 in pool_token(400),
		asset_fee in fee(),
		protocol_fee in fee(),
		buy_amount in trade_amount(),
		min_withdraw_fee in min_withdrawal_fee(),
		(price_adjustment, denom, direction) in adjustment(),
	) {
		let lp1: u64 = 100;
		let lp2: u64 = 200;
		let lp3: u64 = 300;
		let lp4: u64 = 400;
		let seller: u64 = 500;
		let buyer: u64 = 600;

		ExtBuilder::default()
			.with_endowed_accounts(vec![
				(Omnipool::protocol_account(), DAI, stable_reserve ),
				(Omnipool::protocol_account(), HDX, native_reserve ),
				(lp1, 100, token_1.amount + 2 * ONE),
				(lp2, 200, token_2.amount + 2 * ONE),
				(lp3, 300, token_3.amount + 2 * ONE),
				(lp4, 400, token_4.amount + 2 * ONE),
				(seller, 200, amount + 200 * ONE),
				(buyer, DAI, 200_000_000 * ONE),
			])
			.with_registered_asset(100)
			.with_registered_asset(200)
			.with_registered_asset(300)
			.with_registered_asset(400)
			.with_asset_fee(asset_fee)
			.with_asset_fee(protocol_fee)
			.with_initial_pool(
				stable_price,
				FixedU128::from(1),
			)
			.with_token(token_1.asset_id, token_1.price, lp1, token_1.amount)
			.with_token(token_2.asset_id, token_2.price, lp2, token_2.amount)
			.with_token(token_3.asset_id, token_3.price, lp3, token_3.amount)
			.with_token(token_4.asset_id, token_4.price, lp4, token_4.amount)
			.with_min_withdrawal_fee(min_withdraw_fee)
			.with_withdrawal_adjustment((price_adjustment, denom, direction))
			.build()
			.execute_with(|| {
				let old_imbalance = <HubAssetImbalance<Test>>::get();
				let old_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				let position_id = <NextPositionId<Test>>::get();
				assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(seller), 200, amount));

				let position = <Positions<Test>>::get(position_id).unwrap();

				let before_buy_state_200 = Omnipool::load_asset_state(200).unwrap();

				// Let's do a trade so imbalance and price changes
				assert_ok!(Omnipool::buy(RuntimeOrigin::signed(buyer), 200, DAI, buy_amount, Balance::max_value()));

				let old_state_200 = Omnipool::load_asset_state(200).unwrap();

				assert_asset_invariant(&before_buy_state_200, &old_state_200, FixedU128::from((TOLERANCE,ONE)), "Invariant 200");

				assert_ok!(Omnipool::remove_liquidity(RuntimeOrigin::signed(seller), position_id, position.shares));

				let new_state_200 = Omnipool::load_asset_state(200).unwrap();
				let new_imbalance = <HubAssetImbalance<Test>>::get();

				let new_hub_liquidity = Tokens::free_balance(LRNA, &Omnipool::protocol_account());

				// Price should not change
				assert_eq_approx!(old_state_200.price().unwrap(),
						new_state_200.price().unwrap(),
						FixedU128::from_float(0.0000000001),
						"Price has changed after remove liquidity");

				assert_eq_approx!( FixedU128::from((old_imbalance.value, old_hub_liquidity)),
								   FixedU128::from((new_imbalance.value, new_hub_liquidity)),
								   FixedU128::from_float(0.000000001),
								   "L/Q ratio changed after remove liquidity"
				);
			});
	}
}

File: ./pallets/omnipool/src/tests/spot_price.rs
#![allow(clippy::excessive_precision)]

use super::*;
use frame_support::storage::with_transaction;
use hydradx_traits::pools::SpotPriceProvider;
use hydradx_traits::router::PoolType;
use hydradx_traits::router::TradeExecution;
use sp_runtime::{Permill, TransactionOutcome};

#[test]
fn compare_spot_price_with_and_without_fee_between_two_new_tokens() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 20000 * ONE),
			(LP3, 200, 20000 * ONE),
			(LP1, 100, 10000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 20000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 20000 * ONE)
		.with_asset_fee(Permill::from_percent(3))
		.with_protocol_fee(Permill::from_percent(5))
		.build()
		.execute_with(|| {
			let liq_added = 4000 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let asset_a = 100;
			let asset_b = 200;
			let sell_amount = 1000;

			let received = with_transaction::<Balance, DispatchError, _>(|| {
				let balance_before = Tokens::free_balance(asset_b, &LP1);
				assert_ok!(Omnipool::sell(
					RuntimeOrigin::signed(LP1),
					asset_a,
					asset_b,
					sell_amount,
					0
				));
				let balance_after = Tokens::free_balance(asset_b, &LP1);
				let received = balance_after - balance_before;

				TransactionOutcome::Rollback(Ok(received))
			})
			.unwrap();

			//Check spot price without fee
			let spot_price_without_fee = Omnipool::spot_price(asset_a, asset_b).unwrap();
			let calculated_amount_out_without_fee = spot_price_without_fee
				.reciprocal()
				.unwrap()
				.checked_mul_int(sell_amount)
				.unwrap();
			let difference = calculated_amount_out_without_fee - received;
			let relative_difference_without_fee = FixedU128::from_rational(difference, received);
			//Fee is off here with 9% due to high fees used in trade, resulting in big difference
			assert_eq_approx!(
				relative_difference_without_fee,
				FixedU128::from_float(0.086956521739130435),
				FixedU128::from((2, (ONE / 10_000))),
				"the relative difference is not as expected"
			);

			//Check spot price with fee
			let spot_price_with_fee =
				Omnipool::calculate_spot_price_with_fee(PoolType::Omnipool, asset_a, asset_b).unwrap();
			let calculated_amount_out_with_fee = spot_price_with_fee
				.reciprocal()
				.unwrap()
				.checked_mul_int(sell_amount)
				.unwrap();
			let difference = calculated_amount_out_with_fee - received;
			let relative_difference_with_fee = FixedU128::from_rational(difference, received);
			let tolerated_difference = FixedU128::from_rational(2, 1000);

			// The difference of the amount out calculated with spot price should be less than 0.2%
			assert_eq_approx!(
				relative_difference_with_fee,
				FixedU128::from_float(0.001086956521739130),
				FixedU128::from((2, (ONE / 10_000))),
				"the relative difference is not as expected"
			);
			assert!(relative_difference_with_fee < tolerated_difference);

			//Compare teh two price
			assert!(relative_difference_with_fee < relative_difference_without_fee);

			assert!(
				spot_price_with_fee > spot_price_without_fee,
				"Spot price with fee should be smaller than without fee"
			);
		});
}

#[test]
fn compare_spot_price_with_and_without_fee_when_hdx_sold() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
			(LP1, HDX, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.with_asset_fee(Permill::from_percent(3))
		.with_protocol_fee(Permill::from_percent(5))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let asset_a = HDX;
			let asset_b = 200;
			let sell_amount = 1000;

			let received = with_transaction::<Balance, DispatchError, _>(|| {
				let balance_before = Tokens::free_balance(asset_b, &LP1);
				assert_ok!(Omnipool::sell(
					RuntimeOrigin::signed(LP1),
					asset_a,
					asset_b,
					sell_amount,
					0
				));
				let balance_after = Tokens::free_balance(asset_b, &LP1);
				let received = balance_after - balance_before;

				TransactionOutcome::Rollback(Ok(received))
			})
			.unwrap();

			//Check spot price without fee
			let spot_price_without_fee = Omnipool::spot_price(asset_a, asset_b).unwrap();
			let calculated_amount_out_without_fee = spot_price_without_fee
				.reciprocal()
				.unwrap()
				.checked_mul_int(sell_amount)
				.unwrap();
			let difference = calculated_amount_out_without_fee - received;
			let relative_difference_without_fee = FixedU128::from_rational(difference, received);
			//Fee is off here with 9% due to high fees used in trade, resulting in big difference
			assert_eq_approx!(
				relative_difference_without_fee,
				FixedU128::from_float(0.085391672547635850),
				FixedU128::from((2, (ONE / 10_000))),
				"the relative difference is not as expected"
			);

			//Check spot price with fee
			let spot_price_with_fee =
				Omnipool::calculate_spot_price_with_fee(PoolType::Omnipool, asset_a, asset_b).unwrap();
			let calculated_amount_out_with_fee = spot_price_with_fee
				.reciprocal()
				.unwrap()
				.checked_mul_int(sell_amount)
				.unwrap();
			let difference = calculated_amount_out_with_fee - received;
			let relative_difference_with_fee = FixedU128::from_rational(difference, received);
			let tolerated_difference = FixedU128::from_rational(2, 1000);

			assert_eq_approx!(
				relative_difference_with_fee,
				FixedU128::from_float(0.000000000000000000),
				FixedU128::from((2, (ONE / 10_000))),
				"the relative difference is not as expected"
			);
			// The difference of the amount out calculated with spot price should be less than 0.2%
			assert!(relative_difference_with_fee < tolerated_difference);

			//Compare teh two price
			assert!(relative_difference_with_fee < relative_difference_without_fee);

			assert!(
				spot_price_with_fee > spot_price_without_fee,
				"Spot price with fee should be smaller than without fee"
			);
		});
}

#[test]
fn compare_spot_price_with_and_without_fee_when_lrna_sold() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
			(LP1, LRNA, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.with_asset_fee(Permill::from_percent(3))
		.with_protocol_fee(Permill::from_percent(5))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let asset_a = LRNA;
			let asset_b = 200;
			let sell_amount = 1000;

			let received = with_transaction::<Balance, DispatchError, _>(|| {
				let balance_before = Tokens::free_balance(asset_b, &LP1);
				assert_ok!(Omnipool::sell(
					RuntimeOrigin::signed(LP1),
					asset_a,
					asset_b,
					sell_amount,
					0
				));
				let balance_after = Tokens::free_balance(asset_b, &LP1);
				let received = balance_after - balance_before;

				TransactionOutcome::Rollback(Ok(received))
			})
			.unwrap();

			//Check spot price without fee
			let spot_price_without_fee = Omnipool::spot_price(asset_a, asset_b).unwrap();
			let calculated_amount_out_without_fee = spot_price_without_fee
				.reciprocal()
				.unwrap()
				.checked_mul_int(sell_amount)
				.unwrap();
			let difference = calculated_amount_out_without_fee - received;
			let relative_difference_without_fee = FixedU128::from_rational(difference, received);
			//Fee is off here with 3% due to high fees used in trade, resulting in big difference
			assert_eq_approx!(
				relative_difference_without_fee,
				FixedU128::from_float(0.031522468142186452),
				FixedU128::from((2, (ONE / 10_000))),
				"the relative difference is not as expected"
			);

			//Check spot price with fee
			let spot_price_with_fee =
				Omnipool::calculate_spot_price_with_fee(PoolType::Omnipool, asset_a, asset_b).unwrap();
			let calculated_amount_out_with_fee = spot_price_with_fee
				.reciprocal()
				.unwrap()
				.checked_mul_int(sell_amount)
				.unwrap();
			let difference = if calculated_amount_out_with_fee > received {
				calculated_amount_out_with_fee - received
			} else {
				received - calculated_amount_out_with_fee
			};
			let relative_difference_with_fee = FixedU128::from_rational(difference, received);
			let tolerated_difference = FixedU128::from_rational(2, 1000);

			assert_eq_approx!(
				relative_difference_with_fee,
				FixedU128::from_float(0.000670690811535882),
				FixedU128::from((2, (ONE / 10_000))),
				"the relative difference is not as expected"
			);
			// The difference of the amount out calculated with spot price should be less than 0.2%
			assert!(relative_difference_with_fee < tolerated_difference);

			//Compare teh two price
			assert!(relative_difference_with_fee < relative_difference_without_fee);

			assert!(
				spot_price_with_fee > spot_price_without_fee,
				"Spot price with fee should be smaller than without fee"
			);
		});
}

File: ./pallets/omnipool/src/tests/sell.rs
use super::*;
use frame_support::assert_noop;
use pretty_assertions::assert_eq;
use sp_runtime::Permill;

#[test]
fn simple_sell_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let sell_amount = 50 * ONE;
			let min_limit = 10 * ONE;

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP1),
				100,
				200,
				sell_amount,
				min_limit
			));

			assert_eq!(Tokens::free_balance(100, &LP1), 550000000000000);
			assert_eq!(Tokens::free_balance(200, &LP1), 47808764940238);
			assert_eq!(Tokens::free_balance(LRNA, &Omnipool::protocol_account()), 13360 * ONE);
			assert_eq!(Tokens::free_balance(100, &Omnipool::protocol_account()), 2450 * ONE);
			assert_eq!(
				Tokens::free_balance(200, &Omnipool::protocol_account()),
				1952191235059762
			);

			assert_pool_state!(
				13_360 * ONE,
				26_720 * ONE,
				SimpleImbalance {
					value: 0u128,
					negative: true
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2450 * ONE,
					hub_reserve: 1_528_163_265_306_123,
					shares: 2400 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1952191235059762,
					hub_reserve: 1331836734693877,
					shares: 2000 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn sell_with_insufficient_balance_fails() {
	ExtBuilder::default().build().execute_with(|| {
		assert_noop!(
			Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 10000 * ONE, 0),
			Error::<Test>::InsufficientBalance
		);
	});
}
#[test]
fn sell_insufficient_amount_fails() {
	ExtBuilder::default()
		.with_min_trade_amount(5 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, ONE, 0),
				Error::<Test>::InsufficientTradingAmount
			);

			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), LRNA, 200, ONE, 0),
				Error::<Test>::InsufficientTradingAmount
			);
		});
}

#[test]
fn hub_asset_buy_not_allowed() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, HDX, 2000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), HDX, LRNA, 100 * ONE, 0),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn selling_assets_not_in_pool_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, HDX, 1000 * ONE),
			(LP1, 1000, 1000 * ONE),
			(LP1, 2000, 1000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_registered_asset(100)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 1000, HDX, 50 * ONE, 10 * ONE),
				Error::<Test>::AssetNotFound
			);
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), HDX, 1000, 50 * ONE, 10 * ONE),
				Error::<Test>::AssetNotFound
			);
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 1000, 2000, 50 * ONE, 10 * ONE),
				Error::<Test>::AssetNotFound
			);
		});
}

#[test]
fn sell_limit_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, HDX, 50 * ONE, 1000 * ONE),
				Error::<Test>::BuyLimitNotReached
			);
		});
}

#[test]
fn sell_hub_asset_limit() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, LRNA, 100 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP3), LRNA, HDX, 50 * ONE, 1000 * ONE),
				Error::<Test>::BuyLimitNotReached
			);
		});
}

#[test]
fn sell_hub_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				1,
				200,
				50000000000000,
				10000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1_000_000_000_000_000u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 1, 13410000000000000u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 100, 2400000000000000u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 200, 1925925925925925u128, 1);
			assert_balance_approx!(LP1, 100, 3000000000000000u128, 1);
			assert_balance_approx!(LP1, 200, 3000000000000000u128, 1);
			assert_balance_approx!(LP2, 100, 600000000000000u128, 1);
			assert_balance_approx!(LP3, 100, 1000000000000000u128, 1);
			assert_balance_approx!(LP3, 1, 50000000000000u128, 1);
			assert_balance_approx!(LP3, 200, 74074074074074u128, 1);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2400000000000000,
					hub_reserve: 1560000000000000,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1925925925925926,
					hub_reserve: 1350000000000000,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(
				13410000000000000,
				26820000000000000,
				SimpleImbalance {
					value: 99813571961223,
					negative: true
				}
			);
		});
}

#[test]
fn sell_not_allowed_asset_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				100,
				Tradability::FROZEN
			));

			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 50 * ONE, 10 * ONE),
				Error::<Test>::NotAllowed
			);
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				100,
				Tradability::BUY
			));

			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 50 * ONE, 10 * ONE),
				Error::<Test>::NotAllowed
			);
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				100,
				Tradability::SELL
			));

			assert_ok!(Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 50 * ONE, 10 * ONE));

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::FROZEN
			));

			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 50 * ONE, 10 * ONE),
				Error::<Test>::NotAllowed
			);

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::SELL
			));

			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 50 * ONE, 10 * ONE),
				Error::<Test>::NotAllowed
			);

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::BUY
			));

			assert_ok!(Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 50 * ONE, 10 * ONE));
		});
}

#[test]
fn simple_sell_with_fee_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_initial_pool(FixedU128::from(1), FixedU128::from(1))
		.with_token(100, FixedU128::one(), LP2, 2000 * ONE)
		.with_token(200, FixedU128::one(), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let sell_amount = 50 * ONE;
			let min_limit = 10 * ONE;

			let fee = Permill::from_percent(10);
			let fee = Permill::from_percent(100).checked_sub(&fee).unwrap();

			let expected_zero_fee = 47_619_047_619_047u128;
			let expected_10_percent_fee = fee.mul_floor(expected_zero_fee);

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP1),
				100,
				200,
				sell_amount,
				min_limit
			));

			assert_eq!(Tokens::free_balance(100, &LP1), 950_000_000_000_000);
			assert_eq!(Tokens::free_balance(200, &LP1), expected_10_percent_fee);
			assert_eq!(
				Tokens::free_balance(200, &Omnipool::protocol_account()),
				2000000000000000 - expected_10_percent_fee,
			);
		});
}

#[test]
fn sell_hub_asset_should_fail_when_asset_out_is_not_allowed_to_buy() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::SELL | Tradability::ADD_LIQUIDITY
			));

			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP3), 1, 200, 50000000000000, 10000000000000),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn sell_should_fail_when_trading_same_assets() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP3), 100, 100, 10 * ONE, 10000000000000),
				Error::<Test>::SameAssetTradeNotAllowed
			);
		});
}

#[test]
fn sell_should_work_when_trading_native_asset() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
			(LP1, HDX, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_protocol_fee(Permill::from_percent(20))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let sell_amount = 50 * ONE;
			let min_limit = 10 * ONE;

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP1),
				HDX,
				200,
				sell_amount,
				min_limit
			));

			assert_eq!(Tokens::free_balance(HDX, &LP1), 950000000000000);
			assert_eq!(Tokens::free_balance(200, &LP1), 53_471_964_352_023);
			assert_eq!(Tokens::free_balance(LRNA, &Omnipool::protocol_account()), 13360 * ONE);
			assert_eq!(
				Tokens::free_balance(HDX, &Omnipool::protocol_account()),
				NATIVE_AMOUNT + sell_amount
			);
			assert_eq!(
				Tokens::free_balance(200, &Omnipool::protocol_account()),
				1946528035647977
			);

			let hub_reserves: Vec<Balance> = Assets::<Test>::iter().map(|v| v.1.hub_reserve).collect();

			assert_pool_state!(
				hub_reserves.iter().sum::<Balance>(),
				26_720 * ONE,
				SimpleImbalance {
					value: 0u128,
					negative: true
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1946528035647977,
					hub_reserve: 1339800995024876,
					shares: 2000 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
			assert_asset_state!(
				HDX,
				AssetReserveState {
					reserve: 10050000000000000,
					hub_reserve: 9960199004975124,
					shares: 10000 * ONE,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn sell_imbalance() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_protocol_fee(Permill::from_percent(20))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				1,
				200,
				50000000000000,
				10000000000000
			));

			assert_pool_state!(
				13410000000000000,
				26820000000000000,
				SimpleImbalance {
					value: 99813571961223,
					negative: true
				}
			);

			assert_ok!(Omnipool::sell(RuntimeOrigin::signed(LP3), 200, 100, 1000000000000, 1,));
		});
}

#[test]
fn sell_should_fail_when_exceeds_max_in_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.with_max_in_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 1000 * ONE, 0u128),
				Error::<Test>::MaxInRatioExceeded
			);
		});
}

#[test]
fn sell_should_fail_when_exceeds_max_out_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(1.00), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.00), LP3, 100 * ONE)
		.with_max_out_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), 100, 200, 1000 * ONE, 0u128),
				Error::<Test>::MaxOutRatioExceeded
			);
		});
}

#[test]
fn sell_lrna_should_fail_when_exceeds_max_in_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, LRNA, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(1.00), LP2, 2000 * ONE)
		.with_max_in_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), LRNA, 100, 1000 * ONE, 0u128),
				Error::<Test>::MaxInRatioExceeded
			);
		});
}

#[test]
fn sell_lrna_should_fail_when_exceeds_max_out_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, LRNA, 1500 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(1.00), LP2, 2000 * ONE)
		.with_max_out_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::sell(RuntimeOrigin::signed(LP1), LRNA, 100, 1500 * ONE, 0u128),
				Error::<Test>::MaxOutRatioExceeded
			);
		});
}

File: ./pallets/omnipool/src/tests/buy.rs
use super::*;
use frame_support::assert_noop;
use pretty_assertions::assert_eq;

#[test]
fn simple_buy_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			// Arrange
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let buy_amount = 50 * ONE;
			let max_limit = 100 * ONE;

			// Act
			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP1),
				200,
				100,
				buy_amount,
				max_limit
			));

			// Assert
			assert_eq!(Tokens::free_balance(100, &LP1), 547598253275108);
			assert_eq!(Tokens::free_balance(200, &LP1), buy_amount);
			assert_eq!(Tokens::free_balance(LRNA, &Omnipool::protocol_account()), 13360 * ONE);
			assert_eq!(
				Tokens::free_balance(100, &Omnipool::protocol_account()),
				2452401746724892
			);
			assert_eq!(Tokens::free_balance(200, &Omnipool::protocol_account()), 1950 * ONE);

			assert_pool_state!(13_360 * ONE, 26_720 * ONE, SimpleImbalance::default());

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2452401746724892,
					hub_reserve: 1526666666666666,
					shares: 2400 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1950 * ONE,
					hub_reserve: 1333333333333334,
					shares: 2000 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn hub_asset_buy_fails() {
	ExtBuilder::default()
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), LRNA, HDX, 100 * ONE, 0),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn buy_insufficient_amount_fails() {
	ExtBuilder::default()
		.with_min_trade_amount(5 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), LRNA, HDX, ONE, 0),
				Error::<Test>::InsufficientTradingAmount
			);
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 1000, HDX, ONE, 0),
				Error::<Test>::InsufficientTradingAmount
			);
		});
}

#[test]
fn buy_assets_not_in_pool_fails() {
	ExtBuilder::default().build().execute_with(|| {
		assert_noop!(
			Omnipool::buy(RuntimeOrigin::signed(LP1), 1000, 2000, 100 * ONE, 0),
			Error::<Test>::AssetNotFound
		);

		assert_noop!(
			Omnipool::buy(RuntimeOrigin::signed(LP1), 2000, 1000, 100 * ONE, 0),
			Error::<Test>::AssetNotFound
		);
	});
}

#[test]
fn buy_with_insufficient_balance_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from(1), LP2, 500 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 100, HDX, 100 * ONE, 10 * ONE),
				Error::<Test>::InsufficientBalance
			);
		});
}

#[test]
fn buy_exceeding_limit_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
			(LP1, HDX, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from(1), LP2, 500 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 100, HDX, 100 * ONE, 10 * ONE),
				Error::<Test>::SellLimitExceeded
			);
		});
}

#[test]
fn buy_not_allowed_assets_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::FROZEN
			));

			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 50 * ONE, 100 * ONE),
				Error::<Test>::NotAllowed
			);
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::SELL
			));

			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 50 * ONE, 100 * ONE),
				Error::<Test>::NotAllowed
			);
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::BUY
			));

			assert_ok!(Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 50 * ONE, 100 * ONE));

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				100,
				Tradability::FROZEN
			));

			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 50 * ONE, 100 * ONE),
				Error::<Test>::NotAllowed
			);
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				100,
				Tradability::BUY
			));

			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 50 * ONE, 100 * ONE),
				Error::<Test>::NotAllowed
			);
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				100,
				Tradability::SELL
			));

			assert_ok!(Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 50 * ONE, 100 * ONE));
		});
}

#[test]
fn buy_for_hub_asset_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100_000_000_000_000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				1,
				50_000_000_000_000,
				50_000_000_000_000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, 10000000000000000u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 1, 13393333333333334u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 100, 2400000000000000u128, 1);
			assert_balance_approx!(Omnipool::protocol_account(), 200, 1950000000000000u128, 1);
			assert_balance_approx!(LP1, 100, 3000000000000000u128, 1);
			assert_balance_approx!(LP1, 200, 3000000000000000u128, 1);
			assert_balance_approx!(LP2, 100, 600000000000000u128, 1);
			assert_balance_approx!(LP3, 100, 1000000000000000u128, 1);
			assert_balance_approx!(LP3, 1, 66_666_666_666_667u128, 1);
			assert_balance_approx!(LP3, 200, 50000000000000u128, 1);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2400000000000000,
					hub_reserve: 1560000000000000,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1950000000000000,
					hub_reserve: 1333333333333334,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(
				13393333333333334,
				26786666666666668,
				SimpleImbalance {
					value: 66583706653395,
					negative: true
				}
			);
		});
}

#[test]
fn simple_buy_with_fee_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_initial_pool(FixedU128::from(1), FixedU128::from(1))
		.with_token(100, FixedU128::from(1), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from(1), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;

			assert_eq!(Tokens::free_balance(200, &LP1), 0u128);

			assert_eq!(Tokens::free_balance(200, &Omnipool::protocol_account()), token_amount);

			let buy_amount = 50 * ONE;
			let max_limit = 100 * ONE;

			let expected_zero_fee: Balance = 52_631_578_947_370;
			let expected_10_percent_fee: Balance = 58_823_529_411_766;

			assert!(expected_zero_fee < expected_10_percent_fee); // note: dont make much sense as values are constants, but good to see the diff for further verification

			let expect_sold_amount = expected_10_percent_fee;

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP1),
				200,
				100,
				buy_amount,
				max_limit
			));

			assert_eq!(Tokens::free_balance(100, &LP1), 1000 * ONE - expect_sold_amount);

			assert_eq!(Tokens::free_balance(200, &LP1), buy_amount);

			assert_eq!(
				Tokens::free_balance(100, &Omnipool::protocol_account()),
				token_amount + expect_sold_amount
			);
		});
}

#[test]
fn buy_should_emit_event_with_correct_asset_fee_amount() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_initial_pool(FixedU128::from(1), FixedU128::from(1))
		.with_token(100, FixedU128::from(1), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from(1), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let buy_amount = 50 * ONE;
			let max_limit = 100 * ONE;
			let expected_sold_amount = 58_823_529_411_766;

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP1),
				200,
				100,
				buy_amount,
				max_limit
			));

			expect_events(vec![Event::BuyExecuted {
				who: LP1,
				asset_in: 100,
				asset_out: 200,
				amount_in: expected_sold_amount,
				amount_out: buy_amount,
				hub_amount_in: 57142857142858,
				hub_amount_out: 57142857142858,
				asset_fee_amount: 5_555_555_555_556,
				protocol_fee_amount: 0,
			}
			.into()]);
		});
}

#[test]
fn buy_should_emit_event_with_correct_protocol_fee_amount() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_protocol_fee(Permill::from_percent(10))
		.with_initial_pool(FixedU128::from(1), FixedU128::from(1))
		.with_token(100, FixedU128::from(1), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from(1), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let buy_amount = 50 * ONE;
			let max_limit = 100 * ONE;
			let expected_sold_amount = 58_651_026_392_962;

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP1),
				200,
				100,
				buy_amount,
				max_limit
			));

			expect_events(vec![Event::BuyExecuted {
				who: LP1,
				asset_in: 100,
				asset_out: 200,
				amount_in: expected_sold_amount,
				amount_out: buy_amount,
				hub_amount_in: 56980056980057,
				hub_amount_out: 51282051282052,
				asset_fee_amount: 0,
				protocol_fee_amount: 5698005698005,
			}
			.into()]);
		});
}

#[test]
fn sell_should_get_same_amount() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_initial_pool(FixedU128::from(1), FixedU128::from(1))
		.with_token(100, FixedU128::from(1), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from(1), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let buy_amount = 50 * ONE;
			let expected_sold_amount = 58_823_529_411_766;

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP1),
				100,
				200,
				expected_sold_amount,
				0
			));

			expect_events(vec![Event::SellExecuted {
				who: LP1,
				asset_in: 100,
				asset_out: 200,
				amount_in: expected_sold_amount,
				amount_out: buy_amount,
				hub_amount_in: 57142857142858,
				hub_amount_out: 57142857142858,
				asset_fee_amount: 5555555555556,
				protocol_fee_amount: 0,
			}
			.into()]);
		});
}

#[test]
fn buy_should_fail_when_buying_more_than_in_pool() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			// Act
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 200, 100, 3000 * ONE, 100 * ONE),
				Error::<Test>::InsufficientLiquidity
			);
		});
}

#[test]
fn buy_for_hub_asset_should_fail_when_asset_out_is_not_allowed_to_sell() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100_000_000_000_000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				200,
				Tradability::SELL | Tradability::ADD_LIQUIDITY
			));

			assert_noop!(
				Omnipool::buy(
					RuntimeOrigin::signed(LP3),
					200,
					1,
					50_000_000_000_000,
					50_000_000_000_000
				),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn buy_for_hub_asset_should_fail_when_limit_exceeds() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100_000_000_000_000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(
					RuntimeOrigin::signed(LP3),
					200,
					1,
					20_000_000_000_000,
					30_000_000_000_000
				),
				Error::<Test>::SellLimitExceeded
			);
		});
}

#[test]
fn buy_should_fail_when_trading_same_asset() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
			(LP3, 1, 100_000_000_000_000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(
					RuntimeOrigin::signed(LP3),
					200,
					200,
					50_000_000_000_000,
					100_000_000_000
				),
				Error::<Test>::SameAssetTradeNotAllowed
			);
		});
}

#[test]
fn buy_should_work_when_trading_native_asset() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
			(LP1, HDX, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_protocol_fee(Permill::from_percent(20))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 100, liq_added));

			let buy_amount = 50 * ONE;
			let max_limit = 100 * ONE;

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP1),
				200,
				HDX,
				buy_amount,
				max_limit
			));

			assert_eq!(Tokens::free_balance(HDX, &LP1), 953354861858628);
			assert_eq!(Tokens::free_balance(200, &LP1), buy_amount);
			assert_eq!(Tokens::free_balance(LRNA, &Omnipool::protocol_account()), 13360 * ONE);
			assert_eq!(
				Tokens::free_balance(HDX, &Omnipool::protocol_account()),
				10046645138141372
			);
			assert_eq!(
				Tokens::free_balance(200, &Omnipool::protocol_account()),
				1950000000000000
			);

			let hub_reserves: Vec<Balance> = Assets::<Test>::iter().map(|v| v.1.hub_reserve).collect();

			assert_pool_state!(
				hub_reserves.iter().sum::<Balance>(),
				26_720 * ONE,
				SimpleImbalance {
					value: 0u128,
					negative: true
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1950000000000000,
					hub_reserve: 1337142857142858,
					shares: 2000 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
			assert_asset_state!(
				HDX,
				AssetReserveState {
					reserve: 10046645138141372,
					hub_reserve: 9962857142857142,
					shares: 10000 * ONE,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn buy_should_fail_when_exceeds_max_out_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 100, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP3, 2000 * ONE)
		.with_max_out_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 100, 200, 1000 * ONE, 0u128),
				Error::<Test>::MaxOutRatioExceeded
			);
		});
}

#[test]
fn buy_should_fail_when_exceeds_max_in_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP3, 200, 2000 * ONE),
			(LP1, 200, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(1.00), LP2, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.00), LP3, 500 * ONE)
		.with_max_in_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 100, 200, 200 * ONE, Balance::MAX),
				Error::<Test>::MaxInRatioExceeded
			);
		});
}

#[test]
fn buy_for_lrna_should_fail_when_exceeds_max_in_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, LRNA, 1000 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(1.00), LP2, 2000 * ONE)
		.with_max_in_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 100, LRNA, 1000 * ONE, Balance::MAX),
				Error::<Test>::MaxInRatioExceeded
			);
		});
}

#[test]
fn buy_for_lrna_should_fail_when_exceeds_max_out_ratio() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 100, 2000 * ONE),
			(LP1, LRNA, 1500 * ONE),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(1.00), LP2, 2000 * ONE)
		.with_max_out_ratio(3)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::buy(RuntimeOrigin::signed(LP1), 100, LRNA, 1500 * ONE, Balance::MAX),
				Error::<Test>::MaxOutRatioExceeded
			);
		});
}

File: ./pallets/omnipool/src/tests/add_liquidity.rs
use super::*;
use frame_support::assert_noop;

#[test]
fn add_liquidity_should_work_when_asset_exists_in_pool() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;
			let liq_added = 400 * ONE;

			// ACT
			let position_id = last_position_id();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			// ASSERT - asset state, pool state, position
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added,
					hub_reserve: 1560 * ONE,
					shares: 2400 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added,
				shares: liq_added,
				price: (1560 * ONE, token_amount + liq_added),
			};

			assert_eq!(position, expected);

			assert_pool_state!(12_060 * ONE, 24_120 * ONE, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let minted_position = POSITIONS.with(|v| v.borrow().get(&position_id).copied());

			assert_eq!(minted_position, Some(LP1));
		});
}

#[test]
fn add_stable_asset_liquidity_works() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, DAI, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), DAI, liq_added));

			assert_asset_state!(
				DAI,
				AssetReserveState {
					reserve: 1000 * ONE + liq_added,
					hub_reserve: 700000000000000,
					shares: 1400000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: DAI,
				amount: liq_added,
				shares: liq_added,
				price: (700 * ONE, 1400 * ONE),
			};

			assert_eq!(position, expected);

			assert_pool_state!(10_700 * ONE, 21_400 * ONE, SimpleImbalance::default());

			assert_balance!(LP1, DAI, 4600 * ONE);

			let minted_position = POSITIONS.with(|v| v.borrow().get(&position_id).copied());

			assert_eq!(minted_position, Some(LP1));
		});
}

#[test]
fn add_liquidity_for_non_pool_token_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 2000 * ONE,),
				Error::<Test>::AssetNotFound
			);
		});
}

#[test]
fn add_liquidity_with_insufficient_balance_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP3), 1_000, 2000 * ONE,),
				Error::<Test>::InsufficientBalance
			);
		});
}

#[test]
fn add_liquidity_exceeding_weight_cap_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_asset_weight_cap(Permill::from_float(0.1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 100 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 2000 * ONE,),
				Error::<Test>::AssetWeightCapExceeded
			);
		});
}

#[test]
fn add_insufficient_liquidity_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_min_added_liquidity(5 * ONE)
		.with_asset_weight_cap(Permill::from_float(0.1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP3), 1_000, ONE,),
				Error::<Test>::InsufficientLiquidity
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_asset_state_does_not_include_add_liquidity() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_min_added_liquidity(ONE)
		.with_asset_weight_cap(Permill::from_float(0.1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1000,
				Tradability::SELL | Tradability::BUY | Tradability::REMOVE_LIQUIDITY
			));

			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 2 * ONE),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_prices_differ_and_is_higher() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.with_external_price_adjustment((3, 100, false))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_prices_differ_and_is_lower() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.with_external_price_adjustment((3, 100, true))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}

File: ./pallets/omnipool/src/tests/tradability.rs
use super::*;
use frame_support::assert_noop;

#[test]
fn sell_asset_tradable_state_should_work_when_hub_asset_new_state_contains_sell_or_buy() {
	ExtBuilder::default()
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				LRNA,
				Tradability::SELL
			));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				LRNA,
				Tradability::BUY
			));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				LRNA,
				Tradability::SELL | Tradability::BUY
			));
		});
}
#[test]
fn sell_asset_tradable_state_should_fail_when_hub_asset_new_state_contains_liquidity_operations() {
	ExtBuilder::default()
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::set_asset_tradable_state(
					RuntimeOrigin::root(),
					LRNA,
					Tradability::SELL | Tradability::ADD_LIQUIDITY
				),
				Error::<Test>::InvalidHubAssetTradableState
			);
			assert_noop!(
				Omnipool::set_asset_tradable_state(
					RuntimeOrigin::root(),
					LRNA,
					Tradability::SELL | Tradability::REMOVE_LIQUIDITY
				),
				Error::<Test>::InvalidHubAssetTradableState
			);
			assert_noop!(
				Omnipool::set_asset_tradable_state(
					RuntimeOrigin::root(),
					LRNA,
					Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
				),
				Error::<Test>::InvalidHubAssetTradableState
			);
		});
}

File: ./pallets/omnipool/src/tests/add_liquidity_with_limit.rs
use super::*;
use frame_support::assert_noop;

#[test]
fn add_liquidity_should_work_when_asset_exists_in_pool() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;
			let liq_added = 400 * ONE;

			// ACT
			let position_id = last_position_id();
			assert_ok!(Omnipool::add_liquidity_with_limit(
				RuntimeOrigin::signed(LP1),
				1_000,
				liq_added,
				liq_added
			));

			// ASSERT - asset state, pool state, position
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added,
					hub_reserve: 1560 * ONE,
					shares: 2400 * ONE,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added,
				shares: liq_added,
				price: (1560 * ONE, token_amount + liq_added),
			};

			assert_eq!(position, expected);

			assert_pool_state!(12_060 * ONE, 24_120 * ONE, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let minted_position = POSITIONS.with(|v| v.borrow().get(&position_id).copied());

			assert_eq!(minted_position, Some(LP1));
		});
}

#[test]
fn add_stable_asset_liquidity_works() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, DAI, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity_with_limit(
				RuntimeOrigin::signed(LP1),
				DAI,
				liq_added,
				liq_added
			));

			assert_asset_state!(
				DAI,
				AssetReserveState {
					reserve: 1000 * ONE + liq_added,
					hub_reserve: 700000000000000,
					shares: 1400000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: DAI,
				amount: liq_added,
				shares: liq_added,
				price: (700 * ONE, 1400 * ONE),
			};

			assert_eq!(position, expected);

			assert_pool_state!(10_700 * ONE, 21_400 * ONE, SimpleImbalance::default());

			assert_balance!(LP1, DAI, 4600 * ONE);

			let minted_position = POSITIONS.with(|v| v.borrow().get(&position_id).copied());

			assert_eq!(minted_position, Some(LP1));
		});
}

#[test]
fn add_liquidity_for_non_pool_token_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP1), 1_000, 2000 * ONE, 2000 * ONE),
				Error::<Test>::AssetNotFound
			);
		});
}

#[test]
fn add_liquidity_with_insufficient_balance_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP3), 1_000, 2000 * ONE, 2000 * ONE),
				Error::<Test>::InsufficientBalance
			);
		});
}

#[test]
fn add_liquidity_exceeding_weight_cap_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_asset_weight_cap(Permill::from_float(0.1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 100 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP1), 1_000, 2000 * ONE, 2000 * ONE),
				Error::<Test>::AssetWeightCapExceeded
			);
		});
}

#[test]
fn add_insufficient_liquidity_fails() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_min_added_liquidity(5 * ONE)
		.with_asset_weight_cap(Permill::from_float(0.1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP3), 1_000, ONE, ONE),
				Error::<Test>::InsufficientLiquidity
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_asset_state_does_not_include_add_liquidity() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.with_min_added_liquidity(ONE)
		.with_asset_weight_cap(Permill::from_float(0.1))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1000,
				Tradability::SELL | Tradability::BUY | Tradability::REMOVE_LIQUIDITY
			));

			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP1), 1_000, 2 * ONE, 2 * ONE),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_prices_differ_and_is_higher() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.with_external_price_adjustment((3, 100, false))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE, 400 * ONE),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_prices_differ_and_is_lower() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.with_external_price_adjustment((3, 100, true))
		.build()
		.execute_with(|| {
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE, 400 * ONE),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}

#[test]
fn add_liquidity_should_fail_when_doesnt_reach_min_limit() {
	ExtBuilder::default()
		.add_endowed_accounts((LP1, 1_000, 5000 * ONE))
		.add_endowed_accounts((LP2, 1_000, 5000 * ONE))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			//Do some trade not to have parity between liquidity and shares
			assert_ok!(Omnipool::sell(RuntimeOrigin::signed(LP1), 1_000, DAI, 20 * ONE, 0));

			// ACT
			assert_noop!(
				Omnipool::add_liquidity_with_limit(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE, 496 * ONE), //user received 495, so below limit
				Error::<Test>::SlippageLimit
			);
		});
}

File: ./pallets/omnipool/src/tests/remove_liquidity.rs
use super::*;
use crate::types::Tradability;
use frame_support::assert_noop;
use orml_traits::MultiCurrencyExtended;
use sp_runtime::traits::One;
use sp_runtime::DispatchError::BadOrigin;

#[test]
fn remove_liquidity_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;

			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let liq_removed = 200 * ONE;
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed
			));

			assert_pool_state!(11_930 * ONE, 23_860_000_000_000_000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4600 * ONE + liq_removed);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added - liq_removed,
					hub_reserve: 1430000000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn full_liquidity_removal_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;

			let liq_added = 400 * ONE;
			let lp1_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert!(
				get_mock_minted_position(lp1_position_id).is_some(),
				"Position instance was not minted"
			);

			let liq_removed = 400 * ONE;

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				lp1_position_id,
				liq_removed
			));

			assert!(
				Positions::<Test>::get(lp1_position_id).is_none(),
				"Position still found"
			);

			assert_pool_state!(11_800 * ONE, 23_600_000_000_000_000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 5000 * ONE);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added - liq_removed,
					hub_reserve: 1300000000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert!(
				get_mock_minted_position(lp1_position_id).is_none(),
				"Position instance was not burned"
			);
		});
}

#[test]
fn partial_liquidity_removal_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let token_amount = 2000 * ONE;
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert!(
				get_mock_minted_position(current_position_id).is_some(),
				"Position instance was not minted"
			);

			let liq_removed = 200 * ONE;

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed
			));

			assert!(
				Positions::<Test>::get(current_position_id).is_some(),
				"Position has been removed incorrectly"
			);

			assert_pool_state!(11_930 * ONE, 23_860_000_000_000_000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4800 * ONE);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: token_amount + liq_added - liq_removed,
					hub_reserve: 1430000000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert!(
				get_mock_minted_position(current_position_id).is_some(),
				"Position instance was burned"
			);
			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn lp_receives_lrna_when_price_is_higher() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, 1_000, 100 * ONE),
			(LP1, 1_000, 5000 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP3, 100 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));

			assert_balance!(Omnipool::protocol_account(), 1000, 300 * ONE);
			let expected_state = AssetReserveState {
				reserve: 300 * ONE,
				hub_reserve: 541666666666667,
				shares: 500000000000000,
				protocol_shares: Balance::zero(),
				cap: DEFAULT_WEIGHT_CAP,
				tradable: Tradability::default(),
			};
			assert_asset_state!(1_000, expected_state);

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_added
			));
			assert_balance!(Omnipool::protocol_account(), 1000, 60 * ONE);
			assert_balance!(LP1, 1000, 4_840_000_000_000_000);
			assert_balance!(LP1, LRNA, 203_921_568_627_449);

			assert_pool_state!(10391666666666667, 64723183391003641, SimpleImbalance::default());
		});
}

#[test]
fn remove_liquiduity_should_burn_lrna_when_amount_is_below_ed() {
	let asset_id = 1_000;
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, asset_id, 500 * ONE),
			(LP1, asset_id, 2 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP3, 500 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 2 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				asset_id,
				DAI,
				100_000_000_000,
				500000 * ONE
			));

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_added
			));
			assert_balance!(LP1, LRNA, 0);
			let lrna_issuance = Tokens::total_issuance(LRNA);
			assert!(lrna_issuance < 10826000000025799); // this value is when lrna is transferred
		});
}

#[test]
fn remove_liquiduity_should_transfer_lrna_below_ed_when_lp_has_sufficient_lrna_amount() {
	let asset_id = 1_000;
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, asset_id, 500 * ONE),
			(LP1, asset_id, 2 * ONE),
			(LP2, DAI, 50000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_id, FixedU128::from_float(0.65), LP3, 500 * ONE)
		.build()
		.execute_with(|| {
			let liq_added = 2 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_id, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				asset_id,
				DAI,
				100_000_000_000,
				500000 * ONE
			));

			Tokens::update_balance(LRNA, &LP1, ONE as i128).unwrap();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_added
			));
			assert_balance!(LP1, LRNA, 1000259041538);
			let lrna_issuance = Tokens::total_issuance(LRNA);
			assert_eq!(lrna_issuance, 10826000000025799);
		});
}

#[test]
fn protocol_shares_should_update_when_removing_asset_liquidity_after_price_change() {
	let asset_a: AssetId = 1_000;

	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP3, asset_a, 100 * ONE),
			(LP1, asset_a, 5000 * ONE),
			(LP2, asset_a, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(asset_a, FixedU128::from_float(0.65), LP3, 100 * ONE)
		.build()
		.execute_with(|| {
			// Arrange
			// - init pool
			// - add asset_a with initial liquidity of 100 * ONE
			// - add more liquidity of asset a - 400 * ONE
			// - perform a sell so the price changes - adding 1000 * ONE of asset a
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), asset_a, liq_added));

			let expected_state = AssetReserveState::<Balance> {
				reserve: 500000000000000,
				hub_reserve: 325000000000000,
				shares: 500000000000000,
				protocol_shares: 0,
				cap: DEFAULT_WEIGHT_CAP,
				tradable: Tradability::default(),
			};
			assert_asset_state!(asset_a, expected_state);

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				asset_a,
				HDX,
				100 * ONE,
				10 * ONE
			));

			// ACT
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				400 * ONE
			));

			// Assert
			// - check if balance of LP and protocol are correct
			// - check new state of asset a in the pool ( should have updated protocol shares)
			assert_balance!(Omnipool::protocol_account(), asset_a, 206557377049181);
			assert_balance!(LP1, asset_a, 4993442622950819);

			assert_pool_state!(10647404371584700, 21294808743169400, SimpleImbalance::default());

			let expected_state = AssetReserveState {
				reserve: 206557377049181,
				hub_reserve: 93237704918034,
				shares: 172131147540984,
				protocol_shares: 72131147540984,
				cap: DEFAULT_WEIGHT_CAP,
				tradable: Tradability::default(),
			};
			assert_asset_state!(asset_a, expected_state);
		});
}

#[test]
fn remove_liquidity_by_non_owner_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP3), current_position_id, 100 * ONE),
				Error::<Test>::Forbidden
			);
		});
}

#[test]
fn remove_liquidity_from_non_existing_position_fails() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), 1_000_000, 100 * ONE),
				Error::<Test>::Forbidden
			);
		});
}

#[test]
fn remove_liquidity_cannot_exceed_position_shares() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::one(), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 500 * ONE));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 500 * ONE + 1),
				Error::<Test>::InsufficientShares
			);
		});
}

#[test]
fn remove_liquidity_should_fail_when_asset_is_not_allowed_to_remove() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1000,
				Tradability::BUY | Tradability::ADD_LIQUIDITY
			));

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 400 * ONE),
				Error::<Test>::NotAllowed
			);
		});
}

#[test]
fn remove_liquidity_should_fail_when_shares_amount_is_zero() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 0u128),
				Error::<Test>::InvalidSharesAmount
			);
		});
}

#[test]
fn remove_liquidity_should_when_prices_differ_and_is_higher() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, false);
			});

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 200 * ONE,),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}
#[test]
fn remove_liquidity_should_when_prices_differ_and_is_lower() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, true);
			});

			assert_noop!(
				Omnipool::remove_liquidity(RuntimeOrigin::signed(LP1), current_position_id, 200 * ONE,),
				Error::<Test>::PriceDifferenceTooHigh
			);
		});
}

#[test]
fn remove_liquidity_should_apply_min_fee_when_price_is_the_same() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let liq_removed = 200 * ONE;
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed
			));

			assert_pool_state!(11931300000000000, 23862600000000000, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4798000000000000);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2202000000000000,
					hub_reserve: 1431300000000000,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn remove_liquidity_should_apply_correct_fee_when_price_is_different() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.with_withdrawal_adjustment((5, 100, false))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_balance!(LP1, 1_000, 4600 * ONE);

			let liq_removed = 200 * ONE;
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				liq_removed
			));

			assert_pool_state!(11936190476190477, 23872380952380954, SimpleImbalance::default());

			assert_balance!(LP1, 1_000, 4790476190476190);

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2209523809523810,
					hub_reserve: 1436190476190477,
					shares: 2400 * ONE - liq_removed,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			let position = Positions::<Test>::get(current_position_id).unwrap();

			let expected = Position::<Balance, AssetId> {
				asset_id: 1_000,
				amount: liq_added - liq_removed,
				shares: liq_added - liq_removed,
				price: (1560 * ONE, 2400 * ONE),
			};

			assert_eq!(position, expected);
		});
}

#[test]
fn safe_withdrawal_should_work_correctly_when_trading_is_disabled() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));

			let position = Positions::<Test>::get(current_position_id).unwrap();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				position.shares,
			));

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2004000000000000,
					hub_reserve: 1302600000000000,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
				}
			);

			let position = Positions::<Test>::get(current_position_id);
			assert!(position.is_none());

			assert_balance!(LP1, 1_000, 4996000000000000);
			assert_balance!(LP1, LRNA, 0);
		});
}

#[test]
fn safe_withdrawal_should_transfer_lrna() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));

			let position = Positions::<Test>::get(current_position_id).unwrap();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				position.shares,
			));

			let position = Positions::<Test>::get(current_position_id);
			assert!(position.is_none());

			assert_balance!(LP1, 1_000, 4962999999999999);
			assert_balance!(LP1, LRNA, 24371320754716);
		});
}

#[test]
fn withdraw_protocol_liquidity_should_work_correctly() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));
			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2400000000000000,
					hub_reserve: 1560000000000000,
					shares: 2400000000000000,
					protocol_shares: 400000000000000,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_ok!(Omnipool::withdraw_protocol_liquidity(
				RuntimeOrigin::root(),
				1000,
				position.shares,
				position.price,
				1234,
			));
			assert_balance!(1234, 1_000, 400 * ONE);
			assert_balance!(1234, LRNA, 0);
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2000000000000000,
					hub_reserve: 1300000000000000,
					shares: 2000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn withdraw_protocol_liquidity_should_transfer_lrna_when_price_is_different() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 2400000000000000,
					hub_reserve: 1560000000000000,
					shares: 2400000000000000,
					protocol_shares: 400000000000000,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP2),
				1_000,
				DAI,
				200 * ONE,
				500000 * ONE
			));

			assert_ok!(Omnipool::withdraw_protocol_liquidity(
				RuntimeOrigin::root(),
				1000,
				position.shares,
				position.price,
				1234,
			));

			let position = Positions::<Test>::get(current_position_id);
			assert!(position.is_none());

			assert_balance!(1234, 1_000, 366666666666666);
			assert_balance!(1234, LRNA, 24617495711835);
			assert_asset_state!(
				1_000,
				AssetReserveState {
					reserve: 1_833_333_333_333_334,
					hub_reserve: 1418181818181819,
					shares: 2000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);
		});
}

#[test]
fn withdraw_protocol_liquidity_fail_when_not_root() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			assert_noop!(
				Omnipool::withdraw_protocol_liquidity(
					RuntimeOrigin::signed(LP1),
					1000,
					position.shares,
					position.price,
					1234,
				),
				BadOrigin
			);
		});
}

#[test]
fn withdraw_protocol_liquidity_fail_when_withdrawing_more_protocol_shares() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP2, DAI, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_min_withdrawal_fee(Permill::from_float(0.01))
		.build()
		.execute_with(|| {
			let liq_added = 400 * ONE;

			let current_position_id = <NextPositionId<Test>>::get();

			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, liq_added));

			let position = Positions::<Test>::get(current_position_id).unwrap();
			assert_ok!(Omnipool::sacrifice_position(
				RuntimeOrigin::signed(LP1),
				current_position_id
			));

			let state = Assets::<Test>::get(1_000).unwrap();

			assert_noop!(
				Omnipool::withdraw_protocol_liquidity(
					RuntimeOrigin::root(),
					1000,
					state.protocol_shares + 1,
					position.price,
					1234,
				),
				Error::<Test>::InsufficientShares
			);
		});
}

#[test]
fn remove_liquidity_should_skip_price_check_when_price_is_higher_and_is_safe_to_withdraw() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, false);
			});
			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				200 * ONE,
			),);
		});
}

#[test]
fn remove_liquidity_should_skip_price_check_when_price_is_lower_and_is_safe_to_withdraw() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), DAI, 1000 * ONE),
			(Omnipool::protocol_account(), HDX, NATIVE_AMOUNT),
			(LP2, 1_000, 2000 * ONE),
			(LP1, 1_000, 5000 * ONE),
		])
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(1_000, FixedU128::from_float(0.65), LP2, 2000 * ONE)
		.with_max_allowed_price_difference(Permill::from_percent(1))
		.build()
		.execute_with(|| {
			let current_position_id = <NextPositionId<Test>>::get();
			assert_ok!(Omnipool::add_liquidity(RuntimeOrigin::signed(LP1), 1_000, 400 * ONE));

			EXT_PRICE_ADJUSTMENT.with(|v| {
				*v.borrow_mut() = (3, 100, true);
			});

			assert_ok!(Omnipool::set_asset_tradable_state(
				RuntimeOrigin::root(),
				1_000,
				Tradability::ADD_LIQUIDITY | Tradability::REMOVE_LIQUIDITY
			));
			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP1),
				current_position_id,
				200 * ONE,
			),);
		});
}

File: ./pallets/omnipool/src/tests/verification/scenario_08.rs
use crate::tests::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn complex_scenario_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 2000000000000000),
			(LP3, 200, 300000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.1), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_hub_asset!();

			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_hub_asset!();

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				100,
				200,
				110000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				100,
				200,
				50000000000000,
				10000000000000
			));

			let position_id = last_position_id();
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP3),
				200,
				200000000000000
			));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				300000000000000,
				100000000000000000
			));

			assert_hub_asset!();

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP3),
				position_id,
				200000000000000
			));

			assert_hub_asset!();

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				1,
				200,
				20000000000000,
				10000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 1, 14252209513698901u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 100, 3589236949625567u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 200, 1638588974363038u128, 10);
			assert_balance_approx!(LP1, 100, 3000000000000000u128, 10);
			assert_balance_approx!(LP1, 200, 3000000000000000u128, 10);
			assert_balance_approx!(LP2, 100, 550000000000000u128, 10);
			assert_balance_approx!(LP2, 200, 24596656872852u128, 10);
			assert_balance_approx!(LP3, 100, 860763050374432u128, 10);
			assert_balance_approx!(LP3, 200, 636814368764109u128, 10);
			assert_balance_approx!(LP3, 1, 20634322079393u128, 10);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 3589236949625565,
					hub_reserve: 1043118649603388,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1638588974363041,
					hub_reserve: 2709090864095513,
					shares: 2008863636363636,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(
				14252209513698901,
				28504419027397802,
				SimpleImbalance {
					value: 39971934176269,
					negative: true
				}
			);

			assert_ok!(Omnipool::sell(RuntimeOrigin::signed(LP3), 100, 200, 20000000000000, 1,));
		});
}

File: ./pallets/omnipool/src/tests/verification/scenario_09.rs
use crate::tests::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn sell_fee_test() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 2000000000000000),
			(LP3, 200, 300000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_protocol_fee(Permill::from_percent(20))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.1), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				100,
				200,
				110000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				100,
				200,
				50000000000000,
				10000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 1, 14260000000000000u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 100, 2560000000000000u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 200, 1938322315391001u128, 10);
			assert_balance_approx!(LP1, 100, 3000000000000000u128, 10);
			assert_balance_approx!(LP1, 200, 3000000000000000u128, 10);
			assert_balance_approx!(LP2, 100, 550000000000000u128, 10);
			assert_balance_approx!(LP2, 200, 18014179710851u128, 10);
			assert_balance_approx!(LP3, 100, 1890000000000000u128, 10);
			assert_balance_approx!(LP3, 200, 343663504898149u128, 10);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10019499999999999,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2560000000000000,
					hub_reserve: 1462500000000001,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1938322315391000,
					hub_reserve: 2278000000000000,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(
				14260000000000000,
				28520000000000000,
				SimpleImbalance {
					value: 0,
					negative: true
				}
			);
		});
}

File: ./pallets/omnipool/src/tests/verification/scenario_06.rs
use crate::tests::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn scenario_06() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				100,
				200,
				50000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				100,
				200,
				50000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				100,
				200,
				50000000000000,
				10000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance!(Omnipool::protocol_account(), 1, 13360000000000000);
			assert_balance!(Omnipool::protocol_account(), 100, 2550000000000000);
			assert_balance!(Omnipool::protocol_account(), 200, 1868131868131872);
			assert_balance!(LP1, 100, 3000000000000000);
			assert_balance!(LP1, 200, 3000000000000000);
			assert_balance!(LP2, 100, 500000000000000);
			assert_balance!(LP2, 1, 0);
			assert_balance!(LP2, 200, 84059366927890);
			assert_balance!(LP3, 100, 950000000000000);
			assert_balance!(LP3, 1, 0);
			assert_balance!(LP3, 200, 47808764940238);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2550000000000000,
					hub_reserve: 1468235294117649,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1868131868131872,
					hub_reserve: 1391764705882351,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(13360000000000000, 26720000000000000, SimpleImbalance::default());
		});
}

File: ./pallets/omnipool/src/tests/verification/scenario_04.rs
use super::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn scenario_04() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				50000000000000,
				100000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance!(Omnipool::protocol_account(), 1, 13360000000000000);
			assert_balance!(Omnipool::protocol_account(), 100, 2452401746724892);
			assert_balance!(Omnipool::protocol_account(), 200, 1950000000000000);
			assert_balance!(LP1, 100, 3000000000000000);
			assert_balance!(LP1, 200, 3000000000000000);
			assert_balance!(LP2, 100, 600000000000000);
			assert_balance!(LP3, 100, 947598253275108);
			assert_balance!(LP3, 1, 0);
			assert_balance!(LP3, 200, 50 * ONE);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2452401746724892,
					hub_reserve: 1526666666666666,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1950000000000000,
					hub_reserve: 1333333333333334,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(13360000000000000, 26720000000000000, SimpleImbalance::default());
		});
}

File: ./pallets/omnipool/src/tests/verification/mod.rs
use super::*;
mod scenario_04;
mod scenario_05;
mod scenario_06;
mod scenario_08;
mod scenario_09;
mod scenario_10;
mod scenario_11;

File: ./pallets/omnipool/src/tests/verification/scenario_10.rs
use crate::tests::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn fee_test_buy_sell() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 2000000000000000),
			(LP3, 200, 300000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_asset_fee(Permill::from_percent(10))
		.with_protocol_fee(Permill::from_percent(20))
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.1), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				100,
				200,
				110000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				100,
				200,
				50000000000000,
				10000000000000
			));

			let position_id = last_position_id();
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP3),
				200,
				200000000000000
			));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				300000000000000,
				100000000000000000
			));

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP3),
				position_id,
				200000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 1, 14225180042050832u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 100, 4243052260380446u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 200, 1671684145777546u128, 10);
			assert_balance_approx!(LP1, 100, 3000000000000000u128, 10);
			assert_balance_approx!(LP1, 200, 3000000000000000u128, 10);
			assert_balance_approx!(LP2, 100, 550000000000000u128, 10);
			assert_balance_approx!(LP2, 200, 18014179710851u128, 10);
			assert_balance_approx!(LP3, 100, 206947739619554u128, 10);
			assert_balance_approx!(LP3, 200, 610301674511603u128, 10);
			assert_balance_approx!(LP3, 1, 42897803510764u128, 10);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10135523267202732,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 4243052260380446,
					hub_reserve: 882383663986336,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1671684145777545,
					hub_reserve: 2707273110861764,
					shares: 2006364027707802,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(
				14225180042050832,
				28450360084101664,
				SimpleImbalance {
					value: 0,
					negative: true
				}
			);
		});
}

File: ./pallets/omnipool/src/tests/verification/scenario_11.rs
use crate::tests::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn complex_scenario_works() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 2000000000000000),
			(LP3, 200, 300000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(1.1), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				100,
				200,
				110000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP2),
				100,
				200,
				50000000000000,
				10000000000000
			));

			let position_id = last_position_id();
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP3),
				200,
				200000000000000
			));

			assert_ok!(Omnipool::buy(
				RuntimeOrigin::signed(LP3),
				200,
				100,
				300000000000000,
				100000000000000000
			));

			assert_ok!(Omnipool::remove_liquidity(
				RuntimeOrigin::signed(LP3),
				position_id,
				200000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				1,
				200,
				20000000000000,
				10000000000000
			));

			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				500000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 1, 14397521548574755u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 100, 4089236949625567u128, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 200, 1638588974363038u128, 10);
			assert_balance_approx!(LP1, 100, 3000000000000000u128, 10);
			assert_balance_approx!(LP1, 200, 3000000000000000u128, 10);
			assert_balance_approx!(LP2, 100, 50000000000000u128, 10);
			assert_balance_approx!(LP2, 200, 24596656872852u128, 10);
			assert_balance_approx!(LP3, 100, 860763050374432u128, 10);
			assert_balance_approx!(LP3, 200, 636814368764109u128, 10);
			assert_balance_approx!(LP3, 1, 20634322079393u128, 10);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 4089236949625565,
					hub_reserve: 1188430684479242,
					shares: 2734332900513906,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1638588974363041,
					hub_reserve: 2709090864095513,
					shares: 2008863636363636,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(
				14397521548574755,
				28795043097149510,
				SimpleImbalance {
					value: 40379478219702,
					negative: true
				}
			);
		});
}

File: ./pallets/omnipool/src/tests/verification/scenario_05.rs
use crate::tests::*;

/// Auto-generated test
/// This test scenario is generated by python's omnipool implementation - initial implementation done during research.
/// Its purpose is to verify that python and rust omnipool implementation produce same results.
#[test]
fn scenario_05() {
	ExtBuilder::default()
		.with_endowed_accounts(vec![
			(Omnipool::protocol_account(), 0, NATIVE_AMOUNT),
			(Omnipool::protocol_account(), 2, 1000 * ONE),
			(LP1, 100, 5000000000000000),
			(LP1, 200, 5000000000000000),
			(LP2, 100, 1000000000000000),
			(LP3, 100, 1000000000000000),
		])
		.with_registered_asset(100)
		.with_registered_asset(200)
		.with_initial_pool(FixedU128::from_float(0.5), FixedU128::from(1))
		.with_token(100, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.with_token(200, FixedU128::from_float(0.65), LP1, 2000 * ONE)
		.build()
		.execute_with(|| {
			assert_ok!(Omnipool::add_liquidity(
				RuntimeOrigin::signed(LP2),
				100,
				400000000000000
			));

			assert_ok!(Omnipool::sell(
				RuntimeOrigin::signed(LP3),
				100,
				200,
				50000000000000,
				10000000000000
			));

			assert_balance_approx!(Omnipool::protocol_account(), 0, NATIVE_AMOUNT, 10);
			assert_balance_approx!(Omnipool::protocol_account(), 2, 1000000000000000u128, 10);
			assert_balance!(Omnipool::protocol_account(), 1, 13360000000000000);
			assert_balance!(Omnipool::protocol_account(), 100, 2450000000000000);
			assert_balance!(Omnipool::protocol_account(), 200, 1952191235059762);
			assert_balance!(LP1, 100, 3000000000000000);
			assert_balance!(LP1, 200, 3000000000000000);
			assert_balance!(LP2, 100, 600000000000000);
			assert_balance!(LP3, 100, 950000000000000);
			assert_balance!(LP3, 1, 0);
			assert_balance!(LP3, 200, 47808764940238);

			assert_asset_state!(
				2,
				AssetReserveState {
					reserve: 1000000000000000,
					hub_reserve: 500000000000000,
					shares: 1000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				0,
				AssetReserveState {
					reserve: 10000000000000000,
					hub_reserve: 10000000000000000,
					shares: 10000000000000000,
					protocol_shares: 0,
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				100,
				AssetReserveState {
					reserve: 2450000000000000,
					hub_reserve: 1528163265306123,
					shares: 2400000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_asset_state!(
				200,
				AssetReserveState {
					reserve: 1952191235059762,
					hub_reserve: 1331836734693877,
					shares: 2000000000000000,
					protocol_shares: Balance::zero(),
					cap: DEFAULT_WEIGHT_CAP,
					tradable: Tradability::default(),
				}
			);

			assert_pool_state!(13360000000000000, 26720000000000000, SimpleImbalance::default());
		});
}

